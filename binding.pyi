
# type: ignore
import sys
from typing import Literal, List, Any, Optional, Tuple, Dict
import numpy as np
import enum
import numpy

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:GeometryUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __GEOMETRYUTILITIES_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class GeometryUtilitiesConfig:
        """
        (final class)
        """
        @staticmethod
        def default_min_tolerance() -> float:
            pass

        min_tolerance: float = DefaultMinTolerance()
        tolerance1_d: float = MinTolerance
        tolerance2_d: float = MinTolerance
        tolerance3_d: float = MinTolerance
        def __init__(
            self,
            min_tolerance: float = GeometryUtilitiesConfig.DefaultMinTolerance(),
            tolerance1_d: float = GeometryUtilitiesConfig.MinTolerance,
            tolerance2_d: float = GeometryUtilitiesConfig.MinTolerance,
            tolerance3_d: float = GeometryUtilitiesConfig.MinTolerance
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class GeometryUtilities:
        """/ \brief The GeometryUtilities class intersects 3D segments
        (final class)
        """
        class CompareTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                       # (= 0)
            first_before_second = enum.auto()                                                                           # (= 1)
            coincident = enum.auto()                                                                                    # (= 2)
            second_before_first = enum.auto()                                                                           # (= 3)

        class PolygonTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                       # (= 0)
            triangle = enum.auto()                                                                                      # (= 1)
            quadrilateral_convex = enum.auto()                                                                          # (= 2)
            quadrilateral_concave = enum.auto()                                                                         # (= 3)
            generic_convex = enum.auto()                                                                                # (= 4)
            generic_concave = enum.auto()                                                                               # (= 5)

        class PolygonOrientations(enum.IntEnum):
            unknown = enum.auto()                                                                                       # (= 0)
            clockwise = enum.auto()                                                                                     # (= 1)
            counter_clockwise = enum.auto()                                                                             # (= 2)

        class PointSegmentPositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                       # (= 0)
            on_segment_line_before_origin = enum.auto()                                                                 # (= 1)
            on_segment_origin = enum.auto()                                                                             # (= 2)
            inside_segment = enum.auto()                                                                                # (= 3)
            on_segment_end = enum.auto()                                                                                # (= 4)
            on_segment_line_after_end = enum.auto()                                                                     # (= 5)
            left_the_segment = enum.auto()                                                                              # (= 6)
            right_the_segment = enum.auto()                                                                             # (= 7)

        class PointPlanePositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                       # (= 0)
            negative = enum.auto()                                                                                      # (= 1)
            on_plane = enum.auto()                                                                                      # (= 2)
            positive = enum.auto()                                                                                      # (= 3)

        class PolygonCirclePositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                       # (= 0)
            polygon_outside_circle_no_intersection = enum.auto()                                                        # (= 1)
            polygon_outside_circle_one_intersection_on_vertex = enum.auto()                                             # (= 2)
            polygon_outside_circle_one_intersection_tangent_on_edge = enum.auto()                                       # (= 3)
            circle_inside_polygon_no_intersection = enum.auto()                                                         # (= 4)
            circle_inside_polygon_one_intersection_tangent_on_edge = enum.auto()                                        # (= 5)
            polygon_inside_circle_no_intersection = enum.auto()                                                         # (= 6)
            polygon_inside_circle_one_vertex_intersection = enum.auto()                                                 # (= 7)
            polygon_inside_circle_intersection_only_on_vertices = enum.auto()                                           # (= 8)
            circle_polygon_multiple_intersections = enum.auto()                                                         # (= 9)

        class IntersectionPolygonCircleResult:
            """
            (final class)
            """
            class Intersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    secant = enum.auto()                                                                                # (= 1)
                    tangent = enum.auto()                                                                               # (= 2)

                class IndexTypes(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    vertex = enum.auto()                                                                                # (= 1)
                    edge = enum.auto()                                                                                  # (= 2)

                type: Types = Types.unknown
                index_type: IndexTypes = IndexTypes.unknown
                index: int
                curvilinear_coordinate: float                                                                           #/< Valid only in IndexType Edge
                def __init__(
                    self,
                    type: Types = Types.unknown,
                    index_type: IndexTypes = IndexTypes.unknown,
                    curvilinear_coordinate: float = float()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            intersections: List[Intersection] = List[Intersection]()                                                    #/< ordered by edge order
            def __init__(self, intersections: List[Intersection] = List[Intersection]()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PolygonDivisionByAngleQuadrantResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                external_origin = enum.auto()                                                                           # (= 1)
                internal = enum.auto()                                                                                  # (= 2)
                external_end = enum.auto()                                                                              # (= 3)

            points: Eigen.MatrixXd                                                                                      #/< Coordinates of generated points
            sub_polygons: List[List[int]]                                                                               #/< Subpolygon formed
            sub_polygon_types: List[Types]                                                                              #/< SubPolygon types
            def __init__(
                self,
                points: Eigen.MatrixXd = Eigen.MatrixXd(),
                sub_polygon_types: List[Types] = List[Types]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PolygonDivisionByCircleResult:
            """
            (final class)
            """
            points: Eigen.MatrixXd                                                                                      #/< Coordinates of generated points
            sub_triangles: List[List[int]]                                                                              #/< Triangle formed with sub-polygons and circle Center
            internal_triangles: List[List[int]]                                                                         #/< Triangle formed with circle Center and new points
            sub_polygons: List[List[int]]                                                                               #/< Subpolygon formed
            def __init__(self, points: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CircleDivisionByPolygonResult:
            """
            (final class)
            """
            points: Eigen.MatrixXd                                                                                      #/< Coordinates of generated points
            sub_triangles: List[List[int]]                                                                              #/< Triangle formed with sub-polygons and circle Center
            internal_triangles: List[List[int]]                                                                         #/< Triangle formed with circle Center and new points
            sub_polygons: List[List[int]]                                                                               #/< Subpolygon formed
            def __init__(self, points: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonInput:
            """
            (final class)
            """
            class AlignedEdge:
                origin_vertex_index: int
                end_vertex_index: int
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            class SplitSegment:
                class Vertex:
                    """
                    (final class)
                    """
                    class Types(enum.IntEnum):
                        unknown = enum.auto()                                                                           # (= 0)
                        vertex = enum.auto()                                                                            # (= 1)
                        edge = enum.auto()                                                                              # (= 2)

                    type: Types
                    index: int
                    def __init__(self, type: Types = Types()) -> None:
                        """Auto-generated default constructor with named params"""
                        pass

                origin: Vertex
                end: Vertex
                def __init__(self, origin: Vertex = Vertex(), end: Vertex = Vertex()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            number_polygon_vertices: int
            aligned_edges: List[AlignedEdge]
            segment: SplitSegment
            def __init__(
                self,
                aligned_edges: List[AlignedEdge] = List[AlignedEdge](),
                segment: SplitSegment = SplitSegment()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithSegmentResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                no_action = enum.auto()                                                                                 # (= 1)
                polygon_update = enum.auto()                                                                            # (= 2)
                polygon_creation = enum.auto()                                                                          # (= 3)

            class NewVertex:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    segment_origin = enum.auto()                                                                        # (= 1)
                    segment_end = enum.auto()                                                                           # (= 2)

                type: Types = Types.unknown
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdge:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    edge_new = enum.auto()                                                                              # (= 1)
                    edge_update = enum.auto()                                                                           # (= 2)

                type: Types = Types.unknown
                old_edge_id: int = 0
                origin_id: int = 0
                end_id: int = 0
                cell2_d_neighbours: List[int] = List[int]()
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolygon:
                """
                (final class)
                """
                vertices: std.list[int] = std.list<int>()
                edges: std.list[int] = std.list<int>()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            type: Types = Types.unknown
            new_vertices: std.list[NewVertex] = std.list<NewVertex>()
            new_edges: std.list[NewEdge] = std.list<NewEdge>()
            new_polygons: List[NewPolygon] = List[NewPolygon]()
            def __init__(
                self,
                type: Types = Types.unknown,
                new_vertices: std.list[NewVertex] = std.list<NewVertex>(),
                new_edges: std.list[NewEdge] = std.list<NewEdge>(),
                new_polygons: List[NewPolygon] = List[NewPolygon]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithCircleResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                no_action = enum.auto()                                                                                 # (= 1)
                polygon_update = enum.auto()                                                                            # (= 2)
                polygon_creation = enum.auto()                                                                          # (= 3)

            class NewVertex:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    polygon_vertex = enum.auto()                                                                        # (= 1)
                    circle_intersection = enum.auto()                                                                   # (= 2)
                    both = enum.auto()                                                                                  # (= 3)

                type: Types = Types.unknown
                polygon_index: int                                                                                      #/< Index in polygon vertices
                intersection_index: int                                                                                 #/< Index in circle intersections
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdge:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    segment = enum.auto()                                                                               # (= 1)
                    arc = enum.auto()                                                                                   # (= 2)

                class ArcTypes(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    inside_polygon = enum.auto()                                                                        # (= 1)
                    outside_polygon = enum.auto()                                                                       # (= 2)

                type: Types = Types.unknown
                arc_type: ArcTypes = ArcTypes.unknown                                                                   #/< Valid only if Type is Arc
                vertex_indices: List[int]                                                                               #/< Index of vertices in NewVertices
                polygon_index: int                                                                                      #/< Index of Edge in polygon intersections
                def __init__(
                    self,
                    type: Types = Types.unknown,
                    arc_type: ArcTypes = ArcTypes.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolygon:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    inside_only_circle = enum.auto()                                                                    # (= 1)
                    inside_only_polygon = enum.auto()                                                                   # (= 2)
                    inside_circle_and_polygon = enum.auto()                                                             # (= 3)

                type: Types = Types.unknown
                vertices: List[int] = List[int]()
                edges: List[int] = List[int]()
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Types = Types.unknown
            polygon_vertices_new_vertices_position: List[int] = List[int]()
            circle_intersections_new_vertices_position: List[int] = List[int]()
            new_vertices: List[NewVertex] = List[NewVertex]()
            new_edges: List[NewEdge] = List[NewEdge]()
            new_polygons: List[NewPolygon] = List[NewPolygon]()
            def __init__(
                self,
                type: Types = Types.unknown,
                new_vertices: List[NewVertex] = List[NewVertex](),
                new_edges: List[NewEdge] = List[NewEdge](),
                new_polygons: List[NewPolygon] = List[NewPolygon]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentSegmentResult:
            """
            (final class)
            """
            class IntersectionLineTypes(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                on_different_planes = enum.auto()                                                                       # (= 1)
                co_planar_parallel = enum.auto()                                                                        # (= 2)
                co_planar_intersecting = enum.auto()                                                                    # (= 3)

            class IntersectionSegmentTypes(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                no_intersection = enum.auto()                                                                           # (= 1)
                single_intersection = enum.auto()                                                                       # (= 2)
                multiple_intersections = enum.auto()                                                                    # (= 3)

            class IntersectionPosition:
                type: PointSegmentPositionTypes = PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: PointSegmentPositionTypes = PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            intersection_lines_type: IntersectionLineTypes = IntersectionLineTypes.unknown
            intersection_segments_type: IntersectionSegmentTypes = IntersectionSegmentTypes.unknown
            #/ \brief relation between first and second intersection.
            #/ Values are the indeces of the SecondSegmentIntersections vector respect the FirstSegmentIntersections vector
            #/ \example in MultipleIntersection case, if SecondIntersectionRelation[0] = 1,
            #/ then the second intersection point SecondSegmentIntersections[1] is equal to FirstSegmentIntersections[0]
            #/ point
            second_intersection_relation: List[int]
            #/ \brief intersections of the first segment,
            #/ \note if multiple intersections are found, than the origin and the end coordinate are stored
            first_segment_intersections: List[IntersectionPosition]
            #/ \brief intersections of the second segment,
            #/ \note if multiple intersections are found, than the origin and the end coordinate are stored
            second_segment_intersections: List[IntersectionPosition]                                                    #/ intersections of the second segment
            def __init__(
                self,
                intersection_lines_type: IntersectionLineTypes = IntersectionLineTypes.unknown,
                intersection_segments_type: IntersectionSegmentTypes = IntersectionSegmentTypes.unknown,
                first_segment_intersections: List[IntersectionPosition] = List[IntersectionPosition](),
                second_segment_intersections: List[IntersectionPosition] = List[IntersectionPosition]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentCircleResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                no_intersection = enum.auto()                                                                           # (= 1)
                tangent_intersection = enum.auto()                                                                      # (= 2)
                two_intersections = enum.auto()                                                                         # (= 3)

            class IntersectionPosition:
                type: PointSegmentPositionTypes = PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: PointSegmentPositionTypes = PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Types = Types.unknown
            #/ \brief intersections of the segment,
            segment_intersections: List[IntersectionPosition] = List[IntersectionPosition]()
            def __init__(
                self,
                type: Types = Types.unknown,
                segment_intersections: List[IntersectionPosition] = List[IntersectionPosition]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                single_intersection = enum.auto()                                                                       # (= 1)
                no_intersection = enum.auto()                                                                           # (= 2)
                multiple_intersections = enum.auto()                                                                    # (= 3)

            class Intersection:
                type: PointSegmentPositionTypes = PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: PointSegmentPositionTypes = PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Types = Types.unknown                                                                                 #/< The intersection type
            single_intersection: Intersection                                                                           #/< The single intersection, available only is Type is SingleIntersection
            def __init__(
                self,
                type: Types = Types.unknown,
                single_intersection: Intersection = Intersection()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronLineResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                none = enum.auto()                                                                                      # (= 1)  #/< No intersection found
                one_intersection = enum.auto()                                                                          # (= 2)  #/< One intersection found
                two_intersections = enum.auto()                                                                         # (= 3)  #/< Two intersection found
                multiple_intersections = enum.auto()                                                                    # (= 4)  #/< Multiple intersection found

            class PolyhedronFaceIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    intersection = enum.auto()                                                                          # (= 1)
                    no_intersection = enum.auto()                                                                       # (= 2)

                type: Types = Types.unknown
                line_intersection_index: int = 0                                                                        #/< Index of line intersection collection
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class PolyhedronEdgeIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    intersection = enum.auto()                                                                          # (= 1)
                    no_intersection = enum.auto()                                                                       # (= 2)

                type: Types = Types.unknown
                line_intersection_index: int = 0                                                                        #/< Index of line intersection collection
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class PolyhedronVertexIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    intersection = enum.auto()                                                                          # (= 1)
                    no_intersection = enum.auto()                                                                       # (= 2)

                type: Types = Types.unknown
                line_intersection_index: int = 0                                                                        #/< Index of line intersection collection
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class LineIntersection:
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    on_vertex = enum.auto()                                                                             # (= 1)  #/< On polyhedron vertex
                    on_edge = enum.auto()                                                                               # (= 2)  #/< On polyhedron edge
                    on_face = enum.auto()                                                                               # (= 3)  #/< On polyhedron face
                    inside = enum.auto()                                                                                # (= 4)  #/< Inside polyhedron

                polyhedron_type: Types = Types.unknown                                                                  #/< Type of intersection
                polyhedron_index: int = 0                                                                               #/<  Index of the intersecting element of the Polyhedron (face, edge or
                #/<  vertex index)
                curvilinear_coordinate: float = 0.0                                                                     #/< Curvilinear coordinate in the line
                def __init__(
                    self,
                    polyhedron_type: Types = Types.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Types = Types.unknown                                                                                 #/ The
            line_intersections: List[LineIntersection]                                                                  #/< The line intersections
            polyhedron_vertex_intersections: List[PolyhedronVertexIntersection] = List[PolyhedronVertexIntersection]()  #/< Polyhedron Vertex
            #/< intersections, size
            #/< polyhedron num vertices
            polyhedron_edge_intersections: List[PolyhedronEdgeIntersection] = List[PolyhedronEdgeIntersection]()        #/< Polyhedron Edge intersections,
            #/< size polyhedron num edges
            polyhedron_face_intersections: List[PolyhedronFaceIntersection] = List[PolyhedronFaceIntersection]()        #/< Polyhedron Face intersections,
            #/< size polyhedron num faces
            def __init__(
                self,
                type: Types = Types.unknown,
                line_intersections: List[LineIntersection] = List[LineIntersection](),
                polyhedron_vertex_intersections: List[PolyhedronVertexIntersection] = List[PolyhedronVertexIntersection](),
                polyhedron_edge_intersections: List[PolyhedronEdgeIntersection] = List[PolyhedronEdgeIntersection](),
                polyhedron_face_intersections: List[PolyhedronFaceIntersection] = List[PolyhedronFaceIntersection]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronsSegmentResult:
            """
            (final class)
            """
            class IntersectionPoint:
                """
                (final class)
                """
                cell3_d_indices: List[int] = List[int]()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            class IntersectionSegment:
                """
                (final class)
                """
                points: List[float] = List[float]()
                cell3_d_indices: List[int] = List[int]()
                def __init__(self, points: List[float] = List[float]()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            points: Dict[float, IntersectionPoint]
            segments: List[IntersectionSegment]
            def __init__(
                self,
                segments: List[IntersectionSegment] = List[IntersectionSegment]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                none = enum.auto()                                                                                      # (= 1)  #/< No intersection found
                on_vertex = enum.auto()                                                                                 # (= 2)  #/< On polyhedron vertex
                on_edge = enum.auto()                                                                                   # (= 3)  #/< On polyhedron edge
                on_face = enum.auto()                                                                                   # (= 4)  #/< On polyhedron face
                new_polygon = enum.auto()                                                                               # (= 5)  #/< New polygon intersection

            class FaceIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    intersection = enum.auto()                                                                          # (= 1)
                    no_intersection = enum.auto()                                                                       # (= 2)

                type: Types = Types.unknown
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class EdgeIntersection:
                """
                (final class)
                """
                intersection: IntersectionSegmentPlaneResult                                                            #/< Intersection between edge and plane
                def __init__(
                    self,
                    intersection: IntersectionSegmentPlaneResult = IntersectionSegmentPlaneResult()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VertexIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    intersection = enum.auto()                                                                          # (= 1)
                    no_intersection = enum.auto()                                                                       # (= 2)

                type: Types = Types.unknown
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class Intersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    vertex = enum.auto()                                                                                # (= 1)
                    edge = enum.auto()                                                                                  # (= 2)

                type: Types = Types.unknown
                edge_id: int = 0                                                                                        #/<  Edge index of the Polyhedron
                vertex_id: int = 0                                                                                      #/<  Vertex index of the Polyhedron, available only if Type is Types::Vertex
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Types = Types.unknown                                                                                 #/< The intersection type
            intersection_id: int = 0                                                                                    #/< The geometry id of the intersection, available only with Types::OnVertex,
            #/< Types::OnEdge and Types::OnFace
            vertex_intersections: List[VertexIntersection] = List[VertexIntersection]()                                 #/< Vertex intersections
            edge_intersections: List[EdgeIntersection] = List[EdgeIntersection]()                                       #/< Edge intersections
            face_intersections: List[FaceIntersection] = List[FaceIntersection]()                                       #/< Face intersections
            intersections: List[Intersection] = List[Intersection]()                                                    #/< The resulting intersections
            intersection_coordinates: Eigen.MatrixXd                                                                    #/< The resulting intersection coordinates
            def __init__(
                self,
                type: Types = Types.unknown,
                vertex_intersections: List[VertexIntersection] = List[VertexIntersection](),
                edge_intersections: List[EdgeIntersection] = List[EdgeIntersection](),
                face_intersections: List[FaceIntersection] = List[FaceIntersection](),
                intersections: List[Intersection] = List[Intersection](),
                intersection_coordinates: Eigen.MatrixXd = Eigen.MatrixXd()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PointCirclePositionResult(enum.IntEnum):
            unknown = enum.auto()                                                                                       # (= 0)
            outside = enum.auto()                                                                                       # (= 1)
            on_border = enum.auto()                                                                                     # (= 2)
            inside = enum.auto()                                                                                        # (= 3)

        class PointPolygonPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                outside = enum.auto()                                                                                   # (= 1)
                border_edge = enum.auto()                                                                               # (= 2)
                border_vertex = enum.auto()                                                                             # (= 3)
                inside = enum.auto()                                                                                    # (= 4)

            border_index: int = 0                                                                                       #/< index of vertex/edge of border
            type: Types = Types.unknown
            def __init__(self, type: Types = Types.unknown) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class LinePolygonPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                outside = enum.auto()                                                                                   # (= 1)
                intersecting = enum.auto()                                                                              # (= 2)

            class EdgeIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                               # (= 0)
                    on_edge_origin = enum.auto()                                                                        # (= 1)
                    inside_edge = enum.auto()                                                                           # (= 2)
                    on_edge_end = enum.auto()                                                                           # (= 3)
                    parallel = enum.auto()                                                                              # (= 4)

                type: Types = Types.unknown
                index: int = 0
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: Types = Types.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            edge_intersections: List[EdgeIntersection] = List[EdgeIntersection]()
            type: Types = Types.unknown
            def __init__(
                self,
                edge_intersections: List[EdgeIntersection] = List[EdgeIntersection](),
                type: Types = Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PointPolyhedronPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                outside = enum.auto()                                                                                   # (= 1)
                border_face = enum.auto()                                                                               # (= 2)
                border_edge = enum.auto()                                                                               # (= 3)
                border_vertex = enum.auto()                                                                             # (= 4)
                inside = enum.auto()                                                                                    # (= 5)

            border_index: int = 0                                                                                       #/< index of vertex/edge/face of border
            internal_indices: List[int]                                                                                 #/< list of index of internal cell (usually tetrahedrons)
            type: Types = Types.unknown
            def __init__(self, type: Types = Types.unknown) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SegmentPolyhedronPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                outside = enum.auto()                                                                                   # (= 1)
                border_face = enum.auto()                                                                               # (= 2)
                border_edge = enum.auto()                                                                               # (= 3)
                inside = enum.auto()                                                                                    # (= 4)

            border_index: int = 0                                                                                       #/< index of edge/face of border
            type: Types = Types.unknown
            def __init__(self, type: Types = Types.unknown) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Polyhedron:
            """
            (final class)
            """
            vertices: Eigen.MatrixXd                                                                                    #/< vertices, size 3 x numVertices
            edges: Eigen.MatrixXi                                                                                       #/< edges, size 2 x numEdges
            faces: List[Eigen.MatrixXi]                                                                                 #/< faces vertices and edges˝, size numFaces x 2 x numFaceVertices
            def __init__(
                self,
                vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                edges: Eigen.MatrixXi = Eigen.MatrixXi(),
                faces: List[Eigen.MatrixXi] = List[Eigen.MatrixXi]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                split = enum.auto()                                                                                     # (= 1)
                positive = enum.auto()                                                                                  # (= 2)
                negative = enum.auto()                                                                                  # (= 3)
                on_plane = enum.auto()                                                                                  # (= 4)

            positive_vertices: List[int]                                                                                #/ vertices indices of the positive sub-polygon
            negative_vertices: List[int]                                                                                #/ vertices indices of the negative sub-polygon
            points_on_plane: List[int]                                                                                  #/ vertices indices of the points on plane
            new_vertices: List[Eigen.Vector3d]                                                                          #/ new vertices coordinates
            new_vertices_edge_index: List[int]                                                                          #/ new vertices edge indices
            type: Types = Types.unknown                                                                                 #/ type of split
            def __init__(
                self,
                new_vertices: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                type: Types = Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolyhedronWithPlaneResult:
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                   # (= 0)
                split = enum.auto()                                                                                     # (= 1)
                none = enum.auto()                                                                                      # (= 2)

            class NewVertices:
                vertices: Eigen.MatrixXd                                                                                #/< all vertices contained in the new polyhedra
                new_vertices_original_edge: List[int]                                                                   #/< For each new vertex the index of the original edge
                #/< to which is located
                def __init__(self, vertices: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdges:
                edges: Eigen.MatrixXi                                                                                   #/< all edges contained in the new polyhedra
                new_edges_original_edges: List[int]                                                                     #/< indices of original edges for new edges, -1 means no original
                #/< edge
                new_edges_original_face: List[int]                                                                      #/< For each new vertex the index of the original edge to which is
                #/< located
                def __init__(
                    self,
                    edges: Eigen.MatrixXi = Eigen.MatrixXi(),
                    new_edges_original_edges: List[int] = List[int](),
                    new_edges_original_face: List[int] = List[int]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewFaces:
                faces: List[Eigen.MatrixXi]
                new_faces_original_faces: List[int]                                                                     #/< indices of original faces for new faces, -1 means no original
                #/< face
                def __init__(
                    self,
                    faces: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                    new_faces_original_faces: List[int] = List[int]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolyhedron:
                vertices: List[int]
                edges: List[int]
                faces: List[int]
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            original_edges_new_edges: List[List[int]]
            original_faces_new_faces: List[List[int]]
            vertices: NewVertices
            edges: NewEdges
            faces: NewFaces
            positive_polyhedron: NewPolyhedron
            negative_polyhedron: NewPolyhedron
            type: Types = Types.unknown                                                                                 #/ type of split
            def __init__(
                self,
                vertices: NewVertices = NewVertices(),
                edges: NewEdges = NewEdges(),
                faces: NewFaces = NewFaces(),
                positive_polyhedron: NewPolyhedron = NewPolyhedron(),
                negative_polyhedron: NewPolyhedron = NewPolyhedron(),
                type: Types = Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class AlignedPolyhedronEdgesResult:
            aligned_edges_vertices: List[List[int]]
            aligned_edges_edges: List[List[int]]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        def __init__(self, configuration: GeometryUtilitiesConfig) -> None:
            pass

        def tolerance1_d(self) -> float:
            """/ \return tolerance used for segment length"""
            pass
        def tolerance1_d_squared(self) -> float:
            """/ \return tolerance used for squared segment length"""
            pass
        def tolerance2_d(self) -> float:
            """/ \return tolerance used for polygon area"""
            pass
        def tolerance3_d(self) -> float:
            """/ \return tolerance used for polyhedron volume"""
            pass

        def relative_difference(self, first: float, second: float, tolerance: float) -> float:
            """/ \param first the first value
            / \param second the second value
            / \return the relative difference between the two values according the first
            """
            pass

        def compare_values(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> GeometryUtilities.CompareTypes:
            """/ \brief Compare two values according to tolerance
            / \param first the first value
            / \param second the second value
            / \return the result
            / \note the interval [-tolerance, tolerance] is considered 0.0
            """
            pass

        def are_values_equal(self, first: float, second: float, tolerance: float) -> bool:
            """/ \brief Check if two values are equal according to tolerance
            / \param first the first value
            / \param second the second value
            / \return the result
            """
            pass

        def is_value_greater(self, first: float, second: float, tolerance: float) -> bool:
            """/ \param first the first value
            / \param second the second value
            / \return True if first is greater than second
            """
            pass

        def is_value_greater_or_equal(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> bool:
            """/ \param first the first value
            / \param second the second value
            / \return True if first is greater or equal than second
            """
            pass

        def is_value_lower(self, first: float, second: float, tolerance: float) -> bool:
            pass

        def is_value_lower_or_equal(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> bool:
            pass

        def is_value_positive(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is positive
            """
            pass

        def is_value_negative(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is negative
            """
            pass

        def is_value_zero(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is zero
            """
            pass

        def fibonacci_sphere(self, num_points: int) -> Eigen.MatrixXd:
            pass
        def generate_uniform_random_points_in_sphere(
            self,
            num_points: int,
            radius: float = 1.0
            ) -> Eigen.MatrixXd:
            pass

        @overload
        def equispace_coordinates(self, step: float, insert_extremes: bool) -> List[float]:
            """/ \param step the distance between each coordinate
            / \param insertExtremes if True keeps the extremes
            / \return the equispace coordinates between [0.0, 1.0], size 1 x numCoordinates
            """
            pass

        @overload
        def equispace_coordinates(
            self,
            size: int,
            origin: float,
            end: float,
            insert_extremes: bool
            ) -> List[float]:
            """/ \param size the number of resulting coordinates
            / \param origin the starting curvilinear coordinate
            / \param end the ending curvilinear coordinate
            / \param insertExtremes if True keeps the extremes
            / \return equispaced curvilinear coordinates in the interval [origin, end]
            / \note if size < 2 then size will be considered as 2
            """
            pass
        def random_coordinates(
            self,
            size: int,
            insert_extremes: bool,
            min_distance: float,
            seed: int = time(None)
            ) -> List[float]:
            """/ \param size the number of resulting coordinates
            / \param origin the starting curvilinear coordinate
            / \param end the ending curvilinear coordinate
            / \param insertExtremes if True keeps the extremes
            / \return random curvilinear coordinates in the interval [0.0, 1.0], size 1 x numCoordinates
            / \note if size < 2 then size will be considered as 2
            """
            pass

        def polar_angle(
            self,
            v_prev: Eigen.Vector3d,
            v: Eigen.Vector3d,
            v_next: Eigen.Vector3d,
            norm_v_prev_v: float,
            norm_v_next_v: float
            ) -> float:
            """/ \param v_prev the previous point
            / \param v the middle point
            / \param v_next the next point
            / \return the polar angle between the three points, computed as the cross product (v_next-v) x (v_prev-v)
            / \note positive is convex (counter-clockwise), negative is concave (clockwise), zero is collinear
            """
            pass

        def point_distance(
            self,
            first_point: Eigen.Vector3d,
            second_point: Eigen.Vector3d
            ) -> float:
            """/ \brief compute the Point distance
            / \param firstPoint the first point
            / \param secondPoint the second point
            / \return the distance
            """
            pass

        def point_distances(
            self,
            points: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> Eigen.VectorXd:
            """/ \brief compute the distance between a point and a list of points
            / \param points the point collection, size 3 x numPoints
            / \param point the point
            / \return the collection of distances, size 1 x numPoints
            """
            pass

        def points_distance(self, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \param points the point collection, size 3 x numPoints
            / \return the distances between the points collected in matrix, size numPoints x numPoints.
            """
            pass

        def points_bounding_box(self, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \param points the point collection, size 3 x numPoints
            / \return the extreme bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints
            """
            pass

        def is_point_in_bounding_box(
            self,
            point: Eigen.Vector3d,
            bouding_box: Eigen.MatrixXd
            ) -> bool:
            """/ \param point the point
            / \param boudingBox the bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints
            / \return False if the point is outside the bounding box, True otherwise (border or inside)
            """
            pass

        def bounding_boxes_intersects(
            self,
            bouding_box_1: Eigen.MatrixXd,
            bouding_box_2: Eigen.MatrixXd
            ) -> bool:
            pass

        def points_max_distance(self, points: Eigen.MatrixXd) -> float:
            """/ \param points the point collection, size 3 x numPoints
            / \return the maximum distance between the points.
            """
            pass

        def is_point_zero(self, point: Eigen.Vector3d) -> bool:
            pass

        def points_are_coincident(
            self,
            first_point: Eigen.Vector3d,
            second_point: Eigen.Vector3d
            ) -> bool:
            """/ \param firstPoint the first point
            / \param secondPoint the second point
            / \return True if the points are coincident
            """
            pass

        def find_point_in_points(
            self,
            points: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Find a point in point list
            / \param points the point list, size 3 x numPoints
            / \param point the point to find
            / \return the collection of point found
            """
            pass

        def point_line_distance(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            normal_to_line: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the distance between a point and a line
            / \param point a point P
            / \param lineOrigin the line origin O
            / \param normalToLine a normal vector n to the line, in the same plane of P and the line
            / \return the distance d
            / \note The distance is computed as d = n^T * (P - O) / ||n||
            """
            pass

        def point_is2_d(self, point: Eigen.Vector3d) -> bool:
            """/ \param point the point
            / \return True if the point is 2D (z == 0)
            """
            pass

        def points_are2_d(self, points: Eigen.MatrixXd) -> bool:
            """/ \param points the points to test, size 3 x numPoints
            / \return True if the points are 2D (z == 0)
            """
            pass

        def point_curvilinear_coordinate(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief compute the Point Curvilinear Coordinate of segment
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the curvilinear coordinate computed
            """
            pass

        def point_line_curvilinear_coordinate(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d,
            line_tangent_squared_length: float
            ) -> float:
            """/ \brief compute the Point Curvilinear Coordinate of line
            / \param point the point
            / \param lineOrigin the line origin
            / \param lineTangent the line tangent
            / \param lineTangentSquaredLength the line tangent length squared
            / \return the curvilinear coordinate computed
            """
            pass

        def is_point_on_line(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d,
            line_tangent_squared_length: float
            ) -> bool:
            """/ \param point the point
            / \param lineOrigin the line origin
            / \param lineTangent the line tangent
            / \param lineTangentSquaredLength the line tangent length squared
            / \return True if the point belongs on line
            """
            pass

        @overload
        def point_segment_position(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> GeometryUtilities.PointSegmentPositionTypes:
            """/ \brief Compute point position respect to a segment
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return result the point position
            / \warning left and right point positions work only in xy plane
            """
            pass

        @overload
        def point_segment_position(
            self,
            curvilinear_coordinate: float
            ) -> GeometryUtilities.PointSegmentPositionTypes:
            """/ \brief Compute point position on a segment line given the curvilinear Coordinate
            / \param curvilinearCoordinate the curvilinear coordinate, segment is between 0.0 and 1.0
            / \param result the point position on the line
            """
            pass

        def point_segment_projection(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Project point on a segment line
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the projected point curvilinear coordinate
            """
            pass

        @overload
        def point_plane_distance(
            self,
            point: Eigen.Vector3d,
            plane_points: List[Eigen.Vector3d]
            ) -> float:
            """/ \brief Compute point position respect to a plane formed by 3 points
            / \param planePoints the 3 plane points
            / \param point the point
            / \return the signed point distance, 0.0 on plane, positive above, negative bottom
            """
            pass
        @overload
        def point_plane_distance(
            self,
            point: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute point position respect to a plane normal
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \param point the point
            / \return the signed point distance, 0.0 on plane, positive above, negative bottom
            """
            pass

        def point_plane_position(
            self,
            point_plane_distance: float
            ) -> GeometryUtilities.PointPlanePositionTypes:
            """/ \brief Compute point position respect to a plane
            / \param pointPlaneDistance the point plane distance
            / \return result the point position
            """
            pass

        @overload
        def is_point_on_plane(self, point_plane_distance: float) -> bool:
            """/ \param pointPlaneDistance the point plane distance
            / \return True if point is on the plane
            """
            pass

        @overload
        def is_point_on_plane(
            self,
            point: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> bool:
            """/ \param point the point
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \return True if point is on the plane
            """
            pass

        def segment_length(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment length
            """
            pass

        def segment_tangent(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment tangent
            """
            pass

        def segment_normal(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment normal normalized, rotation of the normalized tangent (x,y,0) with 90° clockwise (y, -x,0)
            / \note the segment shall be 2D
            """
            pass

        def segment_slope(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the segment slope m of line y = m * x + q
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment slope
            / \note the segment shall be 2D
            """
            pass

        def segment_intercept(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the segment intercept q of line y = m * x + q
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment intercept
            / \note the segment shall be 2D
            """
            pass

        def make_concatenation(
            self,
            segments: Eigen.MatrixXi,
            starting_vertex: int
            ) -> Eigen.MatrixXi:
            pass

        def check_no_spheres_intersection(
            self,
            first_sphere_center: Eigen.Vector3d,
            second_sphere_center: Eigen.Vector3d,
            first_sphere_diameter: float,
            second_sphere_diameter: float
            ) -> bool:
            """/ \brief Check if two spheres do not intersect
            / \param firstSphereCenter the first sphere center
            / \param secondSphereCenter the second sphere center
            / \param firstSphereDiameter the first sphere diameter
            / \param secondSphereDiameter the second sphere diameter
            / \return True if the two segments do not intersect
            / \note if the function returns True it does not mean that the two segments intersects
            """
            pass

        def check_triangles_intersection(
            self,
            triangle_one: Eigen.MatrixX3d,
            triangle_two: Eigen.MatrixX3d,
            admit_boundary: bool = True
            ) -> bool:
            """/ \note works only for 2D triangles
            / \see https://rosettacode.org/wiki/Determine_if_two_triangles_overlap                                      #C++
            """
            pass

        def are_line_coplanar(
            self,
            first_line_origin: Eigen.Vector3d,
            first_line_tangent: Eigen.Vector3d,
            second_line_origin: Eigen.Vector3d,
            second_line_tangent: Eigen.Vector3d
            ) -> bool:
            """/ \param firstLineOrigin first line origin
            / \param firstLineTangent first line tangent
            / \param secondLineOrigin second line origin
            / \param secondLineTangent second line tangent
            / \return line coplanarity
            """
            pass

        def is_polygon_coplanar(
            self,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd,
            polygon_unaligned_vertices: List[int]
            ) -> bool:
            """/ \brief verify if the polygon is in the coplana to a plane"""
            pass

        def intersection_segment_segment(
            self,
            first_segment_origin: Eigen.Vector3d,
            first_segment_end: Eigen.Vector3d,
            second_segment_origin: Eigen.Vector3d,
            second_segment_end: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionSegmentSegmentResult:
            """/ \brief Compute the intersection between the two segments
            / \param firstSegmentOrigin first segment origin
            / \param firstSegmentEnd first segment end
            / \param secondSegmentOrigin second segment origin
            / \param secondSegmentEnd second segment end
            / \return the resulting intersection
            / \note no check is performed
            """
            pass

        def intersections_between_segments(
            self,
            segments_vertices: List[Eigen.MatrixXd],
            segments_tangent: List[Eigen.Vector3d],
            segments_barycenter: List[Eigen.Vector3d],
            segments_length: List[float]
            ) -> List[std.list[float]]:
            """/ \brief Compute the intersection between a collection of segments
            / \param segmentsVertices the segments vertices
            / \param segmentsTangent the segments tangent
            / \param segmentsBarycenter the segments barycenter
            / \param segmentsLength the segments length
            / \return for each segment the list of intersections curvilinear coordinate
            """
            pass

        def intersection_segment_circle(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.IntersectionSegmentCircleResult:
            """/ \brief Compute the intersection between the a segment and a circle
            / \param segmentOrigin first segment origin
            / \param segmentEnd first segment end
            / \param circleCenter circle center
            / \param circleRadius circle radius
            / \return the resulting intersection
            / \note tested only in 2D
            """
            pass

        def intersection_segment_plane(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionSegmentPlaneResult:
            """/ \brief Intersection between a Segment, represented by origin and end and a plane
            / represented by the normal and a point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segement end
            / \param planeNormal the plane normal normalized
            / \param planeOrigin a plane point
            / \return the resulting intersection
            """
            pass

        def intersection_polyhedron_plane(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            plane_rotation_matrix: Eigen.Matrix3d,
            plane_translation: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronPlaneResult:
            """/ \brief Intersection between a Polyhedron and a Plane
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param planeNormal the plane normal normalized
            / \param planeOrigin the plane origin
            / \param planeRotationMatrix the plane rotation from 3D to 2D
            / \param planeTranslation the plane translation vector
            / \return the intersection result
            / \note works only with convex polyhedra
            """
            pass

        def split_polyhedron_with_plane(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_edge_tangents: List[Eigen.MatrixXd],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            plane_rotation_matrix: Eigen.Matrix3d,
            plane_translation: Eigen.Vector3d
            ) -> GeometryUtilities.SplitPolyhedronWithPlaneResult:
            pass

        def split_polyhedron_with_plane_result_to_polyhedra(
            self,
            result: GeometryUtilities.SplitPolyhedronWithPlaneResult
            ) -> List[GeometryUtilities.Polyhedron]:
            pass

        def intersection_polyhedron_line(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            line_tangent: Eigen.Vector3d,
            line_origin: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronLineResult:
            """/ \brief Intersection between a Polyhedron and a line
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return the intersection result
            / \warning NOT TESTED PROPERLY
            """
            pass

        def intersection_polyhedron_segment(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            polyhedron_line_intersections: GeometryUtilities.IntersectionPolyhedronLineResult
            ) -> GeometryUtilities.IntersectionPolyhedronLineResult:
            """/ \brief Intersection between a Polyhedron and a segment
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \param segmentTangent the segment tangent
            / \param polyhedronLineIntersections the intersection between the polyhedron and the line of the segment
            / \return the intersection result
            / /// \warning NOT TESTED PROPERLY
            """
            pass

        def intersection_polyhedrons_segment(
            self,
            polyhedrons: List[GeometryUtilities.Polyhedron],
            polyhedron_face_normals: List[List[Eigen.Vector3d]],
            polyhedron_face_normal_directions: List[List[bool]],
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronsSegmentResult:
            """/ \brief Intersection between a collectio of Polyhedrons and a segment
            / \param polyhedrons the polyhedron collection
            / \param polyhedronFaceNormals polyhedron face normals
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \param segmentTangent the segment tangent
            / \return the intersection result
            / \warning NOT TESTED PROPERLY
            """
            pass

        def point_polygon_position(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.PointPolygonPositionResult:
            """/ \brief Check if point is inside a polygon
            / \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting position
            / \warning works only in 2D with convex polygons
            """
            pass

        def point_polygon_position_ray_casting(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.PointPolygonPositionResult:
            pass

        def is_point_inside_polygon(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> bool:
            """/ \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return False if it is outside, True the other cases
            / \warning works only in 2D with convex polygons
            """
            pass

        def is_point_inside_polygon_ray_casting(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> bool:
            """/ \brief IsPointInsidePolygon using RayCasting algorithm
            / (see https://en.wikipedia.org/wiki/Point_in_polygon)
            / \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return False if it is outside, True the other cases
            """
            pass

        def line_polygon_position(
            self,
            line_tangent: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.LinePolygonPositionResult:
            pass

        #/ \brief Check if point is inside a polygon
        #/ \param point the point
        #/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
        #/ \param result the resulting position

        @overload
        def point_polyhedron_position(
            self,
            point: Eigen.Vector3d,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> GeometryUtilities.PointPolyhedronPositionResult:
            """/ \brief Check if point is inside a polyhedron
            / \param point the point
            / \param polyhedronFaces the polyhedron faces, size numPolyhedronFaces
            / \param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces
            / \param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces
            / \param polyhedronFaceNormals the polyhedron face normals
            / \param polyhedronFaceNormalDirections the polyhedron face normal directions
            / \param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return the point position respect the polyhedron
            / \note works only for convex polyhedrons
            """
            pass
        @overload
        def point_polyhedron_position(
            self,
            point: Eigen.Vector3d,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_faces_3_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_2_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_normals: List[Eigen.Vector3d],
            polyhedron_faces_normal_direction: List[bool],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_tetrahedrons: List[Eigen.MatrixXd]
            ) -> GeometryUtilities.PointPolyhedronPositionResult:
            """/ \brief Check if point is inside a polyhedron
            / \param point the point
            / \param polyhedronFaces the polyhedron faces, size numPolyhedronFaces
            / \param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces
            / \param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces
            / \param polyhedronFaceNormals the polyhedron face normals
            / \param polyhedronFaceNormalDirections the polyhedron face normal directions
            / \param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return the point position respect the polyhedron
            / \note works for concave and convex polyhedrons
            """
            pass

        def is_point_inside_tetrahedron(
            self,
            tetrahedron: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> bool:
            pass

        def point_circle_position(
            self,
            point: Eigen.Vector3d,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.PointCirclePositionResult:
            """/ \brief Check if point is inside a circle
            / \param point the point
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param result the resulting position
            / \note tested only in 2D
            """
            pass

        def point_circle_positions(
            self,
            points: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> List[GeometryUtilities.PointCirclePositionResult]:
            """/ \brief Check if points are inside a circle
            / \param points the matrix of points (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param result the resulting positions
            / \note tested only in 2D
            """
            pass

        def polygon_circle_position(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            vertex_positions: List[GeometryUtilities.PointCirclePositionResult],
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult
            ) -> GeometryUtilities.PolygonCirclePositionTypes:
            """/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param vertexPositions the polygon vertices positions respect the circle
            / \param polygonCircleIntersections the polygon center intersections
            / \return the Polygon Circle reciprocal position
            / \note tested only in 2D
            """
            pass

        def intersection_polygon_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.IntersectionPolygonCircleResult:
            """/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \return the Polygon Circle reciprocal intersections
            / \note tested only in 2D
            """
            pass

        def polygon_triangulation_by_first_vertex(
            self,
            polygon_vertices: Eigen.MatrixXd
            ) -> List[int]:
            """/ \brief Convex Polygon simple Triangulation from the first vertex
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the sub-division triangulation, size 1 x 3 * numTriangles
            / \note works only for convex polygon
            """
            pass

        def polygon_triangulation_by_ear_clipping(
            self,
            polygon_vertices: Eigen.MatrixXd
            ) -> List[int]:
            """/ \brief Concave Polygon Triangulation with ear clipping algorithm
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the sub-division triangulation, size 1 x 3 * numTriangles
            """
            pass

        def polygon_triangulation_by_internal_point(
            self,
            polygon_vertices: Eigen.MatrixXd,
            internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Convex Polygon simple Triangulation from an internal point
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param point internal polygon point
            / \return the sub-division triangulation, size 1 x 3 * numPolygonVertices,
            / \note the internal point index is numPolygonVertices
            """
            pass

        def polygon_outside_circle_division_by_angle_quadrant(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByAngleQuadrantResult:
            """/ \brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            """
            pass

        def polygon_inside_circle_division_by_angle_quadrant(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByAngleQuadrantResult:
            """/ \brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            """
            pass

        def polygon_division_by_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByCircleResult:
            """/ \brief Convex Polygon sub division from a circle which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            / \note the polygon should be inside the angle quadrant formed by the curved edge
            / \note otherwise use PolygonDivisionByAngleQuadrant function to split the polygon
            """
            pass

        def circle_division_by_polygon(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.CircleDivisionByPolygonResult:
            """/ \brief Circle division from Convex Polygon sub division which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division circle result
            / \note the polygon should be inside the angle quadrant formed by the curved edge
            """
            pass

        def polygon_area(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the polygon area
            / \note the polygon shall be 2D
            """
            pass

        def polygon_area3_d(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the polygon area
            """
            pass

        def polygon_mass(
            self,
            polygon_centroid: Eigen.Vector3d,
            polygon_triangulation_points: List[Eigen.Matrix3d]
            ) -> Eigen.Matrix2d:
            """/ \param polygonCentroid the centroid
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \return the polygon mass matrix
            """
            pass

        def polygon_inertia(
            self,
            polygon_centroid: Eigen.Vector3d,
            polygon_triangulation_points: List[Eigen.Matrix3d]
            ) -> Eigen.Matrix3d:
            """/ \param polygonCentroid the centroid
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \return the polygon intertia tensor
            """
            pass

        def split_polygon_with_segment(
            self,
            input: GeometryUtilities.SplitPolygonInput
            ) -> GeometryUtilities.SplitPolygonWithSegmentResult:
            """/ \brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a segment contained inside
            / \param input the input data
            / \param result the resulting split
            / \note only indices are threated in this function, no space points
            """
            pass

        def split_polygon_with_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            vertex_positions: List[GeometryUtilities.PointCirclePositionResult],
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult,
            polygon_circle_position: GeometryUtilities.PolygonCirclePositionTypes
            ) -> GeometryUtilities.SplitPolygonWithCircleResult:
            """/ \brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a cirle
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param vertexPositions the polygon vertices positions respect the circle
            / \param polygonCircleIntersections the polygon center intersections
            / \param polygonCirclePosition the polygon position respect the circle
            / \note tested only in 2D
            / \return the split result
            / \note only indices are threated in this function, no space points
            """
            pass

        def split_polygon_with_circle_build_sub_polygon(
            self,
            split_result: GeometryUtilities.SplitPolygonWithCircleResult,
            sub_polygon_index: int,
            polygon_vertices: Eigen.MatrixXd,
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult
            ) -> Eigen.MatrixXd:
            """/ \brief Build the subpolygon coordinates from split result
            / \param splitResult the split result
            / \param subPolygonIndex the subpolygon index, from 0 to SplitPolygonWithCircleResult::NewPolygons.size()
            / \param polygonVertices the original polygon vertices
            / \param polygonCircleIntersections the polygon circle intersection
            / \return the resulting subpolygon coordinates
            """
            pass

        def split_polygon_with_plane(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            polygon_translation: Eigen.Vector3d,
            polygon_rotation_matrix: Eigen.Matrix3d
            ) -> GeometryUtilities.SplitPolygonWithPlaneResult:
            """/ \brief Split 3 Polygon With Plane
            / \param polygonVertices the 3D polygon vertices
            / \param polygonEdgeTangents the 3D polygon edge tangents
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \param polygonTranslation the polygon translation vector for rotation
            / \param polygonRotationMatrix the polygon rotation matrix from 2D to 3D
            / \return the splitted polygons
            """
            pass

        def polygon_normal(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon tridimensional normalized Normal
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting normalized normal
            """
            pass

        def polygon_tangents(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_normal: Eigen.Vector3d
            ) -> List[Eigen.Vector3d]:
            pass

        def polygon_edges_centroid(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edges centroid
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edges centroid, size 3 x numVertices
            """
            pass

        def polygon_edge_lengths(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.VectorXd:
            """/ \brief Compute the Polygon edge lengths
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge lengths, size 1 x numVertices
            """
            pass

        def polygon_edge_tangents(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edge tangents
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge tangents, size 3 x numVertices
            """
            pass

        def polygon_edge_normals(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edge normals outgoing the polygon
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge normals outgoing the polygon, size 3 x numVertices
            """
            pass

        def simplex_barycenter(self, vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the simplex barycenter as a mean of all vertices
            / \param vertices the matrix of vertices of the simplex (size 3 x numVertices)
            """
            pass

        def simplex_measure(self, vertices: Eigen.MatrixXd) -> float:
            pass

        def segment_barycenter(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \brief Compute the segment barycenter as a mean of all vertices
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            """
            pass

        def polygon_barycenter(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon barycenter as a mean of all vertices
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            """
            pass

        def polyhedron_barycenter(self, polyhedron_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the polyhedron barycenter as a mean of all vertices
            / \param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)
            """
            pass

        @overload
        def polygon_centroid(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon centroid as described in https://en.wikipedia.org/wiki/Centroid
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param polygonArea the area of the polygon
            / \note the polygon shall be 2D
            """
            pass

        @overload
        def polygon_centroid(
            self,
            sub_polygon_centroids: Eigen.MatrixXd,
            sub_polygon_areas: Eigen.VectorXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon centroid using polygon sub-division
            / \param subPolygonCentroids the centroid of each subPolygon (size 3 x numSubPolygons)
            / \param subPolygonAreas the areas of each subPolygon, size 1 x numSubPolygons
            / \param polygonArea the total area of the polygon
            """
            pass

        def polygon_area_by_boundary_integral(
            self,
            polygon_vertices: Eigen.MatrixXd,
            edge_lengths: Eigen.VectorXd,
            edge_tangents: Eigen.MatrixXd,
            edge_normals: Eigen.MatrixXd,
            reference_quadrature_points: Eigen.MatrixXd = (Eigen.MatrixXd(3, 1) << 0.5, 0.0, 0.0).finished(),
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Ones(1)
            ) -> float:
            """/ \brief Polygon Area By Integral on edges
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param edgeLengths the edge lengths, size numEdges
            / \param edgeTangents the edge tangents, size 3 x numEdges
            / \param edgeNormals the edge outgoint normals, size 3 x numEdges
            / \param referenceQuadraturePoints quadrature points on reference segment [0,1]
            / \param referenceQuadratureWeights quadrature weights on reference segment [0,1]
            / \return the polygon area
            / \note the area is computed as integral_edges x dot n_x with gauss formula on edges of order 1
            """
            pass

        def polygon_area_by_internal_integral(
            self,
            polygon_triangulation_points: List[Eigen.Matrix3d],
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 0.5)
            ) -> float:
            """/ \brief Polygon Area By Internal Integral
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \param referenceQuadratureWeights the reference triangle quadrature weights [0,1]x[0,1]
            / \return the area computed as integral on sub-triangles
            """
            pass

        def polygon_centroid_by_integral(
            self,
            polygon_vertices: Eigen.MatrixXd,
            edge_lengths: Eigen.VectorXd,
            edge_tangents: Eigen.MatrixXd,
            edge_normals: Eigen.MatrixXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Polygon Area By Integral on edges
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param edgeLengths the edge lengths, size numEdges
            / \param edgeTangents the edge tangents, size 3 x numEdges
            / \param edgeNormals the edge outgoint normals, size 3 x numEdges
            / \param polygonArea the polygon area
            / \return the polygon centroid
            / \note the area is computed as integral_edges (x^2, y^2) dot n with gauss formula on edges of order 2
            """
            pass

        def polygon_centroid_edges_distance(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_centroid: Eigen.Vector3d,
            polygon_edge_normals: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            """/ \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param polygonCentroid the polygon centroid
            / \param polygonEdgeNormals the polygon edge normals outgoing the polygon, size 3 x numEdges
            / \return the distance between the centroid and all the polygon edges, size 1 x numEdges
            """
            pass

        def polygon_centroid_vertices_distance(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_centroid: Eigen.Vector3d
            ) -> Eigen.VectorXd:
            """/ \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param polygonCentroid the polygon centroid
            / \return the distance between the centroid and all the polygon vertices, size 1 x numEdges
            """
            pass

        def polygon_in_radius(self, polygon_centroid_edges_distance: Eigen.VectorXd) -> float:
            """/ \param polygonCentroidEdgesDistance the polygon centroid edges distance, size 1 x numEdges
            / \return the polygon in radius, as the minimum distance between the polygon centroid and the edges
            """
            pass

        def polygon_aspect_ratio(
            self,
            polygon_diameter: float,
            polygon_in_radius: float
            ) -> float:
            """/ \param polygonDiameter the polygon diameter
            / \param polygonInRadius the polygon in radius
            / \return the polygon aspect ratio, defined as the ratio bewteen the in and out diameter
            """
            pass

        def polygon_diameter(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \brief Compute the Polygon diameter defined as the maximum distance between the vertices
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            """
            pass

        def polygon_translation(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the translation vector of a tridimensional Polygon
            / \param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)
            / \return the resulting translation vector t which corresponds to the first vertex of the polygon
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def polygon_rotation_matrix(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_normal: Eigen.Vector3d,
            polygon_translation: Eigen.Vector3d
            ) -> Eigen.Matrix3d:
            """/ \brief Compute the rotation matrix and translation vector of a tridimensional Polygon
            / \param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)
            / \param polygonNormal the normalized normal of the plane which contains the polygon
            / \param polygonTranslation the translation vector t
            / \return the resulting rotation matrix Q which rotates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def polygon_is_convex(
            self,
            polygon_vertices: Eigen.MatrixXd,
            convex_hull: Eigen.MatrixXd
            ) -> bool:
            """/ \brief Check if Polygon is Convex
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param convexHull the convex hull vertices counterclockwise
            / \return True if polygon is convex, False otherwise
            / \note works only in 2D-plane
            """
            pass

        def polygon_type(
            self,
            num_polygon_vertices: int,
            is_polygon_convex: bool
            ) -> GeometryUtilities.PolygonTypes:
            """/ \param numPolygonVertices the number of polygon vertices
            / \param isPolygonConvex True if the polygon is convex
            / \return the polygon type
            """
            pass

        def polygon_orientation(
            self,
            convex_hull: List[int]
            ) -> GeometryUtilities.PolygonOrientations:
            """/ \param convexHull the polygon convex hull vertices indices counterclockwise
            / \return the polygon 2D orientation
            / \note works only in 2D-plane
            """
            pass

        def change_polygon_orientation(self, num_polygon_vertices: int) -> List[int]:
            """/ \param numPolygonVertices the number of polygon vertices
            / \return the new polygon vertices indices oriented in the opposite direction
            """
            pass

        def plane_rotation_matrix(self, plane_normal: Eigen.Vector3d) -> Eigen.Matrix3d:
            """/ \brief Compute the rotation matrix of a plane from 2D to 3D
            / \param planeNormal the normalized normal of the plane
            / \return the resulting rotation matrix Q which rotates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def plane_translation(self, plane_origin: Eigen.Vector3d) -> Eigen.Vector3d:
            """/ \brief Compute the translation vector of a plane from 2D to 3D
            / \param planeNormal the normalized normal of the plane
            / \param planeOrigin the 3D plane origin
            / \return the resulting translation vector t which translates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def rotate_points(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P using rotation matrix Q and translation t: Q * P + t
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix, size 3x3
            / \param translation the translation vector, size 1x3
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t
            """
            pass

        def rotate_points_from2_d_to3_d(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P From 2D To 3D using rotation matrix Q and translation t: Q * P + t
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix from 2D to 3D
            / \param translation the translation vector
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t
            """
            pass
        def rotate_points_from3_d_to2_d(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P From 3D To 2D using rotation matrix Q and translation t: Q * (P - t)
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix from 3D to 2D
            / \param translation the translation vector
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * (P - t)
            """
            pass

        def convex_hull(
            self,
            points: Eigen.MatrixXd,
            include_collinear: bool = True
            ) -> List[int]:
            """/ \brief Compute the Convex Hull of 2D points
            / \param points the points, size 3 x numPoints
            / \param includeCollinear include the collinear points, default True
            / \return the convex hull indices counterclockwise, size numConvexHullPoints, numConvexHullPoints <= numPoints
            / \note works in 2D, use the Graham_scan algorithm https://en.wikipedia.org/wiki/Graham_scan
            """
            pass

        def points_are_aligned(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            points: Eigen.MatrixXd
            ) -> List[bool]:
            """/ \brief Check if a set of points are aligned to a line identified by a segment
            / \param segmentOrigin segment origin of the line
            / \param segmentEnd segment end of the line
            / \param points the points, size 3 x numPoints
            / \return True if the i-th point is aligned, size 1 x numPoints
            """
            pass

        def points_are_on_line(
            self,
            points: Eigen.MatrixXd,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d
            ) -> List[bool]:
            """/ \brief Check if a set of points are on a line
            / \param points the points, size 3 x numPoints
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return True if the i-th point is aligned, size 1 x numPoints
            """
            pass

        def point_is_aligned(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            point: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if a point is aligned to a line identified by a segment
            / \param segmentOrigin segment origin of the line
            / \param segmentEnd segment end of the line
            / \param point the point
            / \return True if the point is aligned
            """
            pass

        def point_is_on_line(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if a point is on a line
            / \param point the point
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return True if the point is aligned
            """
            pass

        def unaligned_points(
            self,
            points: Eigen.MatrixXd,
            num_desired_unaligned_points: int = 0
            ) -> List[int]:
            """/ \brief Extract the circumscribed unaligned points (minimum 2) in a set of points
            / \param points the points, size 3 x numPoints
            / \param numDesiredUnalignedPoints the number of desired unaligned points, if 0 all the points are computed
            / \return the unaligned points indices counterclockwise, size numUnalignedPoints, 2 <= numUnalignedPoints <=
            / numPoints
            """
            pass

        def unaligned_polyhedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_unaliged_faces: List[List[int]],
            polyhedron_faces_unaligned_vertices: List[List[int]]
            ) -> List[int]:
            """/ \brief Extract the circumscribed unaligned points (minimum 4) in a polyhedron
            / \return the unaligned points, size numUnalignedPoints, 4 <= numUnalignedPoints <= numPoints
            / \warning works only for convex polyhedron
            """
            pass

        def aligned_polyhedron_edges(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            vertices_adjacency: List[List[int]],
            edges_adjacency: List[List[int]],
            adjacency_vertices_map: List[std.unordered_map[int, int]],
            polyhedron_edge_tangents: Eigen.MatrixXd,
            polyhedron_edge_squared_lenghts: Eigen.VectorXd
            ) -> GeometryUtilities.AlignedPolyhedronEdgesResult:
            pass

        def extract_points(self, points: Eigen.MatrixXd, filter: List[int]) -> Eigen.MatrixXd:
            """/ \param points the points, size 3 x numPoints
            / \param filter indices counterclockwise, size numFilterPoints, numFilterPoints <= numPoints
            / \return the points coordinates filtered, size 3 x numFilterPoints
            """
            pass

        def extract_triangulation_points(
            self,
            points: Eigen.MatrixXd,
            points_triangulation: List[int]
            ) -> List[Eigen.Matrix3d]:
            """/ \param points the points, size 3 x numPoints
            / \param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles
            / \return the triangles coordinates, size 1 x numTriangles
            """
            pass

        def extract_triangulation_points_by_internal_point(
            self,
            points: Eigen.MatrixXd,
            internal_point: Eigen.Vector3d,
            points_triangulation: List[int]
            ) -> List[Eigen.Matrix3d]:
            """/ \param points the points, size 3 x numPoints
            / \param externalPoint the external point coordinates
            / \param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles
            / \return the triangles coordinates, size 1 x numTriangles
            """
            pass

        def create_ellipse(
            self,
            axis_major_length: float,
            axis_minor_length: float,
            resolution: int
            ) -> Eigen.MatrixXd:
            """/ \brief Create 2D Ellipse approximation with 2D polygon
            / \param axisMajorLength the ellipse axis major length
            / \param axisMinorLength the ellipse axis minor length
            / \param resolution the number of points on each ellipse quadrant
            / \return the polygon which approximate the ellipse
            / \note the ellipse is centered in the origin and parallel to xy-axis
            """
            pass

        def create_triangle(
            self,
            p1: Eigen.Vector3d,
            p2: Eigen.Vector3d,
            p3: Eigen.Vector3d
            ) -> Eigen.MatrixXd:
            """/ \brief Create a triangle with points"""
            pass
        def create_parallelogram(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> Eigen.MatrixXd:
            """/ \brief Create a parallelogram with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param widthVector the width vector
            """
            pass
        def create_rectangle(
            self,
            origin: Eigen.Vector3d,
            base: float,
            height: float
            ) -> Eigen.MatrixXd:
            """/ \brief Create a rectangle with origin and dimensions parallel to axis
            / \param origin the origin
            / \param base the base length
            / \param height the height length
            """
            pass

        def create_square(self, origin: Eigen.Vector3d, edge_length: float) -> Eigen.MatrixXd:
            """/ \brief Create a square with origin and dimensions parallel to axis
            / \param origin the origin
            / \param edgeLength the edge length
            """
            pass

        def create_tetrahedron_with_origin(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            height_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Tetrahedron with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param heightVector the heigth vector
            / \param widthVector the width vector
            / \return the tetrahedron created
            """
            pass

        def create_tetrahedron_with_vertices(
            self,
            v1: Eigen.Vector3d,
            v2: Eigen.Vector3d,
            v3: Eigen.Vector3d,
            v4: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Tetrahedron with the four vertices
            / \param v1 the first vertex
            / \param v2 the second vertex
            / \param v3 the third vertex
            / \param v4 the fourth vertex
            / \return the tetrahedron created
            """
            pass

        def create_parallelepiped_with_origin(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            height_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Parallelepiped with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param heightVector the heigth vector
            / \param widthVector the width vector
            / \return the parallelepiped created
            """
            pass

        @overload
        def create_polyhedron_with_extrusion(
            self,
            polygon_vertices: Eigen.MatrixXd,
            height_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create Polyhedron With Extrusion
            / \param polygon the 2D polygon vertices
            / \param heightVector  the height vector
            / \return the polyhedron created
            """
            pass

        @overload
        def create_polyhedron_with_extrusion(
            self,
            polygon_vertices: Eigen.MatrixXd,
            height_vectors: List[Eigen.Vector3d]
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create Polyhedron With Extrusion
            / \param polygon the 2D polygon vertices, size 3 x numPolygonVertices
            / \param heightVectors the height vector to be used for each polygon vertex, size numPolygonVertices
            / \return the polyhedron created
            """
            pass

        def create_cube_with_origin(
            self,
            origin: Eigen.Vector3d,
            edge_length: float
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Cube with origin aligned to axis
            / \param origin the origin
            / \param edgeLength the edge length
            / \return the cube created
            """
            pass

        def polyhedron_volume_by_boundary_integral(
            self,
            polyhedron_face_rotated_triangulation_points: List[List[Eigen.Matrix3d]],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            reference_quadrature_points: Eigen.MatrixXd = (Eigen.MatrixXd(3, 1) << 1.0 / 3.0, 1.0 / 3.0, 0.0).finished(),
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 0.5)
            ) -> float:
            """/ \brief Compute the Polyhedron Volume
            / \param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces
            / x numTrianglesPerFace \param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \param
            / polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \param
            / polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \param
            / polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \param referenceQuadraturePoints
            / the reference tetrahedron quadrature points [0,1]x[0,1]x[0,1] \param referenceQuadratureWeights the reference
            / tetrahedron quadrature weights [0,1]x[0,1]x[0,1] \return the polyhedron volume \note use the divergence theorem,
            / with F = 1/3 (x, y, z), see https://en.wikipedia.org/wiki/Divergence_theorem
            """
            pass

        def polyhedron_volume_by_internal_integral(
            self,
            polyhedron_tetrahedron_vertices: List[Eigen.MatrixXd],
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 1.0 / 6.0)
            ) -> float:
            """/ \brief Polyhedron Volume By Internal Integral
            / \param polyhedronTetrahedronVertices the internal polyhedron sub-tetrahedra
            / \param referenceQuadratureWeights the reference tetrahedron quadrature weights [0,1]x[0,1]x[0,1]
            / \return the area computed as integral on sub-tetrahedra
            """
            pass

        def polyhedron_centroid(
            self,
            polyhedron_face_rotated_triangulation_points: List[List[Eigen.Matrix3d]],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            polyhedron_volume: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polyhedron centroid
            / \param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces
            / x numTrianglesPerFace \param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \param
            / polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \param
            / polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \param
            / polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \param polyhedronVolume the
            / polyhedron volume \return the polyhedron centroid \note use the divergence theorem, with F_x = 1/2 (x^2, 0, 0),
            / F_y = 1/2 (0, y^2, 0), F_z = 1/2 (0, 0, z^2), see https://en.wikipedia.org/wiki/Divergence_theorem
            """
            pass

        def polyhedron_diameter(self, polyhedron_vertices: Eigen.MatrixXd) -> float:
            """/ \brief Compute the Polyhedron diameter defined as the maximum distance between the vertices
            / \param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)
            """
            pass

        def polyhedron_edges_centroid(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.MatrixXd:
            """/ \brief Compute Polyhedron Edges Centroid
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the centroid, size 3xnumEdges
            """
            pass

        def polyhedron_edges_length(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.VectorXd:
            """/ \brief Compute Polyhedron Edges Lenght
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the length, size 1xnumEdges
            """
            pass

        def polyhedron_edge_tangents(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.MatrixXd:
            """/ \brief Compute Polyhedron Edges Tangent
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the tangent, size 3xnumEdges
            """
            pass

        def polyhedron_face_vertices(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi]
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Vertices
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \return for each face the vertices, size 1xnumFaces
            """
            pass

        def polyhedron_face_edge_directions(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi]
            ) -> List[List[bool]]:
            """/ \brief Compute Polyhedron Faces Edge Direction
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \return for each face the edge direction compare to polyhedron edge directions, size 1xnumFaces
            """
            pass

        def polyhedron_face_edge_tangents(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_edge_directions: List[List[bool]],
            polyhedron_edge_tangents: Eigen.MatrixXd
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Edge Tangents
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronEdgeTangents for each polyhedron edge the tangent, size 3xnumEdges
            / \return for each face the edge tangents, size 1xnumFaces
            """
            pass

        def polyhedron_face_rotation_matrices(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_translations: List[Eigen.Vector3d]
            ) -> List[Eigen.Matrix3d]:
            """/ \brief Compute Polyhedron Faces Rotation matrix
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the rotation matrix from 2D to 3D
            """
            pass

        def polyhedron_face_translations(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces translation vectors
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the translation vector
            """
            pass

        def polyhedron_face_rotated_vertices(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Rotated Vertices 2D
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaceTranslations the polyhedron face translations from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return for each face the 2D vertices, size 1xnumFaces
            """
            pass

        def polyhedron_faces_unaligned_vertices(
            self,
            polyhedron_faces_rotated_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Compute Polyhedron Faces Unaligned Vertices Indices
            / \param polyhedronFacesRotatedVertices the polyhedron faces 2D vertices
            / \return for each face the unaligned vertices indices, size 1 x numFaces
            """
            pass

        def polyhedron_face_normals(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces Normals
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the normal
            """
            pass

        def polyhedron_face_tangents(
            self,
            polyhedron_faces_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_normal: List[Eigen.Vector3d],
            polyhedron_faces_normal_direction: List[bool]
            ) -> List[List[Eigen.Vector3d]]:
            pass

        def polyhedron_face_barycenter(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces barycenters
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the barycenter
            """
            pass

        def polyhedron_mass(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_tetrahedron_points: List[Eigen.MatrixXd]
            ) -> Eigen.Matrix3d:
            pass

        def polyhedron_inertia(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_tetrahedra_points: List[Eigen.MatrixXd]
            ) -> Eigen.Matrix3d:
            pass

        def polyhedron_centroid_faces_distance(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_faces_normal: List[Eigen.Vector3d],
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> Eigen.VectorXd:
            pass

        def polyhedron_in_radius(
            self,
            polyhedron_centroid_faces_distance: Eigen.VectorXd
            ) -> float:
            pass

        def polyhedron_is_convex(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if Polyhedron is Convex
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param polyhedronFaceNormals the normal of each face
            / \param polyhedronFaceNormalDirections the normal outgoing direction
            / \param pointInsidePolyhedron a point inside polyhedron
            / \return True if polyhedron is convex, False otherwise
            / \warning still not working
            """
            pass

        @overload
        def polyhedron_face_normal_directions(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            point_inside_polyhedron: Eigen.Vector3d,
            polyhedron_face_normals: List[Eigen.Vector3d]
            ) -> List[bool]:
            """/ \brief Compute Polyhedron Face Normal Directions
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param pointInsidePolyhedron a point inside polyhedron
            / \param polyhedronFaceNormals the normal of each face
            / \return True if the face has normal outgoing
            / \warning works only for convex polyhedrons
            """
            pass
        @overload
        def polyhedron_face_normal_directions(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> List[bool]:
            """/ \brief Compute Polyhedron Face Normal Directions for generic polyhedron (slower)
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param pointInsidePolyhedron a point inside polyhedron
            / \param polyhedronFaceNormals the normal of each face
            / \return True if the face has normal outgoing
            / \warning NOT WORKING in all cases
            """
            pass

        def polyhedron_face_triangulations(
            self,
            polyhedron_faces: List[Eigen.MatrixXi],
            local_face_triangulations: List[List[int]]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations of each face
            / \param polyhedronFaces the polyhedron faces
            / \param localFaceTriangulations the local faces triangulations indices, size 1xnumFaces x (3xnumTriangles)
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass
        def polyhedron_face_triangulations_by_first_vertex(
            self,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by first vertex of each face
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass

        def polyhedron_face_triangulations_by_ear_clipping(
            self,
            num_polyhedron_faces: int,
            polyhedron_faces2_d_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by ear clipping of each face
            / \param numPolyhedronFaces the number of polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass

        def polyhedron_face_extract_triangulation_points(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_triangulations: List[List[int]]
            ) -> List[List[Eigen.Matrix3d]]:
            pass

        def polyhedron_face_triangulation_points_by_internal_point(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_triangulations: List[List[int]]
            ) -> List[List[Eigen.Matrix3d]]:
            pass

        def polyhedron_face_triangulations_by_internal_point(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by internal point of each face
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            / \note the internal point index is polyhedronVertices.size()
            """
            pass

        @overload
        def polyhedron_tetrahedrons_by_face_triangulations(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_triangulations: List[List[int]],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Polyhedron Tetrahedrons By Face Triangulations
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param faceTriangulations the triangulation on face vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)
            / \note the polyhedron internal point index is polyhedronVertices.size() + f
            """
            pass

        @overload
        def polyhedron_tetrahedrons_by_face_triangulations(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_triangulations: List[List[int]],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Polyhedron Tetrahedrons By Face Triangulations with face internal points
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param faceTriangulations the triangulation on face vertices by internal points
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param polyhedronInternalPoint a polyhedron internal point
            / \return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)
            / \note the polyhedron face internal points are polyhedronVertices.size() + f
            / \note the polyhedron internal point index is polyhedronVertices.size() + polyhedronFaceInternalPoints.size()
            """
            pass

        @overload
        def extract_tetrahedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_internal_point: Eigen.Vector3d,
            point_tetrahedrons: List[int]
            ) -> List[Eigen.MatrixXd]:
            """/ \param polyhedronVertices the polyhedron vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra
            / \return the tetrahedrons coordinates, size 1 x numTetra
            """
            pass
        @overload
        def extract_tetrahedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_internal_point: Eigen.Vector3d,
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            point_tetrahedrons: List[int]
            ) -> List[Eigen.MatrixXd]:
            """/ \param polyhedronVertices the polyhedron vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra
            / \return the tetrahedrons coordinates, size 1 x numTetra
            """
            pass

        def polyhedron_coordinate_system(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> List[int]:
            """/ \brief Get Polyhedron Coordinate System
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return the four vertices indices forming a coordinate system for the polyhedron, size 1x4
            """
            pass

        @overload
        def export_polyhedron_to_vtu(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            export_folder: str
            ) -> None:
            """/ \brief Export Polyhedron To VTU
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param exportFolder the folder in which to export
            """
            pass

        @overload
        def export_polyhedron_to_vtu(
            self,
            index: int,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_tetra: List[Eigen.MatrixXd],
            polyhedron_volume: float,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_faces3_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_area: List[float],
            polyhedron_faces2_d_centroid: List[Eigen.Vector3d],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_faces3_d_triangles: List[List[Eigen.Matrix3d]],
            polyhedron_faces3_d_internal_point: List[Eigen.Vector3d],
            polyhedron_faces3_d_normal: List[Eigen.Vector3d],
            polyhedron_faces3_d_normal_direction: List[bool],
            export_folder: str
            ) -> None:
            """/ \brief Export Polyhedron To VTU
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param exportFolder the folder in which to export
            """
            pass

        def export_polygon_to_vtu(
            self,
            index: int,
            polygon: Eigen.MatrixXd,
            polygon_triangles: List[Eigen.Matrix3d],
            polygon_volume: float,
            polygon_centroid: Eigen.Vector3d,
            polygon_edges_centroid: Eigen.MatrixXd,
            polygon_edges_normal: Eigen.MatrixXd,
            polygon_edges_normal_direction: List[bool],
            export_folder: str
            ) -> None:
            pass

# </submodule gedim>
####################    </generated_from:GeometryUtilities.hpp>    ####################

# </litgen_stub> // Autogenerated code end!
            
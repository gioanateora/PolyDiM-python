# type: ignore
import sys
from typing import Literal, List, Any, Optional, Tuple, Dict
import numpy as np
import enum
import numpy

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:GeometryUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __GEOMETRYUTILITIES_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class GeometryUtilitiesConfig:
        """
        (final class)
        """
        @staticmethod
        def default_min_tolerance() -> float:
            pass

        min_tolerance: float = Gedim.GeometryUtilitiesConfig.DefaultMinTolerance()
        tolerance1_d: float = Gedim.GeometryUtilitiesConfig.DefaultMinTolerance()
        tolerance2_d: float = Gedim.GeometryUtilitiesConfig.DefaultMinTolerance()
        tolerance3_d: float = Gedim.GeometryUtilitiesConfig.DefaultMinTolerance()
        def __init__(
            self,
            min_tolerance: float = GeometryUtilitiesConfig.DefaultMinTolerance(),
            tolerance1_d: float = GeometryUtilitiesConfig.DefaultMinTolerance(),
            tolerance2_d: float = GeometryUtilitiesConfig.DefaultMinTolerance(),
            tolerance3_d: float = GeometryUtilitiesConfig.DefaultMinTolerance()
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class GeometryUtilities:
        """/ \brief The GeometryUtilities class intersects 3D segments
        (final class)
        """
        class CompareTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            first_before_second = enum.auto()                                                                                                                                                                                             # (= 1)
            coincident = enum.auto()                                                                                                                                                                                                      # (= 2)
            second_before_first = enum.auto()                                                                                                                                                                                             # (= 3)

        class PolygonTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            triangle = enum.auto()                                                                                                                                                                                                        # (= 1)
            quadrilateral_convex = enum.auto()                                                                                                                                                                                            # (= 2)
            quadrilateral_concave = enum.auto()                                                                                                                                                                                           # (= 3)
            generic_convex = enum.auto()                                                                                                                                                                                                  # (= 4)
            generic_concave = enum.auto()                                                                                                                                                                                                 # (= 5)

        class PolygonOrientations(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            clockwise = enum.auto()                                                                                                                                                                                                       # (= 1)
            counter_clockwise = enum.auto()                                                                                                                                                                                               # (= 2)

        class PointSegmentPositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            on_segment_line_before_origin = enum.auto()                                                                                                                                                                                   # (= 1)
            on_segment_origin = enum.auto()                                                                                                                                                                                               # (= 2)
            inside_segment = enum.auto()                                                                                                                                                                                                  # (= 3)
            on_segment_end = enum.auto()                                                                                                                                                                                                  # (= 4)
            on_segment_line_after_end = enum.auto()                                                                                                                                                                                       # (= 5)
            left_the_segment = enum.auto()                                                                                                                                                                                                # (= 6)
            right_the_segment = enum.auto()                                                                                                                                                                                               # (= 7)

        class PointPlanePositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            negative = enum.auto()                                                                                                                                                                                                        # (= 1)
            on_plane = enum.auto()                                                                                                                                                                                                        # (= 2)
            positive = enum.auto()                                                                                                                                                                                                        # (= 3)

        class PolygonCirclePositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            polygon_outside_circle_no_intersection = enum.auto()                                                                                                                                                                          # (= 1)
            polygon_outside_circle_one_intersection_on_vertex = enum.auto()                                                                                                                                                               # (= 2)
            polygon_outside_circle_one_intersection_tangent_on_edge = enum.auto()                                                                                                                                                         # (= 3)
            circle_inside_polygon_no_intersection = enum.auto()                                                                                                                                                                           # (= 4)
            circle_inside_polygon_one_intersection_tangent_on_edge = enum.auto()                                                                                                                                                          # (= 5)
            polygon_inside_circle_no_intersection = enum.auto()                                                                                                                                                                           # (= 6)
            polygon_inside_circle_one_vertex_intersection = enum.auto()                                                                                                                                                                   # (= 7)
            polygon_inside_circle_intersection_only_on_vertices = enum.auto()                                                                                                                                                             # (= 8)
            circle_polygon_multiple_intersections = enum.auto()                                                                                                                                                                           # (= 9)

        class IntersectionPolygonCircleResult:
            """
            (final class)
            """
            class Intersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    secant = enum.auto()                                                                                                                                                                                                  # (= 1)
                    tangent = enum.auto()                                                                                                                                                                                                 # (= 2)

                class IndexTypes(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    vertex = enum.auto()                                                                                                                                                                                                  # (= 1)
                    edge = enum.auto()                                                                                                                                                                                                    # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection.Types = Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection.Types.unknown
                index_type: Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection.IndexTypes = Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection.IndexTypes.unknown
                index: int
                curvilinear_coordinate: float                                                                                                                                                                                             #/< Valid only in IndexType Edge
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolygonCircleResult.Intersection.Types = GeometryUtilities.IntersectionPolygonCircleResult.Intersection.Types.unknown,
                    index_type: GeometryUtilities.IntersectionPolygonCircleResult.Intersection.IndexTypes = GeometryUtilities.IntersectionPolygonCircleResult.Intersection.IndexTypes.unknown,
                    curvilinear_coordinate: float = float()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            intersections: List[Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection] = List[Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection]()                                                      #/< ordered by edge order
            def __init__(
                self,
                intersections: List[GeometryUtilities.IntersectionPolygonCircleResult.Intersection] = List[GeometryUtilities.IntersectionPolygonCircleResult.Intersection]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PolygonDivisionByAngleQuadrantResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                external_origin = enum.auto()                                                                                                                                                                                             # (= 1)
                internal = enum.auto()                                                                                                                                                                                                    # (= 2)
                external_end = enum.auto()                                                                                                                                                                                                # (= 3)

            points: Eigen.MatrixXd                                                                                                                                                                                                        #/< Coordinates of generated points
            sub_polygons: List[List[int]]                                                                                                                                                                                                 #/< Subpolygon formed
            sub_polygon_types: List[Gedim.GeometryUtilities.PolygonDivisionByAngleQuadrantResult.Types]                                                                                                                                   #/< SubPolygon types
            def __init__(
                self,
                points: Eigen.MatrixXd = Eigen.MatrixXd(),
                sub_polygon_types: List[GeometryUtilities.PolygonDivisionByAngleQuadrantResult.Types] = List[GeometryUtilities.PolygonDivisionByAngleQuadrantResult.Types]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PolygonDivisionByCircleResult:
            """
            (final class)
            """
            points: Eigen.MatrixXd                                                                                                                                                                                                        #/< Coordinates of generated points
            sub_triangles: List[List[int]]                                                                                                                                                                                                #/< Triangle formed with sub-polygons and circle Center
            internal_triangles: List[List[int]]                                                                                                                                                                                           #/< Triangle formed with circle Center and new points
            sub_polygons: List[List[int]]                                                                                                                                                                                                 #/< Subpolygon formed
            def __init__(self, points: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CircleDivisionByPolygonResult:
            """
            (final class)
            """
            points: Eigen.MatrixXd                                                                                                                                                                                                        #/< Coordinates of generated points
            sub_triangles: List[List[int]]                                                                                                                                                                                                #/< Triangle formed with sub-polygons and circle Center
            internal_triangles: List[List[int]]                                                                                                                                                                                           #/< Triangle formed with circle Center and new points
            sub_polygons: List[List[int]]                                                                                                                                                                                                 #/< Subpolygon formed
            def __init__(self, points: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonInput:
            """
            (final class)
            """
            class AlignedEdge:
                origin_vertex_index: int
                end_vertex_index: int
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            class SplitSegment:
                class Vertex:
                    """
                    (final class)
                    """
                    class Types(enum.IntEnum):
                        unknown = enum.auto()                                                                                                                                                                                             # (= 0)
                        vertex = enum.auto()                                                                                                                                                                                              # (= 1)
                        edge = enum.auto()                                                                                                                                                                                                # (= 2)

                    type: Gedim.GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex.Types
                    index: int
                    def __init__(
                        self,
                        type: GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex.Types = GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex.Types()
                        ) -> None:
                        """Auto-generated default constructor with named params"""
                        pass

                origin: Gedim.GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex
                end: Gedim.GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex
                def __init__(
                    self,
                    origin: GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex = GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex(),
                    end: GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex = GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            number_polygon_vertices: int
            aligned_edges: List[Gedim.GeometryUtilities.SplitPolygonInput.AlignedEdge]
            segment: Gedim.GeometryUtilities.SplitPolygonInput.SplitSegment
            def __init__(
                self,
                aligned_edges: List[GeometryUtilities.SplitPolygonInput.AlignedEdge] = List[GeometryUtilities.SplitPolygonInput.AlignedEdge](),
                segment: GeometryUtilities.SplitPolygonInput.SplitSegment = GeometryUtilities.SplitPolygonInput.SplitSegment()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithSegmentResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                no_action = enum.auto()                                                                                                                                                                                                   # (= 1)
                polygon_update = enum.auto()                                                                                                                                                                                              # (= 2)
                polygon_creation = enum.auto()                                                                                                                                                                                            # (= 3)

            class NewVertex:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    segment_origin = enum.auto()                                                                                                                                                                                          # (= 1)
                    segment_end = enum.auto()                                                                                                                                                                                             # (= 2)

                type: Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex.Types = Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex.Types.unknown
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex.Types = GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdge:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    edge_new = enum.auto()                                                                                                                                                                                                # (= 1)
                    edge_update = enum.auto()                                                                                                                                                                                             # (= 2)

                type: Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge.Types = Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge.Types.unknown
                old_edge_id: int = 0
                origin_id: int = 0
                end_id: int = 0
                cell2_d_neighbours: List[int] = List[int]()
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge.Types = GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolygon:
                """
                (final class)
                """
                vertices: std.list[int] = std.list<int>()
                edges: std.list[int] = std.list<int>()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            type: Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.Types = Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.Types.unknown
            new_vertices: std.list[Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex] = std.list<Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex>()
            new_edges: std.list[Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge] = std.list<Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge>()
            new_polygons: List[Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewPolygon] = List[Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewPolygon]()
            def __init__(
                self,
                type: GeometryUtilities.SplitPolygonWithSegmentResult.Types = GeometryUtilities.SplitPolygonWithSegmentResult.Types.unknown,
                new_vertices: std.list[GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex] = std.list<GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex>(),
                new_edges: std.list[GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge] = std.list<GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge>(),
                new_polygons: List[GeometryUtilities.SplitPolygonWithSegmentResult.NewPolygon] = List[GeometryUtilities.SplitPolygonWithSegmentResult.NewPolygon]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithCircleResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                no_action = enum.auto()                                                                                                                                                                                                   # (= 1)
                polygon_update = enum.auto()                                                                                                                                                                                              # (= 2)
                polygon_creation = enum.auto()                                                                                                                                                                                            # (= 3)

            class NewVertex:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    polygon_vertex = enum.auto()                                                                                                                                                                                          # (= 1)
                    circle_intersection = enum.auto()                                                                                                                                                                                     # (= 2)
                    both = enum.auto()                                                                                                                                                                                                    # (= 3)

                type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewVertex.Types = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewVertex.Types.unknown
                polygon_index: int                                                                                                                                                                                                        #/< Index in polygon vertices
                intersection_index: int                                                                                                                                                                                                   #/< Index in circle intersections
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithCircleResult.NewVertex.Types = GeometryUtilities.SplitPolygonWithCircleResult.NewVertex.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdge:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    segment = enum.auto()                                                                                                                                                                                                 # (= 1)
                    arc = enum.auto()                                                                                                                                                                                                     # (= 2)

                class ArcTypes(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    inside_polygon = enum.auto()                                                                                                                                                                                          # (= 1)
                    outside_polygon = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.Types = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.Types.unknown
                arc_type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.ArcTypes = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.ArcTypes.unknown                                                           #/< Valid only if Type is Arc
                vertex_indices: List[int]                                                                                                                                                                                                 #/< Index of vertices in NewVertices
                polygon_index: int                                                                                                                                                                                                        #/< Index of Edge in polygon intersections
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.Types = GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.Types.unknown,
                    arc_type: GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.ArcTypes = GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.ArcTypes.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolygon:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    inside_only_circle = enum.auto()                                                                                                                                                                                      # (= 1)
                    inside_only_polygon = enum.auto()                                                                                                                                                                                     # (= 2)
                    inside_circle_and_polygon = enum.auto()                                                                                                                                                                               # (= 3)

                type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon.Types = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon.Types.unknown
                vertices: List[int] = List[int]()
                edges: List[int] = List[int]()
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon.Types = GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.Types = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.Types.unknown
            polygon_vertices_new_vertices_position: List[int] = List[int]()
            circle_intersections_new_vertices_position: List[int] = List[int]()
            new_vertices: List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewVertex] = List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewVertex]()
            new_edges: List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge] = List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge]()
            new_polygons: List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon] = List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon]()
            def __init__(
                self,
                type: GeometryUtilities.SplitPolygonWithCircleResult.Types = GeometryUtilities.SplitPolygonWithCircleResult.Types.unknown,
                new_vertices: List[GeometryUtilities.SplitPolygonWithCircleResult.NewVertex] = List[GeometryUtilities.SplitPolygonWithCircleResult.NewVertex](),
                new_edges: List[GeometryUtilities.SplitPolygonWithCircleResult.NewEdge] = List[GeometryUtilities.SplitPolygonWithCircleResult.NewEdge](),
                new_polygons: List[GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon] = List[GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentSegmentResult:
            """
            (final class)
            """
            class IntersectionLineTypes(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                on_different_planes = enum.auto()                                                                                                                                                                                         # (= 1)
                co_planar_parallel = enum.auto()                                                                                                                                                                                          # (= 2)
                co_planar_intersecting = enum.auto()                                                                                                                                                                                      # (= 3)

            class IntersectionSegmentTypes(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                no_intersection = enum.auto()                                                                                                                                                                                             # (= 1)
                single_intersection = enum.auto()                                                                                                                                                                                         # (= 2)
                multiple_intersections = enum.auto()                                                                                                                                                                                      # (= 3)

            class IntersectionPosition:
                type: Gedim.GeometryUtilities.PointSegmentPositionTypes = Gedim.GeometryUtilities.PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: GeometryUtilities.PointSegmentPositionTypes = GeometryUtilities.PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            intersection_lines_type: Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionLineTypes = Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionLineTypes.unknown
            intersection_segments_type: Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionSegmentTypes = Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionSegmentTypes.unknown
            #/ \brief relation between first and second intersection.
            #/ Values are the indeces of the SecondSegmentIntersections vector respect the FirstSegmentIntersections vector
            #/ \example in MultipleIntersection case, if SecondIntersectionRelation[0] = 1,
            #/ then the second intersection point SecondSegmentIntersections[1] is equal to FirstSegmentIntersections[0]
            #/ point
            second_intersection_relation: List[int]
            #/ \brief intersections of the first segment,
            #/ \note if multiple intersections are found, than the origin and the end coordinate are stored
            first_segment_intersections: List[Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition]
            #/ \brief intersections of the second segment,
            #/ \note if multiple intersections are found, than the origin and the end coordinate are stored
            second_segment_intersections: List[Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition]                                                                                                             #/ intersections of the second segment
            def __init__(
                self,
                intersection_lines_type: GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionLineTypes = GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionLineTypes.unknown,
                intersection_segments_type: GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionSegmentTypes = GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionSegmentTypes.unknown,
                first_segment_intersections: List[GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition] = List[GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition](),
                second_segment_intersections: List[GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition] = List[GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentCircleResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                no_intersection = enum.auto()                                                                                                                                                                                             # (= 1)
                tangent_intersection = enum.auto()                                                                                                                                                                                        # (= 2)
                two_intersections = enum.auto()                                                                                                                                                                                           # (= 3)

            class IntersectionPosition:
                type: Gedim.GeometryUtilities.PointSegmentPositionTypes = Gedim.GeometryUtilities.PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: GeometryUtilities.PointSegmentPositionTypes = GeometryUtilities.PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.IntersectionSegmentCircleResult.Types = Gedim.GeometryUtilities.IntersectionSegmentCircleResult.Types.unknown
            #/ \brief intersections of the segment,
            segment_intersections: List[Gedim.GeometryUtilities.IntersectionSegmentCircleResult.IntersectionPosition] = List[Gedim.GeometryUtilities.IntersectionSegmentCircleResult.IntersectionPosition]()
            def __init__(
                self,
                type: GeometryUtilities.IntersectionSegmentCircleResult.Types = GeometryUtilities.IntersectionSegmentCircleResult.Types.unknown,
                segment_intersections: List[GeometryUtilities.IntersectionSegmentCircleResult.IntersectionPosition] = List[GeometryUtilities.IntersectionSegmentCircleResult.IntersectionPosition]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                single_intersection = enum.auto()                                                                                                                                                                                         # (= 1)
                no_intersection = enum.auto()                                                                                                                                                                                             # (= 2)
                multiple_intersections = enum.auto()                                                                                                                                                                                      # (= 3)

            class Intersection:
                type: Gedim.GeometryUtilities.PointSegmentPositionTypes = Gedim.GeometryUtilities.PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: GeometryUtilities.PointSegmentPositionTypes = GeometryUtilities.PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.IntersectionSegmentPlaneResult.Types = Gedim.GeometryUtilities.IntersectionSegmentPlaneResult.Types.unknown                                                                                     #/< The intersection type
            single_intersection: Gedim.GeometryUtilities.IntersectionSegmentPlaneResult.Intersection                                                                                                                                      #/< The single intersection, available only is Type is SingleIntersection
            def __init__(
                self,
                type: GeometryUtilities.IntersectionSegmentPlaneResult.Types = GeometryUtilities.IntersectionSegmentPlaneResult.Types.unknown,
                single_intersection: GeometryUtilities.IntersectionSegmentPlaneResult.Intersection = GeometryUtilities.IntersectionSegmentPlaneResult.Intersection()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronLineResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                none = enum.auto()                                                                                                                                                                                                        # (= 1)  #/< No intersection found
                one_intersection = enum.auto()                                                                                                                                                                                            # (= 2)  #/< One intersection found
                two_intersections = enum.auto()                                                                                                                                                                                           # (= 3)  #/< Two intersection found
                multiple_intersections = enum.auto()                                                                                                                                                                                      # (= 4)  #/< Multiple intersection found

            class PolyhedronFaceIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection.Types.unknown
                line_intersection_index: int = 0                                                                                                                                                                                          #/< Index of line intersection collection
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection.Types = GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class PolyhedronEdgeIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection.Types.unknown
                line_intersection_index: int = 0                                                                                                                                                                                          #/< Index of line intersection collection
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection.Types = GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class PolyhedronVertexIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection.Types.unknown
                line_intersection_index: int = 0                                                                                                                                                                                          #/< Index of line intersection collection
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection.Types = GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class LineIntersection:
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    on_vertex = enum.auto()                                                                                                                                                                                               # (= 1)  #/< On polyhedron vertex
                    on_edge = enum.auto()                                                                                                                                                                                                 # (= 2)  #/< On polyhedron edge
                    on_face = enum.auto()                                                                                                                                                                                                 # (= 3)  #/< On polyhedron face
                    inside = enum.auto()                                                                                                                                                                                                  # (= 4)  #/< Inside polyhedron

                polyhedron_type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection.Types.unknown                                #/< Type of intersection
                polyhedron_index: int = 0                                                                                                                                                                                                 #/<  Index of the intersecting element of the Polyhedron (face, edge or
                #/<  vertex index)
                curvilinear_coordinate: float = 0.0                                                                                                                                                                                       #/< Curvilinear coordinate in the line
                def __init__(
                    self,
                    polyhedron_type: GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection.Types = GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection.Types.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.Types.unknown
            line_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection]                                                                                                                           #/< The line intersections
            polyhedron_vertex_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection]()  #/< Polyhedron Vertex
            #/< intersections, size
            #/< polyhedron num vertices
            polyhedron_edge_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection]()        #/< Polyhedron Edge intersections,
            #/< size polyhedron num edges
            polyhedron_face_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection]()        #/< Polyhedron Face intersections,
            #/< size polyhedron num faces
            def __init__(
                self,
                type: GeometryUtilities.IntersectionPolyhedronLineResult.Types = GeometryUtilities.IntersectionPolyhedronLineResult.Types.unknown,
                line_intersections: List[GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection] = List[GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection](),
                polyhedron_vertex_intersections: List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection] = List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection](),
                polyhedron_edge_intersections: List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection] = List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection](),
                polyhedron_face_intersections: List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection] = List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronsSegmentResult:
            """
            (final class)
            """
            class IntersectionPoint:
                """
                (final class)
                """
                cell3_d_indices: List[int] = List[int]()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            class IntersectionSegment:
                """
                (final class)
                """
                points: List[float] = List[float]()
                cell3_d_indices: List[int] = List[int]()
                def __init__(self, points: List[float] = List[float]()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            points: Dict[float, Gedim.GeometryUtilities.IntersectionPolyhedronsSegmentResult.IntersectionPoint]
            segments: List[Gedim.GeometryUtilities.IntersectionPolyhedronsSegmentResult.IntersectionSegment]
            def __init__(
                self,
                segments: List[GeometryUtilities.IntersectionPolyhedronsSegmentResult.IntersectionSegment] = List[GeometryUtilities.IntersectionPolyhedronsSegmentResult.IntersectionSegment]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                none = enum.auto()                                                                                                                                                                                                        # (= 1)  #/< No intersection found
                on_vertex = enum.auto()                                                                                                                                                                                                   # (= 2)  #/< On polyhedron vertex
                on_edge = enum.auto()                                                                                                                                                                                                     # (= 3)  #/< On polyhedron edge
                on_face = enum.auto()                                                                                                                                                                                                     # (= 4)  #/< On polyhedron face
                new_polygon = enum.auto()                                                                                                                                                                                                 # (= 5)  #/< New polygon intersection

            class FaceIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection.Types.unknown
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection.Types = GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class EdgeIntersection:
                """
                (final class)
                """
                intersection: Gedim.GeometryUtilities.IntersectionSegmentPlaneResult                                                                                                                                                      #/< Intersection between edge and plane
                def __init__(
                    self,
                    intersection: GeometryUtilities.IntersectionSegmentPlaneResult = GeometryUtilities.IntersectionSegmentPlaneResult()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VertexIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection.Types.unknown
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection.Types = GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class Intersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    vertex = enum.auto()                                                                                                                                                                                                  # (= 1)
                    edge = enum.auto()                                                                                                                                                                                                    # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection.Types.unknown
                edge_id: int = 0                                                                                                                                                                                                          #/<  Edge index of the Polyhedron
                vertex_id: int = 0                                                                                                                                                                                                        #/<  Vertex index of the Polyhedron, available only if Type is Types::Vertex
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection.Types = GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Types = Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Types.unknown                                                                               #/< The intersection type
            intersection_id: int = 0                                                                                                                                                                                                      #/< The geometry id of the intersection, available only with Types::OnVertex,
            #/< Types::OnEdge and Types::OnFace
            vertex_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection]()                               #/< Vertex intersections
            edge_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.EdgeIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.EdgeIntersection]()                                     #/< Edge intersections
            face_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection]()                                     #/< Face intersections
            intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection]()                                                  #/< The resulting intersections
            intersection_coordinates: Eigen.MatrixXd                                                                                                                                                                                      #/< The resulting intersection coordinates
            def __init__(
                self,
                type: GeometryUtilities.IntersectionPolyhedronPlaneResult.Types = GeometryUtilities.IntersectionPolyhedronPlaneResult.Types.unknown,
                vertex_intersections: List[GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection] = List[GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection](),
                edge_intersections: List[GeometryUtilities.IntersectionPolyhedronPlaneResult.EdgeIntersection] = List[GeometryUtilities.IntersectionPolyhedronPlaneResult.EdgeIntersection](),
                face_intersections: List[GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection] = List[GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection](),
                intersections: List[GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection] = List[GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection](),
                intersection_coordinates: Eigen.MatrixXd = Eigen.MatrixXd()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PointCirclePositionResult(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            outside = enum.auto()                                                                                                                                                                                                         # (= 1)
            on_border = enum.auto()                                                                                                                                                                                                       # (= 2)
            inside = enum.auto()                                                                                                                                                                                                          # (= 3)

        class PointPolygonPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                outside = enum.auto()                                                                                                                                                                                                     # (= 1)
                border_edge = enum.auto()                                                                                                                                                                                                 # (= 2)
                border_vertex = enum.auto()                                                                                                                                                                                               # (= 3)
                inside = enum.auto()                                                                                                                                                                                                      # (= 4)

            border_index: int = 0                                                                                                                                                                                                         #/< index of vertex/edge of border
            type: Gedim.GeometryUtilities.PointPolygonPositionResult.Types = Gedim.GeometryUtilities.PointPolygonPositionResult.Types.unknown
            def __init__(
                self,
                type: GeometryUtilities.PointPolygonPositionResult.Types = GeometryUtilities.PointPolygonPositionResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class LinePolygonPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                outside = enum.auto()                                                                                                                                                                                                     # (= 1)
                intersecting = enum.auto()                                                                                                                                                                                                # (= 2)

            class EdgeIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    on_edge_origin = enum.auto()                                                                                                                                                                                          # (= 1)
                    inside_edge = enum.auto()                                                                                                                                                                                             # (= 2)
                    on_edge_end = enum.auto()                                                                                                                                                                                             # (= 3)
                    parallel = enum.auto()                                                                                                                                                                                                # (= 4)

                type: Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection.Types = Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection.Types.unknown
                index: int = 0
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: GeometryUtilities.LinePolygonPositionResult.EdgeIntersection.Types = GeometryUtilities.LinePolygonPositionResult.EdgeIntersection.Types.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            edge_intersections: List[Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection] = List[Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection]()
            type: Gedim.GeometryUtilities.LinePolygonPositionResult.Types = Gedim.GeometryUtilities.LinePolygonPositionResult.Types.unknown
            def __init__(
                self,
                edge_intersections: List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection] = List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection](),
                type: GeometryUtilities.LinePolygonPositionResult.Types = GeometryUtilities.LinePolygonPositionResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PointPolyhedronPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                outside = enum.auto()                                                                                                                                                                                                     # (= 1)
                border_face = enum.auto()                                                                                                                                                                                                 # (= 2)
                border_edge = enum.auto()                                                                                                                                                                                                 # (= 3)
                border_vertex = enum.auto()                                                                                                                                                                                               # (= 4)
                inside = enum.auto()                                                                                                                                                                                                      # (= 5)

            border_index: int = 0                                                                                                                                                                                                         #/< index of vertex/edge/face of border
            internal_indices: List[int]                                                                                                                                                                                                   #/< list of index of internal cell (usually tetrahedrons)
            type: Gedim.GeometryUtilities.PointPolyhedronPositionResult.Types = Gedim.GeometryUtilities.PointPolyhedronPositionResult.Types.unknown
            def __init__(
                self,
                type: GeometryUtilities.PointPolyhedronPositionResult.Types = GeometryUtilities.PointPolyhedronPositionResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SegmentPolyhedronPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                outside = enum.auto()                                                                                                                                                                                                     # (= 1)
                border_face = enum.auto()                                                                                                                                                                                                 # (= 2)
                border_edge = enum.auto()                                                                                                                                                                                                 # (= 3)
                inside = enum.auto()                                                                                                                                                                                                      # (= 4)

            border_index: int = 0                                                                                                                                                                                                         #/< index of edge/face of border
            type: Gedim.GeometryUtilities.SegmentPolyhedronPositionResult.Types = Gedim.GeometryUtilities.SegmentPolyhedronPositionResult.Types.unknown
            def __init__(
                self,
                type: GeometryUtilities.SegmentPolyhedronPositionResult.Types = GeometryUtilities.SegmentPolyhedronPositionResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Polyhedron:
            """
            (final class)
            """
            vertices: Eigen.MatrixXd                                                                                                                                                                                                      #/< vertices, size 3 x numVertices
            edges: Eigen.MatrixXi                                                                                                                                                                                                         #/< edges, size 2 x numEdges
            faces: List[Eigen.MatrixXi]                                                                                                                                                                                                   #/< faces vertices and edges, size numFaces x 2 x numFaceVertices
            def __init__(
                self,
                vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                edges: Eigen.MatrixXi = Eigen.MatrixXi(),
                faces: List[Eigen.MatrixXi] = List[Eigen.MatrixXi]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                split = enum.auto()                                                                                                                                                                                                       # (= 1)
                positive = enum.auto()                                                                                                                                                                                                    # (= 2)
                negative = enum.auto()                                                                                                                                                                                                    # (= 3)
                on_plane = enum.auto()                                                                                                                                                                                                    # (= 4)

            positive_vertices: List[int]                                                                                                                                                                                                  #/ vertices indices of the positive sub-polygon
            negative_vertices: List[int]                                                                                                                                                                                                  #/ vertices indices of the negative sub-polygon
            points_on_plane: List[int]                                                                                                                                                                                                    #/ vertices indices of the points on plane
            new_vertices: List[Eigen.Vector3d]                                                                                                                                                                                            #/ new vertices coordinates
            new_vertices_edge_index: List[int]                                                                                                                                                                                            #/ new vertices edge indices
            type: Gedim.GeometryUtilities.SplitPolygonWithPlaneResult.Types = Gedim.GeometryUtilities.SplitPolygonWithPlaneResult.Types.unknown                                                                                           #/ type of split
            def __init__(
                self,
                new_vertices: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                type: GeometryUtilities.SplitPolygonWithPlaneResult.Types = GeometryUtilities.SplitPolygonWithPlaneResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolyhedronWithPlaneResult:
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                split = enum.auto()                                                                                                                                                                                                       # (= 1)
                none = enum.auto()                                                                                                                                                                                                        # (= 2)

            class NewVertices:
                vertices: Eigen.MatrixXd                                                                                                                                                                                                  #/< all vertices contained in the new polyhedra
                new_vertices_original_edge: List[int]                                                                                                                                                                                     #/< For each new vertex the index of the original edge
                #/< to which is located
                def __init__(self, vertices: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdges:
                edges: Eigen.MatrixXi                                                                                                                                                                                                     #/< all edges contained in the new polyhedra
                new_edges_original_edges: List[int]                                                                                                                                                                                       #/< indices of original edges for new edges, -1 means no original
                #/< edge
                new_edges_original_face: List[int]                                                                                                                                                                                        #/< For each new vertex the index of the original edge to which is
                #/< located
                def __init__(
                    self,
                    edges: Eigen.MatrixXi = Eigen.MatrixXi(),
                    new_edges_original_edges: List[int] = List[int](),
                    new_edges_original_face: List[int] = List[int]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewFaces:
                faces: List[Eigen.MatrixXi]
                new_faces_original_faces: List[int]                                                                                                                                                                                       #/< indices of original faces for new faces, -1 means no original
                #/< face
                def __init__(
                    self,
                    faces: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                    new_faces_original_faces: List[int] = List[int]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolyhedron:
                vertices: List[int]
                edges: List[int]
                faces: List[int]
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            original_edges_new_edges: List[List[int]]
            original_faces_new_faces: List[List[int]]
            vertices: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewVertices
            edges: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewEdges
            faces: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewFaces
            positive_polyhedron: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron
            negative_polyhedron: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron
            type: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.Types = Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.Types.unknown                                                                                     #/ type of split
            def __init__(
                self,
                vertices: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewVertices = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewVertices(),
                edges: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewEdges = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewEdges(),
                faces: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewFaces = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewFaces(),
                positive_polyhedron: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron(),
                negative_polyhedron: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron(),
                type: GeometryUtilities.SplitPolyhedronWithPlaneResult.Types = GeometryUtilities.SplitPolyhedronWithPlaneResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class AlignedPolyhedronEdgesResult:
            aligned_edges_vertices: List[List[int]]
            aligned_edges_edges: List[List[int]]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class MergePolyhedronsInput:
            none: int = std.numeric_limits<int>.max()                                                                                                                                                                                     # (C++ static member) # (const)
            class MergeTypes(enum.IntEnum):
                none = enum.auto()                                                                                                                                                                                                        # (= 0)
                common = enum.auto()                                                                                                                                                                                                      # (= 1)
                remove = enum.auto()                                                                                                                                                                                                      # (= 2)

            vertices_type: List[List[Tuple[Gedim.GeometryUtilities.MergePolyhedronsInput.MergeTypes]
            edges_type: List[List[Tuple[Gedim.GeometryUtilities.MergePolyhedronsInput.MergeTypes]
            faces_type: List[List[Tuple[Gedim.GeometryUtilities.MergePolyhedronsInput.MergeTypes]
            common_vertices: List[List[int]]
            common_edges: List[List[int]]
            common_faces: List[List[int]]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class MergePolyhedronsResult:
            none: int = std.numeric_limits<int>.max()                                                                                                                                                                                     # (C++ static member) # (const)
            original_to_merged_vertices: List[List[int]]
            original_to_merged_edges: List[List[int]]
            original_to_merged_faces: List[List[int]]
            merged_to_original_vertices: List[List[int]]
            merged_to_original_edges: List[List[int]]
            merged_to_original_faces: List[List[int]]
            merged_polyhedron: Gedim.GeometryUtilities.Polyhedron
            def __init__(
                self,
                merged_polyhedron: GeometryUtilities.Polyhedron = GeometryUtilities.Polyhedron()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self, configuration: GeometryUtilitiesConfig) -> None:
            pass

        def tolerance1_d(self) -> float:
            """/ \return tolerance used for segment length"""
            pass
        def tolerance1_d_squared(self) -> float:
            """/ \return tolerance used for squared segment length"""
            pass
        def tolerance2_d(self) -> float:
            """/ \return tolerance used for polygon area"""
            pass
        def tolerance3_d(self) -> float:
            """/ \return tolerance used for polyhedron volume"""
            pass

        def relative_difference(self, first: float, second: float, tolerance: float) -> float:
            """/ \param first the first value
            / \param second the second value
            / \return the relative difference between the two values according the first
            """
            pass

        def compare_values(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> GeometryUtilities.CompareTypes:
            """/ \brief Compare two values according to tolerance
            / \param first the first value
            / \param second the second value
            / \return the result
            / \note the interval [-tolerance, tolerance] is considered 0.0
            """
            pass

        def are_values_equal(self, first: float, second: float, tolerance: float) -> bool:
            """/ \brief Check if two values are equal according to tolerance
            / \param first the first value
            / \param second the second value
            / \return the result
            """
            pass

        def is_value_greater(self, first: float, second: float, tolerance: float) -> bool:
            """/ \param first the first value
            / \param second the second value
            / \return True if first is greater than second
            """
            pass

        def is_value_greater_or_equal(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> bool:
            """/ \param first the first value
            / \param second the second value
            / \return True if first is greater or equal than second
            """
            pass

        def is_value_lower(self, first: float, second: float, tolerance: float) -> bool:
            pass

        def is_value_lower_or_equal(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> bool:
            pass

        def is_value_positive(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is positive
            """
            pass

        def is_value_negative(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is negative
            """
            pass

        def is_value_zero(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is zero
            """
            pass

        def fibonacci_sphere(self, num_points: int) -> Eigen.MatrixXd:
            pass
        def generate_uniform_random_points_in_sphere(
            self,
            num_points: int,
            radius: float = 1.0
            ) -> Eigen.MatrixXd:
            pass

        @overload
        def equispace_coordinates(self, step: float, insert_extremes: bool) -> List[float]:
            """/ \param step the distance between each coordinate
            / \param insertExtremes if True keeps the extremes
            / \return the equispace coordinates between [0.0, 1.0], size 1 x numCoordinates
            """
            pass

        @overload
        def equispace_coordinates(
            self,
            size: int,
            origin: float,
            end: float,
            insert_extremes: bool
            ) -> List[float]:
            """/ \param size the number of resulting coordinates
            / \param origin the starting curvilinear coordinate
            / \param end the ending curvilinear coordinate
            / \param insertExtremes if True keeps the extremes
            / \return equispaced curvilinear coordinates in the interval [origin, end]
            / \note if size < 2 then size will be considered as 2
            """
            pass
        def random_coordinates(
            self,
            size: int,
            insert_extremes: bool,
            min_distance: float,
            seed: int = time(None)
            ) -> List[float]:
            """/ \param size the number of resulting coordinates
            / \param origin the starting curvilinear coordinate
            / \param end the ending curvilinear coordinate
            / \param insertExtremes if True keeps the extremes
            / \return random curvilinear coordinates in the interval [0.0, 1.0], size 1 x numCoordinates
            / \note if size < 2 then size will be considered as 2
            """
            pass

        def polar_angle(
            self,
            v_prev: Eigen.Vector3d,
            v: Eigen.Vector3d,
            v_next: Eigen.Vector3d,
            norm_v_prev_v: float,
            norm_v_next_v: float
            ) -> float:
            """/ \param v_prev the previous point
            / \param v the middle point
            / \param v_next the next point
            / \return the polar angle between the three points, computed as the cross product (v_next-v) x (v_prev-v)
            / \note positive is convex (counter-clockwise), negative is concave (clockwise), zero is collinear
            """
            pass

        def point_distance(
            self,
            first_point: Eigen.Vector3d,
            second_point: Eigen.Vector3d
            ) -> float:
            """/ \brief compute the Point distance
            / \param firstPoint the first point
            / \param secondPoint the second point
            / \return the distance
            """
            pass

        def point_distances(
            self,
            points: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> Eigen.VectorXd:
            """/ \brief compute the distance between a point and a list of points
            / \param points the point collection, size 3 x numPoints
            / \param point the point
            / \return the collection of distances, size 1 x numPoints
            """
            pass

        def points_distance(self, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \param points the point collection, size 3 x numPoints
            / \return the distances between the points collected in matrix, size numPoints x numPoints.
            """
            pass

        def points_bounding_box(self, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \param points the point collection, size 3 x numPoints
            / \return the extreme bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints
            """
            pass

        def is_point_in_bounding_box(
            self,
            point: Eigen.Vector3d,
            bouding_box: Eigen.MatrixXd
            ) -> bool:
            """/ \param point the point
            / \param boudingBox the bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints
            / \return False if the point is outside the bounding box, True otherwise (border or inside)
            """
            pass

        def bounding_boxes_intersects(
            self,
            bouding_box_1: Eigen.MatrixXd,
            bouding_box_2: Eigen.MatrixXd
            ) -> bool:
            pass

        def points_max_distance(self, points: Eigen.MatrixXd) -> float:
            """/ \param points the point collection, size 3 x numPoints
            / \return the maximum distance between the points.
            """
            pass

        def is_point_zero(self, point: Eigen.Vector3d) -> bool:
            pass

        def points_are_coincident(
            self,
            first_point: Eigen.Vector3d,
            second_point: Eigen.Vector3d
            ) -> bool:
            """/ \param firstPoint the first point
            / \param secondPoint the second point
            / \return True if the points are coincident
            """
            pass

        def find_point_in_points(
            self,
            points: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Find a point in point list
            / \param points the point list, size 3 x numPoints
            / \param point the point to find
            / \return the collection of point found
            """
            pass

        def point_line_distance(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            normal_to_line: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the distance between a point and a line
            / \param point a point P
            / \param lineOrigin the line origin O
            / \param normalToLine a normal vector n to the line, in the same plane of P and the line
            / \return the distance d
            / \note The distance is computed as d = n^T * (P - O) / ||n||
            """
            pass

        def point_is2_d(self, point: Eigen.Vector3d) -> bool:
            """/ \param point the point
            / \return True if the point is 2D (z == 0)
            """
            pass

        def points_are2_d(self, points: Eigen.MatrixXd) -> bool:
            """/ \param points the points to test, size 3 x numPoints
            / \return True if the points are 2D (z == 0)
            """
            pass

        def point_curvilinear_coordinate(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief compute the Point Curvilinear Coordinate of segment
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the curvilinear coordinate computed
            """
            pass

        def point_line_curvilinear_coordinate(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d,
            line_tangent_squared_length: float
            ) -> float:
            """/ \brief compute the Point Curvilinear Coordinate of line
            / \param point the point
            / \param lineOrigin the line origin
            / \param lineTangent the line tangent
            / \param lineTangentSquaredLength the line tangent length squared
            / \return the curvilinear coordinate computed
            """
            pass

        def is_point_on_line(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d,
            line_tangent_squared_length: float
            ) -> bool:
            """/ \param point the point
            / \param lineOrigin the line origin
            / \param lineTangent the line tangent
            / \param lineTangentSquaredLength the line tangent length squared
            / \return True if the point belongs on line
            """
            pass

        @overload
        def point_segment_position(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> GeometryUtilities.PointSegmentPositionTypes:
            """/ \brief Compute point position respect to a segment
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return result the point position
            / \warning left and right point positions work only in xy plane
            """
            pass

        @overload
        def point_segment_position(
            self,
            curvilinear_coordinate: float
            ) -> GeometryUtilities.PointSegmentPositionTypes:
            """/ \brief Compute point position on a segment line given the curvilinear Coordinate
            / \param curvilinearCoordinate the curvilinear coordinate, segment is between 0.0 and 1.0
            / \param result the point position on the line
            """
            pass

        def point_segment_projection(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Project point on a segment line
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the projected point curvilinear coordinate
            """
            pass

        @overload
        def point_plane_distance(
            self,
            point: Eigen.Vector3d,
            plane_points: List[Eigen.Vector3d]
            ) -> float:
            """/ \brief Compute point position respect to a plane formed by 3 points
            / \param planePoints the 3 plane points
            / \param point the point
            / \return the signed point distance, 0.0 on plane, positive above, negative bottom
            """
            pass
        @overload
        def point_plane_distance(
            self,
            point: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute point position respect to a plane normal
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \param point the point
            / \return the signed point distance, 0.0 on plane, positive above, negative bottom
            """
            pass

        def point_plane_position(
            self,
            point_plane_distance: float
            ) -> GeometryUtilities.PointPlanePositionTypes:
            """/ \brief Compute point position respect to a plane
            / \param pointPlaneDistance the point plane distance
            / \return result the point position
            """
            pass

        @overload
        def is_point_on_plane(self, point_plane_distance: float) -> bool:
            """/ \param pointPlaneDistance the point plane distance
            / \return True if point is on the plane
            """
            pass

        @overload
        def is_point_on_plane(
            self,
            point: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> bool:
            """/ \param point the point
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \return True if point is on the plane
            """
            pass

        def segment_length(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment length
            """
            pass

        def segment_tangent(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment tangent
            """
            pass

        def segment_normal(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment normal normalized, rotation of the normalized tangent (x,y,0) with 90 clockwise (y, -x,0)
            / \note the segment shall be 2D
            """
            pass

        def segment_slope(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the segment slope m of line y = m * x + q
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment slope
            / \note the segment shall be 2D
            """
            pass

        def segment_intercept(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the segment intercept q of line y = m * x + q
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment intercept
            / \note the segment shall be 2D
            """
            pass

        def make_concatenation(
            self,
            segments: Eigen.MatrixXi,
            starting_vertex: int
            ) -> Eigen.MatrixXi:
            pass

        def check_no_spheres_intersection(
            self,
            first_sphere_center: Eigen.Vector3d,
            second_sphere_center: Eigen.Vector3d,
            first_sphere_diameter: float,
            second_sphere_diameter: float
            ) -> bool:
            """/ \brief Check if two spheres do not intersect
            / \param firstSphereCenter the first sphere center
            / \param secondSphereCenter the second sphere center
            / \param firstSphereDiameter the first sphere diameter
            / \param secondSphereDiameter the second sphere diameter
            / \return True if the two segments do not intersect
            / \note if the function returns True it does not mean that the two segments intersects
            """
            pass

        def check_triangles_intersection(
            self,
            triangle_one: Eigen.MatrixX3d,
            triangle_two: Eigen.MatrixX3d,
            admit_boundary: bool = True
            ) -> bool:
            """/ \note works only for 2D triangles
            / \see https://rosettacode.org/wiki/Determine_if_two_triangles_overlap                                                                                                                                                        #C++
            """
            pass

        def are_line_coplanar(
            self,
            first_line_origin: Eigen.Vector3d,
            first_line_tangent: Eigen.Vector3d,
            second_line_origin: Eigen.Vector3d,
            second_line_tangent: Eigen.Vector3d
            ) -> bool:
            """/ \param firstLineOrigin first line origin
            / \param firstLineTangent first line tangent
            / \param secondLineOrigin second line origin
            / \param secondLineTangent second line tangent
            / \return line coplanarity
            """
            pass

        def is_polygon_coplanar(
            self,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd,
            polygon_unaligned_vertices: List[int]
            ) -> bool:
            """/ \brief verify if the polygon is in the coplana to a plane"""
            pass

        def intersection_segment_segment(
            self,
            first_segment_origin: Eigen.Vector3d,
            first_segment_end: Eigen.Vector3d,
            second_segment_origin: Eigen.Vector3d,
            second_segment_end: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionSegmentSegmentResult:
            """/ \brief Compute the intersection between the two segments
            / \param firstSegmentOrigin first segment origin
            / \param firstSegmentEnd first segment end
            / \param secondSegmentOrigin second segment origin
            / \param secondSegmentEnd second segment end
            / \return the resulting intersection
            / \note no check is performed
            """
            pass

        def intersections_between_segments(
            self,
            segments_vertices: List[Eigen.MatrixXd],
            segments_tangent: List[Eigen.Vector3d],
            segments_barycenter: List[Eigen.Vector3d],
            segments_length: List[float]
            ) -> List[std.list[float]]:
            """/ \brief Compute the intersection between a collection of segments
            / \param segmentsVertices the segments vertices
            / \param segmentsTangent the segments tangent
            / \param segmentsBarycenter the segments barycenter
            / \param segmentsLength the segments length
            / \return for each segment the list of intersections curvilinear coordinate
            """
            pass

        def intersection_segment_circle(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.IntersectionSegmentCircleResult:
            """/ \brief Compute the intersection between the a segment and a circle
            / \param segmentOrigin first segment origin
            / \param segmentEnd first segment end
            / \param circleCenter circle center
            / \param circleRadius circle radius
            / \return the resulting intersection
            / \note tested only in 2D
            """
            pass

        def intersection_segment_plane(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionSegmentPlaneResult:
            """/ \brief Intersection between a Segment, represented by origin and end and a plane
            / represented by the normal and a point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segement end
            / \param planeNormal the plane normal normalized
            / \param planeOrigin a plane point
            / \return the resulting intersection
            """
            pass

        def intersection_polyhedron_plane(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            plane_rotation_matrix: Eigen.Matrix3d,
            plane_translation: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronPlaneResult:
            """/ \brief Intersection between a Polyhedron and a Plane
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param planeNormal the plane normal normalized
            / \param planeOrigin the plane origin
            / \param planeRotationMatrix the plane rotation from 3D to 2D
            / \param planeTranslation the plane translation vector
            / \return the intersection result
            / \note works only with convex polyhedra
            """
            pass

        def split_polyhedron_with_plane(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_edge_tangents: List[Eigen.MatrixXd],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            plane_rotation_matrix: Eigen.Matrix3d,
            plane_translation: Eigen.Vector3d
            ) -> GeometryUtilities.SplitPolyhedronWithPlaneResult:
            pass

        def split_polyhedron_with_plane_result_to_polyhedra(
            self,
            result: GeometryUtilities.SplitPolyhedronWithPlaneResult
            ) -> List[GeometryUtilities.Polyhedron]:
            pass

        def intersection_polyhedron_line(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            line_tangent: Eigen.Vector3d,
            line_origin: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronLineResult:
            """/ \brief Intersection between a Polyhedron and a line
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return the intersection result
            / \warning NOT TESTED PROPERLY
            """
            pass

        def intersection_polyhedron_segment(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            polyhedron_line_intersections: GeometryUtilities.IntersectionPolyhedronLineResult
            ) -> GeometryUtilities.IntersectionPolyhedronLineResult:
            """/ \brief Intersection between a Polyhedron and a segment
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \param segmentTangent the segment tangent
            / \param polyhedronLineIntersections the intersection between the polyhedron and the line of the segment
            / \return the intersection result
            / /// \warning NOT TESTED PROPERLY
            """
            pass

        def intersection_polyhedrons_segment(
            self,
            polyhedrons: List[GeometryUtilities.Polyhedron],
            polyhedron_face_normals: List[List[Eigen.Vector3d]],
            polyhedron_face_normal_directions: List[List[bool]],
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronsSegmentResult:
            """/ \brief Intersection between a collectio of Polyhedrons and a segment
            / \param polyhedrons the polyhedron collection
            / \param polyhedronFaceNormals polyhedron face normals
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \param segmentTangent the segment tangent
            / \return the intersection result
            / \warning NOT TESTED PROPERLY
            """
            pass

        def point_polygon_position(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.PointPolygonPositionResult:
            """/ \brief Check if point is inside a polygon
            / \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting position
            / \warning works only in 2D with convex polygons
            """
            pass

        def point_polygon_position_ray_casting(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.PointPolygonPositionResult:
            pass

        def is_point_inside_polygon(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> bool:
            """/ \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return False if it is outside, True the other cases
            / \warning works only in 2D with convex polygons
            """
            pass

        def is_point_inside_polygon_ray_casting(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> bool:
            """/ \brief IsPointInsidePolygon using RayCasting algorithm
            / (see https://en.wikipedia.org/wiki/Point_in_polygon)
            / \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return False if it is outside, True the other cases
            """
            pass

        def line_polygon_position(
            self,
            line_tangent: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.LinePolygonPositionResult:
            pass

        #/ \brief Check if point is inside a polygon
        #/ \param point the point
        #/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
        #/ \param result the resulting position

        @overload
        def point_polyhedron_position(
            self,
            point: Eigen.Vector3d,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> GeometryUtilities.PointPolyhedronPositionResult:
            """/ \brief Check if point is inside a polyhedron
            / \param point the point
            / \param polyhedronFaces the polyhedron faces, size numPolyhedronFaces
            / \param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces
            / \param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces
            / \param polyhedronFaceNormals the polyhedron face normals
            / \param polyhedronFaceNormalDirections the polyhedron face normal directions
            / \param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return the point position respect the polyhedron
            / \note works only for convex polyhedrons
            """
            pass
        @overload
        def point_polyhedron_position(
            self,
            point: Eigen.Vector3d,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_faces_3_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_2_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_normals: List[Eigen.Vector3d],
            polyhedron_faces_normal_direction: List[bool],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_tetrahedrons: List[Eigen.MatrixXd]
            ) -> GeometryUtilities.PointPolyhedronPositionResult:
            """/ \brief Check if point is inside a polyhedron
            / \param point the point
            / \param polyhedronFaces the polyhedron faces, size numPolyhedronFaces
            / \param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces
            / \param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces
            / \param polyhedronFaceNormals the polyhedron face normals
            / \param polyhedronFaceNormalDirections the polyhedron face normal directions
            / \param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return the point position respect the polyhedron
            / \note works for concave and convex polyhedrons
            """
            pass

        def is_point_inside_tetrahedron(
            self,
            tetrahedron: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> bool:
            pass

        def point_circle_position(
            self,
            point: Eigen.Vector3d,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.PointCirclePositionResult:
            """/ \brief Check if point is inside a circle
            / \param point the point
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param result the resulting position
            / \note tested only in 2D
            """
            pass

        def point_circle_positions(
            self,
            points: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> List[GeometryUtilities.PointCirclePositionResult]:
            """/ \brief Check if points are inside a circle
            / \param points the matrix of points (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param result the resulting positions
            / \note tested only in 2D
            """
            pass

        def polygon_circle_position(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            vertex_positions: List[GeometryUtilities.PointCirclePositionResult],
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult
            ) -> GeometryUtilities.PolygonCirclePositionTypes:
            """/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param vertexPositions the polygon vertices positions respect the circle
            / \param polygonCircleIntersections the polygon center intersections
            / \return the Polygon Circle reciprocal position
            / \note tested only in 2D
            """
            pass

        def intersection_polygon_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.IntersectionPolygonCircleResult:
            """/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \return the Polygon Circle reciprocal intersections
            / \note tested only in 2D
            """
            pass

        def polygon_triangulation_by_first_vertex(
            self,
            polygon_vertices: Eigen.MatrixXd
            ) -> List[int]:
            """/ \brief Convex Polygon simple Triangulation from the first vertex
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the sub-division triangulation, size 1 x 3 * numTriangles
            / \note works only for convex polygon
            """
            pass

        def polygon_triangulation_by_ear_clipping(
            self,
            polygon_vertices: Eigen.MatrixXd
            ) -> List[int]:
            """/ \brief Concave Polygon Triangulation with ear clipping algorithm
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the sub-division triangulation, size 1 x 3 * numTriangles
            """
            pass

        def polygon_triangulation_by_internal_point(
            self,
            polygon_vertices: Eigen.MatrixXd,
            internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Convex Polygon simple Triangulation from an internal point
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param point internal polygon point
            / \return the sub-division triangulation, size 1 x 3 * numPolygonVertices,
            / \note the internal point index is numPolygonVertices
            """
            pass

        def polygon_outside_circle_division_by_angle_quadrant(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByAngleQuadrantResult:
            """/ \brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            """
            pass

        def polygon_inside_circle_division_by_angle_quadrant(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByAngleQuadrantResult:
            """/ \brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            """
            pass

        def polygon_division_by_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByCircleResult:
            """/ \brief Convex Polygon sub division from a circle which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            / \note the polygon should be inside the angle quadrant formed by the curved edge
            / \note otherwise use PolygonDivisionByAngleQuadrant function to split the polygon
            """
            pass

        def circle_division_by_polygon(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.CircleDivisionByPolygonResult:
            """/ \brief Circle division from Convex Polygon sub division which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division circle result
            / \note the polygon should be inside the angle quadrant formed by the curved edge
            """
            pass

        def polygon_area(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the polygon area
            / \note the polygon shall be 2D
            """
            pass

        def polygon_area3_d(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the polygon area
            """
            pass

        def polygon_mass(
            self,
            polygon_centroid: Eigen.Vector3d,
            polygon_triangulation_points: List[Eigen.Matrix3d]
            ) -> Eigen.Matrix2d:
            """/ \param polygonCentroid the centroid
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \return the polygon mass matrix
            """
            pass

        def polygon_inertia(
            self,
            polygon_centroid: Eigen.Vector3d,
            polygon_triangulation_points: List[Eigen.Matrix3d]
            ) -> Eigen.Matrix3d:
            """/ \param polygonCentroid the centroid
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \return the polygon intertia tensor
            """
            pass

        def split_polygon_with_segment(
            self,
            input: GeometryUtilities.SplitPolygonInput
            ) -> GeometryUtilities.SplitPolygonWithSegmentResult:
            """/ \brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a segment contained inside
            / \param input the input data
            / \param result the resulting split
            / \note only indices are threated in this function, no space points
            """
            pass

        def split_polygon_with_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            vertex_positions: List[GeometryUtilities.PointCirclePositionResult],
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult,
            polygon_circle_position: GeometryUtilities.PolygonCirclePositionTypes
            ) -> GeometryUtilities.SplitPolygonWithCircleResult:
            """/ \brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a cirle
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param vertexPositions the polygon vertices positions respect the circle
            / \param polygonCircleIntersections the polygon center intersections
            / \param polygonCirclePosition the polygon position respect the circle
            / \note tested only in 2D
            / \return the split result
            / \note only indices are threated in this function, no space points
            """
            pass

        def split_polygon_with_circle_build_sub_polygon(
            self,
            split_result: GeometryUtilities.SplitPolygonWithCircleResult,
            sub_polygon_index: int,
            polygon_vertices: Eigen.MatrixXd,
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult
            ) -> Eigen.MatrixXd:
            """/ \brief Build the subpolygon coordinates from split result
            / \param splitResult the split result
            / \param subPolygonIndex the subpolygon index, from 0 to SplitPolygonWithCircleResult::NewPolygons.size()
            / \param polygonVertices the original polygon vertices
            / \param polygonCircleIntersections the polygon circle intersection
            / \return the resulting subpolygon coordinates
            """
            pass

        def split_polygon_with_plane(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            polygon_translation: Eigen.Vector3d,
            polygon_rotation_matrix: Eigen.Matrix3d
            ) -> GeometryUtilities.SplitPolygonWithPlaneResult:
            """/ \brief Split 3 Polygon With Plane
            / \param polygonVertices the 3D polygon vertices
            / \param polygonEdgeTangents the 3D polygon edge tangents
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \param polygonTranslation the polygon translation vector for rotation
            / \param polygonRotationMatrix the polygon rotation matrix from 2D to 3D
            / \return the splitted polygons
            """
            pass

        def polygon_normal(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon tridimensional normalized Normal
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting normalized normal
            """
            pass

        def polygon_tangents(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_normal: Eigen.Vector3d
            ) -> List[Eigen.Vector3d]:
            pass

        def polygon_edges_centroid(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edges centroid
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edges centroid, size 3 x numVertices
            """
            pass

        def polygon_edge_lengths(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.VectorXd:
            """/ \brief Compute the Polygon edge lengths
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge lengths, size 1 x numVertices
            """
            pass

        def polygon_edge_tangents(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edge tangents
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge tangents, size 3 x numVertices
            """
            pass

        def polygon_edge_normals(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edge normals outgoing the polygon
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge normals outgoing the polygon, size 3 x numVertices
            """
            pass

        def simplex_barycenter(self, vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the simplex barycenter as a mean of all vertices
            / \param vertices the matrix of vertices of the simplex (size 3 x numVertices)
            """
            pass

        def simplex_measure(self, vertices: Eigen.MatrixXd) -> float:
            pass

        def segment_barycenter(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \brief Compute the segment barycenter as a mean of all vertices
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            """
            pass

        def polygon_barycenter(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon barycenter as a mean of all vertices
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            """
            pass

        def polyhedron_barycenter(self, polyhedron_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the polyhedron barycenter as a mean of all vertices
            / \param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)
            """
            pass

        @overload
        def polygon_centroid(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon centroid as described in https://en.wikipedia.org/wiki/Centroid
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param polygonArea the area of the polygon
            / \note the polygon shall be 2D
            """
            pass

        @overload
        def polygon_centroid(
            self,
            sub_polygon_centroids: Eigen.MatrixXd,
            sub_polygon_areas: Eigen.VectorXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon centroid using polygon sub-division
            / \param subPolygonCentroids the centroid of each subPolygon (size 3 x numSubPolygons)
            / \param subPolygonAreas the areas of each subPolygon, size 1 x numSubPolygons
            / \param polygonArea the total area of the polygon
            """
            pass

        def polygon_area_by_boundary_integral(
            self,
            polygon_vertices: Eigen.MatrixXd,
            edge_lengths: Eigen.VectorXd,
            edge_tangents: Eigen.MatrixXd,
            edge_normals: Eigen.MatrixXd,
            reference_quadrature_points: Eigen.MatrixXd = (Eigen.MatrixXd(3, 1) << 0.5, 0.0, 0.0).finished(),
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Ones(1)
            ) -> float:
            """/ \brief Polygon Area By Integral on edges
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param edgeLengths the edge lengths, size numEdges
            / \param edgeTangents the edge tangents, size 3 x numEdges
            / \param edgeNormals the edge outgoint normals, size 3 x numEdges
            / \param referenceQuadraturePoints quadrature points on reference segment [0,1]
            / \param referenceQuadratureWeights quadrature weights on reference segment [0,1]
            / \return the polygon area
            / \note the area is computed as integral_edges x dot n_x with gauss formula on edges of order 1
            """
            pass

        def polygon_area_by_internal_integral(
            self,
            polygon_triangulation_points: List[Eigen.Matrix3d],
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 0.5)
            ) -> float:
            """/ \brief Polygon Area By Internal Integral
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \param referenceQuadratureWeights the reference triangle quadrature weights [0,1]x[0,1]
            / \return the area computed as integral on sub-triangles
            """
            pass

        def polygon_centroid_by_integral(
            self,
            polygon_vertices: Eigen.MatrixXd,
            edge_lengths: Eigen.VectorXd,
            edge_tangents: Eigen.MatrixXd,
            edge_normals: Eigen.MatrixXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Polygon Area By Integral on edges
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param edgeLengths the edge lengths, size numEdges
            / \param edgeTangents the edge tangents, size 3 x numEdges
            / \param edgeNormals the edge outgoint normals, size 3 x numEdges
            / \param polygonArea the polygon area
            / \return the polygon centroid
            / \note the area is computed as integral_edges (x^2, y^2) dot n with gauss formula on edges of order 2
            """
            pass

        def polygon_centroid_edges_distance(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_centroid: Eigen.Vector3d,
            polygon_edge_normals: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            """/ \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param polygonCentroid the polygon centroid
            / \param polygonEdgeNormals the polygon edge normals outgoing the polygon, size 3 x numEdges
            / \return the distance between the centroid and all the polygon edges, size 1 x numEdges
            """
            pass

        def polygon_centroid_vertices_distance(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_centroid: Eigen.Vector3d
            ) -> Eigen.VectorXd:
            """/ \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param polygonCentroid the polygon centroid
            / \return the distance between the centroid and all the polygon vertices, size 1 x numEdges
            """
            pass

        def polygon_in_radius(self, polygon_centroid_edges_distance: Eigen.VectorXd) -> float:
            """/ \param polygonCentroidEdgesDistance the polygon centroid edges distance, size 1 x numEdges
            / \return the polygon in radius, as the minimum distance between the polygon centroid and the edges
            """
            pass

        def polygon_aspect_ratio(
            self,
            polygon_diameter: float,
            polygon_in_radius: float
            ) -> float:
            """/ \param polygonDiameter the polygon diameter
            / \param polygonInRadius the polygon in radius
            / \return the polygon aspect ratio, defined as the ratio bewteen the in and out diameter
            """
            pass

        def polygon_diameter(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \brief Compute the Polygon diameter defined as the maximum distance between the vertices
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            """
            pass

        def polygon_translation(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the translation vector of a tridimensional Polygon
            / \param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)
            / \return the resulting translation vector t which corresponds to the first vertex of the polygon
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def polygon_rotation_matrix(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_normal: Eigen.Vector3d,
            polygon_translation: Eigen.Vector3d
            ) -> Eigen.Matrix3d:
            """/ \brief Compute the rotation matrix and translation vector of a tridimensional Polygon
            / \param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)
            / \param polygonNormal the normalized normal of the plane which contains the polygon
            / \param polygonTranslation the translation vector t
            / \return the resulting rotation matrix Q which rotates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def polygon_is_convex(
            self,
            polygon_vertices: Eigen.MatrixXd,
            convex_hull: Eigen.MatrixXd
            ) -> bool:
            """/ \brief Check if Polygon is Convex
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param convexHull the convex hull vertices counterclockwise
            / \return True if polygon is convex, False otherwise
            / \note works only in 2D-plane
            """
            pass

        def polygon_type(
            self,
            num_polygon_vertices: int,
            is_polygon_convex: bool
            ) -> GeometryUtilities.PolygonTypes:
            """/ \param numPolygonVertices the number of polygon vertices
            / \param isPolygonConvex True if the polygon is convex
            / \return the polygon type
            """
            pass

        def polygon_orientation(
            self,
            convex_hull: List[int]
            ) -> GeometryUtilities.PolygonOrientations:
            """/ \param convexHull the polygon convex hull vertices indices counterclockwise
            / \return the polygon 2D orientation
            / \note works only in 2D-plane
            """
            pass

        def change_polygon_orientation(self, num_polygon_vertices: int) -> List[int]:
            """/ \param numPolygonVertices the number of polygon vertices
            / \return the new polygon vertices indices oriented in the opposite direction
            """
            pass

        def plane_rotation_matrix(self, plane_normal: Eigen.Vector3d) -> Eigen.Matrix3d:
            """/ \brief Compute the rotation matrix of a plane from 2D to 3D
            / \param planeNormal the normalized normal of the plane
            / \return the resulting rotation matrix Q which rotates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def plane_translation(self, plane_origin: Eigen.Vector3d) -> Eigen.Vector3d:
            """/ \brief Compute the translation vector of a plane from 2D to 3D
            / \param planeNormal the normalized normal of the plane
            / \param planeOrigin the 3D plane origin
            / \return the resulting translation vector t which translates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def plane_reflection_matrix(self, plane_normal: Eigen.Vector3d) -> Eigen.Matrix3d:
            pass
        def plane_reflection_translation(
            self,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            pass

        def rotate_points(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P using rotation matrix Q and translation t: Q * P + t
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix, size 3x3
            / \param translation the translation vector, size 1x3
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t
            """
            pass

        def rotate_points_from2_d_to3_d(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P From 2D To 3D using rotation matrix Q and translation t: Q * P + t
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix from 2D to 3D
            / \param translation the translation vector
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t
            """
            pass
        def rotate_points_from3_d_to2_d(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P From 3D To 2D using rotation matrix Q and translation t: Q * (P - t)
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix from 3D to 2D
            / \param translation the translation vector
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * (P - t)
            """
            pass

        def convex_hull(
            self,
            points: Eigen.MatrixXd,
            include_collinear: bool = True
            ) -> List[int]:
            """/ \brief Compute the Convex Hull of 2D points
            / \param points the points, size 3 x numPoints
            / \param includeCollinear include the collinear points, default True
            / \return the convex hull indices counterclockwise, size numConvexHullPoints, numConvexHullPoints <= numPoints
            / \note works in 2D, use the Graham_scan algorithm https://en.wikipedia.org/wiki/Graham_scan
            """
            pass

        def points_are_aligned(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            points: Eigen.MatrixXd
            ) -> List[bool]:
            """/ \brief Check if a set of points are aligned to a line identified by a segment
            / \param segmentOrigin segment origin of the line
            / \param segmentEnd segment end of the line
            / \param points the points, size 3 x numPoints
            / \return True if the i-th point is aligned, size 1 x numPoints
            """
            pass

        def points_are_on_line(
            self,
            points: Eigen.MatrixXd,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d
            ) -> List[bool]:
            """/ \brief Check if a set of points are on a line
            / \param points the points, size 3 x numPoints
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return True if the i-th point is aligned, size 1 x numPoints
            """
            pass

        def point_is_aligned(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            point: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if a point is aligned to a line identified by a segment
            / \param segmentOrigin segment origin of the line
            / \param segmentEnd segment end of the line
            / \param point the point
            / \return True if the point is aligned
            """
            pass

        def point_is_on_line(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if a point is on a line
            / \param point the point
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return True if the point is aligned
            """
            pass

        def unaligned_points(
            self,
            points: Eigen.MatrixXd,
            num_desired_unaligned_points: int = 0
            ) -> List[int]:
            """/ \brief Extract the circumscribed unaligned points (minimum 2) in a set of points
            / \param points the points, size 3 x numPoints
            / \param numDesiredUnalignedPoints the number of desired unaligned points, if 0 all the points are computed
            / \return the unaligned points indices counterclockwise, size numUnalignedPoints, 2 <= numUnalignedPoints <=
            / numPoints
            """
            pass

        def unaligned_polyhedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_unaliged_faces: List[List[int]],
            polyhedron_faces_unaligned_vertices: List[List[int]]
            ) -> List[int]:
            """/ \brief Extract the circumscribed unaligned points (minimum 4) in a polyhedron
            / \return the unaligned points, size numUnalignedPoints, 4 <= numUnalignedPoints <= numPoints
            / \warning works only for convex polyhedron
            """
            pass

        def aligned_polyhedron_edges(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            vertices_adjacency: List[List[int]],
            edges_adjacency: List[List[int]],
            adjacency_vertices_map: List[std.unordered_map[int, int]],
            polyhedron_edge_tangents: Eigen.MatrixXd,
            polyhedron_edge_squared_lenghts: Eigen.VectorXd
            ) -> GeometryUtilities.AlignedPolyhedronEdgesResult:
            pass

        def extract_points(self, points: Eigen.MatrixXd, filter: List[int]) -> Eigen.MatrixXd:
            """/ \param points the points, size 3 x numPoints
            / \param filter indices counterclockwise, size numFilterPoints, numFilterPoints <= numPoints
            / \return the points coordinates filtered, size 3 x numFilterPoints
            """
            pass

        def extract_triangulation_points(
            self,
            points: Eigen.MatrixXd,
            points_triangulation: List[int]
            ) -> List[Eigen.Matrix3d]:
            """/ \param points the points, size 3 x numPoints
            / \param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles
            / \return the triangles coordinates, size 1 x numTriangles
            """
            pass

        def extract_triangulation_points_by_internal_point(
            self,
            points: Eigen.MatrixXd,
            internal_point: Eigen.Vector3d,
            points_triangulation: List[int]
            ) -> List[Eigen.Matrix3d]:
            """/ \param points the points, size 3 x numPoints
            / \param externalPoint the external point coordinates
            / \param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles
            / \return the triangles coordinates, size 1 x numTriangles
            """
            pass

        def create_ellipse(
            self,
            axis_major_length: float,
            axis_minor_length: float,
            resolution: int
            ) -> Eigen.MatrixXd:
            """/ \brief Create 2D Ellipse approximation with 2D polygon
            / \param axisMajorLength the ellipse axis major length
            / \param axisMinorLength the ellipse axis minor length
            / \param resolution the number of points on each ellipse quadrant
            / \return the polygon which approximate the ellipse
            / \note the ellipse is centered in the origin and parallel to xy-axis
            """
            pass

        def create_triangle(
            self,
            p1: Eigen.Vector3d,
            p2: Eigen.Vector3d,
            p3: Eigen.Vector3d
            ) -> Eigen.MatrixXd:
            """/ \brief Create a triangle with points"""
            pass
        def create_parallelogram(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> Eigen.MatrixXd:
            """/ \brief Create a parallelogram with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param widthVector the width vector
            """
            pass
        def create_rectangle(
            self,
            origin: Eigen.Vector3d,
            base: float,
            height: float
            ) -> Eigen.MatrixXd:
            """/ \brief Create a rectangle with origin and dimensions parallel to axis
            / \param origin the origin
            / \param base the base length
            / \param height the height length
            """
            pass

        def create_square(self, origin: Eigen.Vector3d, edge_length: float) -> Eigen.MatrixXd:
            """/ \brief Create a square with origin and dimensions parallel to axis
            / \param origin the origin
            / \param edgeLength the edge length
            """
            pass

        def create_tetrahedron_with_origin(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            height_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Tetrahedron with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param heightVector the heigth vector
            / \param widthVector the width vector
            / \return the tetrahedron created
            """
            pass

        def create_tetrahedron_with_vertices(
            self,
            v1: Eigen.Vector3d,
            v2: Eigen.Vector3d,
            v3: Eigen.Vector3d,
            v4: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Tetrahedron with the four vertices
            / \param v1 the first vertex
            / \param v2 the second vertex
            / \param v3 the third vertex
            / \param v4 the fourth vertex
            / \return the tetrahedron created
            """
            pass

        def create_parallelepiped_with_origin(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            height_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Parallelepiped with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param heightVector the heigth vector
            / \param widthVector the width vector
            / \return the parallelepiped created
            """
            pass

        @overload
        def create_polyhedron_with_extrusion(
            self,
            polygon_vertices: Eigen.MatrixXd,
            height_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create Polyhedron With Extrusion
            / \param polygon the 2D polygon vertices
            / \param heightVector  the height vector
            / \return the polyhedron created
            """
            pass

        @overload
        def create_polyhedron_with_extrusion(
            self,
            polygon_vertices: Eigen.MatrixXd,
            height_vectors: List[Eigen.Vector3d]
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create Polyhedron With Extrusion
            / \param polygon the 2D polygon vertices, size 3 x numPolygonVertices
            / \param heightVectors the height vector to be used for each polygon vertex, size numPolygonVertices
            / \return the polyhedron created
            """
            pass

        def create_cube_with_origin(
            self,
            origin: Eigen.Vector3d,
            edge_length: float
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Cube with origin aligned to axis
            / \param origin the origin
            / \param edgeLength the edge length
            / \return the cube created
            """
            pass

        def polyhedron_volume_by_boundary_integral(
            self,
            polyhedron_face_rotated_triangulation_points: List[List[Eigen.Matrix3d]],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            reference_quadrature_points: Eigen.MatrixXd = (Eigen.MatrixXd(3, 1) << 1.0 / 3.0, 1.0 / 3.0, 0.0).finished(),
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 0.5)
            ) -> float:
            """/ \brief Compute the Polyhedron Volume
            / \param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces
            / x numTrianglesPerFace \param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \param
            / polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \param
            / polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \param
            / polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \param referenceQuadraturePoints
            / the reference tetrahedron quadrature points [0,1]x[0,1]x[0,1] \param referenceQuadratureWeights the reference
            / tetrahedron quadrature weights [0,1]x[0,1]x[0,1] \return the polyhedron volume \note use the divergence theorem,
            / with F = 1/3 (x, y, z), see https://en.wikipedia.org/wiki/Divergence_theorem
            """
            pass

        def polyhedron_volume_by_internal_integral(
            self,
            polyhedron_tetrahedron_vertices: List[Eigen.MatrixXd],
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 1.0 / 6.0)
            ) -> float:
            """/ \brief Polyhedron Volume By Internal Integral
            / \param polyhedronTetrahedronVertices the internal polyhedron sub-tetrahedra
            / \param referenceQuadratureWeights the reference tetrahedron quadrature weights [0,1]x[0,1]x[0,1]
            / \return the area computed as integral on sub-tetrahedra
            """
            pass

        def polyhedron_centroid(
            self,
            polyhedron_face_rotated_triangulation_points: List[List[Eigen.Matrix3d]],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            polyhedron_volume: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polyhedron centroid
            / \param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces
            / x numTrianglesPerFace \param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \param
            / polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \param
            / polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \param
            / polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \param polyhedronVolume the
            / polyhedron volume \return the polyhedron centroid \note use the divergence theorem, with F_x = 1/2 (x^2, 0, 0),
            / F_y = 1/2 (0, y^2, 0), F_z = 1/2 (0, 0, z^2), see https://en.wikipedia.org/wiki/Divergence_theorem
            """
            pass

        def polyhedron_diameter(self, polyhedron_vertices: Eigen.MatrixXd) -> float:
            """/ \brief Compute the Polyhedron diameter defined as the maximum distance between the vertices
            / \param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)
            """
            pass

        def polyhedron_edges_centroid(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.MatrixXd:
            """/ \brief Compute Polyhedron Edges Centroid
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the centroid, size 3xnumEdges
            """
            pass

        def polyhedron_edges_length(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.VectorXd:
            """/ \brief Compute Polyhedron Edges Lenght
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the length, size 1xnumEdges
            """
            pass

        def polyhedron_edge_tangents(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.MatrixXd:
            """/ \brief Compute Polyhedron Edges Tangent
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the tangent, size 3xnumEdges
            """
            pass

        def polyhedron_face_vertices(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi]
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Vertices
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \return for each face the vertices, size 1xnumFaces
            """
            pass

        def polyhedron_face_edge_directions(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi]
            ) -> List[List[bool]]:
            """/ \brief Compute Polyhedron Faces Edge Direction
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \return for each face the edge direction compare to polyhedron edge directions, size 1xnumFaces
            """
            pass

        def polyhedron_face_edge_tangents(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_edge_directions: List[List[bool]],
            polyhedron_edge_tangents: Eigen.MatrixXd
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Edge Tangents
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronEdgeTangents for each polyhedron edge the tangent, size 3xnumEdges
            / \return for each face the edge tangents, size 1xnumFaces
            """
            pass

        def polyhedron_face_rotation_matrices(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_translations: List[Eigen.Vector3d]
            ) -> List[Eigen.Matrix3d]:
            """/ \brief Compute Polyhedron Faces Rotation matrix
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the rotation matrix from 2D to 3D
            """
            pass

        def polyhedron_face_translations(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces translation vectors
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the translation vector
            """
            pass

        def polyhedron_face_rotated_vertices(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Rotated Vertices 2D
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaceTranslations the polyhedron face translations from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return for each face the 2D vertices, size 1xnumFaces
            """
            pass

        def polyhedron_faces_unaligned_vertices(
            self,
            polyhedron_faces_rotated_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Compute Polyhedron Faces Unaligned Vertices Indices
            / \param polyhedronFacesRotatedVertices the polyhedron faces 2D vertices
            / \return for each face the unaligned vertices indices, size 1 x numFaces
            """
            pass

        def polyhedron_face_normals(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces Normals
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the normal
            """
            pass

        def polyhedron_face_tangents(
            self,
            polyhedron_faces_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_normal: List[Eigen.Vector3d],
            polyhedron_faces_normal_direction: List[bool]
            ) -> List[List[Eigen.Vector3d]]:
            pass

        def polyhedron_face_barycenter(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces barycenters
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the barycenter
            """
            pass

        def polyhedron_mass(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_tetrahedron_points: List[Eigen.MatrixXd]
            ) -> Eigen.Matrix3d:
            pass

        def polyhedron_inertia(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_tetrahedra_points: List[Eigen.MatrixXd]
            ) -> Eigen.Matrix3d:
            pass

        def polyhedron_centroid_faces_distance(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_faces_normal: List[Eigen.Vector3d],
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> Eigen.VectorXd:
            pass

        def polyhedron_in_radius(
            self,
            polyhedron_centroid_faces_distance: Eigen.VectorXd
            ) -> float:
            pass

        def polyhedron_is_convex(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if Polyhedron is Convex
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param polyhedronFaceNormals the normal of each face
            / \param polyhedronFaceNormalDirections the normal outgoing direction
            / \param pointInsidePolyhedron a point inside polyhedron
            / \return True if polyhedron is convex, False otherwise
            / \warning still not working
            """
            pass

        @overload
        def polyhedron_face_normal_directions(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            point_inside_polyhedron: Eigen.Vector3d,
            polyhedron_face_normals: List[Eigen.Vector3d]
            ) -> List[bool]:
            """/ \brief Compute Polyhedron Face Normal Directions
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param pointInsidePolyhedron a point inside polyhedron
            / \param polyhedronFaceNormals the normal of each face
            / \return True if the face has normal outgoing
            / \warning works only for convex polyhedrons
            """
            pass
        @overload
        def polyhedron_face_normal_directions(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> List[bool]:
            """/ \brief Compute Polyhedron Face Normal Directions for generic polyhedron (slower)
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param pointInsidePolyhedron a point inside polyhedron
            / \param polyhedronFaceNormals the normal of each face
            / \return True if the face has normal outgoing
            / \warning NOT WORKING in all cases
            """
            pass

        def polyhedron_face_triangulations(
            self,
            polyhedron_faces: List[Eigen.MatrixXi],
            local_face_triangulations: List[List[int]]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations of each face
            / \param polyhedronFaces the polyhedron faces
            / \param localFaceTriangulations the local faces triangulations indices, size 1xnumFaces x (3xnumTriangles)
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass
        def polyhedron_face_triangulations_by_first_vertex(
            self,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by first vertex of each face
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass

        def polyhedron_face_triangulations_by_ear_clipping(
            self,
            num_polyhedron_faces: int,
            polyhedron_faces2_d_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by ear clipping of each face
            / \param numPolyhedronFaces the number of polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass

        def polyhedron_face_extract_triangulation_points(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_triangulations: List[List[int]]
            ) -> List[List[Eigen.Matrix3d]]:
            pass

        def polyhedron_face_triangulation_points_by_internal_point(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_triangulations: List[List[int]]
            ) -> List[List[Eigen.Matrix3d]]:
            pass

        def polyhedron_face_triangulations_by_internal_point(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by internal point of each face
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            / \note the internal point index is polyhedronVertices.size()
            """
            pass

        @overload
        def polyhedron_tetrahedrons_by_face_triangulations(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_triangulations: List[List[int]],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Polyhedron Tetrahedrons By Face Triangulations
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param faceTriangulations the triangulation on face vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)
            / \note the polyhedron internal point index is polyhedronVertices.size() + f
            """
            pass

        @overload
        def polyhedron_tetrahedrons_by_face_triangulations(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_triangulations: List[List[int]],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Polyhedron Tetrahedrons By Face Triangulations with face internal points
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param faceTriangulations the triangulation on face vertices by internal points
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param polyhedronInternalPoint a polyhedron internal point
            / \return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)
            / \note the polyhedron face internal points are polyhedronVertices.size() + f
            / \note the polyhedron internal point index is polyhedronVertices.size() + polyhedronFaceInternalPoints.size()
            """
            pass

        @overload
        def extract_tetrahedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_internal_point: Eigen.Vector3d,
            point_tetrahedrons: List[int]
            ) -> List[Eigen.MatrixXd]:
            """/ \param polyhedronVertices the polyhedron vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra
            / \return the tetrahedrons coordinates, size 1 x numTetra
            """
            pass
        @overload
        def extract_tetrahedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_internal_point: Eigen.Vector3d,
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            point_tetrahedrons: List[int]
            ) -> List[Eigen.MatrixXd]:
            """/ \param polyhedronVertices the polyhedron vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra
            / \return the tetrahedrons coordinates, size 1 x numTetra
            """
            pass

        def polyhedron_coordinate_system(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> List[int]:
            """/ \brief Get Polyhedron Coordinate System
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return the four vertices indices forming a coordinate system for the polyhedron, size 1x4
            """
            pass

        @overload
        def export_polyhedron_to_vtu(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            export_folder: str
            ) -> None:
            """/ \brief Export Polyhedron To VTU
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param exportFolder the folder in which to export
            """
            pass

        @overload
        def export_polyhedron_to_vtu(
            self,
            polyhedron: GeometryUtilities.Polyhedron,
            export_folder: str
            ) -> None:
            pass

        @overload
        def export_polyhedron_to_vtu(
            self,
            index: int,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_tetra: List[Eigen.MatrixXd],
            polyhedron_volume: float,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_faces3_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_area: List[float],
            polyhedron_faces2_d_centroid: List[Eigen.Vector3d],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_faces3_d_triangles: List[List[Eigen.Matrix3d]],
            polyhedron_faces3_d_internal_point: List[Eigen.Vector3d],
            polyhedron_faces3_d_normal: List[Eigen.Vector3d],
            polyhedron_faces3_d_normal_direction: List[bool],
            export_folder: str
            ) -> None:
            """/ \brief Export Polyhedron To VTU
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param exportFolder the folder in which to export
            """
            pass

        def export_polygon_to_vtu(
            self,
            index: int,
            polygon: Eigen.MatrixXd,
            polygon_triangles: List[Eigen.Matrix3d],
            polygon_volume: float,
            polygon_centroid: Eigen.Vector3d,
            polygon_edges_centroid: Eigen.MatrixXd,
            polygon_edges_normal: Eigen.MatrixXd,
            polygon_edges_normal_direction: List[bool],
            export_folder: str
            ) -> None:
            pass

        def merge_polyhedron_by_face(
            self,
            polyhedrons: List[GeometryUtilities.Polyhedron],
            polyhedrons_common_face_index: List[int],
            remove_common_face: bool
            ) -> GeometryUtilities.MergePolyhedronsInput:
            pass

        def merge_polyhedrons(
            self,
            polyhedrons: List[GeometryUtilities.Polyhedron],
            merge_information: GeometryUtilities.MergePolyhedronsInput = GeometryUtilities.MergePolyhedronsInput()
            ) -> GeometryUtilities.MergePolyhedronsResult:
            pass

        def facets_to_polyhedron(
            self,
            points: Eigen.MatrixXd,
            facets: List[List[int]]
            ) -> GeometryUtilities.Polyhedron:
            pass
        def polyhedron_to_facets(
            self,
            polyhedron: GeometryUtilities.Polyhedron
            ) -> List[List[int]]:
            pass


# </submodule gedim>
####################    </generated_from:GeometryUtilities.hpp>    ####################


####################    <generated_from:MapParallelepiped.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapParallelepiped_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapParallelepiped:
        class MapParallelepipedData:
            """
            (final class)
            """
            q: Eigen.Matrix3d
            b: Eigen.Vector3d
            q_inv: Eigen.Matrix3d
            det_q: float
            det_q_inv: float
            def __init__(
                self,
                q: Eigen.Matrix3d = Eigen.Matrix3d(),
                b: Eigen.Vector3d = Eigen.Vector3d(),
                q_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                det_q: float = float(),
                det_q_inv: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        reference_vertices: Eigen.MatrixXd

        def __init__(self, geometry_utilities: GeometryUtilities) -> None:
            pass


        @staticmethod
        def q(
            first_vertex: Eigen.Vector3d,
            second_vertex: Eigen.Vector3d,
            third_vertex: Eigen.Vector3d,
            fourth_vertex: Eigen.Vector3d
            ) -> Eigen.Matrix3d:
            """/ Matrix Q for linear map x = Q * x_r + b from reference Hexahedron [0,1]x[0,1]x[0,1] to Hexahedron with x points
            / vertices the Hexahedron to map vertices, size 3 x 4
            / return the resulting value, size 3 x 3
            """
            pass

        @staticmethod
        def b(first_vertex: Eigen.Vector3d) -> Eigen.Vector3d:
            """/ Matrix Q for linear map x = Q * x_r + b from reference Hexahedron [0,1]x[0,1]x[0,1] to Hexahedron with x points
            / vertices the Hexahedron to map vertices, size 3 x 4
            / return the resulting value, size 3 x 3
            """
            pass

        def compute(
            self,
            vertices: Eigen.MatrixXd,
            coordinate_system: List[int]
            ) -> MapParallelepiped.MapParallelepipedData:
            """/ Map from the hexahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b
            / \param vertices the hexahedron to map vertices, size 3 x 4
            / \param edges the hexahedron edges
            / \return the map data
            """
            pass

        @staticmethod
        def f(
            map_data: MapParallelepiped.MapParallelepipedData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Map from the Hexahedron reference element [0,1]x[0,1]x[0,1] to the polygon x = F(x_r) = Q * x_r + b
            / \param mapData the map data computed
            / \param x points in reference Hexahedron, size 3 x numPoints
            / \return the mapped points, size 3 x numPoints
            """
            pass

        @staticmethod
        def f_inv(
            map_data: MapParallelepiped.MapParallelepipedData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j(
            map_data: MapParallelepiped.MapParallelepipedData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Compute the jacobian matrix of the transformation F
            / \param mapData the map data computed
            / \param x points in reference Hexahedron, size 3 x numPoints
            / \return the Q matrix for each points, size 2 x (2 * numPoints)
            """
            pass

        @staticmethod
        def det_j(
            map_data: MapParallelepiped.MapParallelepipedData,
            x: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data computed
            / \param x points in reference Hexahedron, size 3 x numPoints
            / \return the determinant of Jacobian matrix for each points, size 1 x numPoints
            """
            pass

# </submodule gedim>
####################    </generated_from:MapParallelepiped.hpp>    ####################


####################    <generated_from:MapHexahedron.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapHexahedron_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapHexahedron:
        class MapHexahedronData:
            """
            (final class)
            """
            reference_vertices: Eigen.MatrixXd
            a: Eigen.MatrixXd
            coefficients: Eigen.MatrixXd
            vertices: Eigen.MatrixXd
            vertex_order: Dict[int, int]
            def __init__(
                self,
                reference_vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                a: Eigen.MatrixXd = Eigen.MatrixXd(),
                coefficients: Eigen.MatrixXd = Eigen.MatrixXd(),
                vertices: Eigen.MatrixXd = Eigen.MatrixXd()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        @staticmethod
        def compute(
            vertices: Eigen.MatrixXd,
            faces: List[Eigen.MatrixXi]
            ) -> MapHexahedron.MapHexahedronData:
            pass

        @staticmethod
        def f(
            map_data: MapHexahedron.MapHexahedronData,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def f_inv(
            map_data: MapHexahedron.MapHexahedronData,
            points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j(
            map_data: MapHexahedron.MapHexahedronData,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j_inv(
            map_data: MapHexahedron.MapHexahedronData,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def det_j(
            map_data: MapHexahedron.MapHexahedronData,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            pass

# </submodule gedim>
####################    </generated_from:MapHexahedron.hpp>    ####################


####################    <generated_from:MapParallelogram.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapParallelogram_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapParallelogram:
        class MapParallelogramData:
            """
            (final class)
            """
            b: Eigen.Matrix3d
            b_inv: Eigen.Matrix3d
            b: Eigen.Vector3d
            det_b: float
            det_b_inv: float
            def __init__(
                self,
                b: Eigen.Matrix3d = Eigen.Matrix3d(),
                b_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                b: Eigen.Vector3d = Eigen.Vector3d(),
                det_b: float = float(),
                det_b_inv: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass
        reference_vertices: Eigen.MatrixXd

        def __init__(self) -> None:
            pass

        def compute(self, vertices: Eigen.MatrixXd) -> MapParallelogram.MapParallelogramData:
            pass

        @staticmethod
        def f(
            map_data: MapParallelogram.MapParallelogramData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def f_inv(
            map_data: MapParallelogram.MapParallelogramData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j(
            map_data: MapParallelogram.MapParallelogramData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Compute the jacobian matrix of the transformation F
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the B matrix for each points, size 3 x (3 * numPoints)
            """
            pass

        @staticmethod
        @overload
        def det_j(
            map_data: MapParallelogram.MapParallelogramData,
            x: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            pass

        @staticmethod
        @overload
        def det_j(map_data: MapParallelogram.MapParallelogramData) -> float:
            pass

# </submodule gedim>
####################    </generated_from:MapParallelogram.hpp>    ####################


####################    <generated_from:MapQuadrilateral.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapQuadrilateral_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapQuadrilateral:
        reference_points: Eigen.MatrixXd

        def __init__(self) -> None:
            pass

        def f(
            self,
            vertices: Eigen.MatrixXd,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        def f_inv(self, vertices: Eigen.MatrixXd, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
            pass

        def j(
            self,
            vertices: Eigen.MatrixXd,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        def j_inv(
            self,
            vertices: Eigen.MatrixXd,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        def det_j(
            self,
            vertices: Eigen.MatrixXd,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            pass

# </submodule gedim>
####################    </generated_from:MapQuadrilateral.hpp>    ####################


####################    <generated_from:MapTetrahedron.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapTetrahedron_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapTetrahedron:
        class MapTetrahedronData:
            """
            (final class)
            """
            q: Eigen.Matrix3d
            b: Eigen.Vector3d
            q_inv: Eigen.Matrix3d
            det_q: float
            det_q_inv: float
            def __init__(
                self,
                q: Eigen.Matrix3d = Eigen.Matrix3d(),
                b: Eigen.Vector3d = Eigen.Vector3d(),
                q_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                det_q: float = float(),
                det_q_inv: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self, geometry_utilities: GeometryUtilities) -> None:
            pass


        @staticmethod
        def q(
            first_vertex: Eigen.Vector3d,
            second_vertex: Eigen.Vector3d,
            third_vertex: Eigen.Vector3d,
            fourth_vertex: Eigen.Vector3d
            ) -> Eigen.Matrix3d:
            """/ Matrix Q for linear map x = Q * x_r + b from reference tetrahedron [0,1]x[0,1]x[0,1]/2 to tetrahedron with x
            / points vertices the tetrahedron to map vertices, size 3 x 4 return the resulting value, size 3 x 3
            """
            pass

        @staticmethod
        def b(first_vertex: Eigen.Vector3d) -> Eigen.Vector3d:
            """/ Matrix Q for linear map x = Q * x_r + b from reference tetrahedron [0,1]x[0,1]x[0,1]/2 to tetrahedron with x
            / points vertices the tetrahedron to map vertices, size 3 x 4 return the resulting value, size 3 x 3
            """
            pass

        def compute(self, vertices: Eigen.MatrixXd) -> MapTetrahedron.MapTetrahedronData:
            """/ Map from the tetrahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b
            / \param vertices the tetrahedron to map vertices, size 3 x 4
            / \return the map data
            """
            pass

        @staticmethod
        def f(
            map_data: MapTetrahedron.MapTetrahedronData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Map from the tetrahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b
            / \param mapData the map data computed
            / \param x points in reference tetrahedron, size 3 x numPoints
            / \return the mapped points, size 3 x numPoints
            """
            pass

        @staticmethod
        def f_inv(
            map_data: MapTetrahedron.MapTetrahedronData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j(
            map_data: MapTetrahedron.MapTetrahedronData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Compute the jacobian matrix of the transformation F
            / \param mapData the map data computed
            / \param x points in reference tetrahedron, size 3 x numPoints
            / \return the Q matrix for each points, size 2 x (2 * numPoints)
            """
            pass
        @staticmethod
        @overload
        def det_j(
            map_data: MapTetrahedron.MapTetrahedronData,
            x: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data computed
            / \param x points in reference tetrahedron, size 3 x numPoints
            / \return the determinant of Jacobian matrix for each points, size 1 x numPoints
            """
            pass

        @staticmethod
        @overload
        def det_j(map_data: MapTetrahedron.MapTetrahedronData) -> float:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data computed
            / \return the determinant of Jacobian matrix
            """
            pass

# </submodule gedim>
####################    </generated_from:MapTetrahedron.hpp>    ####################


####################    <generated_from:MapTriangle.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapTriangle_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapTriangle:
        class MapTriangleData:
            """
            (final class)
            """
            b: Eigen.Matrix3d
            b_inv: Eigen.Matrix3d
            b: Eigen.Vector3d
            det_b: float
            det_b_inv: float
            def __init__(
                self,
                b: Eigen.Matrix3d = Eigen.Matrix3d(),
                b_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                b: Eigen.Vector3d = Eigen.Vector3d(),
                det_b: float = float(),
                det_b_inv: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def compute(self, vertices: Eigen.Matrix3d) -> MapTriangle.MapTriangleData:
            """/ Map from the triangle reference element [0,1]x[0,1]/2 to the polygon x = F(x_r) = B * x_r + b
            / \param vertices the triangle 2D to map vertices, size 3 x 3
            / \return the map data
            """
            pass

        @staticmethod
        def f(map_data: MapTriangle.MapTriangleData, x: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ Map from the triangle reference element [0,1]x[0,1] to the polygon x = F(x_r) = B * x_r + b
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the mapped polygon points, size 3 x numPoints
            """
            pass
        @staticmethod
        def f_inv(map_data: MapTriangle.MapTriangleData, x: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ Map from the polygon x to the triangle reference element [0,1]x[0,1] x_r = F^-1(x_r) = B^-1 * (x - b)
            / \param mapData the map data
            / \param x points in polygon, size 3 x numPoints
            / \return the mapped reference points, size 3 x numPoints
            """
            pass
        @staticmethod
        def j(map_data: MapTriangle.MapTriangleData, x: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ Compute the jacobian matrix of the transformation F
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the B matrix for each points, size 3 x (3 * numPoints)
            """
            pass

        @staticmethod
        @overload
        def det_j(map_data: MapTriangle.MapTriangleData, x: Eigen.MatrixXd) -> Eigen.VectorXd:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the determinant of Jacobian matrix for each points, size 1 x numPoints
            """
            pass

        @staticmethod
        @overload
        def det_j(map_data: MapTriangle.MapTriangleData) -> float:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the determinant of Jacobian matrix
            """
            pass

# </submodule gedim>
####################    </generated_from:MapTriangle.hpp>    ####################


####################    <generated_from:ConformerMeshPolygon.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __ConformerMeshPolygon_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class ConformerMeshPolygon:
        """
        (final class)
        """
        class ConformerMeshPolygonConfiguration:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                generalized = enum.auto()   # (= 0)  # conform checking the intersection types
                only_on_edges = enum.auto() # (= 1)  # mesh 2D is already conform on edges, check only vertices

            type: Types = Types.generalized
            def __init__(self, type: Types = Types.generalized) -> None:
                """Auto-generated default constructor with named params"""
                pass

        @overload
        def __init__(self, geometry_utilities: GeometryUtilities) -> None:
            pass
        @overload
        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            configuration: ConformerMeshPolygon.ConformerMeshPolygonConfiguration
            ) -> None:
            pass

        def create_conform_mesh(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            mesh1_d: ConformerMeshSegment.ConformMesh,
            mesh2_d: IMeshDAO
            ) -> None:
            """/ \brief Conformer the input Mesh2D with a linear mesh1D
            / \param mesh1D the 1D mesh
            / \param mesh2DConformed the resulting conformed mesh
            """
            pass

# </submodule gedim>
####################    </generated_from:ConformerMeshPolygon.hpp>    ####################


####################    <generated_from:ConformerMeshSegment.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __CONFORMERMESHSEGMENT_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class ConformerMeshSegment:
        """
        (final class)
        """
        class ConformMesh:
            """
            (final class)
            """
            class ConformMeshPoint:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()   # (= 0)
                    original = enum.auto()  # (= 1)  #/< point belong to original intersection mesh
                    inherited = enum.auto() # (= 2)  #/< point belong to other intersection mesh
                    external = enum.auto()  # (= 3)  #/< other points not inherith from intersection mesh

                cell2_d_ids: std.set[int] = std.set<int>()
                edge2_d_ids: std.set[int] = std.set<int>()
                vertex2_d_ids: std.set[int] = std.set<int>()
                type: Types
                def __init__(self, type: Types = Types()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class ConformMeshSegment:
                """
                (final class)
                """
                points: List[float] = List[float]()
                cell2_d_ids: std.set[int] = std.set<int>()
                edge2_d_ids: std.set[int] = std.set<int>()
                def __init__(self, points: List[float] = List[float]()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            points: Dict[float, ConformMeshPoint]
            segments: List[ConformMeshSegment]
            def __init__(
                self,
                segments: List[ConformMeshSegment] = List[ConformMeshSegment]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        @staticmethod
        def to_curvilinear_coordinates(
            conform_mesh: ConformerMeshSegment.ConformMesh,
            curvilinear_coordinates: List[float]
            ) -> None:
            """/ \brief convert IntersectionMesh to Curvilinear Coordinates vector"""
            pass

        @staticmethod
        def to_string(conform_mesh: ConformerMeshSegment.ConformMesh) -> str:
            pass

        @staticmethod
        def create_conform_segments(result: ConformerMeshSegment.ConformMesh) -> None:
            pass

        @staticmethod
        def serialize(os: std.ostream, mesh: ConformerMeshSegment.ConformMesh) -> None:
            pass

        @staticmethod
        def deserialize(is_: std.istream, mesh: ConformerMeshSegment.ConformMesh) -> None:
            pass

        def __init__(self, geometry_utilities: GeometryUtilities) -> None:
            pass

        def create_conform_mesh(
            self,
            mesh_intersection: IntersectorMesh2DSegment.IntersectionMesh,
            mesh_union: UnionMeshSegment.UnionMesh,
            mesh_intersection_position: int,
            result: ConformerMeshSegment.ConformMesh
            ) -> None:
            """/ \brief Create ConformMesh on segment starting from an intersection mesh and the corresponding union mesh
            / \param meshIntersection the segment intersection mesh
            / \param meshUnion the segment mesh union of meshIntersection and an other meshIntersection
            / \param meshIntersectionPosition the position of meshIntersection inside meshUnion, starting from 0
            / \param result the resulting conform mesh
            """
            pass

        def insert_external_point(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            mesh2_d: IMeshDAO,
            curvilinear_coordinate: float,
            result: ConformerMeshSegment.ConformMesh
            ) -> None:
            """/ \brief Insert an external point on conform mesh
            / \param mesh2D the bidimensional mesh where to add the new point
            / \param curvilinearCoordinate the curvilinear coordinate of the new point
            / \param result the resulting conform mesh
            """
            pass

        def update_with_updated_mesh2_d(
            self,
            mesh2_d: IMeshDAO,
            conformed_mesh: ConformerMeshSegment.ConformMesh
            ) -> None:
            """/ \brief Update the conformed 1D mesh with updated mesh 2D data
            / \param mesh2D the updated mesh data
            / \param conformedMesh the resulting conformed mesh
            """
            pass

        def update_with_active_mesh2_d(
            self,
            active_mesh2_d_data: MeshUtilities.ExtractActiveMeshData,
            conformed_mesh: ConformerMeshSegment.ConformMesh
            ) -> None:
            """/ \brief Update the conformed 1D mesh with active mesh 2D data
            / \param activeMesh2DData the active mesh data
            / \param conformedMesh the resulting conformed mesh
            """
            pass

        def add_missing_mesh2_d_cell0_ds(
            self,
            segment_origin: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            segment_squared_length: float,
            mesh2_d: IMeshDAO,
            conformed_mesh: ConformerMeshSegment.ConformMesh
            ) -> List[float]:
            """/ \brief Add Missing Mesh2D Cell0Ds generated from the intersections with other interfaces
            / \param mesh2D the mesh data
            / \param conformedMesh the resulting conformed mesh
            / \note the mesh2D shall be made by only active elements
            / \return the list of coordinates added
            """
            pass

# </submodule gedim>
####################    </generated_from:ConformerMeshSegment.hpp>    ####################


####################    <generated_from:ConformMeshUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __ConformMeshUtilities_H
#




# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class ConformMeshUtilities:
        """
        (final class)
        """
        class ComputeDomainConformedMeshOptions:
            """
            (final class)
            """
            print_status: bool = False
            vtk_export_folder: str = ""
            def __init__(self, print_status: bool = False, vtk_export_folder: str = "") -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            mesh_utilities: MeshUtilities
            ) -> None:
            pass

        def compute_conformed_mesh_with_segments(
            self,
            segments_additional_points: List[std.list[float]],
            segments_vertices: List[Eigen.MatrixXd],
            segments_tangent: List[Eigen.Vector3d],
            segments_barycenter: List[Eigen.Vector3d],
            segments_length: List[float],
            segments_squared_length: List[float],
            domain_mesh: IMeshDAO,
            segments_intersection_mesh: List[IntersectorMesh2DSegment.IntersectionMesh],
            segments_curvilinear_coordinates_mesh: List[List[float]],
            segments_union_mesh: List[UnionMeshSegment.UnionMesh],
            segments_conform_mesh: List[ConformerMeshSegment.ConformMesh],
            conform_domain_mesh_type: ConformerMeshPolygon.ConformerMeshPolygonConfiguration.Types,
            options: ConformMeshUtilities.ComputeDomainConformedMeshOptions
            ) -> None:
            pass

        def add_conformed_mesh_properties(
            self,
            segments_conform_mesh: List[ConformerMeshSegment.ConformMesh],
            conformed_mesh: IMeshDAO
            ) -> None:
            pass

# </submodule gedim>
####################    </generated_from:ConformMeshUtilities.hpp>    ####################


####################    <generated_from:IMeshDAO.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __IMeshWrapper_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class IMeshDAO:
        """/ \brief The IMeshDAO (mesh data access object) class to read and write mesh data"""

        def initialize_dimension(self, dimension: int) -> None:
            """/ \brief Initialize the mesh dimension"""
            pass
        def dimension(self) -> int:
            """/ \return the geometric dimension of the mesh"""
            pass

        def cell0_ds_initialize(self, number_cell0_ds: int) -> None:
            """/ \brief Initialize the Cell0Ds container
            / \param numberCell0Ds the total number of Cell0Ds
            / \note No reset of Cell0Ds is performed
            """
            pass
        def cell0_d_append(self, number_cell0_ds: int) -> int:
            """/ \brief Append Cell0Ds to the Cell0Ds container
            / \param numberCell0Ds the number of Cell0Ds to append
            / \return the previous number of Cell0Ds before the append operation
            """
            pass

        def cell0_d_remove(self, cell0_d_index: int) -> None:
            """/ \brief Remove the Cell0D from the mesh
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \note the cell0D is removed and no integrity check in the mesh are performed
            """
            pass
        def cell0_d_insert_coordinates(
            self,
            cell0_d_index: int,
            coordinates: Eigen.Vector3d
            ) -> None:
            """/ \brief Add the Cell0D Coordinates
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param coordinates the coordinates of the Cell0D
            """
            pass
        def cell0_ds_insert_coordinates(self, coordinates: Eigen.MatrixXd) -> None:
            """/ \brief Add the Cell0Ds Coordinates
            / \param coordinates the coordinates of the Cell0Ds, size 3 x Cell0DTotalNumber()
            """
            pass
        def cell0_d_set_marker(self, cell0_d_index: int, marker: int) -> None:
            """/ \brief Set the Cell0D Marker
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param marker the marker of the Cell0D
            """
            pass
        def cell0_d_set_state(self, cell0_d_index: int, state: bool) -> None:
            """/ \brief Set the Cell0D state
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param state True if Cell0D is active, False otherwise
            """
            pass
        def cell0_d_total_number(self) -> int:
            """/ \return the total number of Cell0Ds"""
            pass
        def cell0_d_coordinate_x(self, cell0_d_index: int) -> float:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the X coordinate of cell0D
            """
            pass
        def cell0_d_coordinate_y(self, cell0_d_index: int) -> float:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the Y coordinate of cell0D
            """
            pass
        def cell0_d_coordinate_z(self, cell0_d_index: int) -> float:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the Z coordinate of cell0D
            """
            pass
        def cell0_d_coordinates(self, cell0_d_index: int) -> Eigen.Vector3d:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the coordinates as Eigen Vector3 of cell0D, size 3x1
            """
            pass
        #/ \return the coordinates as Eigen MatrixXd of cell0D, size 3xCell0DTotalNumber()
        @overload
        def cell0_ds_coordinates(self) -> Eigen.MatrixXd:
            pass
        @overload
        def cell0_ds_coordinates(self, cell0_ds: List[int]) -> Eigen.MatrixXd:
            pass
        def cell0_d_is_active(self, cell0_d_index: int) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return if the cell0D is active
            """
            pass
        #/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
        #/ \return the cell0D marker
        def cell0_d_marker(self, cell0_d_index: int) -> int:
            pass
        def cell0_ds_marker(self) -> List[int]:
            pass
        def cell0_d_has_updated_cell0_ds(self, cell0_d_index: int) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return if the cell0D has new cell0Ds associated
            """
            pass
        def cell0_d_number_updated_cell0_ds(self, cell0_d_index: int) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the number of new cell0Ds associated to cell0DIndex
            """
            pass
        def cell0_d_has_updated_cell0_d(
            self,
            cell0_d_index: int,
            updated_cell0_d_idex: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param updatedCell0DIdex the index of the new cell0D from 0 to Cell0DTotalNumber()
            / \return if the cell0D has the updatedCell0DIdex associated
            """
            pass
        def cell0_d_insert_updated_cell0_d(
            self,
            cell0_d_index: int,
            updated_cell0_d_idex: int
            ) -> None:
            """/ \brief Add the new Cell0D to an existing Cell0D
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param updatedCell0DIdex the index of the new cell0D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell0_d_updated_cell0_ds(
            self,
            cell0_d_index: int,
            updated_cell0_d_ids: std.list[int]
            ) -> bool:
            """/ \brief return the updated Cell0D Ids for cell0DIndex
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param updatedCell0DIds the list of the new Cell0D Ids associated to cell0DIndex
            / \return True if the cell0DIndex is contained in the updatedCell0DIds list, False otherwise
            """
            pass

        def cell0_ds_neighbour_cell1_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell1_ds(
            self,
            numbers_neighbour_cell1_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell0Ds Cell1D neighbours number
            / \param numbersNeighbourCell1Ds the number of Cell1D neighbours of each Cell0D, size 1 x Cell0DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell0D Cell1D neighbours number
        #/ \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
        #/ \param numberNeighbourCell1Ds the number of Cell1D neighbours of the Cell0D
        @overload
        def cell0_d_initialize_neighbour_cell1_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell1_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell1_ds(
            self,
            cell0_d_index: int,
            neighbour_cell1_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell1_d_index: int
            ) -> None:
            """/ \brief Insert the Cell0D Cell1D neighbour
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell1D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell1D(cell0DIndex) \param neigbourCell1DIndex the Cell1D neighbour index from 0 to
            / Cell1DTotalNumber() \note Cell0DInitializeNeighbourCell1Ds() shall be called before
            """
            pass
        def cell0_d_number_neighbour_cell1_d(self, cell0_d_index: int) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the number of Neighbour Cell1Ds of Cell0D
            """
            pass
        def cell0_d_neighbour_cell1_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell1D from 0 to Cell0DNumberNeighbourCell1D(cell0DIndex)
            / \return the Cell1D index of Neighbour Cell1Ds of Cell0D from 0 to Cell1DTotalNumber()
            """
            pass

        def cell0_d_neighbour_cell1_ds(self, cell0_d_index: int) -> List[int]:
            pass

        def cell0_d_has_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell1D from 0 to Cell0DNumberNeighbourCell1D(cell0DIndex)
            / \return True if Neighbour Cell1Ds of Cell0D at position neighbourIndex exists
            """
            pass

        def cell0_d_reset_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell0D Cell1D neighbour to empty value (Cell0DHasNeighbourCell1D is False)
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell1D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell1D(cell0DIndex)
            """
            pass

        def cell0_ds_neighbour_cell2_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell2_ds(
            self,
            numbers_neighbour_cell2_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell0Ds Cell2D neighbours number
            / \param numbersNeighbourCell2Ds the number of Cell2D neighbours of each Cell0D, size 1 x Cell0DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell0D Cell2D neighbours number
        #/ \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
        #/ \param numberNeighbourCell2Ds the number of Cell2D neighbours of the Cell0D
        @overload
        def cell0_d_initialize_neighbour_cell2_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell2_ds(
            self,
            cell0_d_index: int,
            neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell2_d_index: int
            ) -> None:
            """/ \brief Insert the Cell0D Cell2D neighbour
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell2D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell2D(cell0DIndex) \param neigbourCell2DIndex the Cell2D neighbour index from 0 to
            / Cell2DTotalNumber() \note Cell0DInitializeNeighbourCell2Ds() shall be called before
            """
            pass
        def cell0_d_number_neighbour_cell2_d(self, cell0_d_index: int) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the number of Neighbour Cell2Ds of Cell0D
            """
            pass
        def cell0_d_neighbour_cell2_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell2D from 0 to Cell0DNumberNeighbourCell2D(cell0DIndex)
            / \return the Cell2D index of Neighbour Cell2Ds of Cell0D from 0 to Cell2DTotalNumber()
            """
            pass

        def cell0_d_neighbour_cell2_ds(self, cell0_d_index: int) -> List[int]:
            pass

        def cell0_d_has_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell2D from 0 to Cell0DNumberNeighbourCell2D(cell0DIndex)
            / \return True if Neighbour Cell2Ds of Cell0D at position neighbourIndex exists
            """
            pass
        def cell0_d_reset_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell0D Cell2D neighbour to empty value (Cell0DHasNeighbourCell2D is False)
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell2D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell2D(cell0DIndex)
            """
            pass

        def cell0_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell3_ds(
            self,
            numbers_neighbour_cell3_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell0Ds Cell3D neighbours number
            / \param numbersNeighbourCell3Ds the number of Cell3D neighbours of each Cell0D, size 1 x Cell0DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell0D Cell3D neighbours number
        #/ \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
        #/ \param numberNeighbourCell3Ds the number of Cell3D neighbours of the Cell0D
        @overload
        def cell0_d_initialize_neighbour_cell3_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell3_ds(
            self,
            cell0_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            """/ \brief Insert the Cell0D Cell3D neighbour
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell3D(cell0DIndex) \param neigbourCell3DIndex the Cell3D neighbour index from 0 to
            / Cell3DTotalNumber() \note Cell0DInitializeNeighbourCell3Ds() shall be called before
            """
            pass
        def cell0_d_number_neighbour_cell3_d(self, cell0_d_index: int) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the number of Neighbour Cell3Ds of Cell0D
            """
            pass
        #/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
        #/ \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell0DNumberNeighbourCell3D(cell0DIndex)
        #/ \return the Cell3D index of Neighbour Cell3Ds of Cell0D from 0 to Cell3DTotalNumber()
        def cell0_d_neighbour_cell3_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            pass
        def cell0_d_neighbour_cell3_ds(self, cell0_d_index: int) -> List[int]:
            pass
        def cell0_d_has_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell0DNumberNeighbourCell3D(cell0DIndex)
            / \return True if Neighbour Cell3Ds of Cell0D at position neighbourIndex exists
            """
            pass
        def cell0_d_reset_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell0D Cell3D neighbour to empty value (Cell0DHasNeighbourCell3D is False)
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell3D(cell0DIndex)
            """
            pass

        def cell0_d_initialize_double_properties(self, number_double_properties: int) -> None:
            """/ \brief Initialize the Cell0Ds double properties
            / \param numberDoubleProperties the total number of Cell0Ds properties
            / \note No reset of Cell0Ds is performed
            """
            pass
        def cell0_d_add_double_property(self, property_id: str) -> int:
            """/ \brief Add the Cell0Ds double property identified by id
            / \param propertyId the id of Cell0Ds property
            / \return the double property position
            """
            pass
        def cell0_ds_initialize_double_property_values(
            self,
            property_index: int,
            porperty_sizes: List[int]
            ) -> None:
            """/ \brief Initialize the Cell0Ds double property sizes
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            / \param porpertySize the double property size of each Cell0D, size 1 x Cell0DTotalNumber()
            """
            pass
        def cell0_d_initialize_double_property_values(
            self,
            cell0_d_index: int,
            property_index: int,
            porperty_size: int
            ) -> None:
            """/ \brief Initialize the Cell0Ds double property size
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            / \param porpertySize the double property size of Cell0D
            """
            pass
        def cell0_d_insert_double_property_value(
            self,
            cell0_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            """/ \brief Insert the Cell0Ds double property value at position
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            """
            pass

        def cell0_d_number_double_properties(self) -> int:
            """/ \return the total number of double properties of Cell0Ds"""
            pass
        def cell0_d_double_property_id(self, property_index: int) -> str:
            """/ \return the id of the double property of Cell0Ds
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            """
            pass
        def cell0_d_double_property_exists(self, property_id: str) -> bool:
            """/ \return True if the double propertyId of Cell0Ds exists
            / \param propertyId the id of Cell0D double property
            """
            pass
        def cell0_d_double_property_index(self, property_id: str) -> int:
            """/ \return the propertyIndex of the double property of Cell0Ds from 0 to Cell0DNumberProperties()
            / \param propertyId the id of Cell0D double property
            """
            pass
        def cell0_d_double_property_size(self, cell0_d_index: int, property_index: int) -> int:
            """/ \return the size of the double property of Cell0D
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            """
            pass
        def cell0_d_double_property_value(
            self,
            cell0_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            """/ \return the value of the double property at valueIndex of Cell0D
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            / \param propertyValueIndex the index of Cell0D double property value from 0 to Cell0DDoublePropertySize()
            """
            pass

        def cell1_ds_initialize(self, number_cell1_ds: int) -> None:
            """/ \brief Initialize the Cell1Ds container
            / \param numberCell1Ds the total number of Cell1Ds
            / \note No reset of Cell1Ds is performed
            """
            pass
        def cell1_d_append(self, number_cell1_ds: int) -> int:
            """/ \brief Append Cell1Ds to the Cell1Ds container
            / \param numberCell1Ds the number of Cell1Ds to append
            / \return the previous number of Cell1Ds before the append operation
            """
            pass
        def cell1_d_remove(self, cell1_d_index: int) -> None:
            """/ \brief Remove the Cell1D from the mesh
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \note the cell1D is removed and no integrity check in the mesh are performed
            """
            pass
        def cell1_d_insert_extremes(
            self,
            cell1_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> None:
            """/ \brief Set the Cell1D Origin and End
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param originCell0DIndex the Cell0D index of Cell1D origin from 0 to Cell0DTotalNumber()
            / \param endCell0DIndex the Cell0D index of Cell1D end from 0 to Cell0DTotalNumber()
            """
            pass

        def cell1_ds_insert_extremes(self, cell1_d_extremes: Eigen.MatrixXi) -> None:
            """/ \brief Set the Cell1D Extremes for the whole mesh edges
            / \param cell1DExtremes the origin and end indices of all the edges, size 2 x Cell1DTotalNumber()
            """
            pass

        @overload
        def cell1_ds_extremes(self) -> Eigen.MatrixXi:
            """/ \return the extrems as Eigen MatrixXi of cell1Ds, size 2xCell1DTotalNumber()"""
            pass
        #/ \return the extrems as Eigen MatrixXi of cell1D, size 2
        #/ \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
        def cell1_d_extremes(self, cell1_d_index: int) -> Eigen.VectorXi:
            pass
        @overload
        def cell1_ds_extremes(self, cell1_ds: List[int]) -> Eigen.MatrixXi:
            pass
        def cell1_d_by_extremes(
            self,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            """/ \return the Cell1D Index if Cell1D (origin->end) exists, Cell1DTotalNumber() otherwise
            / \param originCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \param endCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            """
            pass
        def cell1_d_set_marker(self, cell1_d_index: int, marker: int) -> None:
            """/ \brief Set the Cell1D Marker
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param marker the marker of the Cell1D
            """
            pass
        def cell1_d_set_state(self, cell1_d_index: int, state: bool) -> None:
            """/ \brief Set the Cell1D state
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param state True if Cell1D is active, False otherwise
            """
            pass
        def cell1_d_total_number(self) -> int:
            """/ \return the total number of Cell1Ds"""
            pass
        def cell1_d_vertex(self, cell1_d_index: int, vertex_index: int) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param vertexIndex the index of the vertex from 0 to 2
            / \return Cell0D index of the vertex of Cell1D
            """
            pass
        def cell1_d_coordinates(self, cell1_d_index: int) -> Eigen.MatrixXd:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the coordinates of Cell1D, size 3x2
            """
            pass
        def cell1_d_origin_coordinates(self, cell1_d_index: int) -> Eigen.Vector3d:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the origin coordinates of Cell1D
            """
            pass
        def cell1_d_end_coordinates(self, cell1_d_index: int) -> Eigen.Vector3d:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the end coordinates of Cell1D
            """
            pass
        def cell1_d_origin(self, cell1_d_index: int) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the origin Cell0D index of Cell1D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell1_d_end(self, cell1_d_index: int) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the end Cell0D index of Cell1D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell1_d_find_extreme(self, cell1_d_index: int, cell0_d_index: int) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the index of the cell0DIndex on the cell1D from 0 to 1, 2 if not found
            """
            pass
        #/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
        #/ \return the cell1D marker
        def cell1_d_marker(self, cell1_d_index: int) -> int:
            pass
        def cell1_ds_marker(self) -> List[int]:
            pass
        def cell1_d_is_active(self, cell1_d_index: int) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return if the cell1D is active
            """
            pass

        def cell1_d_has_original_cell1_d(self, updated_cell1_d_index: int) -> bool:
            """/ \param updatedCell1DIndex the updated cell1D index, from 0 to Cell1DTotalNumber()
            / \return True if has an original cell, False otherwise (the original cell is itself)
            """
            pass
        def cell1_d_original_cell1_d(self, updated_cell1_d_index: int) -> int:
            """/ \param updatedCell1DIndex the updated cell1D index, from 0 to Cell1DTotalNumber()
            / \return the original cell1D index, from 0 to Cell1DTotalNumber()
            """
            pass
        def cell1_d_has_updated_cell1_ds(self, cell1_d_index: int) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return if the cell1D has new cell1Ds associated
            """
            pass
        def cell1_d_number_updated_cell1_ds(self, cell1_d_index: int) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the number of new cell1Ds associated to cell1DIndex
            """
            pass
        def cell1_d_has_updated_cell1_d(
            self,
            cell1_d_index: int,
            updated_cell1_d_idex: int
            ) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param updatedCell1DIdex the index of the new Cell1D from 0 to Cell1DTotalNumber()
            / \return if the Cell1D has the updatedCell1DIdex associated
            """
            pass
        def cell1_d_insert_updated_cell1_d(
            self,
            cell1_d_index: int,
            updated_cell1_d_idex: int
            ) -> None:
            """/ \brief Add the new Cell1D to an existing Cell1D
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param updatedCell1DIdex the index of the new Cell1D from 0 to Cell1DTotalNumber()
            """
            pass
        def cell1_d_updated_cell1_ds(
            self,
            cell1_d_index: int,
            updated_cell1_d_ids: std.list[int]
            ) -> bool:
            """/ \brief return the updated Cell1D Ids for cell1DIndex
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param updatedCell1DIds the list of the new Cell1D Ids associated to cell1DIndex
            / \return True if the cell1DIndex is contained in the updatedCell1DIds list, False otherwise
            """
            pass

        def cell1_ds_neighbour_cell2_ds(self) -> List[List[int]]:
            pass
        @overload
        def cell1_ds_initialize_neighbour_cell2_ds(
            self,
            numbers_neighbour_cell2_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell1Ds Cell2D neighbours number
            / \param numbersNeighbourCell2Ds the number of Cell2D neighbours of each Cell1D, size 1 x Cell1DTotalNumber()
            """
            pass
        @overload
        def cell1_ds_initialize_neighbour_cell2_ds(
            self,
            number_neighbour_cell2_ds: int
            ) -> None:
            """/ \brief Initialize the Cell1Ds Cell2D neighbours number
            / \param numberNeighbourCell2Ds the number of Cell2D neighbours of the Cell1D
            """
            pass

        #/ \brief Initialize the Cell1D Cell2D neighbours number
        #/ \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
        #/ \param numberNeighbourCell2Ds the number of Cell2D neighbours of the Cell1D
        @overload
        def cell1_d_initialize_neighbour_cell2_ds(
            self,
            cell1_d_index: int,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell2_ds(
            self,
            cell1_d_index: int,
            neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        def cell1_d_insert_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int,
            neigbour_cell2_d_index: int
            ) -> None:
            """/ \brief Insert the Cell1D Cell2D neighbour
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of Cell2D neighbour of the Cell1D from 0 to
            / Cell1DNumberNeighbourCell2D(cell1DIndex) \param neigbourCell2DIndex the Cell2D neighbour index from 0 to
            / Cell2DTotalNumber() \note Cell1DInitializeNeighbourCell2Ds() shall be called before
            """
            pass
        def cell1_d_number_neighbour_cell2_d(self, cell1_d_index: int) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the number of Neighbour Cell2Ds of Cell1D
            """
            pass
        def cell1_d_neighbour_cell2_d(self, cell1_d_index: int, neighbour_index: int) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell2D from 0 to Cell1DNumberNeighbourCell2D(cell1DIndex)
            / \return the Cell2D index of Neighbour Cell2Ds of Cell1D from 0 to Cell2DTotalNumber()
            """
            pass

        def cell1_d_neighbour_cell2_ds(self, cell1_d_index: int) -> List[int]:
            pass

        def cell1_d_has_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell2D from 0 to Cell1DNumberNeighbourCell2D(cell1DIndex)
            / \return True if Neighbour Cell2Ds of Cell1D at position neighbourIndex exists
            """
            pass
        def cell1_d_reset_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell1D Cell2D neighbour to empty value (Cell1DHasNeighbourCell2D is False)
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of Cell2D neighbour of the Cell1D from 0 to
            / Cell1DNumberNeighbourCell2D(cell1DIndex)
            """
            pass

        def cell1_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell1_ds_initialize_neighbour_cell3_ds(
            self,
            numbers_neighbour_cell3_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell1Ds Cell3D neighbours number
            / \param numbersNeighbourCell3Ds the number of Cell2D neighbours of each Cell1D, size 1 x Cell1DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell1D Cell3D neighbours number
        #/ \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
        #/ \param numberNeighbourCell3Ds the number of Cell3D neighbours of the Cell1D
        @overload
        def cell1_d_initialize_neighbour_cell3_ds(
            self,
            cell1_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell3_ds(
            self,
            cell1_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell1_d_insert_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            """/ \brief Insert the Cell1D Cell3D neighbour
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell1D from 0 to
            / Cell1DNumberNeighbourCell3D(cell1DIndex) \param neigbourCell3DIndex the Cell3D neighbour index from 0 to
            / Cell3DTotalNumber() \note Cell1DInitializeNeighbourCell3Ds() shall be called before
            """
            pass
        def cell1_d_number_neighbour_cell3_d(self, cell1_d_index: int) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the number of Neighbour Cell3Ds of Cell1D
            """
            pass
        #/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
        #/ \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell1DNumberNeighbourCell3D(cell1DIndex)
        #/ \return the Cell3D index of Neighbour Cell3Ds of Cell1D from 0 to Cell3DTotalNumber()
        def cell1_d_neighbour_cell3_d(self, cell1_d_index: int, neighbour_index: int) -> int:
            pass
        def cell1_d_neighbour_cell3_ds(self, cell1_d_index: int) -> List[int]:
            pass
        def cell1_d_has_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell1DNumberNeighbourCell3D(cell1DIndex)
            / \return True if Neighbour Cell3Ds of Cell1D at position neighbourIndex exists
            """
            pass
        def cell1_d_reset_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell1D Cell3D neighbour to empty value (Cell1DHasNeighbourCell3D is False)
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell1D from 0 to
            / Cell1DNumberNeighbourCell3D(cell1DIndex)
            """
            pass

        def cell1_d_initialize_double_properties(self, number_double_properties: int) -> None:
            """/ \brief Initialize the Cell1Ds double properties
            / \param numberDoubleProperties the total number of Cell1Ds properties
            / \note No reset of Cell1Ds is performed
            """
            pass
        def cell1_d_add_double_property(self, property_id: str) -> int:
            """/ \brief Add the Cell1Ds double property identified by id
            / \param propertyId the id of Cell1Ds property
            / \return the double property position
            """
            pass
        def cell1_ds_initialize_double_property_values(
            self,
            property_index: int,
            porperty_sizes: List[int]
            ) -> None:
            """/ \brief Initialize the Cell1Ds double property sizes
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            / \param porpertySize the double property size of each Cell1D, size 1 x Cell1DTotalNumber()
            """
            pass
        def cell1_d_initialize_double_property_values(
            self,
            cell1_d_index: int,
            property_index: int,
            porperty_size: int
            ) -> None:
            """/ \brief Initialize the Cell1Ds double property size
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            / \param porpertySize the double property size of Cell1D
            """
            pass
        def cell1_d_insert_double_property_value(
            self,
            cell1_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            """/ \brief Insert the Cell1Ds double property value at position
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            """
            pass

        def cell1_d_number_double_properties(self) -> int:
            """/ \return the total number of double properties of Cell1Ds"""
            pass
        def cell1_d_double_property_id(self, property_index: int) -> str:
            """/ \return the id of the double property of Cell1Ds
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            """
            pass
        def cell1_d_double_property_exists(self, property_id: str) -> bool:
            """/ \return True if the double propertyId of Cell1Ds exists
            / \param propertyId the id of Cell1D double property
            """
            pass
        def cell1_d_double_property_index(self, property_id: str) -> int:
            """/ \return the propertyIndex of the double property of Cell1Ds from 0 to Cell1DNumberProperties()
            / \param propertyId the id of Cell1D double property
            """
            pass
        def cell1_d_double_property_size(self, cell1_d_index: int, property_index: int) -> int:
            """/ \return the size of the double property of Cell1D
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            """
            pass
        def cell1_d_double_property_value(
            self,
            cell1_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            """/ \return the value of the double property at valueIndex of Cell1D
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            / \param propertyValueIndex the index of Cell1D double property value from 0 to Cell1DDoublePropertySize()
            """
            pass

        def cell2_ds_initialize(self, number_cell2_ds: int) -> None:
            """/ \brief Initialize the Cell2Ds container
            / \param numberCell2Ds the total number of Cell2Ds
            / \note No reset of Cell2Ds is performed
            """
            pass
        def cell2_d_append(self, number_cell2_ds: int) -> int:
            """/ \brief Append Cell2Ds to the Cell2Ds container
            / \param numberCell2Ds the number of Cell2Ds to append
            / \return the previous number of Cell2Ds before the append operation
            """
            pass
        def cell2_d_remove(self, cell2_d_index: int) -> None:
            """/ \brief Remove the Cell2D from the mesh
            / \param cell2DIndex the index of Cell0D from 0 to Cell2DTotalNumber()
            / \note the cell2D is removed and no integrity check in the mesh are performed
            """
            pass
        @overload
        def cell2_ds_initialize_vertices(self, number_cell2_d_vertices: int) -> None:
            """/ \brief Initialize the Cell2Ds vertices number
            / \param numberCell2DVertices the number of vertices of all Cell2Ds
            """
            pass
        @overload
        def cell2_ds_initialize_vertices(self, number_cell2_ds_vertices: List[int]) -> None:
            """/ \brief Initialize the Cell2Ds vertices number
            / \param numberCell2DsVertices the number of vertices of each Cell2D
            """
            pass
        def cell2_d_initialize_vertices(
            self,
            cell2_d_index: int,
            number_cell2_d_vertices: int
            ) -> None:
            """/ \brief Initialize the Cell2D vertices  number
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param numberCell2DVertices the number of vertices of Cell2D
            """
            pass
        @overload
        def cell2_ds_initialize_edges(self, number_cell2_d_edges: int) -> None:
            """/ \brief Initialize the Cell2Ds edges number
            / \param numberCell2DEdges the number of edges of all Cell2Ds
            """
            pass
        @overload
        def cell2_ds_initialize_edges(self, number_cell2_ds_edges: List[int]) -> None:
            """/ \brief Initialize the Cell2Ds edges number
            / \param numberCell2DsEdges the number of edges of each Cell2D
            """
            pass
        def cell2_d_initialize_edges(
            self,
            cell2_d_index: int,
            number_cell2_d_edges: int
            ) -> None:
            """/ \brief Initialize the Cell2D edges number
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param numberCell2DEdges the number of edges of Cell2D
            """
            pass
        def cell2_d_insert_vertices(
            self,
            cell2_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Insert the Cell2D vertex
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param verticesCell0DIndices the Cell0D vertices index from 0 to Cell0DTotalNumber()
            / \note Cell2DInitializeVertices() should be called before using this method
            """
            pass
        def cell2_d_insert_vertex(
            self,
            cell2_d_index: int,
            vertex_index: int,
            vertex_cell0_d_index: int
            ) -> None:
            """/ \brief Insert the Cell2D vertex
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param vertexIndex the number of vertex of the Cell2D from 0 to Cell2DNumberVertices(cell2DIndex)
            / \param vertexCell0DIndex the Cell0D vertex index from 0 to Cell0DTotalNumber()
            / \note Cell2DInitializeVertices() should be called before using this method
            """
            pass
        def cell2_d_add_vertices(
            self,
            cell2_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell2D vertices
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param vertexCell0DIndices the Cell0D vertices indices from 0 to Cell0DTotalNumber()
            / \note No itialization is necessary
            """
            pass
        def cell2_d_insert_edges(
            self,
            cell2_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            """/ \brief Insert the Cell2D edge
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param edgesCell1DIndices the Cell1D edges indices from 0 to Cell1DTotalNumber()
            / \note Cell2DInitializeEdges() should be called before using this method
            """
            pass
        def cell2_d_insert_edge(
            self,
            cell2_d_index: int,
            edge_index: int,
            edge_cell1_d_index: int
            ) -> None:
            """/ \brief Insert the Cell2D edge
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param edgeIndex the number of edge of the Cell2D from 0 to Cell2DNumberEdges(cell2DIndex)
            / \param edgeCell0DIndex the Cell1D edge index from 0 to Cell1DTotalNumber()
            / \note Cell2DInitializeEdges() should be called before using this method
            """
            pass
        def cell2_d_add_edges(
            self,
            cell2_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell2D edges
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param edgesCell1DIndices the Cell1D edges indices from 0 to Cell1DTotalNumber()
            / \note No itialization is necessary
            """
            pass

        def cell2_d_add_vertices_and_edges(
            self,
            cell2_d_index: int,
            vertices_and_edges_indices: Eigen.MatrixXi
            ) -> None:
            """/ \brief Cell2D Add Vertices And Edges
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param verticesAndEdgesIndices the matrix of Cell0Ds and Cell1Ds indices
            / \note No itialization is necessary
            """
            pass

        def cell2_d_set_marker(self, cell2_d_index: int, marker: int) -> None:
            """/ \brief Set the Cell2D Marker
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param marker the marker of the Cell2D
            """
            pass
        def cell2_d_set_state(self, cell2_d_index: int, state: bool) -> None:
            """/ \brief Set the Cell1D state
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param state True if Cell1D is active, False otherwise
            """
            pass
        def cell2_d_total_number(self) -> int:
            """/ \return the total number of Cell2Ds"""
            pass
        def cell2_d_number_vertices(self, cell2_d_index: int) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the number of vertices of Cell2D
            """
            pass
        def cell2_d_number_edges(self, cell2_d_index: int) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the number of edges of Cell2D
            """
            pass
        def cell2_ds_vertices(self) -> List[List[int]]:
            """/ \return the Cell0D index collections of all Cell2Ds, size Cell2DTotalNumber() x
            / Cell2DNumberVertices(cell2DIndex)
            """
            pass
        def cell2_ds_extremes(self) -> List[Eigen.MatrixXi]:
            """/ \return the Cell0Ds and Cell1Ds index collections of all Cell2Ds, size Cell2DTotalNumber() x (2 x
            / Cell2DNumberVertices(cell2DIndex))
            """
            pass
        def cell2_d_vertices(self, cell2_d_index: int) -> List[int]:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the Cell0D index collections of Cell2D from 0 to Cell0DTotalNumber(), size
            / Cell2DNumberVertices(cell2DIndex)
            """
            pass
        def cell2_d_vertex(self, cell2_d_index: int, vertex_index: int) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param vertexIndex the index of cell0D vertex from 0 to NumberCell2DVertices(cell2DIndex)
            / \return the Cell0D index of vertex of Cell2D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell2_d_vertex_coordinates(
            self,
            cell2_d_index: int,
            vertex_index: int
            ) -> Eigen.Vector3d:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param vertexIndex the index of cell0D vertex from 0 to NumberCell2DVertices(cell2DIndex)
            / \return the Cell0D coordinates of vertex of Cell2D, size 3 x 1
            """
            pass
        def cell2_d_vertices_coordinates(self, cell2_d_index: int) -> Eigen.MatrixXd:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the Cell0D coordinates of all the vertices of Cell2D, size 3 x NumberCell2DVertices(cell2DIndex)
            """
            pass
        def cell2_d_find_vertex(self, cell2_d_index: int, cell0_d_index: int) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the index of the cell0DIndex on the cell2D from 0 to NumberCell2DVertices(cell2DIndex),
            / NumberCell2DVertices(cell2DIndex) if not found
            """
            pass
        def cell2_d_edges(self, cell2_d_index: int) -> List[int]:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the Cell1D index collections of Cell2D from 0 to Cell1DTotalNumber(), size
            / Cell2DNumberEdges(cell2DIndex)
            """
            pass
        def cell2_d_edge(self, cell2_d_index: int, edge_index: int) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param edgeIndex the index of cell1D edge from 0 to NumberCell2DEdges(cell2DIndex)
            / \return the Cell1D index of edge of Cell2D from 0 to Cell1DTotalNumber()
            """
            pass
        def cell2_d_find_edge(self, cell2_d_index: int, cell1_d_index: int) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the index of the cell1DIndex on the cell2D from 0 to NumberCell2DEdges(cell2DIndex),
            / NumberCell2DEdges(cell2DIndex) if not found
            """
            pass
        def cell2_d_find_edge_by_extremes(
            self,
            cell2_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param originCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \param endCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \return the index of the cell1DIndex on the cell2D from 0 to NumberCell2DEdges(cell2DIndex),
            / NumberCell2DEdges(cell2DIndex) otherwise
            """
            pass
        #/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
        #/ \return the cell2D marker
        def cell2_d_marker(self, cell2_d_index: int) -> int:
            pass
        def cell2_ds_marker(self) -> List[int]:
            pass
        def cell2_d_is_active(self, cell2_d_index: int) -> bool:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return if the cell2D is active
            """
            pass

        def cell2_d_has_updated_cell2_ds(self, cell2_d_index: int) -> bool:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return if the cell2D has new cell2Ds associated
            """
            pass
        def cell2_d_number_updated_cell2_ds(self, cell2_d_index: int) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the number of new cell2Ds associated to cell2DIndex
            """
            pass
        def cell2_d_has_updated_cell2_d(
            self,
            cell2_d_index: int,
            updated_cell2_d_index: int
            ) -> bool:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param updatedCell2DIndex the index of the new Cell2D from 0 to Cell2DTotalNumber()
            / \return if the Cell2D has the updatedCell2DIdex associated
            """
            pass
        def cell2_d_insert_updated_cell2_d(
            self,
            cell2_d_index: int,
            updated_cell2_d_idex: int
            ) -> None:
            """/ \brief Add the new Cell2D to an existing Cell2D
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param updatedCell2DIdex the index of the new Cell2D from 0 to Cell2DTotalNumber()
            """
            pass

        def cell2_d_has_original_cell2_d(self, updated_cell2_d_index: int) -> bool:
            """/ \param updatedCell2DIndex the updated cell2D index, from 0 to Cell2DTotalNumber()
            / \return True if has an original cell, False otherwise (the original cell is itself)
            """
            pass
        def cell2_d_original_cell2_d(self, updated_cell2_d_index: int) -> int:
            """/ \param updatedCell2DIndex the updated cell2D index, from 0 to Cell2DTotalNumber()
            / \return the original cell2D index, from 0 to Cell2DTotalNumber()
            """
            pass
        def cell2_d_updated_cell2_ds(
            self,
            cell2_d_index: int,
            updated_cell2_d_ids: std.list[int]
            ) -> bool:
            """/ \brief return the updated Cell2D Ids for cell2DIndex
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param updatedCell2DIds the list of the new Cell2D Ids associated to cell2DIndex
            / \return True if the cell2DIndex is contained in the updatedCell2DIds list, False otherwise
            """
            pass

        def cell2_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell2_ds_initialize_neighbour_cell3_ds(
            self,
            numbers_neighbour_cell3_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell2Ds Cell3D neighbours number
            / \param numbersNeighbourCell3Ds the number of Cell3D neighbours of each Cell2D, size 1 x Cell2DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell2D Cell3D neighbours number
        #/ \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
        #/ \param numberNeighbourCell3Ds the number of Cell3D neighbours of the Cell2D
        @overload
        def cell2_d_initialize_neighbour_cell3_ds(
            self,
            cell2_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell2_d_initialize_neighbour_cell3_ds(
            self,
            cell2_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell2_d_insert_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            """/ \brief Insert the Cell2D Cell3D neighbour
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell2D from 0 to
            / Cell2DNumberNeighbourCell3D(cell2DIndex) \param neigbourCell3DIndex the Cell3D neighbour index from 0 to
            / Cell3DTotalNumber() \note Cell2DInitializeNeighbourCell3Ds() shall be called before
            """
            pass
        def cell2_d_number_neighbour_cell3_d(self, cell2_d_index: int) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the number of Neighbour Cell3Ds of Cell2D
            """
            pass
        #/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
        #/ \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell2DNumberNeighbourCell3D(cell2DIndex)
        #/ \return the Cell3D index of Neighbour Cell3Ds of Cell2D from 0 to Cell3DTotalNumber()
        def cell2_d_neighbour_cell3_d(self, cell2_d_index: int, neighbour_index: int) -> int:
            pass
        def cell2_d_neighbour_cell3_ds(self, cell2_d_index: int) -> List[int]:
            pass
        def cell2_d_has_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell2DNumberNeighbourCell3D(cell2DIndex)
            / \return True if Neighbour Cell3Ds of Cell2D at position neighbourIndex exists
            """
            pass
        def cell2_d_reset_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell2D Cell3D neighbour to empty value (Cell2DHasNeighbourCell3D is False)
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell2D from 0 to
            / Cell2DNumberNeighbourCell3D(cell2DIndex)
            """
            pass

        def cell2_d_initialize_double_properties(self, number_double_properties: int) -> None:
            """/ \brief Initialize the Cell2Ds double properties
            / \param numberDoubleProperties the total number of Cell2Ds properties
            / \note No reset of Cell2Ds is performed
            """
            pass
        def cell2_d_add_double_property(self, property_id: str) -> int:
            """/ \brief Add the Cell2Ds double property identified by id
            / \param propertyId the id of Cell2Ds property
            / \return the double property position
            """
            pass
        def cell2_ds_initialize_double_property_values(
            self,
            property_index: int,
            porperty_sizes: List[int]
            ) -> None:
            """/ \brief Initialize the Cell2Ds double property sizes
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            / \param porpertySize the double property size of each Cell2D, size 1 x Cell2DTotalNumber()
            """
            pass
        def cell2_d_initialize_double_property_values(
            self,
            cell2_d_index: int,
            property_index: int,
            porperty_size: int
            ) -> None:
            """/ \brief Initialize the Cell2Ds double property size
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            / \param porpertySize the double property size of Cell2D
            """
            pass
        def cell2_d_insert_double_property_value(
            self,
            cell2_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            """/ \brief Insert the Cell2Ds double property value at position
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            """
            pass

        def cell2_d_number_double_properties(self) -> int:
            """/ \return the total number of double properties of Cell2Ds"""
            pass
        def cell2_d_double_property_id(self, property_index: int) -> str:
            """/ \return the id of the double property of Cell2Ds
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            """
            pass
        def cell2_d_double_property_exists(self, property_id: str) -> bool:
            """/ \return True if the double propertyId of Cell2Ds exists
            / \param propertyId the id of Cell2D double property
            """
            pass
        def cell2_d_double_property_index(self, property_id: str) -> int:
            """/ \return the propertyIndex of the double property of Cell2Ds from 0 to Cell2DNumberProperties()
            / \param propertyId the id of Cell2D double property
            """
            pass
        def cell2_d_double_property_size(self, cell2_d_index: int, property_index: int) -> int:
            """/ \return the size of the double property of Cell2D
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            """
            pass
        def cell2_d_double_property_value(
            self,
            cell2_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            """/ \return the value of the double property at valueIndex of Cell2D
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            / \param propertyValueIndex the index of Cell2D double property value from 0 to Cell2DDoublePropertySize()
            """
            pass

        def cell2_ds_initialize_sub_division(self, number_sub_divisions: List[int]) -> None:
            """/ \brief Initialize the Cell2D subdivision number for each Cell2D
            / \param numberSubDivisions the number of sub-polygons for each Cell2D, size 1 x Cell2DTotalNumber()
            / \note each subdivision is a triangle, thus numberSubDivision shall be a multiple of 3
            """
            pass
        def cell2_d_initialize_sub_division(
            self,
            cell2_d_index: int,
            number_sub_division: int
            ) -> None:
            """/ \brief Initialize the Cell2D subdivision number
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param numberSubDivision the number of sub-polygons of the Cell2D
            / \note each subdivision is a triangle, thus numberSubDivision shall be a multiple of 3
            """
            pass
        def cell2_d_insert_sub_division(
            self,
            cell2_d_index: int,
            sub_division_index: int,
            cell2_d_vertex_index: int
            ) -> None:
            """/ \brief Insert the subDivision vertex index
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param subDivisionIndex the subDivision index, from 0 to Cell2DNumberSubDivision(cell2DIndex)
            / \param cell2DVertexIndex the Cell2D vertex index of the subDivision, from 0 to Cell0DTotalNumber()
            / \note each subdivision is a triangle
            """
            pass

        def cell2_d_number_sub_division(self, cell2_d_index: int) -> int:
            """/ \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \return the total number of vertices of sub-polygons contained in the subdivision, a multiple of 3
            / \note each subdivision is a triangle
            """
            pass

        def cell2_d_sub_division_cell0_d(
            self,
            cell2_d_index: int,
            sub_division_index: int
            ) -> int:
            """/ \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param subDivisionIndex the subDivision index, from 0 to Cell2DNumberSubDivision(cell2DIndex)
            / \return the Cell0D index of sub-polygons contained in the subdivision, from 0 to Cell0DTotalNumber()
            / \note each sub-division shall be a triangle
            """
            pass

        def cell3_ds_initialize(self, number_cell3_ds: int) -> None:
            """/ \brief Initialize the Cell3Ds container
            / \param numberCell3Ds the total number of Cell3Ds
            / \note No reset of Cell3Ds is performed
            """
            pass
        def cell3_d_append(self, number_cell3_ds: int) -> int:
            """/ \brief Append Cell3Ds to the Cell3Ds container
            / \param numberCell3Ds the number of Cell3Ds to append
            / \return the previous number of Cell3Ds before the append operation
            """
            pass
        def cell3_d_remove(self, cell3_d_index: int) -> None:
            """/ \brief Remove the Cell3D from the mesh
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \note the cell3D is removed and no integrity check in the mesh are performed
            """
            pass
        def cell3_ds_initialize_vertices(self, number_cell3_ds_vertices: List[int]) -> None:
            """/ \brief Initialize the Cell3Ds vertices number
            / \param numberCell3DsVertices the number of vertices of each Cell3D
            """
            pass
        def cell3_d_initialize_vertices(
            self,
            cell3_d_index: int,
            number_cell3_d_vertices: int
            ) -> None:
            """/ \brief Initialize the Cell3D vertices  number
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param numberCell3DVertices the number of vertices of Cell3D
            """
            pass
        def cell3_ds_initialize_edges(self, number_cell3_ds_edges: List[int]) -> None:
            """/ \brief Initialize the Cell3Ds edges number
            / \param numberCell3DsEdges the number of edges of each Cell3D
            """
            pass
        def cell3_d_initialize_edges(
            self,
            cell3_d_index: int,
            number_cell3_d_edges: int
            ) -> None:
            """/ \brief Initialize the Cell3D edges number
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param numberCell3DEdges the number of edges of Cell3D
            """
            pass
        def cell3_ds_initialize_faces(self, number_cell3_ds_faces: List[int]) -> None:
            """/ \brief Initialize the Cell3Ds faces number
            / \param numberCell3DsFaces the number of faces of each Cell3D
            """
            pass
        def cell3_d_initialize_faces(
            self,
            cell3_d_index: int,
            number_cell3_d_faces: int
            ) -> None:
            """/ \brief Initialize the Cell3D faces number
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param numberCell3DFaces the number of faces of Cell3D
            """
            pass
        def cell3_d_insert_vertex(
            self,
            cell3_d_index: int,
            vertex_index: int,
            vertex_cell0_d_index: int
            ) -> None:
            """/ \brief Insert the Cell3D vertex
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param vertexIndex the number of vertex of the Cell3D from 0 to Cell3DNumberVertices(cell3DIndex)
            / \param vertexCell0DIndex the Cell0D vertex index from 0 to Cell0DTotalNumber()
            / \note Cell3DInitializeVertices() should be called before using this method
            """
            pass
        def cell3_d_add_vertices(
            self,
            cell3_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell3D vertices
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param vertexCell0DIndices the Cell0D vertices indices from 0 to Cell0DTotalNumber()
            / \note No itialization is necessary
            """
            pass
        def cell3_d_insert_edge(
            self,
            cell3_d_index: int,
            edge_index: int,
            edge_cell1_d_index: int
            ) -> None:
            """/ \brief Insert the Cell3D edge
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param edgeIndex the number of edge of the Cell3D from 0 to Cell3DNumberEdges(cell3DIndex)
            / \param edgeCell0DIndex the Cell1D edge index from 0 to Cell1DTotalNumber()
            / \note Cell3DInitializeEdges() should be called before using this method
            """
            pass
        def cell3_d_add_edges(
            self,
            cell3_d_index: int,
            edges_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell3D edges
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param edgesCell0DIndices the Cell1D edges indices from 0 to Cell1DTotalNumber()
            / \note No itialization is necessary
            """
            pass
        def cell3_d_find_vertex(self, cell3_d_index: int, cell0_d_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the index of the cell0DIndex on the cell3D from 0 to NumberCell3DVertices(cell3DIndex),
            / NumberCell3DVertices(cell3DIndex) if not found
            """
            pass
        def cell3_d_find_edge(self, cell3_d_index: int, cell1_d_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the index of the cell1DIndex on the cell3D from 0 to NumberCell3DEdges(cell3DIndex),
            / NumberCell3DEdges(cell3DIndex) if not found
            """
            pass
        def cell3_d_find_face(self, cell3_d_index: int, cell2_d_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the index of the cell2DIndex on the cell3D from 0 to NumberCell3DFaces(cell3DIndex),
            / NumberCell3DFaces(cell3DIndex) if not found
            """
            pass

        def cell3_d_find_edge_by_extremes(
            self,
            cell3_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param originCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \param endCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \return the index of the cell1DIndex on the cell2D from 0 to NumberCell2DEdges(cell3DIndex),
            / NumberCell2DEdges(cell2DIndex) otherwise
            """
            pass
        def cell3_d_insert_face(
            self,
            cell3_d_index: int,
            face_index: int,
            face_cell2_d_index: int
            ) -> None:
            """/ \brief Insert the Cell3D face
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param faceIndex the number of face of the Cell3D from 0 to Cell3DNumberFaces(cell3DIndex)
            / \param faceCell0DIndex the Cell2D face index from 0 to Cell2DTotalNumber()
            / \note Cell3DInitializeFaces() should be called before using this method
            """
            pass
        def cell3_d_add_faces(
            self,
            cell3_d_index: int,
            faces_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell3D faces
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param facesCell0DIndices the Cell2D faces indices from 0 to Cell2DTotalNumber()
            / \note No itialization is necessary
            """
            pass
        def cell3_d_set_marker(self, cell3_d_index: int, marker: int) -> None:
            """/ \brief Set the Cell1D Marker
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param marker the marker of the Cell3D
            """
            pass
        def cell3_d_set_state(self, cell3_d_index: int, state: bool) -> None:
            """/ \brief Set the Cell3D state
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param state True if Cell3D is active, False otherwise
            """
            pass
        def cell3_d_total_number(self) -> int:
            """/ \return the total number of Cell3Ds"""
            pass
        def cell3_d_number_vertices(self, cell3_d_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the number of vertices of Cell3D
            """
            pass
        def cell3_d_number_edges(self, cell3_d_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the number of edges of Cell3D
            """
            pass
        def cell3_d_number_faces(self, cell3_d_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the number of faces of Cell3D
            """
            pass
        def cell3_d_vertices(self, cell3_d_index: int) -> List[int]:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the Cell0D index collections of Cell3D from 0 to Cell0DTotalNumber(), size
            / Cell3DNumberVertices(cell3DIndex)
            """
            pass
        def cell3_d_vertex(self, cell3_d_index: int, vertex_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param vertexIndex the index of cell0D vertex from 0 to NumberCell3DVertices(cell3DIndex)
            / \return the Cell0D index of vertex of Cell3D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell3_d_vertex_coordinates(
            self,
            cell3_d_index: int,
            vertex_index: int
            ) -> Eigen.Vector3d:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param vertexIndex the index of cell0D vertex from 0 to NumberCell3DVertices(cell3DIndex)
            / \return the Cell0D coordinates of vertex of Cell3D, size 3 x 1
            """
            pass
        def cell3_d_vertices_coordinates(self, cell3_d_index: int) -> Eigen.MatrixXd:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the Cell0D coordinates of all the vertices of Cell3D, size 3 x NumberCell3DVertices(cell3DIndex)
            """
            pass

        def cell3_d_edges(self, cell3_d_index: int) -> List[int]:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the Cell1D index collections of Cell3D from 0 to Cell1DTotalNumber(), size
            / Cell3DNumberEdges(cell3DIndex)
            """
            pass

        def cell3_d_edge(self, cell3_d_index: int, edge_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param edgeIndex the index of cell1D edge from 0 to NumberCell3DEdges(edgeIndex)
            / \return the Cell1D index of edge of Cell3D from 0 to Cell1DTotalNumber()
            """
            pass

        def cell3_d_faces(self, cell3_d_index: int) -> List[int]:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the Cell2D index collections of Cell3D from 0 to Cell2DTotalNumber(), size
            / Cell3DNumberFaces(cell3DIndex)
            """
            pass

        def cell3_ds_faces_vertices(self) -> List[List[List[int]]]:
            """/ \return the Cell0D index collections of all the faces of all Cell3Ds, size Cell3DTotalNumber() x
            / Cell3DNumberFaces(cell3DIndex) x Cell2DNumberVertices(cell2DIndex)
            """
            pass
        def cell3_ds_vertices(self) -> List[List[int]]:
            """/ \return the Cell0D index collections of all Cell3Ds, size Cell3DTotalNumber() x
            / Cell3DNumberVertices(cell3DIndex)
            """
            pass
        def cell3_ds_edges(self) -> List[List[int]]:
            """/ \return the Cell1D index collections of all Cell3Ds, size Cell3DTotalNumber() x Cell3DNumberEdges(cell3DIndex)"""
            pass
        def cell3_ds_faces(self) -> List[List[int]]:
            """/ \return the Cell2D index collections of all Cell3Ds, size Cell3DTotalNumber() x Cell3DNumberFaces(cell3DIndex)"""
            pass

        def cell3_d_face(self, cell3_d_index: int, face_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param faceIndex the index of cell2D face from 0 to NumberCell3DFaces(cell3DIndex)
            / \return the Cell2D index of face of Cell3D from 0 to Cell2DTotalNumber()
            """
            pass
        #/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
        #/ \return the cell3D marker
        def cell3_d_marker(self, cell3_d_index: int) -> int:
            pass
        def cell3_ds_marker(self) -> List[int]:
            pass
        def cell3_d_is_active(self, cell3_d_index: int) -> bool:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return if the cell3D is active
            """
            pass

        def cell3_d_has_original_cell3_d(self, updated_cell3_d_index: int) -> bool:
            """/ \param updatedCell3DIndex the updated cell3D index, from 0 to Cell3DTotalNumber()
            / \return True if has an original cell, False otherwise (the original cell is itself)
            """
            pass
        def cell3_d_original_cell3_d(self, updated_cell3_d_index: int) -> int:
            """/ \param updatedCell3DIndex the updated cell3D index, from 0 to Cell3DTotalNumber()
            / \return the original cell3D index, from 0 to Cell3DTotalNumber()
            """
            pass
        def cell3_d_has_updated_cell3_ds(self, cell3_d_index: int) -> bool:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return if the cell3D has new cell3Ds associated
            """
            pass
        def cell3_d_number_updated_cell3_ds(self, cell3_d_index: int) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the number of new cell3Ds associated to cell3DIndex
            """
            pass
        def cell3_d_has_updated_cell3_d(
            self,
            cell3_d_index: int,
            updated_cell3_d_idex: int
            ) -> bool:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param updatedCell3DIdex the index of the new Cell3D from 0 to Cell3DTotalNumber()
            / \return if the Cell3D has the updatedCell3DIdex associated
            """
            pass
        def cell3_d_insert_updated_cell3_d(
            self,
            cell3_d_index: int,
            updated_cell3_d_idex: int
            ) -> None:
            """/ \brief Add the new Cell3D to an existing Cell3D
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param updatedCell3DIdex the index of the new Cell3D from 0 to Cell3DTotalNumber()
            """
            pass
        def cell3_d_updated_cell3_ds(
            self,
            cell3_d_index: int,
            updated_cell3_d_ids: std.list[int]
            ) -> bool:
            """/ \brief return the updated Cell3D Ids for cell3DIndex
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param updatedCell3DIds the list of the new Cell3D Ids associated to cell3DIndex
            / \return True if the cell3DIndex is contained in the updatedCell3DIds list, False otherwise
            """
            pass

        def cell3_d_initialize_double_properties(self, number_double_properties: int) -> None:
            """/ \brief Initialize the Cell3Ds double properties
            / \param numberDoubleProperties the total number of Cell3Ds properties
            / \note No reset of Cell3Ds is performed
            """
            pass
        def cell3_d_add_double_property(self, property_id: str) -> int:
            """/ \brief Add the Cell3Ds double property identified by id
            / \param propertyId the id of Cell3Ds property
            / \return the double property position
            """
            pass
        def cell3_ds_initialize_double_property_values(
            self,
            property_index: int,
            porperty_sizes: List[int]
            ) -> None:
            """/ \brief Initialize the Cell3Ds double property sizes
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            / \param porpertySize the double property size of each Cell3D, size 1 x Cell3DTotalNumber()
            """
            pass
        def cell3_d_initialize_double_property_values(
            self,
            cell3_d_index: int,
            property_index: int,
            porperty_size: int
            ) -> None:
            """/ \brief Initialize the Cell3Ds double property size
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            / \param porpertySize the double property size of Cell3D
            """
            pass
        def cell3_d_insert_double_property_value(
            self,
            cell3_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            """/ \brief Insert the Cell3Ds double property value at position
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            """
            pass

        def cell3_d_number_double_properties(self) -> int:
            """/ \return the total number of double properties of Cell3Ds"""
            pass
        def cell3_d_double_property_id(self, property_index: int) -> str:
            """/ \return the id of the double property of Cell3Ds
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            """
            pass
        def cell3_d_double_property_exists(self, property_id: str) -> bool:
            """/ \return True if the double propertyId of Cell3Ds exists
            / \param propertyId the id of Cell3D double property
            """
            pass
        def cell3_d_double_property_index(self, property_id: str) -> int:
            """/ \return the propertyIndex of the double property of Cell3Ds from 0 to Cell3DNumberProperties()
            / \param propertyId the id of Cell3D double property
            """
            pass
        def cell3_d_double_property_size(self, cell3_d_index: int, property_index: int) -> int:
            """/ \return the size of the double property of Cell3D
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            """
            pass
        def cell3_d_double_property_value(
            self,
            cell3_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            """/ \return the value of the double property at valueIndex of Cell3D
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            / \param propertyValueIndex the index of Cell3D double property value from 0 to Cell3DDoublePropertySize()
            """
            pass

        def compress(self) -> None:
            """/ \brief Compact the mesh to save memory"""
            pass

        def to_string(self) -> str:
            """/ \return The mesh converted to string"""
            pass
        def __init__(self) -> None:
            """Autogenerated default constructor"""
            pass

# </submodule gedim>
####################    </generated_from:IMeshDAO.hpp>    ####################


####################    <generated_from:IntersectorMesh2DSegment.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __IntersectorMesh2DSegment_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class IntersectorMesh2DSegment:
        """
        (final class)
        """
        class IntersectionMesh:
            """
            (final class)
            """
            class IntersectionMeshPoint:
                """
                (final class)
                """
                cell2_d_ids: std.set[int] = std.set<int>()
                edge2_d_ids: std.set[int] = std.set<int>()
                vertex2_d_ids: std.set[int] = std.set<int>()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            class IntersectionMeshSegment:
                """
                (final class)
                """
                points: List[float] = List[float]()
                cell2_d_ids: std.set[int] = std.set<int>()
                edge2_d_ids: std.set[int] = std.set<int>()
                def __init__(self, points: List[float] = List[float]()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            points: Dict[float, IntersectionMeshPoint]
            segments: List[IntersectionMeshSegment]
            def __init__(
                self,
                segments: List[IntersectionMeshSegment] = List[IntersectionMeshSegment]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        @staticmethod
        def to_curvilinear_coordinates(
            intersecting_mesh: IntersectorMesh2DSegment.IntersectionMesh,
            curvilinear_coordinates: List[float]
            ) -> None:
            """/ \brief convert IntersectionMesh to Curvilinear Coordinates vector"""
            pass

        @staticmethod
        def to_string(intersecting_mesh: IntersectorMesh2DSegment.IntersectionMesh) -> None:
            pass

        def __init__(self, mesh: IMeshDAO, geometry_utilities: GeometryUtilities) -> None:
            pass

        def create_intersection_mesh(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            segment_barycenter: Eigen.Vector3d,
            segment_length: float,
            result: IntersectorMesh2DSegment.IntersectionMesh
            ) -> None:
            pass

# </submodule gedim>
####################    </generated_from:IntersectorMesh2DSegment.hpp>    ####################


####################    <generated_from:IntersectorMesh3DSegment.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __IntersectorMesh3DSegment_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class IntersectorMesh3DSegment:
        """
        (final class)
        """
        class IntersectionMesh:
            """
            (final class)
            """
            class IntersectionMeshPoint:
                """
                (final class)
                """
                curvilinear_coordinate: float
                cell3_d_ids: List[int]
                positions: List[GeometryUtilities.PointPolyhedronPositionResult]
                def __init__(
                    self,
                    curvilinear_coordinate: float = float(),
                    positions: List[GeometryUtilities.PointPolyhedronPositionResult] = List[GeometryUtilities.PointPolyhedronPositionResult]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class IntersectionMeshSegment:
                """
                (final class)
                """
                points_index: List[int]
                cell3_d_ids: List[int]
                positions: List[GeometryUtilities.SegmentPolyhedronPositionResult]
                def __init__(
                    self,
                    positions: List[GeometryUtilities.SegmentPolyhedronPositionResult] = List[GeometryUtilities.SegmentPolyhedronPositionResult]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            points: List[IntersectionMeshPoint]
            segments: List[IntersectionMeshSegment]
            def __init__(
                self,
                points: List[IntersectionMeshPoint] = List[IntersectionMeshPoint](),
                segments: List[IntersectionMeshSegment] = List[IntersectionMeshSegment]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPoint:
            """
            (final class)
            """
            cell3_d_ids: std.set[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class FindSegmentStartingCell3DResult:
            """
            (final class)
            """
            starting_cell3_d_index: int
            segment_full_inside_cell3_d: bool
            position: GeometryUtilities.PointPolyhedronPositionResult
            def __init__(
                self,
                segment_full_inside_cell3_d: bool = bool(),
                position: GeometryUtilities.PointPolyhedronPositionResult = GeometryUtilities.PointPolyhedronPositionResult()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            mesh_utilities: MeshUtilities
            ) -> None:
            pass

        @staticmethod
        def to_curvilinear_coordinates(
            intersecting_mesh: IntersectorMesh3DSegment.IntersectionMesh
            ) -> List[float]:
            pass
        @staticmethod
        def mesh_segments_cell3_ds(
            intersecting_mesh: IntersectorMesh3DSegment.IntersectionMesh
            ) -> List[List[int]]:
            pass
        @staticmethod
        def to_string(intersecting_mesh: IntersectorMesh3DSegment.IntersectionMesh) -> str:
            pass

        def create_intersection_mesh(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            mesh3_d: IMeshDAO,
            mesh3_d_geometric_data: MeshUtilities.MeshGeometricData3D
            ) -> IntersectorMesh3DSegment.IntersectionMesh:
            pass

        def find_segment_starting_cell3_d(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            mesh3_d: IMeshDAO,
            mesh3_d_geometric_data: MeshUtilities.MeshGeometricData3D
            ) -> IntersectorMesh3DSegment.FindSegmentStartingCell3DResult:
            pass

# </submodule gedim>
####################    </generated_from:IntersectorMesh3DSegment.hpp>    ####################


####################    <generated_from:MeshDAOExporterToCsv.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshDAOExporterToCsv_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshDAOExporterToCsv:
        """/ \brief MeshDAOExporterToCsv
        / \copyright See top level LICENSE file for details.
        (final class)
        """
        def __init__(self, utilities: MeshFromCsvUtilities) -> None:
            pass

        def export(
            self,
            configuration: MeshFromCsvUtilities.Configuration,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export the mesh in all parts
            / \param configuration the configuration for export
            / \param mesh the mesh to be exported
            """
            pass


# </submodule gedim>
####################    </generated_from:MeshDAOExporterToCsv.hpp>    ####################


####################    <generated_from:MeshDAOImporterFromCsv.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshDAOImporterFromCsv_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshDAOImporterFromCsv:
        """/ \brief MeshDAOImporterFromCsv
        / \note each file could be EmptyFileReader if not necessary
        / \copyright See top level LICENSE file for details
        (final class)
        """
        def __init__(self, utilities: MeshFromCsvUtilities) -> None:
            pass

        def import_(
            self,
            configuration: MeshFromCsvUtilities.Configuration,
            mesh: IMeshDAO
            ) -> None:
            pass

        def import_mesh2_d(
            self,
            configuration: MeshFromCsvUtilities.Configuration,
            mesh: IMeshDAO
            ) -> None:
            pass


# </submodule gedim>
####################    </generated_from:MeshDAOImporterFromCsv.hpp>    ####################


####################    <generated_from:MeshFromCsvUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshImporterFromCsvUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshFromCsvUtilities:
        """/ \brief MeshImporterFromCsvUtilities
        / \note each file could be EmptyFileReader if not necessary
        / \copyright See top level LICENSE file for details
        (final class)
        """
        class Configuration:
            folder: str = "./"
            file_cell0_ds_name: str = "Cell0Ds"
            file_cell1_ds_name: str = "Cell1Ds"
            file_cell2_ds_name: str = "Cell2Ds"
            file_cell3_ds_name: str = "Cell3Ds"
            file_cell0_d_neighbours_name: str = "Cell0DNeighbours"
            file_cell1_d_neighbours_name: str = "Cell1DNeighbours"
            file_cell2_d_neighbours_name: str = "Cell2DNeighbours"
            file_cell0_d_properties_name: str = "Cell0DProperties"
            file_cell1_d_properties_name: str = "Cell1DProperties"
            file_cell2_d_properties_name: str = "Cell2DProperties"
            file_cell3_d_properties_name: str = "Cell3DProperties"
            file_cell2_d_sub_divisions_name: str = "Cell2DSubDivisions"
            file_cell0_d_updated_cells_name: str = "Cell0DUpdatedCells"
            file_cell1_d_updated_cells_name: str = "Cell1DUpdatedCells"
            file_cell2_d_updated_cells_name: str = "Cell2DUpdatedCells"
            file_cell3_d_updated_cells_name: str = "Cell3DUpdatedCells"
            separator: char = ';'
            file_extension: str = "csv"
            def __init__(
                self,
                folder: str = "./",
                file_cell0_ds_name: str = "Cell0Ds",
                file_cell1_ds_name: str = "Cell1Ds",
                file_cell2_ds_name: str = "Cell2Ds",
                file_cell3_ds_name: str = "Cell3Ds",
                file_cell0_d_neighbours_name: str = "Cell0DNeighbours",
                file_cell1_d_neighbours_name: str = "Cell1DNeighbours",
                file_cell2_d_neighbours_name: str = "Cell2DNeighbours",
                file_cell0_d_properties_name: str = "Cell0DProperties",
                file_cell1_d_properties_name: str = "Cell1DProperties",
                file_cell2_d_properties_name: str = "Cell2DProperties",
                file_cell3_d_properties_name: str = "Cell3DProperties",
                file_cell2_d_sub_divisions_name: str = "Cell2DSubDivisions",
                file_cell0_d_updated_cells_name: str = "Cell0DUpdatedCells",
                file_cell1_d_updated_cells_name: str = "Cell1DUpdatedCells",
                file_cell2_d_updated_cells_name: str = "Cell2DUpdatedCells",
                file_cell3_d_updated_cells_name: str = "Cell3DUpdatedCells",
                separator: char = ';',
                file_extension: str = "csv"
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CellDoubleProperty:
            class Value:
                cell_id: int
                values: List[float]
                def __init__(self, values: List[float] = List[float]()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            id: str
            file_path: str
            values: List[Value]
            def __init__(
                self,
                id: str = "",
                file_path: str = "",
                values: List[Value] = List[Value]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell0D:
            id: int
            x: float
            y: float
            z: float
            marker: int
            active: bool
            def __init__(
                self,
                x: float = float(),
                y: float = float(),
                z: float = float(),
                active: bool = bool()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell0DNeighbours:
            id: int
            cell1_d_neighbours: List[int]
            cell2_d_neighbours: List[int]
            cell3_d_neighbours: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class CellUpdatedCells:
            id: int
            updated_cells: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class Cell1D:
            id: int
            origin: int
            end: int
            marker: int
            active: bool
            def __init__(self, active: bool = bool()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell1DNeighbours:
            id: int
            cell2_d_neighbours: List[int]
            cell3_d_neighbours: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class Cell2D:
            id: int
            vertices: List[int]
            edges: List[int]
            marker: int
            active: bool
            def __init__(self, active: bool = bool()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell2DNeighbours:
            id: int
            cell3_d_neighbours: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class Cell2DSubDivision:
            id: int
            sub_division: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class Cell3D:
            id: int
            vertices: List[int]
            edges: List[int]
            faces: List[int]
            marker: int
            active: bool
            def __init__(self, active: bool = bool()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def convert_mesh2_d(
            self,
            cell0_ds: List[MeshFromCsvUtilities.Cell0D],
            cell1_ds: List[MeshFromCsvUtilities.Cell1D],
            cell2_ds: List[MeshFromCsvUtilities.Cell2D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert a 2D Mesh
            / \param cell0Ds the container of cell0Ds
            / \param cell1Ds the container of cell1Ds
            / \param cell2Ds the container of cell2Ds
            / \param mesh the resulting mesh
            """
            pass

        def convert_cell0_ds(
            self,
            cell0_ds: List[MeshFromCsvUtilities.Cell0D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell0Ds to mesh
            / \param cell0Ds the container of cell0Ds
            / \param mesh the mesh
            """
            pass
        def convert_cell1_ds(
            self,
            cell1_ds: List[MeshFromCsvUtilities.Cell1D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell1Ds to mesh
            / \param cell1Ds the container of cell1Ds
            / \param mesh the mesh
            """
            pass
        def convert_cell2_ds(
            self,
            cell2_ds: List[MeshFromCsvUtilities.Cell2D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2Ds to mesh
            / \param cell2Ds the container of cell2Ds
            / \param mesh the mesh
            """
            pass
        def convert_cell3_ds(
            self,
            cell3_ds: List[MeshFromCsvUtilities.Cell3D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell3Ds to mesh
            / \param cell3Ds the container of cell3Ds
            / \param mesh the mesh
            """
            pass

        def convert_cell0_d_neighbours(
            self,
            cell0_d_neighbours: List[MeshFromCsvUtilities.Cell0DNeighbours],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell0D neighbours to mesh
            / \param cell0DNeighbours the container of cell0D neighbours
            / \param mesh the mesh
            """
            pass
        def convert_cell1_d_neighbours(
            self,
            cell1_d_neighbours: List[MeshFromCsvUtilities.Cell1DNeighbours],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell1D neighbours to mesh
            / \param cell1DNeighbours the container of cell1D neighbours
            / \param mesh the mesh
            """
            pass
        def convert_cell2_d_neighbours(
            self,
            cell2_d_neighbours: List[MeshFromCsvUtilities.Cell2DNeighbours],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2D neighbours to mesh
            / \param cell2DNeighbours the container of cell2D neighbours
            / \param mesh the mesh
            """
            pass

        def convert_cell2_d_sub_divisions(
            self,
            cell2_d_sub_divisions: List[MeshFromCsvUtilities.Cell2DSubDivision],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2D subdivision to mesh
            / \param cell2DSubDivisions the container of cell2D neighbours
            / \param mesh the mesh
            """
            pass

        def convert_cell0_d_double_properties(
            self,
            cell0_d_double_properties: List[MeshFromCsvUtilities.CellDoubleProperty],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell0D double properties to mesh
            / \param cell0DDoubleProperties the container of cell0D double properties
            / \param mesh the mesh
            """
            pass
        def convert_cell1_d_double_properties(
            self,
            cell1_d_double_properties: List[MeshFromCsvUtilities.CellDoubleProperty],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell1D double properties to mesh
            / \param cell1DDoubleProperties the container of cell1D double properties
            / \param mesh the mesh
            """
            pass
        def convert_cell2_d_double_properties(
            self,
            cell2_d_double_properties: List[MeshFromCsvUtilities.CellDoubleProperty],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2D double properties to mesh
            / \param cell2DDoubleProperties the container of cell2D double properties
            / \param mesh the mesh
            """
            pass
        def convert_cell3_d_double_properties(
            self,
            cell3_d_double_properties: List[MeshFromCsvUtilities.CellDoubleProperty],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell3D double properties to mesh
            / \param cell3DDoubleProperties the container of cell3D double properties
            / \param mesh the mesh
            """
            pass

        def convert_cell0_d_updated_cells(
            self,
            cell0_d_updated_cells: List[MeshFromCsvUtilities.CellUpdatedCells],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell0D updated cells to mesh
            / \param cell0DUpdatedCells the container of cell0D updated cells
            / \param mesh the mesh
            """
            pass
        def convert_cell1_d_updated_cells(
            self,
            cell1_d_updated_cells: List[MeshFromCsvUtilities.CellUpdatedCells],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell1D updated cells to mesh
            / \param cell1DUpdatedCells the container of cell1D updated cells
            / \param mesh the mesh
            """
            pass
        def convert_cell2_d_updated_cells(
            self,
            cell2_d_updated_cells: List[MeshFromCsvUtilities.CellUpdatedCells],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2D updated cells to mesh
            / \param cell2DUpdatedCells the container of cell2D updated cells
            / \param mesh the mesh
            """
            pass
        def convert_cell3_d_updated_cells(
            self,
            cell3_d_updated_cells: List[MeshFromCsvUtilities.CellUpdatedCells],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell3D updated cells to mesh
            / \param cell3DUpdatedCells the container of cell3D updated cells
            / \param mesh the mesh
            """
            pass

        def import_cell0_ds(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell0D]:
            """/ \brief Import Cell0Ds; format: Id, Marker, Active, X, Y, Z
            / \param csvFileReader the file reader
            / \param separator the file separator
            / \param mesh the mesh to be Imported
            """
            pass
        def import_cell1_ds(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell1D]:
            """/ \brief Import Cell1Ds; format: Id, Marker, Active, Origin, End
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass
        def import_cell2_ds(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell2D]:
            """/ \brief Import Cell2Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass
        def import_cell3_ds(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell3D]:
            """/ \brief Import Cell3Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges, NumFaces, Faces
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell0_d_neighbours(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell0DNeighbours]:
            """/ \brief Import Cell0DNeighbours; format: Id, Num1DNeighbours, 1DNeighbours, Num2DNeighbours, 2DNeighbours,
            / Num3DNeighbours, 3DNeighbours \param csvFileReader the file reader \param separator the file separator
            """
            pass
        def import_cell1_d_neighbours(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell1DNeighbours]:
            """/ \brief Import Cell1DNeighbours; format: Id, Num2DNeighbours, 2DNeighbours, Num3DNeighbours, 3DNeighbours
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell2_d_neighbours(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell2DNeighbours]:
            """/ \brief Import Cell2DNeighbours; format: Id, Num3DNeighbours, 3DNeighbours
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell2_d_sub_division(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell2DSubDivision]:
            """/ \brief Import Cell2DSubDivision; format: Id, NumSubDivision, SubDivisions
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell_double_properties(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.CellDoubleProperty]:
            """/ \brief Import CellProperties; format: Id, FilePath
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell_updated_cells(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.CellUpdatedCells]:
            """/ \brief Import CellUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def export_cell0_ds(self, file_path: str, separator: str, mesh: IMeshDAO) -> None:
            """/ \brief Export Cell0Ds; format: Id, Marker, Active, X, Y, Z
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell1_ds(self, file_path: str, separator: str, mesh: IMeshDAO) -> None:
            """/ \brief Export Cell1Ds; format: Id, Marker, Active, Origin, End
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell2_ds(self, file_path: str, separator: str, mesh: IMeshDAO) -> None:
            """/ \brief Export Cell2Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell3_ds(self, file_path: str, separator: str, mesh: IMeshDAO) -> None:
            """/ \brief Export Cell3Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges, NumFaces, Faces
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell0_d_properties(
            self,
            export_folder: str,
            property_file_name: str,
            property_file_extension: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell0DProperties; format: Id, FilePath
            / \param exportFolder the folder where to export the files
            / \param propertyFileName the name of property file
            / \param propertyFileExtension the extension of the files
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell0_d_property(
            self,
            property_index: int,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell0DProperty identified by index; format: Id, PropertySize, PropertyValues
            / \param propertyIndex the property index
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell1_d_properties(
            self,
            export_folder: str,
            property_file_name: str,
            property_file_extension: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell1DProperties; format: Id, FilePath
            / \param exportFolder the folder where to export the files
            / \param propertyFileName the name of property file
            / \param propertyFileExtension the extension of the files
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell1_d_property(
            self,
            property_index: int,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell1DProperty identified by index; format: Id, PropertySize, PropertyValues
            / \param propertyIndex the property index
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell2_d_properties(
            self,
            export_folder: str,
            property_file_name: str,
            property_file_extension: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DProperties; format: Id, FilePath
            / \param exportFolder the folder where to export the files
            / \param propertyFileName the name of property file
            / \param propertyFileExtension the extension of the files
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell2_d_property(
            self,
            property_index: int,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DProperty identified by index; format: Id, PropertySize, PropertyValues
            / \param propertyIndex the property index
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell3_d_properties(
            self,
            export_folder: str,
            property_file_name: str,
            property_file_extension: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell3DProperties; format: Id, FilePath
            / \param exportFolder the folder where to export the files
            / \param propertyFileName the name of property file
            / \param propertyFileExtension the extension of the files
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell3_d_property(
            self,
            property_index: int,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell3DProperty identified by index; format: Id, PropertySize, PropertyValues
            / \param propertyIndex the property index
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell0_d_neighbours(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell0DNeighbours; format: Id, Num1DNeighbours, 1DNeighbours, Num2DNeighbours, 2DNeighbours,
            / Num3DNeighbours, 3DNeighbours \param filePath the path of the file \param separator the file separator \param
            / mesh the mesh to be exported
            """
            pass
        def export_cell1_d_neighbours(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell1DNeighbours; format: Id, Num2DNeighbours, 2DNeighbours, Num3DNeighbours, 3DNeighbours
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell2_d_neighbours(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DNeighbours; format: Id, Num3DNeighbours, 3DNeighbours
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell2_d_sub_divisions(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DSubDivisions; format: Id, NumSubDivision, SubDivisions
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell0_d_updated_cells(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell0DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell1_d_updated_cells(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell1DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell2_d_updated_cells(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell3_d_updated_cells(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell3DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass


# </submodule gedim>
####################    </generated_from:MeshFromCsvUtilities.hpp>    ####################


####################    <generated_from:MeshMatrices.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshMatrices_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshMatrices:
        """
        (final class)
        """
        dimension: int = 0                                                                                                   #/< Geometric dimension
        number_cell0_d: int = 0                                                                                              #/< number of Cell0D
        cell0_d_coordinates: List[float] = List[float]()                                                                     #/< Cell0D coordinates, size 3 x NumberCell0D (x,y,z)
        cell0_d_markers: List[int] = List[int]()                                                                             #/< Cell0D markers, size 1 x NumberCell0D (marker)
        number_cell0_d_neighbour_cell1_d: List[int] = List[int](0)                                                           #/< Cell0D neighbour Cell1D indices per cell, size  1
        #/< x NumberCell0D + 1
        cell0_d_neighbour_cell1_ds: List[int] = List[int]()                                                                  #/< Cell0D neighbour Cell1D indices, size 1 x
        #/< NumberCell0DNeighbourCell1D[NumberCell0D]
        number_cell0_d_neighbour_cell2_d: List[int] = List[int](0)                                                           #/< Cell0D neighbour Cell2D indices per cell, size  1
        #/< x NumberCell0D + 1
        cell0_d_neighbour_cell2_ds: List[int] = List[int]()                                                                  #/< Cell0D neighbour Cell2D indices, size 1 x
        #/< NumberCell0DNeighbourCell2D[NumberCell0D]
        number_cell0_d_neighbour_cell3_d: List[int] = List[int](0)                                                           #/< Cell0D neighbour Cell2D indices per cell, size  1
        #/< x NumberCell0D + 1
        cell0_d_neighbour_cell3_ds: List[int] = List[int]()                                                                  #/< Cell0D neighbour Cell3D indices, size 1 x
        #/< NumberCell0DNeighbourCell3D[NumberCell0D]
        active_cell0_d: List[bool] = List[bool]()                                                                            #/< active Cell0D
        updated_cell0_ds: std.unordered_map[int, std.unordered_set[int]] = std.unordered_map<int, std.unordered_set<int>>()  #/< for each cell0D the
        #/< list to the new cell0Ds
        cell0_d_double_property_ids: List[str] = List[str]()                                                                 #/< Cell0D double property id - double property index
        cell0_d_double_property_indices: std.unordered_map[str, int] = std.unordered_map<str, int>()                         #/< Cell0D double property id -
        #/< double property index
        cell0_d_double_property_sizes: List[List[int]] = List[List[int]]()                                                   #/< Cell0D double property sizes
        cell0_d_double_property_values: List[List[float]] = List[List[float]]()                                              #/< Cell0D double property values
        number_cell1_d: int = 0                                                                                              #/< number of Cell1D
        cell1_d_vertices: List[int] = List[int]()                                                                            #/< Cell1D vertices indices, size 2 x NumberCell1D (fromId,toId)
        number_cell1_d_neighbour_cell2_d: List[int] = List[int](0)                                                           #/< Cell1D neighbour Cell2D indices per cell, size  1
        #/< x NumberCell1D + 1
        number_cell1_d_neighbour_cell3_d: List[int] = List[int](0)                                                           #/< Cell1D neighbour Cell3D indices per cell, size  1
        #/< x NumberCell1D + 1
        cell1_d_neighbour_cell2_ds: List[int] = List[int]()                                                                  #/< Cell1D neighbour Cell2D indices, size 1 x
        #/< NumberCell1DNeighbourCell2D[NumberCell1D]
        cell1_d_neighbour_cell3_ds: List[int] = List[int]()                                                                  #/< Cell1D neighbour Cell3D indices, size 1 x
        #/< NumberCell1DNeighbourCell3D[NumberCell1D]
        cell1_d_markers: List[int] = List[int]()                                                                             #/< Cell1D propertoes, size 1 x NumberCell1D (marker)
        active_cell1_d: List[bool] = List[bool]()                                                                            #/< active Cell1D
        cell1_d_original_cell1_ds: List[int] = List[int]()                                                                   #/< for each cell1D the index of original cell1D,
        #/< NumberCell1D is the default value (no original cell),
        #/< size 1 x NumberCell1D
        updated_cell1_ds: std.unordered_map[int, std.unordered_set[int]] = std.unordered_map<int, std.unordered_set<int>>()  #/< for each cell1D the
        #/< list to the new cell1Ds
        cell1_d_double_property_ids: List[str] = List[str]()                                                                 #/< Cell1D double property id - double property index
        cell1_d_double_property_indices: std.unordered_map[str, int] = std.unordered_map<str, int>()                         #/< Cell1D double property id -
        #/< double property index
        cell1_d_double_property_sizes: List[List[int]] = List[List[int]]()                                                   #/< Cell1D double property sizes
        cell1_d_double_property_values: List[List[float]] = List[List[float]]()                                              #/< Cell1D double property values
        number_cell2_d: int = 0                                                                                              #/< number of Cell2D
        number_cell2_d_vertices: List[int] = List[int](0)                                                                    #/< number of Vertices per Cell2D, size 1 x NumberCell2D + 1
        number_cell2_d_edges: List[int] = List[int](0)                                                                       #/< number of Edges per Cell2D, size 1 x NumberCell2D + 1
        cell2_d_vertices: List[int] = List[int]()                                                                            #/< Cell2D Vertices indices, size 1 x
        #/< NumberCell2DVertices[NumberCell2D]
        cell2_d_edges: List[int] = List[int]()                                                                               #/< Cell2D Cell1D indices, size 1 x NumberCell2DEdges[NumberCell2D]
        number_cell2_d_neighbour_cell3_d: List[int] = List[int](0)                                                           #/< Cell2D neighbour Cell3D indices per cell, size  1
        #/< x NumberCell2D + 1
        cell2_d_neighbour_cell3_ds: List[int] = List[int]()                                                                  #/< Cell2D neighbour Cell3D indices, size 1 x
        #/< NumberCell2DNeighbourCell3D[NumberCell2D]
        cell2_d_markers: List[int] = List[int]()                                                                             #/< Cell2D markers, size 1 x NumberCell2D (marker)
        active_cell2_d: List[bool] = List[bool]()                                                                            #/< active Cell2D
        number_cell2_d_subdivision: List[int] = List[int](0)                                                                 #/< number of sub-division per Cell2D, size 1 x
        #/< NumberCell2D + 1
        cell2_d_subdivision: List[int] = List[int]()                                                                         #/< Sub-division of Cell2Ds, used for Concave polygons, size 1 x
        #/< NumberCell2DSubdivision[NumberCell2D]
        cell2_d_original_cell2_ds: List[int] = List[int]()                                                                   #/< for each cell2D the index of original cell2D,
        #/< NumberCell2D is the default value (no original cell),
        #/< size 1 x NumberCell2D
        updated_cell2_ds: std.unordered_map[int, std.unordered_set[int]] = std.unordered_map<int, std.unordered_set<int>>()  #/< for each cell2D the
        #/< list to the new cell2Ds
        cell2_d_double_property_ids: List[str] = List[str]()                                                                 #/< Cell2D double property id - double property index
        cell2_d_double_property_indices: std.unordered_map[str, int] = std.unordered_map<str, int>()                         #/< Cell2D double property id -
        #/< double property index
        cell2_d_double_property_sizes: List[List[int]] = List[List[int]]()                                                   #/< Cell2D double property sizes
        cell2_d_double_property_values: List[List[float]] = List[List[float]]()                                              #/< Cell2D double property values
        number_cell3_d: int = 0                                                                                              #/< number of Cell3D
        number_cell3_d_vertices: List[int] = List[int](0)                                                                    #/< number of Vertices per Cell3D, size 1 x NumberCell3D + 1
        number_cell3_d_edges: List[int] = List[int](0)                                                                       #/< number of Edges per Cell3D, size 1 x NumberCell3D + 1
        number_cell3_d_faces: List[int] = List[int](0)                                                                       #/< number of Faces per Cell3D, size 1 x NumberCell3D + 1
        cell3_d_vertices: List[int] = List[int]()                                                                            #/< Cell3D Cell0D indices, size 1 x
        #/< NumberCell3DVertices[NumberCell3D]
        cell3_d_edges: List[int] = List[int]()                                                                               #/< Cell3D Cell1D indices, size 1 x NumberCell3DEdges[NumberCell3D]
        cell3_d_faces: List[int] = List[int]()                                                                               #/< Cell3D Cell2D indices, size 1 x NumberCell3DFaces[NumberCell3D]
        cell3_d_markers: List[int] = List[int]()                                                                             #/< Cell3D markers, size 1 x NumberCell3D (marker)
        active_cell3_d: List[bool] = List[bool]()                                                                            #/< active Cell3D
        cell3_d_original_cell3_ds: List[int] = List[int]()                                                                   #/< for each cell3D the index of original cell3D,
        #/< NumberCell3D is the default value (no original cell),
        #/< size 1 x NumberCell3D
        updated_cell3_ds: std.unordered_map[int, std.unordered_set[int]] = std.unordered_map<int, std.unordered_set<int>>()  #/< for each cell3D the
        #/< list to the new cell3Ds
        cell3_d_double_property_ids: List[str] = List[str]()                                                                 #/< Cell3D double property id - double property index
        cell3_d_double_property_indices: std.unordered_map[str, int] = std.unordered_map<str, int>()                         #/< Cell3D double property id -
        #/< double property index
        cell3_d_double_property_sizes: List[List[int]] = List[List[int]]()                                                   #/< Cell3D double property sizes
        cell3_d_double_property_values: List[List[float]] = List[List[float]]()                                              #/< Cell3D double property values
        def __init__(
            self,
            cell0_d_coordinates: List[float] = List[float](),
            active_cell0_d: List[bool] = List[bool](),
            cell0_d_double_property_ids: List[str] = List[str](),
            cell0_d_double_property_values: List[List[float]] = List[List[float]](),
            active_cell1_d: List[bool] = List[bool](),
            cell1_d_double_property_ids: List[str] = List[str](),
            cell1_d_double_property_values: List[List[float]] = List[List[float]](),
            active_cell2_d: List[bool] = List[bool](),
            cell2_d_double_property_ids: List[str] = List[str](),
            cell2_d_double_property_values: List[List[float]] = List[List[float]](),
            active_cell3_d: List[bool] = List[bool](),
            cell3_d_double_property_ids: List[str] = List[str](),
            cell3_d_double_property_values: List[List[float]] = List[List[float]]()
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

# </submodule gedim>
####################    </generated_from:MeshMatrices.hpp>    ####################


####################    <generated_from:MeshMatricesDAO.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshMatricesWrapper_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshMatricesDAO:
        """
        (final class)
        """
        def __init__(self, mesh: MeshMatrices) -> None:
            pass

        def initialize_dimension(self, dimension: int) -> None:
            pass
        def dimension(self) -> int:
            pass

        def cell0_ds_initialize(self, number_cell0_ds: int) -> None:
            pass
        def cell0_d_append(self, number_cell0_ds: int) -> int:
            pass
        def cell0_d_remove(self, cell0_d_index: int) -> None:
            pass

        def cell0_d_insert_coordinates(
            self,
            cell0_d_index: int,
            coordinates: Eigen.Vector3d
            ) -> None:
            pass
        def cell0_ds_insert_coordinates(self, coordinates: Eigen.MatrixXd) -> None:
            pass
        def cell0_d_set_marker(self, cell0_d_index: int, marker: int) -> None:
            pass
        def cell0_d_set_state(self, cell0_d_index: int, state: bool) -> None:
            pass

        def cell0_d_total_number(self) -> int:
            pass
        def cell0_d_coordinate_x(self, cell0_d_index: int) -> float:
            pass
        def cell0_d_coordinate_y(self, cell0_d_index: int) -> float:
            pass
        def cell0_d_coordinate_z(self, cell0_d_index: int) -> float:
            pass
        def cell0_d_coordinates(self, cell0_d_index: int) -> Eigen.Vector3d:
            pass
        @overload
        def cell0_ds_coordinates(self) -> Eigen.MatrixXd:
            pass
        @overload
        def cell0_ds_coordinates(self, cell0_ds: List[int]) -> Eigen.MatrixXd:
            pass
        def cell0_d_marker(self, cell0_d_index: int) -> int:
            pass
        def cell0_ds_marker(self) -> List[int]:
            pass
        def cell0_d_is_active(self, cell0_d_index: int) -> bool:
            pass

        def cell0_d_has_updated_cell0_ds(self, cell0_d_index: int) -> bool:
            pass
        def cell0_d_number_updated_cell0_ds(self, cell0_d_index: int) -> int:
            pass
        def cell0_d_has_updated_cell0_d(
            self,
            cell0_d_index: int,
            updated_cell0_d_idex: int
            ) -> bool:
            pass
        def cell0_d_insert_updated_cell0_d(
            self,
            cell0_d_index: int,
            updated_cell0_d_idex: int
            ) -> None:
            pass
        def cell0_d_updated_cell0_ds(
            self,
            cell0_d_index: int,
            updated_cell0_d_ids: std.list[int]
            ) -> bool:
            pass

        def cell0_ds_neighbour_cell1_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell1_ds(
            self,
            number_neighbour_cell1_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell1_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell1_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell1_ds(
            self,
            cell0_d_index: int,
            neighbour_cell1_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell1_d_index: int
            ) -> None:
            pass
        def cell0_d_number_neighbour_cell1_d(self, cell0_d_index: int) -> int:
            pass
        def cell0_d_neighbour_cell1_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            pass
        def cell0_d_neighbour_cell1_ds(self, cell0_d_index: int) -> List[int]:
            pass
        def cell0_d_has_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell0_d_reset_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            pass

        def cell0_ds_neighbour_cell2_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell2_ds(
            self,
            number_neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell2_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell2_ds(
            self,
            cell0_d_index: int,
            neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell2_d_index: int
            ) -> None:
            pass
        def cell0_d_number_neighbour_cell2_d(self, cell0_d_index: int) -> int:
            pass
        def cell0_d_neighbour_cell2_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            pass
        def cell0_d_neighbour_cell2_ds(self, cell0_d_index: int) -> List[int]:
            pass
        def cell0_d_has_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell0_d_reset_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            pass
        def cell0_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell3_ds(
            self,
            number_neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell3_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell3_ds(
            self,
            cell0_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            pass
        def cell0_d_number_neighbour_cell3_d(self, cell0_d_index: int) -> int:
            pass
        def cell0_d_neighbour_cell3_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            pass
        def cell0_d_neighbour_cell3_ds(self, cell0_d_index: int) -> List[int]:
            pass
        def cell0_d_has_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell0_d_reset_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            pass

        def cell0_d_initialize_double_properties(self, number_double_properties: int) -> None:
            pass
        def cell0_d_add_double_property(self, property_id: str) -> int:
            pass
        def cell0_ds_initialize_double_property_values(
            self,
            property_index: int,
            property_sizes: List[int]
            ) -> None:
            pass
        def cell0_d_initialize_double_property_values(
            self,
            cell0_d_index: int,
            property_index: int,
            property_size: int
            ) -> None:
            pass
        def cell0_d_insert_double_property_value(
            self,
            cell0_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            pass
        def cell0_d_number_double_properties(self) -> int:
            pass
        def cell0_d_double_property_id(self, property_index: int) -> str:
            pass
        def cell0_d_double_property_exists(self, property_id: str) -> bool:
            pass
        def cell0_d_double_property_index(self, property_id: str) -> int:
            pass
        def cell0_d_double_property_size(self, cell0_d_index: int, property_index: int) -> int:
            pass
        def cell0_d_double_property_value(
            self,
            cell0_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            pass

        def cell1_ds_initialize(self, number_cell1_ds: int) -> None:
            pass
        def cell1_d_append(self, number_cell1_ds: int) -> int:
            pass
        def cell1_d_remove(self, cell1_d_index: int) -> None:
            pass
        def cell1_d_insert_extremes(
            self,
            cell1_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> None:
            pass

        def cell1_ds_insert_extremes(self, cell1_d_extremes: Eigen.MatrixXi) -> None:
            pass

        @overload
        def cell1_ds_extremes(self) -> Eigen.MatrixXi:
            pass
        @overload
        def cell1_ds_extremes(self, cell1_ds: List[int]) -> Eigen.MatrixXi:
            pass
        def cell1_d_extremes(self, cell1_d_index: int) -> Eigen.VectorXi:
            """/ \return the extrems as Eigen MatrixXi of cell1D, size 2
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            """
            pass

        def cell1_d_by_extremes(
            self,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            pass

        def cell1_d_set_marker(self, cell1_d_index: int, marker: int) -> None:
            pass
        def cell1_d_set_state(self, cell1_d_index: int, state: bool) -> None:
            pass
        def cell1_ds_neighbour_cell2_ds(self) -> List[List[int]]:
            pass
        @overload
        def cell1_ds_initialize_neighbour_cell2_ds(
            self,
            number_neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell1_ds_initialize_neighbour_cell2_ds(
            self,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell2_ds(
            self,
            cell1_d_index: int,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell2_ds(
            self,
            cell1_d_index: int,
            neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        def cell1_d_insert_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int,
            neigbour_cell2_d_index: int
            ) -> None:
            pass
        def cell1_d_total_number(self) -> int:
            pass
        def cell1_d_vertex(self, cell1_d_index: int, vertex_index: int) -> int:
            pass
        def cell1_d_origin(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_end(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_find_extreme(self, cell1_d_index: int, cell0_d_index: int) -> int:
            pass
        def cell1_d_coordinates(self, cell1_d_index: int) -> Eigen.MatrixXd:
            pass
        def cell1_d_origin_coordinates(self, cell1_d_index: int) -> Eigen.Vector3d:
            pass
        def cell1_d_end_coordinates(self, cell1_d_index: int) -> Eigen.Vector3d:
            pass
        def cell1_d_number_neighbour_cell2_d(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_neighbour_cell2_d(self, cell1_d_index: int, neighbour_index: int) -> int:
            pass
        def cell1_d_neighbour_cell2_ds(self, cell1_d_index: int) -> List[int]:
            pass
        def cell1_d_has_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell1_d_reset_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> None:
            pass

        def cell1_d_marker(self, cell1_d_index: int) -> int:
            pass
        def cell1_ds_marker(self) -> List[int]:
            pass
        def cell1_d_is_active(self, cell1_d_index: int) -> bool:
            pass
        def cell1_d_has_original_cell1_d(self, updated_cell1_d_index: int) -> bool:
            pass
        def cell1_d_original_cell1_d(self, updated_cell1_d_index: int) -> int:
            pass
        def cell1_d_has_updated_cell1_ds(self, cell1_d_index: int) -> bool:
            pass
        def cell1_d_number_updated_cell1_ds(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_has_updated_cell1_d(
            self,
            cell1_d_index: int,
            updated_cell1_d_idex: int
            ) -> bool:
            pass
        def cell1_d_insert_updated_cell1_d(
            self,
            cell1_d_index: int,
            updated_cell1_d_idex: int
            ) -> None:
            pass
        def cell1_d_updated_cell1_ds(
            self,
            cell1_d_index: int,
            updated_cell1_d_ids: std.list[int]
            ) -> bool:
            pass
        def cell1_d_initialize_double_properties(self, number_double_properties: int) -> None:
            pass

        def cell1_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell1_ds_initialize_neighbour_cell3_ds(
            self,
            number_neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell3_ds(
            self,
            cell1_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell3_ds(
            self,
            cell1_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell1_d_insert_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            pass
        def cell1_d_number_neighbour_cell3_d(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_neighbour_cell3_d(self, cell1_d_index: int, neighbour_index: int) -> int:
            pass
        def cell1_d_neighbour_cell3_ds(self, cell1_d_index: int) -> List[int]:
            pass
        def cell1_d_has_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell1_d_reset_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> None:
            pass

        def cell1_d_add_double_property(self, property_id: str) -> int:
            pass
        def cell1_ds_initialize_double_property_values(
            self,
            property_index: int,
            property_sizes: List[int]
            ) -> None:
            pass
        def cell1_d_initialize_double_property_values(
            self,
            cell1_d_index: int,
            property_index: int,
            property_size: int
            ) -> None:
            pass
        def cell1_d_insert_double_property_value(
            self,
            cell1_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            pass
        def cell1_d_number_double_properties(self) -> int:
            pass
        def cell1_d_double_property_id(self, property_index: int) -> str:
            pass
        def cell1_d_double_property_exists(self, property_id: str) -> bool:
            pass
        def cell1_d_double_property_index(self, property_id: str) -> int:
            pass
        def cell1_d_double_property_size(self, cell1_d_index: int, property_index: int) -> int:
            pass
        def cell1_d_double_property_value(
            self,
            cell1_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            pass

        def cell2_ds_initialize(self, number_cell2_ds: int) -> None:
            pass
        def cell2_d_append(self, number_cell2_ds: int) -> int:
            pass
        def cell2_d_remove(self, cell2_d_index: int) -> None:
            pass
        def cell2_d_set_marker(self, cell2_d_index: int, marker: int) -> None:
            pass
        def cell2_d_set_state(self, cell2_d_index: int, state: bool) -> None:
            pass
        @overload
        def cell2_ds_initialize_vertices(self, number_cell2_d_vertices: int) -> None:
            pass
        @overload
        def cell2_ds_initialize_vertices(self, number_cell2_ds_vertices: List[int]) -> None:
            pass
        def cell2_d_initialize_vertices(
            self,
            cell2_d_index: int,
            number_cell2_d_vertices: int
            ) -> None:
            pass
        @overload
        def cell2_ds_initialize_edges(self, number_cell2_d_edges: int) -> None:
            pass
        @overload
        def cell2_ds_initialize_edges(self, number_cell2_ds_edges: List[int]) -> None:
            pass
        def cell2_d_initialize_edges(
            self,
            cell2_d_index: int,
            number_cell2_d_edges: int
            ) -> None:
            pass
        def cell2_d_insert_vertices(
            self,
            cell2_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            pass
        def cell2_d_insert_vertex(
            self,
            cell2_d_index: int,
            vertex_index: int,
            vertex_cell0_d_index: int
            ) -> None:
            pass
        def cell2_d_insert_edges(
            self,
            cell2_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            pass
        def cell2_d_insert_edge(
            self,
            cell2_d_index: int,
            edge_index: int,
            edge_cell1_d_index: int
            ) -> None:
            pass
        def cell2_d_add_vertices(
            self,
            cell2_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            pass
        def cell2_d_add_edges(
            self,
            cell2_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            pass
        def cell2_d_add_vertices_and_edges(
            self,
            cell2_d_index: int,
            vertices_and_edges_indices: Eigen.MatrixXi
            ) -> None:
            pass

        def cell2_d_total_number(self) -> int:
            pass
        def cell2_d_number_vertices(self, cell2_d_index: int) -> int:
            pass
        def cell2_d_number_edges(self, cell2_d_index: int) -> int:
            pass

        def cell2_d_vertices(self, cell2_d_index: int) -> List[int]:
            pass
        def cell2_ds_vertices(self) -> List[List[int]]:
            pass
        def cell2_ds_extremes(self) -> List[Eigen.MatrixXi]:
            pass

        def cell2_d_vertex(self, cell2_d_index: int, vertex_index: int) -> int:
            pass
        def cell2_d_vertex_coordinates(
            self,
            cell2_d_index: int,
            vertex_index: int
            ) -> Eigen.Vector3d:
            pass
        def cell2_d_vertices_coordinates(self, cell2_d_index: int) -> Eigen.MatrixXd:
            pass
        def cell2_d_find_vertex(self, cell2_d_index: int, cell0_d_index: int) -> int:
            pass

        def cell2_d_edges(self, cell2_d_index: int) -> List[int]:
            pass

        def cell2_d_edge(self, cell2_d_index: int, edge_index: int) -> int:
            pass
        def cell2_d_find_edge(self, cell2_d_index: int, cell1_d_index: int) -> int:
            pass
        def cell2_d_find_edge_by_extremes(
            self,
            cell2_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            pass
        def cell2_d_marker(self, cell2_d_index: int) -> int:
            pass
        def cell2_ds_marker(self) -> List[int]:
            pass
        def cell2_d_is_active(self, cell2_d_index: int) -> bool:
            pass

        def cell2_d_has_updated_cell2_ds(self, cell2_d_index: int) -> bool:
            pass
        def cell2_d_number_updated_cell2_ds(self, cell2_d_index: int) -> int:
            pass
        def cell2_d_has_updated_cell2_d(
            self,
            cell2_d_index: int,
            updated_cell2_d_index: int
            ) -> bool:
            pass
        def cell2_d_insert_updated_cell2_d(
            self,
            cell2_d_index: int,
            updated_cell2_d_idex: int
            ) -> None:
            pass
        def cell2_d_has_original_cell2_d(self, updated_cell2_d_index: int) -> bool:
            pass
        def cell2_d_original_cell2_d(self, updated_cell2_d_index: int) -> int:
            pass
        def cell2_d_updated_cell2_ds(
            self,
            cell2_d_index: int,
            updated_cell2_d_ids: std.list[int]
            ) -> bool:
            pass

        def cell2_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell2_ds_initialize_neighbour_cell3_ds(
            self,
            number_neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell2_d_initialize_neighbour_cell3_ds(
            self,
            cell2_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell2_d_initialize_neighbour_cell3_ds(
            self,
            cell2_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell2_d_insert_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            pass
        def cell2_d_number_neighbour_cell3_d(self, cell2_d_index: int) -> int:
            pass
        def cell2_d_neighbour_cell3_d(self, cell2_d_index: int, neighbour_index: int) -> int:
            pass
        def cell2_d_neighbour_cell3_ds(self, cell2_d_index: int) -> List[int]:
            pass
        def cell2_d_has_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell2_d_reset_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> None:
            pass
        def cell2_d_initialize_double_properties(self, number_double_properties: int) -> None:
            pass
        def cell2_d_add_double_property(self, property_id: str) -> int:
            pass
        def cell2_ds_initialize_double_property_values(
            self,
            property_index: int,
            property_sizes: List[int]
            ) -> None:
            pass
        def cell2_d_initialize_double_property_values(
            self,
            cell2_d_index: int,
            property_index: int,
            property_size: int
            ) -> None:
            pass
        def cell2_d_insert_double_property_value(
            self,
            cell2_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            pass
        def cell2_d_number_double_properties(self) -> int:
            pass
        def cell2_d_double_property_id(self, property_index: int) -> str:
            pass
        def cell2_d_double_property_exists(self, property_id: str) -> bool:
            pass
        def cell2_d_double_property_index(self, property_id: str) -> int:
            pass
        def cell2_d_double_property_size(self, cell2_d_index: int, property_index: int) -> int:
            pass
        def cell2_d_double_property_value(
            self,
            cell2_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            pass

        def cell2_ds_initialize_sub_division(self, number_sub_divisions: List[int]) -> None:
            pass

        def cell2_d_initialize_sub_division(
            self,
            cell2_d_index: int,
            number_sub_division: int
            ) -> None:
            pass
        def cell2_d_insert_sub_division(
            self,
            cell2_d_index: int,
            sub_division_index: int,
            cell0_d_index: int
            ) -> None:
            pass
        def cell2_d_number_sub_division(self, cell2_d_index: int) -> int:
            pass
        def cell2_d_sub_division_cell0_d(
            self,
            cell2_d_index: int,
            sub_division_index: int
            ) -> int:
            pass

        def cell3_ds_initialize(self, number_cell3_ds: int) -> None:
            pass
        def cell3_d_append(self, number_cell3_ds: int) -> int:
            pass
        def cell3_d_remove(self, cell3_d_index: int) -> None:
            pass
        def cell3_d_set_marker(self, cell3_d_index: int, marker: int) -> None:
            pass
        def cell3_d_set_state(self, cell3_d_index: int, state: bool) -> None:
            pass
        def cell3_ds_initialize_vertices(self, number_cell3_ds_vertices: List[int]) -> None:
            pass
        def cell3_ds_initialize_edges(self, number_cell3_ds_edges: List[int]) -> None:
            pass
        def cell3_ds_initialize_faces(self, number_cell3_ds_faces: List[int]) -> None:
            pass
        def cell3_d_initialize_vertices(
            self,
            cell3_d_index: int,
            number_cell3_d_vertices: int
            ) -> None:
            pass
        def cell3_d_initialize_edges(
            self,
            cell3_d_index: int,
            number_cell3_d_edges: int
            ) -> None:
            pass
        def cell3_d_initialize_faces(
            self,
            cell3_d_index: int,
            number_cell3_d_faces: int
            ) -> None:
            pass
        def cell3_d_insert_vertex(
            self,
            cell3_d_index: int,
            vertex_index: int,
            vertex_cell0_d_index: int
            ) -> None:
            pass
        def cell3_d_insert_edge(
            self,
            cell3_d_index: int,
            edge_index: int,
            edge_cell1_d_index: int
            ) -> None:
            pass
        def cell3_d_insert_face(
            self,
            cell3_d_index: int,
            face_index: int,
            face_cell2_d_index: int
            ) -> None:
            pass
        def cell3_d_add_vertices(
            self,
            cell3_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            pass
        def cell3_d_add_edges(
            self,
            cell3_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            pass
        def cell3_d_add_faces(
            self,
            cell3_d_index: int,
            faces_cell2_d_indices: List[int]
            ) -> None:
            pass

        def cell3_d_find_vertex(self, cell3_d_index: int, cell0_d_index: int) -> int:
            pass
        def cell3_d_find_edge(self, cell3_d_index: int, cell1_d_index: int) -> int:
            pass
        def cell3_d_find_face(self, cell3_d_index: int, cell2_d_index: int) -> int:
            pass

        def cell3_d_find_edge_by_extremes(
            self,
            cell3_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            pass

        def cell3_d_total_number(self) -> int:
            pass
        def cell3_d_number_vertices(self, cell3_d_index: int) -> int:
            pass
        def cell3_d_number_edges(self, cell3_d_index: int) -> int:
            pass
        def cell3_d_number_faces(self, cell3_d_index: int) -> int:
            pass
        def cell3_d_vertices(self, cell3_d_index: int) -> List[int]:
            pass
        def cell3_d_vertex(self, cell3_d_index: int, vertex_index: int) -> int:
            pass
        def cell3_d_vertex_coordinates(
            self,
            cell3_d_index: int,
            vertex_index: int
            ) -> Eigen.Vector3d:
            pass
        def cell3_d_vertices_coordinates(self, cell3_d_index: int) -> Eigen.MatrixXd:
            pass
        def cell3_d_edges(self, cell3_d_index: int) -> List[int]:
            pass
        def cell3_d_edge(self, cell3_d_index: int, edge_index: int) -> int:
            pass
        def cell3_d_faces(self, cell3_d_index: int) -> List[int]:
            pass
        def cell3_d_face(self, cell3_d_index: int, face_index: int) -> int:
            pass
        def cell3_ds_faces_vertices(self) -> List[List[List[int]]]:
            pass
        def cell3_ds_vertices(self) -> List[List[int]]:
            pass
        def cell3_ds_edges(self) -> List[List[int]]:
            pass
        def cell3_ds_faces(self) -> List[List[int]]:
            pass
        def cell3_d_marker(self, cell3_d_index: int) -> int:
            pass
        def cell3_ds_marker(self) -> List[int]:
            pass
        def cell3_d_is_active(self, cell3_d_index: int) -> bool:
            pass

        def cell3_d_has_updated_cell3_ds(self, cell3_d_index: int) -> bool:
            pass
        def cell3_d_number_updated_cell3_ds(self, cell3_d_index: int) -> int:
            pass
        def cell3_d_has_updated_cell3_d(
            self,
            cell3_d_index: int,
            updated_cell3_d_idex: int
            ) -> bool:
            pass
        def cell3_d_insert_updated_cell3_d(
            self,
            cell3_d_index: int,
            updated_cell3_d_idex: int
            ) -> None:
            pass
        def cell3_d_updated_cell3_ds(
            self,
            cell3_d_index: int,
            updated_cell3_d_ids: std.list[int]
            ) -> bool:
            pass
        def cell3_d_has_original_cell3_d(self, updated_cell3_d_index: int) -> bool:
            pass
        def cell3_d_original_cell3_d(self, updated_cell3_d_index: int) -> int:
            pass

        def cell3_d_initialize_double_properties(self, number_double_properties: int) -> None:
            pass
        def cell3_d_add_double_property(self, property_id: str) -> int:
            pass
        def cell3_ds_initialize_double_property_values(
            self,
            property_index: int,
            property_sizes: List[int]
            ) -> None:
            pass
        def cell3_d_initialize_double_property_values(
            self,
            cell3_d_index: int,
            property_index: int,
            property_size: int
            ) -> None:
            pass
        def cell3_d_insert_double_property_value(
            self,
            cell3_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            pass
        def cell3_d_number_double_properties(self) -> int:
            pass
        def cell3_d_double_property_id(self, property_index: int) -> str:
            pass
        def cell3_d_double_property_exists(self, property_id: str) -> bool:
            pass
        def cell3_d_double_property_index(self, property_id: str) -> int:
            pass
        def cell3_d_double_property_size(self, cell3_d_index: int, property_index: int) -> int:
            pass
        def cell3_d_double_property_value(
            self,
            cell3_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            pass

        def compress(self) -> None:
            pass

        def to_string(self) -> str:
            pass

# </submodule gedim>
####################    </generated_from:MeshMatricesDAO.hpp>    ####################


####################    <generated_from:MeshUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshUtilities:
        """/ \brief MeshUtilities
        / \copyright See top level LICENSE file for details.
        (final class)
        """
        class CheckMesh2DConfiguration:
            """
            (final class)
            """
            cell0_d_check_coordinates2_d: bool = True
            cell0_d_check_duplications: bool = True
            cell1_d_check_duplications: bool = True
            cell1_d_check_neighbours: bool = True
            cell1_d_check_measure: bool = True
            cell2_d_check_edges: bool = True
            cell2_d_check_duplications: bool = True
            cell2_d_check_convexity: bool = True
            cell2_d_check_measure: bool = True
            def __init__(
                self,
                cell0_d_check_coordinates2_d: bool = True,
                cell0_d_check_duplications: bool = True,
                cell1_d_check_duplications: bool = True,
                cell1_d_check_neighbours: bool = True,
                cell1_d_check_measure: bool = True,
                cell2_d_check_edges: bool = True,
                cell2_d_check_duplications: bool = True,
                cell2_d_check_convexity: bool = True,
                cell2_d_check_measure: bool = True
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CheckMesh3DConfiguration:
            """
            (final class)
            """
            cell0_d_check_duplications: bool = True
            cell1_d_check_duplications: bool = True
            cell1_d_check_measure: bool = True
            cell2_d_check_edges: bool = True
            cell2_d_check_duplications: bool = True
            cell2_d_check_convexity: bool = True
            cell2_d_check_measure: bool = True
            cell3_d_check_duplications: bool = True
            cell3_d_check_edges: bool = True
            cell3_d_check_edges_are_active: bool = True
            cell3_d_check_convexity: bool = True
            cell3_d_check_measure: bool = True
            def __init__(
                self,
                cell0_d_check_duplications: bool = True,
                cell1_d_check_duplications: bool = True,
                cell1_d_check_measure: bool = True,
                cell2_d_check_edges: bool = True,
                cell2_d_check_duplications: bool = True,
                cell2_d_check_convexity: bool = True,
                cell2_d_check_measure: bool = True,
                cell3_d_check_duplications: bool = True,
                cell3_d_check_edges: bool = True,
                cell3_d_check_edges_are_active: bool = True,
                cell3_d_check_convexity: bool = True,
                cell3_d_check_measure: bool = True
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CheckMeshGeometricData3DConfiguration:
            """
            (final class)
            """
            cell1_d_check_measure: bool = True
            cell1_d_check_normals: bool = True
            cell2_d_check_measure: bool = True
            cell2_d_check_triangles: bool = True
            cell2_d_check_normals: bool = True
            cell3_d_check_measure: bool = True
            cell3_d_check_tetrahedra: bool = True
            cell1_d_quadrature_order: int = 0
            cell2_d_quadrature_order: int = 0
            cell3_d_quadrature_order: int = 0
            def __init__(
                self,
                cell1_d_check_measure: bool = True,
                cell1_d_check_normals: bool = True,
                cell2_d_check_measure: bool = True,
                cell2_d_check_triangles: bool = True,
                cell2_d_check_normals: bool = True,
                cell3_d_check_measure: bool = True,
                cell3_d_check_tetrahedra: bool = True
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class ExtractActiveMeshData:
            """
            (final class)
            """
            old_cell0_d_to_new_cell0_d: std.unordered_map[int, int]                                             #/< each pair is {old Cell0D index, new
            #/< Cell0D index}
            old_cell1_d_to_new_cell1_d: std.unordered_map[int, int]                                             #/< each pair is {old Cell1D index, new
            #/< Cell1D index}
            old_cell2_d_to_new_cell2_d: std.unordered_map[int, int]                                             #/< each pair is {old Cell2D index, new
            #/< Cell2D index}
            old_cell3_d_to_new_cell3_d: std.unordered_map[int, int]                                             #/< each pair is {old Cell3D index, new
            #/< Cell3D index}
            new_cell0_d_to_old_cell0_d: std.unordered_map[int, int]                                             #/< each pair is {new Cell0D index, old
            #/< Cell0D index}
            new_cell1_d_to_old_cell1_d: std.unordered_map[int, int]                                             #/< each pair is {new Cell1D index, old
            #/< Cell1D index}
            new_cell2_d_to_old_cell2_d: std.unordered_map[int, int]                                             #/< each pair is {new Cell2D index, old
            #/< Cell2D index}
            new_cell3_d_to_old_cell3_d: std.unordered_map[int, int]                                             #/< each pair is {new Cell3D index, old
            #/< Cell3D index}
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class FilterMeshData:
            """
            (final class)
            """
            cell0_ds: List[int]
            cell1_ds: List[int]
            cell2_ds: List[int]
            cell3_ds: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class ExtractMeshData:
            """
            (final class)
            """
            old_cell0_d_to_new_cell0_d: List[int] = List[int]()                                                 #/< each element is [old Cell0D index] = new Cell0D index
            old_cell1_d_to_new_cell1_d: List[int] = List[int]()                                                 #/< each element is [old Cell1D index] = new Cell1D index
            old_cell2_d_to_new_cell2_d: List[int] = List[int]()                                                 #/< each element is [old Cell2D index] = new Cell2D index
            old_cell3_d_to_new_cell3_d: List[int] = List[int]()                                                 #/< each element is [old Cell3D index] = new Cell3D index
            new_cell0_d_to_old_cell0_d: List[int] = List[int]()                                                 #/< each element is [new Cell0D index] = old Cell0D index
            new_cell1_d_to_old_cell1_d: List[int] = List[int]()                                                 #/< each element is [new Cell1D index] = old Cell1D index
            new_cell2_d_to_old_cell2_d: List[int] = List[int]()                                                 #/< each element is [new Cell2D index] = old Cell2D index
            new_cell3_d_to_old_cell3_d: List[int] = List[int]()                                                 #/< each element is [new Cell3D index] = old Cell3D index
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class ComputeMesh2DCell1DsResult:
            """
            (final class)
            """
            cell1_ds: Eigen.MatrixXi                                                                            #/ Cell1Ds vertices, size 2 x Cell1DTotalNumber()
            cell2_ds: List[Eigen.MatrixXi]                                                                      #/< Cell2Ds vertices and edges, size
            #/< Cell2DTotalNumber()x2xCell2DNumberVertices()
            def __init__(
                self,
                cell1_ds: Eigen.MatrixXi = Eigen.MatrixXi(),
                cell2_ds: List[Eigen.MatrixXi] = List[Eigen.MatrixXi]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class ComputeMesh3DAlignedCell1DsResult:
            """
            (final class)
            """

            aligned_cell1_ds: Eigen.MatrixXi
            cell0_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi]
            cell1_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi]
            cell3_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi]
            aligned_cell1_ds_sub_cell0_ds: List[List[int]]
            aligned_cell1_ds_sub_cell1_ds: List[List[int]]
            aligned_cell1_ds_cell3_ds: List[List[int]]
            def __init__(
                self,
                aligned_cell1_ds: Eigen.MatrixXi = Eigen.MatrixXi(),
                cell0_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                cell1_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                cell3_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi] = List[Eigen.MatrixXi]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class MeshGeometricData1D:
            """
            (final class)
            """
            cell1_ds_bounding_box: List[Eigen.MatrixXd]
            cell1_ds_vertices: List[Eigen.MatrixXd]                                                             #/< cell1D vertices coordinates
            cell1_ds_tangents: List[Eigen.Vector3d]                                                             #/< cell1D tangents
            cell1_ds_lengths: List[float]                                                                       #/< cell1D lengths
            cell1_ds_squared_lengths: List[float]                                                               #/< cell1D squared lengths
            cell1_ds_centroids: List[Eigen.Vector3d]                                                            #/< cell1D centroids
            def __init__(
                self,
                cell1_ds_bounding_box: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell1_ds_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell1_ds_tangents: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                cell1_ds_lengths: List[float] = List[float](),
                cell1_ds_squared_lengths: List[float] = List[float](),
                cell1_ds_centroids: List[Eigen.Vector3d] = List[Eigen.Vector3d]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class MeshGeometricData2D:
            """
            (final class)
            """
            cell2_ds_bounding_box: List[Eigen.MatrixXd]
            cell2_ds_vertices: List[Eigen.MatrixXd]                                                             #/< cell2D vertices coordinates
            cell2_ds_triangulations: List[List[Eigen.Matrix3d]]                                                 #/< cell2D triangulations
            cell2_ds_areas: List[float]                                                                         #/< cell2D areas
            cell2_ds_centroids: List[Eigen.Vector3d]                                                            #/< cell2D centroids
            cell2_ds_diameters: List[float]                                                                     #/< cell2D diameters
            cell2_ds_edge_directions: List[List[bool]]                                                          #/< cell2D edge directions
            cell2_ds_edges_centroid: List[Eigen.MatrixXd]                                                       #/< cell2D edge centroid
            cell2_ds_edge_lengths: List[Eigen.VectorXd]                                                         #/< cell2D edge lengths
            cell2_ds_edge_tangents: List[Eigen.MatrixXd]                                                        #/< cell2D edge tangents
            cell2_ds_edge_normals: List[Eigen.MatrixXd]                                                         #/< cell2D edge normals
            def __init__(
                self,
                cell2_ds_bounding_box: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell2_ds_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell2_ds_triangulations: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]](),
                cell2_ds_areas: List[float] = List[float](),
                cell2_ds_centroids: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                cell2_ds_diameters: List[float] = List[float](),
                cell2_ds_edge_directions: List[List[bool]] = List[List[bool]](),
                cell2_ds_edges_centroid: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell2_ds_edge_lengths: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                cell2_ds_edge_tangents: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell2_ds_edge_normals: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class MeshGeometricData3D:
            """
            (final class)
            """
            cell3_ds_vertices: List[Eigen.MatrixXd]
            cell3_ds_edges: List[Eigen.MatrixXi]
            cell3_ds_faces: List[List[Eigen.MatrixXi]]
            cell3_ds_bounding_box: List[Eigen.MatrixXd]
            cell3_ds_volumes: List[float]
            cell3_ds_diameters: List[float]
            cell3_ds_centroids: List[Eigen.Vector3d]
            cell3_ds_edges_centroid: List[Eigen.MatrixXd]
            cell3_ds_edge_lengths: List[Eigen.VectorXd]
            cell3_ds_edge_tangents: List[Eigen.MatrixXd]
            cell3_ds_edge_directions: List[List[bool]]
            cell3_ds_tetrahedron_points: List[List[Eigen.MatrixXd]]
            cell3_ds_faces_translations: List[List[Eigen.Vector3d]]
            cell3_ds_faces_rotation_matrices: List[List[Eigen.Matrix3d]]
            cell3_ds_faces_normals: List[List[Eigen.Vector3d]]
            cell3_ds_faces_tangents: List[List[List[Eigen.Vector3d]]]
            cell3_ds_faces_normal_directions: List[List[bool]]
            cell3_ds_faces_normal_global_direction: List[List[bool]]
            cell3_ds_faces_tangents_global_direction: List[List[List[bool]]]
            cell3_ds_faces_edge_directions: List[List[List[bool]]]
            cell3_ds_faces3_d_vertices: List[List[Eigen.MatrixXd]]                                              #/< faces vertices 3D coordinates
            cell3_ds_faces2_d_vertices: List[List[Eigen.MatrixXd]]                                              #/< faces vertices 2D coordinates
            cell3_ds_faces3_d_triangulations: List[List[List[Eigen.Matrix3d]]]                                  #/< faces triangulations
            #/< 2D
            cell3_ds_faces2_d_triangulations: List[List[List[Eigen.Matrix3d]]]                                  #/< faces triangulations
            #/< 2D
            cell3_ds_faces_areas: List[List[float]]                                                             #/< faces areas
            cell3_ds_faces2_d_centroids: List[List[Eigen.Vector3d]]                                             #/< faces centroids
            cell3_ds_faces_diameters: List[List[float]]                                                         #/< faces diameters
            cell3_ds_faces_edge_lengths: List[List[Eigen.VectorXd]]                                             #/< faces edge lengths
            cell3_ds_faces_edge3_d_tangents: List[List[Eigen.MatrixXd]]                                         #/< faces edge 3D tangents
            cell3_ds_faces_edges3_d_centroid: List[List[Eigen.MatrixXd]]
            cell3_ds_faces_edge2_d_tangents: List[List[Eigen.MatrixXd]]                                         #/< faces edge 2D tangents
            cell3_ds_faces_edges2_d_centroid: List[List[Eigen.MatrixXd]]
            cell3_ds_faces_edge2_d_normals: List[List[Eigen.MatrixXd]]                                          #/< faces edge normals
            def __init__(
                self,
                cell3_ds_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell3_ds_edges: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                cell3_ds_faces: List[List[Eigen.MatrixXi]] = List[List[Eigen.MatrixXi]](),
                cell3_ds_bounding_box: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell3_ds_volumes: List[float] = List[float](),
                cell3_ds_diameters: List[float] = List[float](),
                cell3_ds_centroids: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                cell3_ds_edges_centroid: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell3_ds_edge_lengths: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                cell3_ds_edge_tangents: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell3_ds_edge_directions: List[List[bool]] = List[List[bool]](),
                cell3_ds_tetrahedron_points: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_translations: List[List[Eigen.Vector3d]] = List[List[Eigen.Vector3d]](),
                cell3_ds_faces_rotation_matrices: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]](),
                cell3_ds_faces_normals: List[List[Eigen.Vector3d]] = List[List[Eigen.Vector3d]](),
                cell3_ds_faces_normal_directions: List[List[bool]] = List[List[bool]](),
                cell3_ds_faces_normal_global_direction: List[List[bool]] = List[List[bool]](),
                cell3_ds_faces_edge_directions: List[List[List[bool]]] = List[List[List[bool]]](),
                cell3_ds_faces3_d_vertices: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces2_d_vertices: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces3_d_triangulations: List[List[List[Eigen.Matrix3d]]] = List[List[List[Eigen.Matrix3d]]](),
                cell3_ds_faces2_d_triangulations: List[List[List[Eigen.Matrix3d]]] = List[List[List[Eigen.Matrix3d]]](),
                cell3_ds_faces_areas: List[List[float]] = List[List[float]](),
                cell3_ds_faces2_d_centroids: List[List[Eigen.Vector3d]] = List[List[Eigen.Vector3d]](),
                cell3_ds_faces_diameters: List[List[float]] = List[List[float]](),
                cell3_ds_faces_edge_lengths: List[List[Eigen.VectorXd]] = List[List[Eigen.VectorXd]](),
                cell3_ds_faces_edge3_d_tangents: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_edges3_d_centroid: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_edge2_d_tangents: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_edges2_d_centroid: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_edge2_d_normals: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class VTPPolyhedron:
            """
            (final class)
            """
            vertices: Eigen.MatrixXd                                                                            #/ size 3xnumVertices
            polyhedron_faces: List[List[int]]                                                                   #/ size numFaces x numFaceVertices
            def __init__(self, vertices: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class AgglomerateTrianglesResult:
            """
            (final class)
            """
            removed_edges: List[int]
            vertices_index: List[int]
            edges_index: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class AgglomerateMeshFromTriangularMeshResult:
            """
            (final class)
            """
            class ConcaveCell2D:
                cell2_d_index: int
                convex_cell2_ds_index: List[int]
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            concave_cell2_ds: List[ConcaveCell2D]
            removed_cell1_ds: List[int]
            removed_cell2_ds: List[int]
            def __init__(
                self,
                concave_cell2_ds: List[ConcaveCell2D] = List[ConcaveCell2D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class AgglomerationInformation:
            """
            (final class)
            """
            original_cell0_d_to_agglomerated_cell0_ds: List[int] = List[int]()
            original_cell1_d_to_agglomerated_cell1_ds: List[int] = List[int]()
            original_cell2_d_to_agglomerated_cell2_ds: List[int] = List[int]()
            agglomerated_cell0_d_to_original_cell0_ds: List[int] = List[int]()
            agglomerated_cell1_d_to_original_cell1_ds: List[List[int]] = List[List[int]]()
            agglomerated_cell2_d_to_original_cell2_ds: List[List[int]] = List[List[int]]()
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class AgglomerateCell1DInformation:
            """
            (final class)
            """
            agglomerate_cell1_d_vertices: List[int]
            sub_cell1_ds_removed_vertices: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class AgglomerateCell2DInformation:
            """
            (final class)
            """
            agglomerate_cell2_d_vertices: List[int]
            agglomerate_cell2_d_edges: List[int]
            sub_cell2_ds_removed_vertices: List[int]
            sub_cell2_ds_removed_edges: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class AgglomerateCell3DInformation:
            """
            (final class)
            """
            agglomerate_cell3_d_vertices: List[int]
            agglomerate_cell3_d_edges: List[int]
            agglomerate_cell3_d_faces: List[int]
            sub_cell3_ds_removed_vertices: List[int]
            sub_cell3_ds_removed_edges: List[int]
            sub_cell3_ds_removed_faces: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class FindConcaveCell3DFacesConvexCell2DResult:
            """
            (final class)
            """
            class ConvexCell2D:
                """
                (final class)
                """
                convex_cell3_d_index: int = 0
                convex_cell3_d_face_index: int = 0
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            concave_cell3_d_faces_convex_cell2_d: List[ConvexCell2D] = List[ConvexCell2D]()
            def __init__(
                self,
                concave_cell3_d_faces_convex_cell2_d: List[ConvexCell2D] = List[ConvexCell2D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Mesh3DPolyhedron:
            """
            (final class)
            """
            vertices_index: List[int]
            edges_index: List[int]
            faces_index: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class FindPointMeshPositionResult:
            """
            (final class)
            """
            class PointMeshPosition:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                       # (= 0)
                    outside = enum.auto()                                                                       # (= 1)
                    cell0_d = enum.auto()                                                                       # (= 2)
                    cell1_d = enum.auto()                                                                       # (= 3)
                    cell2_d = enum.auto()                                                                       # (= 4)
                    cell3_d = enum.auto()                                                                       # (= 5)

                type: Types
                cell_index: int
                def __init__(self, type: Types = Types()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            mesh_positions: List[PointMeshPosition]
            def __init__(
                self,
                mesh_positions: List[PointMeshPosition] = List[PointMeshPosition]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class FindPointCell2DResult:
            """
            (final class)
            """
            class PointCell2DFound:
                """
                (final class)
                """
                cell2_d_index: int
                cell2_d_position: GeometryUtilities.PointPolygonPositionResult
                def __init__(
                    self,
                    cell2_d_position: GeometryUtilities.PointPolygonPositionResult = GeometryUtilities.PointPolygonPositionResult()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            cell2_ds_found: List[PointCell2DFound]
            def __init__(
                self,
                cell2_ds_found: List[PointCell2DFound] = List[PointCell2DFound]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class FindPointCell3DResult:
            """
            (final class)
            """
            class PointCell3DFound:
                """
                (final class)
                """
                cell3_d_index: int
                cell3_d_position: GeometryUtilities.PointPolyhedronPositionResult
                def __init__(
                    self,
                    cell3_d_position: GeometryUtilities.PointPolyhedronPositionResult = GeometryUtilities.PointPolyhedronPositionResult()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            cell3_ds_found: List[PointCell3DFound]
            def __init__(
                self,
                cell3_ds_found: List[PointCell3DFound] = List[PointCell3DFound]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Intersect_mesh_polyhedron_result:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                none = enum.auto()                                                                              # (= 1)  #/< No intersection found
                vertices = enum.auto()                                                                          # (= 2)  #/< Vertices

            class Polyhedron_Intersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    vertex = enum.auto()                                                                        # (= 1)
                    edge = enum.auto()                                                                          # (= 2)
                    face = enum.auto()                                                                          # (= 3)
                    polyhedron = enum.auto()                                                                    # (= 4)

                type: Types
                geometry_index: int
                cell0_ds_index: List[int]
                cell1_ds_index: List[int]
                cell2_ds_index: List[int]
                cell3_ds_index: List[int]
                def __init__(self, type: Types = Types()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class Mesh_Intersections:
                """
                (final class)
                """
                cell0_ds_intersections: Dict[int, int]
                cell1_ds_intersections: Dict[int, List[int]]
                cell2_ds_intersections: Dict[int, List[int]]
                cell3_ds_intersections: Dict[int, List[int]]
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            type: Types
            intersections_coordinates: Eigen.MatrixXd
            polyhedron_intersections: List[Polyhedron_Intersection]
            mesh_intersections: Mesh_Intersections
            def __init__(
                self,
                type: Types = Types(),
                intersections_coordinates: Eigen.MatrixXd = Eigen.MatrixXd(),
                polyhedron_intersections: List[Polyhedron_Intersection] = List[Polyhedron_Intersection](),
                mesh_intersections: Mesh_Intersections = Mesh_Intersections()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def extract_active_mesh(
            self,
            mesh: IMeshDAO,
            extraction_data: MeshUtilities.ExtractActiveMeshData
            ) -> None:
            """/ \brief Extract Active Cells from mesh
            / \note the resulting mesh has no inactive elements
            """
            pass

        def filter_active_mesh(self, mesh: IMeshDAO) -> MeshUtilities.FilterMeshData:
            pass

        def filter_mesh1_d(
            self,
            cell1_ds_filter: List[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.FilterMeshData:
            """/ \brief Extract mesh1D cells from a mesh"""
            pass

        def filter_mesh2_d(
            self,
            cell2_ds_filter: List[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.FilterMeshData:
            """/ \brief Extract mesh2D cells from a mesh"""
            pass

        def filter_mesh3_d(
            self,
            cell3_ds_filter: List[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.FilterMeshData:
            """/ \brief Extract mesh3D cells from a mesh"""
            pass

        def extract_mesh1_d(
            self,
            cell0_ds_filter: List[int],
            cell1_ds_filter: List[int],
            original_mesh: IMeshDAO,
            mesh: IMeshDAO
            ) -> MeshUtilities.ExtractMeshData:
            pass

        def extract_mesh2_d(
            self,
            cell0_ds_filter: List[int],
            cell1_ds_filter: List[int],
            cell2_ds_filter: List[int],
            original_mesh: IMeshDAO,
            mesh: IMeshDAO
            ) -> MeshUtilities.ExtractMeshData:
            pass

        def extract_mesh3_d(
            self,
            cell0_ds_filter: List[int],
            cell1_ds_filter: List[int],
            cell2_ds_filter: List[int],
            cell3_ds_filter: List[int],
            original_mesh: IMeshDAO,
            mesh: IMeshDAO
            ) -> MeshUtilities.ExtractMeshData:
            pass

        def fill_mesh1_d(
            self,
            geometry_utilities: GeometryUtilities,
            segment_origin: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            coordinates: List[float],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Fill Mesh 1D From segment Coordinates
            / \param segmentOrigin the segment origin
            / \param segmentTangent the segment tangent vector
            / \param coordinates relative coordinates between [0.0, 1.0]
            / \param mesh the resulting mesh
            """
            pass

        def fill_mesh2_d(
            self,
            cell0_ds: Eigen.MatrixXd,
            cell1_ds: Eigen.MatrixXi,
            cell2_ds: List[Eigen.MatrixXi],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Fill a Mesh 2D with vertices, edges and polygons
            / \param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()
            / \param cell1Ds the origin and end as Eigen MatrixXd of cell1Ds, size 2xCell1DTotalNumber()
            / \param cell2Ds the vertices and edges indices of the cell2Ds ordered counterclockwise, size
            / Cell2DTotalNumber()x2xCell2DNumberVertices()
            """
            pass

        def fill_mesh3_d(
            self,
            cell0_ds: Eigen.MatrixXd,
            cell1_ds: Eigen.MatrixXi,
            cell2_ds: List[Eigen.MatrixXi],
            cell3_ds: List[MeshUtilities.Mesh3DPolyhedron],
            mesh: IMeshDAO
            ) -> None:
            pass

        def compute_mesh2_d_cell1_ds(
            self,
            cell0_ds: Eigen.MatrixXd,
            cell2_ds: List[Eigen.VectorXi]
            ) -> MeshUtilities.ComputeMesh2DCell1DsResult:
            """/ \brief Compute edges in a Mesh 2D with vertices and polygons
            / \param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()
            / \param cell2Ds the vertices indices of the cell2Ds ordered counterclockwise, size
            / Cell2DTotalNumber()xCell2DNumberVertices() \return the Cell1Ds data
            """
            pass

        def check_mesh2_d(
            self,
            configuration: MeshUtilities.CheckMesh2DConfiguration,
            geometry_utilities: GeometryUtilities,
            convex_mesh: IMeshDAO
            ) -> None:
            """/ \brief Check Mesh2D correctness
            / \param geometryUtilities the geometry utilities
            / \param convexMesh a convex 2D mesh
            """
            pass

        def check_mesh3_d(
            self,
            configuration: MeshUtilities.CheckMesh3DConfiguration,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Check Mesh3D correctness
            / \param geometryUtilities the geometry utilities
            / \param mesh a 3D mesh
            """
            pass

        def compute_mesh3_d_aligned_cell1_ds(
            self,
            cell3_ds_aligned_edges_vertices: List[List[List[int]]],
            cell3_ds_aligned_edges_edges: List[List[List[int]]],
            mesh: IMeshDAO
            ) -> MeshUtilities.ComputeMesh3DAlignedCell1DsResult:
            """/ \brief Compute edges in a Mesh 2D with vertices and polygons
            / \param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()
            / \param cell2Ds the vertices indices of the cell2Ds ordered counterclockwise, size
            / Cell2DTotalNumber()xCell2DNumberVertices() \return the Cell1Ds data
            """
            pass

        def check_mesh_geometric_data3_d(
            self,
            configuration: MeshUtilities.CheckMeshGeometricData3DConfiguration,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            geometric_data: MeshUtilities.MeshGeometricData3D
            ) -> None:
            """/ \brief Check MeshGeometricData3D correctness
            / \param geometryUtilities the geometry utilities
            / \param mesh the 3D mesh
            / \param geometricData the mesh geometric data
            """
            pass

        def mesh1_d_from_segment(
            self,
            geometry_utilities: GeometryUtilities,
            segment_vertices: Eigen.MatrixXd,
            vertex_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Create a Mesh 1D with a segment
            / \param segmentVertices the segment coordinates, size 3x2
            / \param vertexMarkers mesh markers of vertices, size 1xNumPolygonVertices()
            """
            pass

        def mesh2_d_from_polygon(
            self,
            polygon_vertices: Eigen.MatrixXd,
            vertex_markers: List[int],
            edge_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Create a Mesh 2D with a polygon
            / \param polygonVertices the polygon coordinates, size 3xNumPolygonVertices()
            / \param vertexMarkers mesh markers of vertices, size 1xNumPolygonVertices()
            / \param edgeMarkers mesh markers of edges, size 1xNumPolygonVertices()
            """
            pass

        def set_mesh_markers_on_line(
            self,
            geometry_utilities: GeometryUtilities,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d,
            line_tangent_squared_length: float,
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Set the marker on all the mesh 2D elements laying on the line
            / \param geometryUtilities the geometry utilities
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \param lineTangentSquaredLength the line tangent squared length
            / \param marker the marker
            / \param mesh the mesh
            """
            pass

        def set_mesh_markers_on_segment(
            self,
            geometry_utilities: GeometryUtilities,
            segment_origin: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            segment_tangent_squared_length: float,
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            pass

        def mesh3_d_from_polyhedron(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            vertex_markers: List[int],
            edge_markers: List[int],
            face_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Create a Mesh 3D with a polyhedron
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param vertexMarkers mesh markers of vertices, size 1xnumVertices
            / \param edgeMarkers mesh markers of edges, size 1xnumEdges
            / \param faceMarkers mesh markers of faces, size 1xnumFaces
            """
            pass

        def set_mesh_markers_on_plane(
            self,
            geometry_utilities: GeometryUtilities,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Set the marker on all the mesh 3D elements laying on the plane
            / \param geometryUtilities the geometry utilities
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \param marker the marker
            / \param mesh the mesh
            """
            pass

        def set_mesh_markers_by_face_normal(
            self,
            geometry_utilities: GeometryUtilities,
            normal: Eigen.Vector3d,
            cell2_ds_normal: List[Eigen.Vector3d],
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            pass

        @overload
        def set_mesh_markers_on_polygon(
            self,
            geometry_utilities: GeometryUtilities,
            polygon_plane_normal: Eigen.Vector3d,
            polygon_plane_origin: Eigen.Vector3d,
            polygon_vertices_2_d: Eigen.MatrixXd,
            polygon_translation: Eigen.Vector3d,
            polygon_rotation_matrix: Eigen.Matrix3d,
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            """/ \warning Only for convex points"""
            pass

        @overload
        def set_mesh_markers_on_polygon(
            self,
            geometry_utilities: GeometryUtilities,
            polygon_plane_normal: Eigen.Vector3d,
            polygon_plane_origin: Eigen.Vector3d,
            polygon_vertices_2_d: Eigen.MatrixXd,
            polygon_translation: Eigen.Vector3d,
            polygon_rotation_matrix: Eigen.Matrix3d,
            cell1_ds_centroid: List[Eigen.Vector3d],
            cell2_ds_centroid: List[Eigen.Vector3d],
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            pass

        def mesh_cell2_d_roots(self, mesh: IMeshDAO) -> List[int]:
            """/ \brief Extract the mesh Cell2D Roots
            / \param mesh the mesh
            / \return the root cell for each cell2D, size 1xCell2DTotalNumber()
            """
            pass

        def fill_mesh1_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            convex_mesh: IMeshDAO
            ) -> MeshUtilities.MeshGeometricData1D:
            """/ \brief Fill Mesh1D Geometric Data given a mesh with convex mesh cells
            / \param convexMesh the convex mesh
            / \return the MeshGeometricData computed
            """
            pass

        def import_mesh_geometric_data1_d_from_txt(
            self,
            file_path: str
            ) -> MeshUtilities.MeshGeometricData1D:
            pass
        def export_mesh_geometric_data1_d_to_txt(
            self,
            mesh_geometric_data: MeshUtilities.MeshGeometricData1D,
            file_path: str
            ) -> None:
            pass

        @overload
        def fill_mesh2_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            convex_mesh: IMeshDAO
            ) -> MeshUtilities.MeshGeometricData2D:
            """/ \brief Fill Mesh2D Geometric Data given a mesh with convex mesh cells
            / \param convexMesh the convex mesh
            / \return the MeshGeometricData computed
            """
            pass

        @overload
        def fill_mesh2_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            mesh_cell2_ds_polygon_type: List[GeometryUtilities.PolygonTypes]
            ) -> MeshUtilities.MeshGeometricData2D:
            """/ \brief Fill Mesh2D Geometric Data given a mesh with mesh cells type
            / \param mesh the mesh
            / \param meshCell2DsPolygonType the cell2D polygon type
            / \return the MeshGeometricData computed
            """
            pass

        @overload
        def fill_mesh2_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            convex_mesh: IMeshDAO,
            mesh_cell2_d_to_convex_cell2_d_indices: List[List[int]]
            ) -> MeshUtilities.MeshGeometricData2D:
            """/ \brief Fill Mesh2D Geometric Data starting given a mesh with non convex mesh cells and its convex sub-mesh cells
            / \param mesh the mesh
            / \param convexMesh the convex mesh cells of mesh
            / \param meshCell2DToConvexCell2DIndices the collection of convex cell2Ds for each mesh cell2D
            / \return the MeshGeometricData computed
            """
            pass

        def import_mesh_geometric_data2_d_from_txt(
            self,
            file_path: str
            ) -> MeshUtilities.MeshGeometricData2D:
            pass
        def export_mesh_geometric_data2_d_to_txt(
            self,
            mesh_geometric_data: MeshUtilities.MeshGeometricData2D,
            file_path: str
            ) -> None:
            pass

        @overload
        def fill_mesh3_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            convex_mesh: IMeshDAO
            ) -> MeshUtilities.MeshGeometricData3D:
            """/ \brief Fill Mesh3D Geometric Data given a mesh with convex mesh cells
            / \param convexMesh the convex mesh
            / \return the MeshGeometricData computed
            """
            pass

        @overload
        def fill_mesh3_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            convex_mesh: IMeshDAO,
            mesh_cell3_d_to_convex_cell3_d_indices: List[List[int]]
            ) -> MeshUtilities.MeshGeometricData3D:
            """/ \brief Fill Mesh3D Geometric Data starting given a mesh with non convex mesh cells and its convex sub-mesh cells
            / \param mesh the mesh
            / \param convexMesh the convex mesh
            / \param meshCell2DToConvexCell2DIndices the collection of convex cell2Ds for each mesh cell2D
            / \param meshCell3DToConvexCell3DIndices the collection of convex cell3Ds for each mesh cell3D
            / \return the MeshGeometricData computed
            """
            pass

        @overload
        def fill_mesh3_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            cell3_ds_tetra_vertices: List[List[Eigen.MatrixXd]],
            cell2_ds_triangles_3_d_vertices: List[List[Eigen.Matrix3d]]
            ) -> MeshUtilities.MeshGeometricData3D:
            pass

        def import_mesh_geometric_data3_d_from_txt(
            self,
            file_path: str
            ) -> MeshUtilities.MeshGeometricData3D:
            pass
        def export_mesh_geometric_data3_d_to_txt(
            self,
            mesh_geometric_data: MeshUtilities.MeshGeometricData3D,
            file_path: str
            ) -> None:
            pass

        def compute_cell0_d_cell1_d_neighbours(self, mesh: IMeshDAO) -> None:
            pass
        def compute_cell0_d_cell2_d_neighbours(self, mesh: IMeshDAO) -> None:
            pass
        def compute_cell0_d_cell3_d_neighbours(self, mesh: IMeshDAO) -> None:
            pass

        def compute_cell1_d_cell2_d_neighbours(self, mesh: IMeshDAO) -> None:
            """/ \brief Compute Cell1D Cell2DNeighbours with given mesh data
            / \param mesh the resulting mesh
            """
            pass

        def compute_cell1_d_cell3_d_neighbours(self, mesh: IMeshDAO) -> None:
            """/ \brief Compute Cell1D Cell3DNeighbours with given mesh data
            / \param mesh the resulting mesh
            """
            pass

        def compute_cell2_d_cell3_d_neighbours(self, mesh: IMeshDAO) -> None:
            """/ \brief Compute Cell2D Cell3DNeighbours with given mesh data
            / \param mesh the resulting mesh
            """
            pass

        def create_rectangle_mesh(
            self,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            base_mesh_curvilinear_coordinates: List[float],
            height_mesh_curvilinear_coordinates: List[float],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Crete rectange Mesh on rectangle base x height
            / \param rectangleOrigin the rectangle origin point
            / \param rectangleBaseTangent the rectangle base tangent vector
            / \param rectangleHeightTangent the rectangle height tangent vector
            / \param baseMeshCurvilinearCoordinates the base mesh 1D curvilinear coordinates
            / \param heightMeshCurvilinearCoordinates the height mesh 1D curvilinear coordinates
            / \note markers on border are set as { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *
            / numVertices } for cell1Ds
            """
            pass

        def create_parallelepiped_mesh(
            self,
            rectangle_origin: Eigen.Vector3d,
            rectangle_length_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            rectangle_width_tangent: Eigen.Vector3d,
            length_mesh_curvilinear_coordinates: List[float],
            height_mesh_curvilinear_coordinates: List[float],
            width_mesh_curvilinear_coordinates: List[float],
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_triangle_plus_hanging_nodes_mesh(
            self,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            base_mesh_curvilinear_coordinates: List[float],
            height_mesh_curvilinear_coordinates: List[float],
            number_of_added_vertices_for_each_rectangle: List[int],
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_rectangle_plus_hanging_nodes_mesh(
            self,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            base_mesh_curvilinear_coordinates: List[float],
            height_mesh_curvilinear_coordinates: List[float],
            number_of_added_vertices_for_each_rectangle: List[int],
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_triangular_mesh(
            self,
            polygon_vertices: Eigen.MatrixXd,
            max_triangle_area: float,
            mesh: IMeshDAO,
            options: str = "-QDzpqnea"
            ) -> None:
            """/ \brief Create triangular mesh on 2D polygon
            / \param polygonVertices the 2D polygon vertices, size 3xnumVertices
            / \param maxTriangleArea the maximum triangular area
            / \param options mesh options, see https://www.cs.cmu.edu/~quake/triangle.switch.html
            / \note markers on border are set as { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *
            / numVertices } for cell1Ds \note use triangle library
            """
            pass

        def create_polygonal_mesh(
            self,
            geometry_utilities: GeometryUtilities,
            polygon_vertices: Eigen.MatrixXd,
            num_points: int,
            num_iterations: int,
            mesh: IMeshDAO,
            random_seed: int = 0
            ) -> None:
            pass

        #/ \brief Create tetrahedral mesh on 3D polyhedron
        #/ \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
        #/ \param polyhedronEdges the polyhedron edges, size 2 x numEdges
        #/ \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
        #/ \param maxTetrahedronVolume the maximum tetrahedron area
        #/ \param options mesh options, see https://wias-berlin.de/software/tetgen/1.5/doc/manual/manual005.html#cmd-q
        #/ \note markers on border are set as { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *
        #/ numVertices } for cell1Ds \note use tetgen library
        @overload
        def create_tetrahedral_mesh(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            max_tetrahedron_volume: float,
            mesh: IMeshDAO,
            options: str = "Qpqfezna"
            ) -> None:
            pass
        @overload
        def create_tetrahedral_mesh(
            self,
            points: Eigen.MatrixXd,
            facets: List[List[int]],
            max_tetrahedron_volume: float,
            mesh: IMeshDAO,
            options: str = "Qpqfezna"
            ) -> None:
            pass

        def create_delaunay_mesh3_d(
            self,
            points: Eigen.MatrixXd,
            points_marker: List[int],
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_polyhedral_mesh(
            self,
            geometry_utilities: GeometryUtilities,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            num_points: int,
            num_iterations: int,
            mesh: IMeshDAO,
            random_seed: int = 0
            ) -> None:
            pass

        def make_mesh_triangular_faces(
            self,
            faces_triangulation: List[List[int]],
            mesh: IMeshDAO
            ) -> None:
            pass

        def import_open_volume_mesh(
            self,
            ovm_file_path: str,
            mesh: IMeshDAO,
            mesh_cell3_ds_faces_orientation: List[List[bool]]
            ) -> None:
            """/ \brief Import 3D mesh from OVM file"""
            pass

        def export_mesh_to_open_volume(
            self,
            mesh: IMeshDAO,
            mesh_cell3_ds_faces_orientation: List[List[bool]],
            ovm_file_path: str
            ) -> None:
            """/ \brief Export 3D mesh to OVM file"""
            pass

        def import_vtk_mesh3_d(self, vtk_file_path: str, mesh: IMeshDAO) -> None:
            """/ \brief Import 3D mesh from VTK file"""
            pass

        def import_object_file_format(self, off_file_path: str, mesh: IMeshDAO) -> None:
            """/ \brief Import 2D mesh from OFF file"""
            pass

        def export_mesh_to_object_file_format(
            self,
            mesh: IMeshDAO,
            off_file_path: str
            ) -> None:
            """/ \brief Export 2D mesh to OFF file"""
            pass

        def change_polygon_mesh_markers(
            self,
            polygon_vertices: Eigen.MatrixXd,
            cell0_d_markers: List[int],
            cell1_d_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Change Polygon Mesh Markers from { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *
            / numVertices } for cell1Ds to cell0DMarkers and cell1DMarkers \param polygonVertices the 2D polygon vertices,
            / size 3xnumVertices \param cell0DMarkers the new cell0D markers, size 1xnumPolygonVertices \param cell1DMarkers
            / the new cell1D markers, size 1xnumPolygonVertices \param mesh the mesh
            """
            pass

        def change_polyhedron_mesh_markers(
            self,
            geometry_utilities: GeometryUtilities,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_edges_tangent: Eigen.MatrixXd,
            polyhedron_edges_length: Eigen.VectorXd,
            polyhedron_faces_normal: List[Eigen.Vector3d],
            polyhedron_faces_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_vertices_2_d: List[Eigen.MatrixXd],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_vertices_marker: List[int],
            polyhedron_edges_marker: List[int],
            polyhedron_faces_marker: List[int],
            cell1_ds_centroid: List[Eigen.Vector3d],
            cell2_ds_centroid: List[Eigen.Vector3d],
            mesh: IMeshDAO
            ) -> None:
            pass

        def export_mesh_to_vtu(
            self,
            mesh: IMeshDAO,
            export_folder: str,
            file_name: str,
            separate_file: bool = False
            ) -> None:
            """/ \brief Export Mesh To VTU
            / \param mesh the mesh
            / \param exportFolder the folder in which the mesh is exported
            """
            pass

        def export_mesh_to_ucd(
            self,
            mesh: IMeshDAO,
            export_folder: str,
            file_name: str,
            separate_file: bool = False
            ) -> None:
            """/ \brief Export Mesh To UCD
            / \param mesh the mesh
            / \param exportFolder the folder in which the mesh is exported
            """
            pass

        def export_cell2_d_to_vtu(
            self,
            mesh: IMeshDAO,
            cell2_d_index: int,
            cell2_d_vertices: Eigen.MatrixXd,
            cell2_d_triangulations: List[Eigen.Matrix3d],
            cell2_d_area: float,
            cell2_d_centroid: Eigen.Vector3d,
            export_folder: str
            ) -> None:
            """/ \brief Export Cell2D To VTU
            / \param mesh the mesh
            / \param cell2DIndex the cell2D index
            / \param cell2DVertices the cell2D vertices
            / \param cell2DTriangulations the cell2D triangulation
            / \param cell2DArea the cell2D area
            / \param cell2DCentroid the cell2D centroid
            / \param exportFolder the folder in which to export
            """
            pass

        def export_cell3_d_to_vtu(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            cell3_d_index: int,
            cell3_d_vertices: Eigen.MatrixXd,
            cell3_d_tetrahedrons: List[Eigen.MatrixXd],
            cell3_d_faces3_d_triangulations: List[List[Eigen.Matrix3d]],
            cell3_d_volume: float,
            cell3_d_centroid: Eigen.Vector3d,
            cell3_d_faces_translation: List[Eigen.Vector3d],
            cell3_d_faces_rotation_matrix: List[Eigen.Matrix3d],
            cell3_d_faces_area: List[float],
            cell3_d_faces2_d_vertices: List[Eigen.MatrixXd],
            cell3_d_faces3_d_vertices: List[Eigen.MatrixXd],
            cell3_d_faces_edge_lengths: List[Eigen.VectorXd],
            cell3_d_faces_edge_directions: List[List[bool]],
            cell3_d_faces_edges2_d_tangent: List[Eigen.MatrixXd],
            cell3_d_faces_edges2_d_normal: List[Eigen.MatrixXd],
            cell3_d_faces_normals: List[Eigen.Vector3d],
            cell3_d_faces_normal_directions: List[bool],
            cell3_d_faces2_d_centroids: List[Eigen.Vector3d],
            export_folder: str
            ) -> None:
            pass

        def mesh_cell3_d_to_polyhedron(
            self,
            mesh: IMeshDAO,
            cell3_d_index: int
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Convert a mesh cell3D to a geometric polydheron
            / \param mesh a mesh
            / \param cell3DIndex the cell3D index
            / \return polyhedron from mesh 3D cell
            """
            pass

        def mesh_cell3_d_to_vtp_polyhedron(
            self,
            mesh: IMeshDAO,
            cell3_d_index: int
            ) -> MeshUtilities.VTPPolyhedron:
            """/ \brief Convert a mesh cell3D to a VTP polydheron
            / \param mesh a mesh
            / \param cell3DIndex the cell3D index
            / \return VTP polyhedron from mesh 3D cell
            """
            pass

        def split_cell1_d(
            self,
            cell1_d_index: int,
            sub_cell1_ds: Eigen.MatrixXi,
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Split cell2D into subcells
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param subCell1Ds the list of sub-cells 1D mesh vertices indices, size 2 x numSubCells)
            / \param mesh the mesh to update
            / \return the list of new cell1Ds indices, from 0 to Cell1DTotalNumber()
            """
            pass

        def split_cell2_d(
            self,
            cell2_d_index: int,
            sub_cell2_ds: List[Eigen.MatrixXi],
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Split cell2D into subcells
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param subCell2Ds the list of sub-cells 2D mesh vertices and edges indices, size numSubCells x (2 x numVertices)
            / \param mesh the mesh to update
            / \return the list of new cell2Ds indices, from 0 to Cell2DTotalNumber()
            """
            pass

        def split_cell3_d(
            self,
            cell3_d_index: int,
            sub_cell3_ds_vertices: List[List[int]],
            sub_cell3_ds_edges: List[List[int]],
            sub_cell3_ds_faces: List[List[int]],
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Split cell3D into subcells
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param subCell3Ds the list of sub-cells 3D mesh vertices and edges indices, size numSubCells x (2 x numVertices)
            / \param mesh the mesh to update
            / \return the list of new cell3Ds indices, from 0 to Cell3DTotalNumber()
            """
            pass

        @overload
        def agglomerate_cell1_ds(
            self,
            cell1_ds_index: std.unordered_set[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateCell1DInformation:
            pass

        @overload
        def agglomerate_cell2_ds(
            self,
            geometry_utilities: GeometryUtilities,
            cell2_ds_index: std.unordered_set[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateCell2DInformation:
            pass

        @overload
        def agglomerate_cell3_ds(
            self,
            cell3_ds_index: std.unordered_set[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateCell3DInformation:
            pass

        @overload
        def agglomerate_cell1_ds(
            self,
            sub_cell1_ds_index: std.unordered_set[int],
            agglomerate_cell1_d_vertices: List[int],
            sub_cell1_ds_removed_cell0_ds: List[int],
            mesh: IMeshDAO,
            mesh_cell1_ds_original_cell1_ds: List[List[int]],
            mantain_neigh2_d_order: bool = False
            ) -> int:
            pass

        @overload
        def agglomerate_cell2_ds(
            self,
            sub_cell2_ds_index: std.unordered_set[int],
            agglomerate_cell2_d_vertices: List[int],
            agglomerate_cell2_d_edges: List[int],
            sub_cell2_ds_removed_cell0_ds: List[int],
            sub_cell2_ds_removed_cell1_ds: List[int],
            mesh: IMeshDAO,
            mesh_cell2_ds_original_cell2_ds: List[List[int]]
            ) -> int:
            pass

        @overload
        def agglomerate_cell3_ds(
            self,
            sub_cell3_ds_index: std.unordered_set[int],
            agglomerate_cell3_d_vertices: List[int],
            agglomerate_cell3_d_edges: List[int],
            agglomerate_cell3_d_faces: List[int],
            sub_cell3_ds_removed_cell0_ds: List[int],
            sub_cell3_ds_removed_cell1_ds: List[int],
            sub_cell3_ds_removed_cell2_ds: List[int],
            mesh: IMeshDAO,
            mesh_cell3_ds_original_cell3_ds: List[List[int]]
            ) -> int:
            pass

        def create_randomly_deformed_quadrilaterals(
            self,
            geometry_utilities: GeometryUtilities,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            num_quadrilaterals_base_tangent: int,
            num_quadrilaterals_height_tangent: int,
            max_deforming_percentage_base: float,
            max_deforming_percentage_height: float,
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_distorted_quadrilaterals(
            self,
            geometry_utilities: GeometryUtilities,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            num_quadrilaterals_base_tangent: int,
            num_quadrilaterals_height_tangent: int,
            mesh: IMeshDAO
            ) -> None:
            pass
        def find_cell2_ds_common_vertices(
            self,
            cell2_ds_index: List[int],
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Given a set of Cell2Ds find the common Cell0Ds
            / \param cell2DsIndex the cell2Ds index
            / \param mesh the mesh
            / \return the Cell0D indices
            """
            pass

        def find_cell2_ds_common_edges(
            self,
            cell2_ds_index: List[int],
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Given a set of Cell2Ds find the common Cell1Ds
            / \param cell2DsIndex the cell2Ds index
            / \param mesh the mesh
            / \return the Cell1D indices
            """
            pass

        @overload
        def find_concave_cell3_d_faces_convex_cell2_d(
            self,
            geometry_utilities: GeometryUtilities,
            concave_cell3_d_index: int,
            mesh: IMeshDAO,
            convex_mesh: IMeshDAO,
            convex_cell3_d_indices: List[int],
            concave_cell3_d_faces3_d_vertices: List[Eigen.MatrixXd],
            concave_cell3_d_faces2_d_vertices: List[Eigen.MatrixXd],
            concave_cell3_d_faces_translation: List[Eigen.Vector3d],
            concave_cell3_d_faces_rotation_matrix: List[Eigen.Matrix3d],
            concave_cell3_d_faces_normal: List[Eigen.Vector3d],
            convex_cell3_ds_faces3_d_vertices: List[List[Eigen.MatrixXd]],
            convex_cell3_ds_faces_unaligned_vertices: List[List[List[int]]]
            ) -> MeshUtilities.FindConcaveCell3DFacesConvexCell2DResult:
            pass

        @overload
        def find_concave_cell3_d_faces_convex_cell2_d(
            self,
            geometry_utilities: GeometryUtilities,
            concave_cell3_d_index: int,
            mesh: IMeshDAO,
            concave_cell3_d_tetra: List[Eigen.MatrixXd],
            concave_cell3_d_faces_2_d_triangles: List[List[Eigen.Matrix3d]],
            concave_cell3_d_faces3_d_vertices: List[Eigen.MatrixXd],
            concave_cell3_d_faces_translation: List[Eigen.Vector3d],
            concave_cell3_d_faces_rotation_matrix: List[Eigen.Matrix3d],
            concave_cell3_d_faces_normal: List[Eigen.Vector3d],
            convex_cell3_ds_faces3_d_vertices: List[List[Eigen.MatrixXd]],
            convex_cell3_ds_faces_unaligned_vertices: List[List[List[int]]]
            ) -> MeshUtilities.FindConcaveCell3DFacesConvexCell2DResult:
            pass

        @overload
        def find_point_mesh_position(
            self,
            find_cell2_d_result: MeshUtilities.FindPointCell2DResult,
            mesh: IMeshDAO
            ) -> MeshUtilities.FindPointMeshPositionResult:
            pass

        @overload
        def find_point_mesh_position(
            self,
            find_cell3_d_result: MeshUtilities.FindPointCell3DResult,
            mesh: IMeshDAO
            ) -> MeshUtilities.FindPointMeshPositionResult:
            pass

        def find_point_cell2_d(
            self,
            geometry_utilities: GeometryUtilities,
            point: Eigen.Vector3d,
            mesh: IMeshDAO,
            cell2_ds_vertices: List[Eigen.MatrixXd],
            cell2_ds_bounding_box: List[Eigen.MatrixXd],
            find_only_first_cell2_d: bool = True,
            starting_cell2_d_index: int = 0
            ) -> MeshUtilities.FindPointCell2DResult:
            pass

        @overload
        def find_point_cell3_d(
            self,
            geometry_utilities: GeometryUtilities,
            point: Eigen.Vector3d,
            mesh: IMeshDAO,
            cell3_ds_faces: List[List[Eigen.MatrixXi]],
            cell3_ds_face_vertices: List[List[Eigen.MatrixXd]],
            cell3_ds_face_rotated_vertices: List[List[Eigen.MatrixXd]],
            cell3_ds_face_normals: List[List[Eigen.Vector3d]],
            cell3_ds_face_normal_directions: List[List[bool]],
            cell3_ds_face_translations: List[List[Eigen.Vector3d]],
            cell3_ds_face_rotation_matrices: List[List[Eigen.Matrix3d]],
            cell3_ds_bounding_box: List[Eigen.MatrixXd],
            find_only_first_cell3_d: bool = True,
            starting_cell3_d_index: int = 0
            ) -> MeshUtilities.FindPointCell3DResult:
            pass

        @overload
        def find_point_cell3_d(
            self,
            geometry_utilities: GeometryUtilities,
            point: Eigen.Vector3d,
            mesh: IMeshDAO,
            cell3_ds_faces: List[List[Eigen.MatrixXi]],
            cell3_ds_face_vertices: List[List[Eigen.MatrixXd]],
            cell3_ds_face_rotated_vertices: List[List[Eigen.MatrixXd]],
            cell3_ds_face_normals: List[List[Eigen.Vector3d]],
            cell3_ds_face_normal_directions: List[List[bool]],
            cell3_ds_face_translations: List[List[Eigen.Vector3d]],
            cell3_ds_face_rotation_matrices: List[List[Eigen.Matrix3d]],
            cell3_ds_bounding_box: List[Eigen.MatrixXd],
            cell3_ds_tetrahedra: List[List[Eigen.MatrixXd]],
            find_only_first_cell3_d: bool,
            starting_cell3_d_index: int
            ) -> MeshUtilities.FindPointCell3DResult:
            pass

        def agglomerate_triangles(
            self,
            triangles_index_to_agglomerate: List[int],
            triangular_mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateTrianglesResult:
            """/ \brief Agglomerate Triangles with one vertex in common
            / \param trianglesIndexToAgglomerate the cell2Ds triangular index in the mesh
            / \param triangularMesh the triangular mesh
            / \return the agglomearted polygon indices
            / \note the triangular index shall be done counterclockwise
            """
            pass

        def agglomerate_mesh_from_triangular_mesh(
            self,
            triangles_indices_to_agglomerate: List[List[int]],
            triangular_mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateMeshFromTriangularMeshResult:
            pass

        def import_agglomeration_information_from_csv(
            self,
            geometry_utilities: GeometryUtilities,
            original_mesh: IMeshDAO,
            agglomerated_mesh: IMeshDAO,
            file_name: str,
            separator: str
            ) -> MeshUtilities.AgglomerationInformation:
            """/ \brief Import Agglomeration mesh Information From file Csv
            / \param geometryUtilities the geometry utilities
            / \param originalMesh the original mesh
            / \param agglomeratedMesh the agglomerated mesh
            / \param fileName the csv file name
            / \param separator the csv file separator
            / \param originalCell0DToAgglomeratedCell0Ds original Cell0Ds to agglomerated Cell0Ds
            / \param originalCell1DToAgglomeratedCell1Ds original Cell1Ds to agglomerated Cell1Ds
            / \param originalCell2DToAgglomeratedCell2Ds original Cell2Ds to agglomerated Cell2Ds
            / \param agglomeratedCell0DToOriginalCell0Ds agglomerated Cell0Ds to original Cell0Ds
            / \param agglomeratedCell1DToOriginalCell1Ds agglomerated Cell1Ds to original Cell1Ds
            / \param agglomeratedCell2DToOriginalCell2Ds agglomerated Cell2Ds to original Cell2Ds
            """
            pass

        def import_agglomeration_information_from_off(
            self,
            geometry_utilities: GeometryUtilities,
            original_mesh: IMeshDAO,
            agglomerated_mesh: IMeshDAO,
            file_name: str,
            separator: str
            ) -> MeshUtilities.AgglomerationInformation:
            """/ \brief Import Agglomeration mesh Information From file OFF
            / \param geometryUtilities the geometry utilities
            / \param originalMesh the original mesh
            / \param agglomeratedMesh the agglomerated mesh
            / \param fileName the csv file name
            / \param separator the csv file separator
            / \param originalCell0DToAgglomeratedCell0Ds original Cell0Ds to agglomerated Cell0Ds
            / \param originalCell1DToAgglomeratedCell1Ds original Cell1Ds to agglomerated Cell1Ds
            / \param originalCell2DToAgglomeratedCell2Ds original Cell2Ds to agglomerated Cell2Ds
            / \param agglomeratedCell0DToOriginalCell0Ds agglomerated Cell0Ds to original Cell0Ds
            / \param agglomeratedCell1DToOriginalCell1Ds agglomerated Cell1Ds to original Cell1Ds
            / \param agglomeratedCell2DToOriginalCell2Ds agglomerated Cell2Ds to original Cell2Ds
            """
            pass

        def export_mesh_to_csv(
            self,
            mesh: IMeshDAO,
            separator: str,
            export_folder_path: str
            ) -> None:
            """/ \brief Export mesh to csv file"""
            pass

        def export_concave_mesh2_d_to_csv(
            self,
            mesh: IMeshDAO,
            convex_cell2_ds_index: List[List[int]],
            separator: str,
            export_folder_path: str
            ) -> None:
            """/ \brief Export 2D concave mesh to csv file"""
            pass

        def mark_cells(
            self,
            marking_function: Callable[[ Eigen.MatrixXd ], Eigen.VectorXi],
            cells_points: List[Eigen.MatrixXd],
            default_mark: int
            ) -> List[int]:
            pass

        def intersect_mesh_polyhedron(
            self,
            geometry_utilities: GeometryUtilities,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_edges_vertices: List[Eigen.MatrixXd],
            polyhedron_edges_tangent: Eigen.MatrixXd,
            polyhedron_edges_bouding_box: List[Eigen.MatrixXd],
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_faces_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_normals: List[Eigen.Vector3d],
            polyhedron_faces_normal_direction: List[bool],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_faces_bouding_box: List[Eigen.MatrixXd],
            polyhedron_bouding_box: Eigen.MatrixXd,
            mesh: IMeshDAO,
            mesh_cell1_ds_bouding_box: List[Eigen.MatrixXd],
            mesh_cell1_ds_vertices: List[Eigen.MatrixXd],
            mesh_cell1_ds_tangent: List[Eigen.Vector3d],
            mesh_cell2_ds_vertices: List[Eigen.MatrixXd],
            mesh_cell2_ds_normal: List[Eigen.Vector3d],
            mesh_cell2_ds_2_d_vertices: List[Eigen.MatrixXd],
            mesh_cell2_ds_translation: List[Eigen.Vector3d],
            mesh_cell2_ds_rotation_matrix: List[Eigen.Matrix3d],
            mesh_cell2_ds_bouding_box: List[Eigen.MatrixXd],
            mesh_cell3_ds_bouding_box: List[Eigen.MatrixXd],
            mesh_cell3_ds_faces: List[List[Eigen.MatrixXi]],
            mesh_cell3_ds_faces_vertices: List[List[Eigen.MatrixXd]],
            mesh_cell3_ds_faces_2_d_vertices: List[List[Eigen.MatrixXd]],
            mesh_cell3_ds_faces_normal: List[List[Eigen.Vector3d]],
            mesh_cell3_ds_faces_normal_directions: List[List[bool]],
            mesh_cell3_ds_faces_translation: List[List[Eigen.Vector3d]],
            mesh_cell3_ds_faces_rotation_matrix: List[List[Eigen.Matrix3d]]
            ) -> MeshUtilities.Intersect_mesh_polyhedron_result:
            pass

        def set_polygon_mesh_markers(
            self,
            geometry_utilities: GeometryUtilities,
            polygon_vertices: Eigen.MatrixXd,
            cell0_d_markers: List[int],
            cell1_d_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            pass


# </submodule gedim>
####################    </generated_from:MeshUtilities.hpp>    ####################


####################    <generated_from:ObjectFileFormatInterface.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __ObjectFileFormatInterface_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class ObjectFileFormatInterface:
        """
        (final class)
        """
        class OFFMesh:
            """
            (final class)
            """
            num_cell0_ds: int
            num_cell1_ds: int
            num_cell2_ds: int

            cell0_ds: Eigen.MatrixXd
            cell2_ds: List[Eigen.VectorXi]
            def __init__(
                self,
                cell0_ds: Eigen.MatrixXd = Eigen.MatrixXd(),
                cell2_ds: List[Eigen.VectorXi] = List[Eigen.VectorXi]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def strings_to_off_mesh(
            self,
            file_lines: List[str]
            ) -> ObjectFileFormatInterface.OFFMesh:
            pass
        def off_mesh_to_strings(self, mesh: ObjectFileFormatInterface.OFFMesh) -> List[str]:
            pass
        def mesh_dao_to_off_mesh(
            self,
            original_mesh: IMeshDAO
            ) -> ObjectFileFormatInterface.OFFMesh:
            pass
        def off_mesh_to_mesh_dao(
            self,
            original_mesh: ObjectFileFormatInterface.OFFMesh,
            mesh_utilities: MeshUtilities,
            converted_mesh: IMeshDAO
            ) -> None:
            pass

        def import_mesh_from_file(
            self,
            off_file_path: str,
            mesh_utilities: MeshUtilities,
            mesh: IMeshDAO
            ) -> None:
            pass

        def export_mesh_to_file(self, mesh: IMeshDAO, off_file_path: str) -> None:
            pass

# </submodule gedim>
####################    </generated_from:ObjectFileFormatInterface.hpp>    ####################


####################    <generated_from:OpenVolumeMeshInterface.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __OpenVolumeMeshInterface_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class OpenVolumeMeshInterface:
        """
        (final class)
        """
        class OVMMesh:
            """
            (final class)
            """
            class Cell3D:
                """
                (final class)
                """
                faces_index: List[int]
                faces_orientation: List[bool]
                def __init__(self, faces_orientation: List[bool] = List[bool]()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            num_cell0_ds: int
            num_cell1_ds: int
            num_cell2_ds: int
            num_cell3_ds: int

            cell0_ds: Eigen.MatrixXd
            cell1_ds: Eigen.MatrixXi
            cell2_ds: List[Eigen.MatrixXi]
            cell3_ds: List[Cell3D]
            def __init__(
                self,
                cell0_ds: Eigen.MatrixXd = Eigen.MatrixXd(),
                cell1_ds: Eigen.MatrixXi = Eigen.MatrixXi(),
                cell2_ds: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                cell3_ds: List[Cell3D] = List[Cell3D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def strings_to_ovm_mesh(
            self,
            file_lines: List[str]
            ) -> OpenVolumeMeshInterface.OVMMesh:
            pass
        def ovm_mesh_to_strings(self, mesh: OpenVolumeMeshInterface.OVMMesh) -> List[str]:
            pass
        def mesh_dao_to_ovm_mesh(
            self,
            original_mesh: IMeshDAO,
            cell3_ds_faces_orientation: List[List[bool]]
            ) -> OpenVolumeMeshInterface.OVMMesh:
            pass
        def ovm_mesh_to_mesh_dao(
            self,
            original_mesh: OpenVolumeMeshInterface.OVMMesh,
            converted_mesh: IMeshDAO,
            converted_mesh_cell3_ds_faces_orientation: List[List[bool]]
            ) -> None:
            pass

        def import_mesh_from_file(
            self,
            ovm_file_path: str,
            mesh: IMeshDAO,
            mesh_cell3_ds_faces_orientation: List[List[bool]]
            ) -> None:
            pass

        def export_mesh_to_file(
            self,
            mesh: IMeshDAO,
            mesh_cell3_ds_faces_orientation: List[List[bool]],
            ovm_file_path: str
            ) -> None:
            pass

# </submodule gedim>
####################    </generated_from:OpenVolumeMeshInterface.hpp>    ####################


####################    <generated_from:PlatonicSolid.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __PlatonicSolid_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class PlatonicSolid:
        """/ \brief MeshUtilities
        / \copyright See top level LICENSE file for details.
        /
        / https://danielsieger.com/blog/2021/01/03/generating-platonic-solids.html
        (final class)
        """
        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            mesh_utilities: MeshUtilities
            ) -> None:
            pass


        def project_to_unit_sphere(self, polyhedron: GeometryUtilities.Polyhedron) -> None:
            pass

        def project_to_unit_sphere_geodesic(
            self,
            mesh_data: MeshMatrices,
            mesh: MeshMatricesDAO
            ) -> None:
            pass

        def project_to_unit_sphere_goldberg(
            self,
            mesh_data: MeshMatrices,
            mesh: MeshMatricesDAO
            ) -> None:
            pass

        def dual_polyhedron(
            self,
            polyhedron: GeometryUtilities.Polyhedron
            ) -> GeometryUtilities.Polyhedron:
            pass

        def first_class_geodesic_polyhedron(
            self,
            starting_polyhedron: GeometryUtilities.Polyhedron,
            frequency: int,
            filter_mesh: MeshMatricesDAO
            ) -> None:
            pass

        def second_class_geodesic_polyhedron(
            self,
            starting_polyhedron: GeometryUtilities.Polyhedron,
            frequency: int,
            filter_mesh: MeshMatricesDAO
            ) -> None:
            pass

        def goldberg_polyhedron(
            self,
            p: int,
            q: int,
            b: int,
            c: int
            ) -> GeometryUtilities.Polyhedron:
            pass

        def geodesic_polyhedron(
            self,
            p: int,
            q: int,
            b: int,
            c: int
            ) -> GeometryUtilities.Polyhedron:
            pass

        def tetrahedron(self) -> GeometryUtilities.Polyhedron:
            pass

        def hexahedron(self) -> GeometryUtilities.Polyhedron:
            pass

        def octahedron(self) -> GeometryUtilities.Polyhedron:
            pass

        def icosahedron(self) -> GeometryUtilities.Polyhedron:
            pass

        def dodecahedron(self) -> GeometryUtilities.Polyhedron:
            pass


# </submodule gedim>
####################    </generated_from:PlatonicSolid.hpp>    ####################


####################    <generated_from:RefinementUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __RefinementUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class RefinementUtilities:
        """/ \brief RefinementUtilities
        / \copyright See top level LICENSE file for details.
        (final class)
        """
        class TriangleMaxEdgeDirection:
            """
            (final class)
            """
            max_edge_index: int = 0
            opposite_vertex_index: int = 0
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class TetrahedronMaxEdgeDirection:
            """
            (final class)
            """
            max_edge_index: int = 0
            opposite_vertices_index: List[int] = List[int]()
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class PolygonDirection:
            """
            (final class)
            """
            line_origin: Eigen.Vector3d
            line_tangent: Eigen.Vector3d
            def __init__(
                self,
                line_origin: Eigen.Vector3d = Eigen.Vector3d(),
                line_tangent: Eigen.Vector3d = Eigen.Vector3d()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class MeshQuality:
            """
            (final class)
            """
            cell2_ds_quality: List[float]
            cell1_ds_quality: List[float]
            def __init__(
                self,
                cell2_ds_quality: List[float] = List[float](),
                cell1_ds_quality: List[float] = List[float]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitCell1D_Result:
            """
            (final class)
            """
            new_cell0_d_index: int = 0
            new_cell1_ds_index: List[int] = List[int]()
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class SplitPolygon_Result:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                split = enum.auto()                              # (= 1)
                no_split = enum.auto()                           # (= 2)

            type: Types = Types.unknown
            new_cell1_d_index: int = 0
            new_cell2_ds_index: List[int] = List[int]()
            def __init__(self, type: Types = Types.unknown) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolygon_CheckResult:
            """
            (final class)
            """
            class ResultTypes(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                cell2_d_to_be_splitted = enum.auto()             # (= 1)
                cell2_d_already_splitted = enum.auto()           # (= 2)
                cell2_d_split_under_tolerance = enum.auto()      # (= 3)
                split_direction_not_inside_cell2_d = enum.auto() # (= 4)

            class Cell1DToSplit:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                        # (= 0)
                    not_inside = enum.auto()                     # (= 1)
                    edge_length_not_enough = enum.auto()         # (= 2)
                    only_local_quality_not_enough = enum.auto()  # (= 3)
                    only_neigh_quality_not_enough = enum.auto()  # (= 4)
                    both_quality_not_enough = enum.auto()        # (= 5)
                    only_local_aligned_not_respect = enum.auto() # (= 6)
                    only_neigh_aligned_not_respect = enum.auto() # (= 7)
                    both_aligned_not_respect = enum.auto()       # (= 8)
                    to_split = enum.auto()                       # (= 9)

                is_intersection_inside: bool = False
                is_edge_length_enough: bool = False
                is_local_quality_enough: bool = False
                is_quality_enough: bool = False
                is_neigh_quality_enough: List[bool] = List[bool]()
                is_local_aligned_respect: bool = False
                is_aligned_respect: bool = False
                is_neigh_aligned_respect: List[bool] = List[bool]()
                is_to_split: bool = False
                cell2_d_edge_index: int = 0
                type: Types = Types.unknown
                def __init__(
                    self,
                    is_intersection_inside: bool = False,
                    is_edge_length_enough: bool = False,
                    is_local_quality_enough: bool = False,
                    is_quality_enough: bool = False,
                    is_neigh_quality_enough: List[bool] = List[bool](),
                    is_local_aligned_respect: bool = False,
                    is_aligned_respect: bool = False,
                    is_neigh_aligned_respect: List[bool] = List[bool](),
                    is_to_split: bool = False,
                    type: Types = Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            cell1_ds_index: List[int] = List[int]()
            cell1_ds_intersection: List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection] = List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection]()
            cell1_ds_to_split: List[Cell1DToSplit] = List[Cell1DToSplit]()
            result_type: ResultTypes = ResultTypes.unknown
            def __init__(
                self,
                cell1_ds_intersection: List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection] = List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection](),
                cell1_ds_to_split: List[Cell1DToSplit] = List[Cell1DToSplit](),
                result_type: ResultTypes = ResultTypes.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CheckSplitType_Result:
            """
            (final class)
            """
            class SplitTypes(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                no_split = enum.auto()                           # (= 1)
                no_new_vertices = enum.auto()                    # (= 2)
                new_vertex_from = enum.auto()                    # (= 3)
                new_vertex_to = enum.auto()                      # (= 4)
                new_vertices = enum.auto()                       # (= 5)

            no_new_vertices_index: List[int] = List[int]()       #/< valid only for NoNewVertices type
            type: SplitTypes = SplitTypes.unknown
            def __init__(self, type: SplitTypes = SplitTypes.unknown) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolyhedron_Result:
            """
            (final class)
            """
            class ResultTypes(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                successfull = enum.auto()                        # (= 1)
                cell3_d_already_splitted = enum.auto()           # (= 2)
                cell3_d_split_under_tolerance = enum.auto()      # (= 3)
                cell3_d_split_none = enum.auto()                 # (= 4)

            class RefinedCell1D:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                        # (= 0)
                    updated = enum.auto()                        # (= 1)
                    new = enum.auto()                            # (= 2)

                type: Types = Types.unknown
                new_cell1_ds_index: List[int] = List[int]()
                original_cell1_d_index: int = 0
                new_cell0_d_index: int = 0
                original_cell3_d_edge_index: int = 0
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class RefinedCell2D:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                        # (= 0)
                    updated = enum.auto()                        # (= 1)
                    new = enum.auto()                            # (= 2)

                type: Types = Types.unknown
                new_cell2_ds_index: List[int] = List[int]()
                original_cell2_d_index: int = 0
                new_cell1_d_index: int = 0
                new_cell1_ds_position: List[int] = List[int]()   #/< Position in NewCell1DsIndex array
                original_cell3_d_face_index: int = 0
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            result_type: ResultTypes = ResultTypes.unknown
            new_cell0_ds_index: List[int] = List[int]()
            new_cell1_ds_index: List[RefinedCell1D] = List[RefinedCell1D]()
            new_cell2_ds_index: List[RefinedCell2D] = List[RefinedCell2D]()
            new_cell3_ds_index: List[int] = List[int]()
            def __init__(
                self,
                result_type: ResultTypes = ResultTypes.unknown,
                new_cell1_ds_index: List[RefinedCell1D] = List[RefinedCell1D](),
                new_cell2_ds_index: List[RefinedCell2D] = List[RefinedCell2D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolygon_Result:
            """
            (final class)
            """
            class ResultTypes(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                successfull = enum.auto()                        # (= 1)
                cell2_d_already_splitted = enum.auto()           # (= 2)
                cell2_d_split_under_tolerance = enum.auto()      # (= 3)
                split_direction_not_inside_cell2_d = enum.auto() # (= 4)
                split_quality_check_cell2_d_failed = enum.auto() # (= 5)

            class RefinedCell1D:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                        # (= 0)
                    updated = enum.auto()                        # (= 1)
                    new = enum.auto()                            # (= 2)

                type: Types = Types.unknown
                new_cell1_ds_index: List[int] = List[int]()
                original_cell1_d_index: int = 0
                new_cell0_d_index: int = 0
                original_cell2_d_edge_index: int = 0
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            new_cell0_ds_index: List[int] = List[int]()
            new_cell1_ds_index: List[RefinedCell1D] = List[RefinedCell1D]()
            new_cell2_ds_index: List[int] = List[int]()

            split_type: CheckSplitType_Result.SplitTypes = CheckSplitType_Result.SplitTypes.unknown
            result_type: ResultTypes = ResultTypes.unknown
            def __init__(
                self,
                new_cell1_ds_index: List[RefinedCell1D] = List[RefinedCell1D](),
                split_type: CheckSplitType_Result.SplitTypes = CheckSplitType_Result.SplitTypes.unknown,
                result_type: ResultTypes = ResultTypes.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolygon_UpdateNeighbour_Result:
            """
            (final class)
            """
            class UpdatedCell2D:
                """
                (final class)
                """
                original_cell2_d_index: int = 0
                new_cell2_d_index: int = 0
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            updated_cell2_ds: List[UpdatedCell2D] = List[UpdatedCell2D]()
            def __init__(
                self,
                updated_cell2_ds: List[UpdatedCell2D] = List[UpdatedCell2D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolyhedron_UpdateNeighbour_Result:
            """
            (final class)
            """
            class UpdatedCell3D:
                """
                (final class)
                """
                original_cell3_d_index: int = 0
                new_cell3_d_index: int = 0
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            updated_cell3_ds: List[UpdatedCell3D] = List[UpdatedCell3D]()
            def __init__(
                self,
                updated_cell3_ds: List[UpdatedCell3D] = List[UpdatedCell3D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell2Ds_GeometricData:
            """
            (final class)
            """
            class Cell2D_GeometricData:
                """
                (final class)
                """
                unaligned_vertices_index: List[List[int]] = List[List[int]]()
                vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                area: List[float] = List[float]()
                centroid: List[Eigen.Vector3d] = List[Eigen.Vector3d]()
                edges_direction: List[List[bool]] = List[List[bool]]()
                edges_normal: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                edges_length: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                triangulations: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]]()
                inertia: List[Eigen.Matrix3d] = List[Eigen.Matrix3d]()
                unaligned_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                unaligned_edges_length: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                centroid_edges_distance: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                centroid_vertices_distance: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                in_radius: List[float] = List[float]()
                quality: List[float] = List[float]()
                def __init__(
                    self,
                    vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    area: List[float] = List[float](),
                    centroid: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                    edges_direction: List[List[bool]] = List[List[bool]](),
                    edges_normal: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    edges_length: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                    triangulations: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]](),
                    inertia: List[Eigen.Matrix3d] = List[Eigen.Matrix3d](),
                    unaligned_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    unaligned_edges_length: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                    centroid_edges_distance: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                    centroid_vertices_distance: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                    in_radius: List[float] = List[float](),
                    quality: List[float] = List[float]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class Cell1D_GeometricData:
                """
                (final class)
                """
                max_aligned: int = 0
                aligned: List[int] = List[int]()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            cell1_ds: Cell1D_GeometricData
            cell2_ds: Cell2D_GeometricData
            def __init__(
                self,
                cell1_ds: Cell1D_GeometricData = Cell1D_GeometricData(),
                cell2_ds: Cell2D_GeometricData = Cell2D_GeometricData()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            mesh_utilities: MeshUtilities
            ) -> None:
            pass

        def split_cell1_d(
            self,
            cell1_d_index: int,
            new_vertex_coordinate: Eigen.Vector3d,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitCell1D_Result:
            pass
        def update_cell2_d_new_vertex(
            self,
            cell2_d_index: int,
            cell2_d_edge_direction: bool,
            cell2_d_edge_position: int,
            new_cell1_ds_index: List[int],
            new_cell0_d_index: int,
            mesh: IMeshDAO
            ) -> int:
            """/ \brief update cell2DIndex with a new splitted edge cell1DIndex by newCell0DIndex"""
            pass

        def split_cell1_d_middle_point(
            self,
            cell1_d_index: int,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitCell1D_Result:
            pass

        def are_vertices_aligned(
            self,
            cell2_d_vertices: Eigen.MatrixXd,
            from_vertex: int,
            to_vertex: int
            ) -> bool:
            pass

        def split_polygon_check_split_type(
            self,
            cell2_d_polygon_type: GeometryUtilities.PolygonTypes,
            cell2_d_unaligned_polygon_type: GeometryUtilities.PolygonTypes,
            cell2_d_vertices: Eigen.MatrixXd,
            cell2_d_check_to_refine: RefinementUtilities.RefinePolygon_CheckResult
            ) -> RefinementUtilities.CheckSplitType_Result:
            pass

        def split_polygon_check_is_not_to_extend(
            self,
            cell1_d_split_one: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit,
            cell1_d_split_two: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit
            ) -> bool:
            pass
        def split_polygon_check_is_to_split_relaxed(
            self,
            cell1_d_split_one: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit,
            cell1_d_split_two: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit
            ) -> bool:
            pass

        def split_polygon_is_area_positive(
            self,
            new_cell2_d_indices: Eigen.VectorXi,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            mesh: IMeshDAO
            ) -> bool:
            pass

        def split_polygon_no_new_vertices(
            self,
            cell2_d_index: int,
            cell2_d_num_vertices: int,
            from_vertex: int,
            to_vertex: int,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitPolygon_Result:
            pass
        def split_polygon_new_vertex_from(
            self,
            cell2_d_index: int,
            cell2_d_num_vertices: int,
            from_edge: int,
            to_vertex: int,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            from_new_cell0_d_index: int,
            from_split_cell1_ds_index: List[int],
            from_edge_direction: bool,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitPolygon_Result:
            pass
        def split_polygon_new_vertex_to(
            self,
            cell2_d_index: int,
            cell2_d_num_vertices: int,
            from_vertex: int,
            to_edge: int,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            to_new_cell0_d_index: int,
            to_split_cell1_ds_index: List[int],
            to_edge_direction: bool,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitPolygon_Result:
            pass
        def split_polygon_new_vertices(
            self,
            cell2_d_index: int,
            cell2_d_num_vertices: int,
            from_edge: int,
            to_edge: int,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            from_new_cell0_d_index: int,
            to_new_cell0_d_index: int,
            from_split_cell1_ds_index: List[int],
            to_split_cell1_ds_index: List[int],
            from_edge_direction: bool,
            to_edge_direction: bool,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitPolygon_Result:
            pass

        def compute_triangle_max_edge_direction(
            self,
            edges_length: Eigen.VectorXd
            ) -> RefinementUtilities.TriangleMaxEdgeDirection:
            pass

        def compute_polygon_max_diameter_direction(
            self,
            unaligned_vertices: Eigen.MatrixXd,
            centroid: Eigen.Vector3d
            ) -> RefinementUtilities.PolygonDirection:
            pass
        def compute_polygon_max_inertia_direction(
            self,
            unaligned_vertices: Eigen.MatrixXd,
            unaligned_edges_length: Eigen.VectorXd,
            centroid: Eigen.Vector3d,
            inertia: Eigen.Matrix3d
            ) -> RefinementUtilities.PolygonDirection:
            pass

        def compute_tetrahedron_max_edge_direction(
            self,
            polyhedron_edges: Eigen.MatrixXi,
            edges_length: Eigen.VectorXd
            ) -> RefinementUtilities.TetrahedronMaxEdgeDirection:
            pass

        def refine_triangle_cell_by_edge(
            self,
            cell2_d_index: int,
            edge_index: int,
            opposite_vertex_index: int,
            cell2_d_edges_direction: List[bool],
            cell2_d_area: float,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            cell2_d_edges_length: Eigen.VectorXd,
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_Result:
            """/ \brief Refine Triangle Cell2D By Edge
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param cell2DVertices the cell2D 2D vertices
            / \param edgeIndex the edge local index to split
            / \param oppositeVertexIndex the vertex opposite to edge local index
            / \param mesh the mesh to be updated
            """
            pass

        def refine_polyhedron_cell_by_plane(
            self,
            cell3_d_index: int,
            cell3_d_vertices: Eigen.MatrixXd,
            cell3_d_edges: Eigen.MatrixXi,
            cell3_d_edges_length: Eigen.VectorXd,
            cell3_d_faces: List[Eigen.MatrixXi],
            cell3_d_faces3_d_vertices: List[Eigen.MatrixXd],
            cell3_d_faces_edges3_d_tangent: List[Eigen.MatrixXd],
            cell3_d_faces_translation: List[Eigen.Vector3d],
            cell3_d_faces_rotation_matrix: List[Eigen.Matrix3d],
            cell3_d_volume: float,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            plane_rotation_matrix: Eigen.Matrix3d,
            plane_translation: Eigen.Vector3d,
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolyhedron_Result:
            """/ \brief Refine Polyhedral Cell3D By Plane"""
            pass

        def refine_polyhedron_cell_update_face_neighbours(
            self,
            cell3_d_index: int,
            cell2_d_index: int,
            new_cell1_d_index: int,
            split_cell1_ds_original_index: List[int],
            split_cell1_ds_new_cell0_d_index: List[int],
            split_cell1_ds_updated_indices: List[List[int]],
            split_cell2_ds_index: List[int],
            cell3_ds_faces_edges_direction: List[List[List[bool]]],
            updated_cell2_ds: Dict[int, int],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolyhedron_UpdateNeighbour_Result:
            pass

        def refine_polyhedron_cell_update_edge_neighbours(
            self,
            cell3_d_index: int,
            cell1_d_index: int,
            new_cell1_ds_index: List[int],
            new_cell0_d_index: int,
            cell3_ds_faces_edges_direction: List[List[List[bool]]],
            updated_cell2_ds: Dict[int, int],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolyhedron_UpdateNeighbour_Result:
            pass

        def refine_triangle_cell_update_neighbours(
            self,
            cell2_d_index: int,
            cell1_d_index: int,
            new_cell0_d_index: int,
            split_cell1_ds_index: List[int],
            cell2_d_edge_direction: bool,
            cell2_ds_rotation: List[Eigen.Matrix3d],
            cell2_ds_translation: List[Eigen.Vector3d],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Update Cell1D neighbours of refined triangle by edge with refine by edge
            / \param cell2DIndex the index of Cell2D refined, from 0 to Cell2DTotalNumber()
            / \param cell1DIndex the index of Cell1D splitted by the refinement, from 0 to Cell1DTotalNumber()
            / \param newCell0DIndex the index of Cell0D created by the cell1D splitting process, from 0 to Cell0DTotalNumber()
            / \param splitCell1DsIndex the indices of the new Cell1Ds created by the splitting process, from 0 to
            / Cell1DTotalNumber() \param cell2DEdgeDirection the direction of the Cell1D splitted in the Cell2D \param mesh
            / the mesh to be updated
            """
            pass

        def refine_polygon_cell_check_refinement(
            self,
            cell2_d_index: int,
            cell2_d_vertices: Eigen.MatrixXd,
            line_tangent: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            cell2_ds_quality: List[float],
            cell1_ds_aligned: List[int],
            cell1_ds_quality_weight: float,
            cell1_ds_aligned_weight: float,
            cell2_d_area: float,
            cell2_ds_edges_length: List[Eigen.VectorXd],
            cell2_d_edges_direction: List[bool],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_CheckResult:
            """/ \brief Refine Polygon Cell2D By Direction"""
            pass

        def refine_polygon_cell_by_direction(
            self,
            cell2_d_index: int,
            cell2_d_polygon_type: GeometryUtilities.PolygonTypes,
            cell2_d_unaligned_polygon_type: GeometryUtilities.PolygonTypes,
            cell2_d_vertices: Eigen.MatrixXd,
            cell2_d_check_to_refine: RefinementUtilities.RefinePolygon_CheckResult,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            cell2_d_edges_direction: List[bool],
            extend_to_neighbours: bool,
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_Result:
            """/ \brief Refine Polygon Cell2D By Direction"""
            pass

        def refine_polygon_cell_update_neighbours(
            self,
            cell2_d_index: int,
            cell1_d_index: int,
            new_cell0_d_index: int,
            split_cell1_ds_index: List[int],
            cell2_ds_edges_direction: List[List[bool]],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_UpdateNeighbour_Result:
            pass

        def refine_polygon_cell_initialize_geometric_data(
            self,
            mesh: IMeshDAO
            ) -> RefinementUtilities.Cell2Ds_GeometricData:
            """/ Compute the geometric data for all the mesh"""
            pass

        def refine_polygon_cell_update_geometric_data(
            self,
            mesh: IMeshDAO,
            cell2_ds_index: List[int],
            geometric_data: RefinementUtilities.Cell2Ds_GeometricData
            ) -> None:
            """/ \brief Update the geometric data for only cell2Ds"""
            pass

        def refine_polygon_cell_is_cell1_d_to_split(
            self,
            cell1_d_index: int,
            cell2_d_index: int,
            edge_intersection: GeometryUtilities.LinePolygonPositionResult.EdgeIntersection,
            cell2_ds_edges_length: List[Eigen.VectorXd],
            cell1_ds_quality_weight: float,
            cell1_ds_aligned_weight: float,
            cell2_ds_quality: List[float],
            cell1_ds_aligned: List[int],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit:
            pass


# </submodule gedim>
####################    </generated_from:RefinementUtilities.hpp>    ####################


####################    <generated_from:SphereMeshUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __SphereMeshUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class SphereMeshUtilities:
        """/ \brief MeshUtilities
        / \copyright See top level LICENSE file for details.
        /
        / https://danielsieger.com/blog/2021/03/27/generating-spheres.html
        (final class)
        """
        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            mesh_utilities: MeshUtilities
            ) -> None:
            pass


        def uv_sphere(self, meridians: int, parallels: int) -> GeometryUtilities.Polyhedron:
            pass


# </submodule gedim>
####################    </generated_from:SphereMeshUtilities.hpp>    ####################


####################    <generated_from:TetgenInterface.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __TetgenInterface_H
#





# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class TetgenInterface:
        """/ \brief The Tetgen Interface
        / \see http://wias-berlin.de/software/tetgen/files/tetcall.cxx
        (final class)
        """
        class Region:
            id: int                   # unique id of the region
            centroid: Eigen.Vector3d  # internal point of the region
            max_volume: float         # default -1.0
            def __init__(
                self,
                id: int = int(),
                centroid: Eigen.Vector3d = Eigen.Vector3d(),
                max_volume: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def create_delaunay(
            self,
            points: Eigen.MatrixXd,
            points_marker: List[int],
            mesh: IMeshDAO
            ) -> None:
            pass

        @overload
        def create_mesh(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            max_tetrahedron_volume: float,
            mesh: IMeshDAO,
            tetgen_options: str = "Qpqfezna"
            ) -> None:
            pass

        @overload
        def create_mesh(
            self,
            points: Eigen.MatrixXd,
            facets: List[List[int]],
            max_tetrahedron_volume: float,
            mesh: IMeshDAO,
            tetgen_options: str = "Qpqfezna"
            ) -> None:
            pass

        @overload
        def create_mesh(
            self,
            points: Eigen.MatrixXd,
            facets: List[List[int]],
            regions: List[TetgenInterface.Region],
            mesh: IMeshDAO,
            tetgen_options: str = "QpqfeznaA"
            ) -> None:
            pass


# </submodule gedim>
####################    </generated_from:TetgenInterface.hpp>    ####################


####################    <generated_from:TriangleInterface.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __TriangleInterface_H
#





# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class TriangleInterface:
        """
        (final class)
        """
        def __init__(self) -> None:
            pass

        def create_mesh(
            self,
            polygon_vertices: Eigen.MatrixXd,
            max_triangle_area: float,
            mesh: IMeshDAO,
            triangle_options: str = "-QDzpqnea"
            ) -> None:
            pass

# </submodule gedim>
####################    </generated_from:TriangleInterface.hpp>    ####################


####################    <generated_from:UnionMeshSegment.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __UNIONMESHSEGMENT_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class UnionMeshSegment:
        """
        (final class)
        """
        class UnionMesh:
            """
            (final class)
            """
            class UnionMeshPoint:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()              # (= 0)
                    first = enum.auto()                # (= 1)
                    second = enum.auto()               # (= 2)
                    both = enum.auto()                 # (= 3)

                type: Types = Types.unknown
                mesh_indices: List[int] = List[int]()  #/< vector of size 2 containing in each i the indices in mesh_i
                def __init__(self, type: Types = Types.unknown) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class UnionMeshSegment:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()              # (= 0)
                    first = enum.auto()                # (= 1)
                    second = enum.auto()               # (= 2)
                    both = enum.auto()                 # (= 3)

                type: Types = Types.unknown
                points: List[float] = List[float]()
                mesh_indices: List[int] = List[int]()  #/< vector of size 2 containing in each i the indices in mesh_i
                def __init__(
                    self,
                    type: Types = Types.unknown,
                    points: List[float] = List[float]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            points: Dict[float, UnionMeshPoint] = Dict[float, UnionMeshPoint]()
            segments: List[UnionMeshSegment] = List[UnionMeshSegment]()
            def __init__(
                self,
                segments: List[UnionMeshSegment] = List[UnionMeshSegment]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        @staticmethod
        def to_curvilinear_coordinates(
            union_mesh: UnionMeshSegment.UnionMesh,
            curvilinear_coordinates: List[float]
            ) -> None:
            """/ \brief convert UnionMesh to Curvilinear Coordinates vector"""
            pass

        @staticmethod
        def to_string(union_mesh: UnionMeshSegment.UnionMesh) -> None:
            pass

        def __init__(self, geometry_utilities: GeometryUtilities) -> None:
            pass

        def create_union_mesh(
            self,
            curvilinear_coordinates_mesh_one: List[float],
            curvilinear_coordinates_mesh_two: List[float],
            result: UnionMeshSegment.UnionMesh
            ) -> None:
            pass

# </submodule gedim>
####################    </generated_from:UnionMeshSegment.hpp>    ####################


####################    <generated_from:VoroInterface.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VoroInterface_H
#





def generate_voronoi_tassellations2_d(
    polygon_vertices: Eigen.MatrixXd,
    num_iterations: int,
    voronoi_points: Eigen.MatrixXd,
    mesh: gedim.IMeshDAO
    ) -> None:
    pass


def generate_cartesian_points3_d(
    polyhedron_vertices: Eigen.MatrixXd,
    num_points: int,
    con: voro.container
    ) -> None:
    pass

def generate_random_points(
    domain_vertices: Eigen.MatrixXd,
    num_points: int,
    voronoi_points: Eigen.MatrixXd,
    random_seed: int = static_cast<int>(time(None)
    ) -> None:
    pass
# #endif
# };
#

# namespace Gedim

# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    class VoroInterface:
        """
        (final class)
        """
        class Cell0D:
            x: float # (const)
            y: float # (const)
            z: float # (const)

            id: int
            marker: int

            def __init__(self, x: float, y: float, z: float) -> None:
                pass

        class Cell2D:
            id: int
            marker: int
            vertices: List[int]
            edges: List[int]
            def __init__(self, marker: int = int()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self, geometry_utilities: GeometryUtilities) -> None:
            pass

        def generate_voronoi_tassellations3_d(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            num_points: int,
            num_iterations: int,
            mesh: IMeshDAO,
            random_seed: int = static_cast<int>(time(None)
            ) -> None:
            pass

    @staticmethod
    def generate_voronoi_tassellations2_d(
        polygon_vertices: Eigen.MatrixXd,
        num_points: int,
        num_iterations: int,
        mesh: IMeshDAO,
        random_seed: int = static_cast<int>(time(None)
        ) -> None:
        pass

# </submodule gedim>
####################    </generated_from:VoroInterface.hpp>    ####################


####################    <generated_from:VtkMeshInterface.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VtkMeshInterface_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class VtkMeshInterface:
        """
        (final class)
        """
        class VtkMesh:
            """
            (final class)
            """
            class Cell3D:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()     # (= 0)
                    tetrahedron = enum.auto() # (= 1)
                    hexahedron = enum.auto()  # (= 2)

                cell0_d_id: List[int]
                type: Types
                def __init__(self, type: Types = Types()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            num_cell0_ds: int
            num_cell3_ds: int

            cell0_ds: Eigen.MatrixXd
            cell3_ds: List[Cell3D]
            def __init__(
                self,
                cell0_ds: Eigen.MatrixXd = Eigen.MatrixXd(),
                cell3_ds: List[Cell3D] = List[Cell3D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class VtkMesh3D:
            """
            (final class)
            """
            markers: List[List[int]]

            cell0_ds: Eigen.MatrixXd
            cell1_ds: Eigen.MatrixXi
            cell2_ds: List[Eigen.MatrixXi]
            cell3_ds: List[Gedim.MeshUtilities.Mesh3DPolyhedron]
            def __init__(
                self,
                cell0_ds: Eigen.MatrixXd = Eigen.MatrixXd(),
                cell1_ds: Eigen.MatrixXi = Eigen.MatrixXi(),
                cell2_ds: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                cell3_ds: List[MeshUtilities.Mesh3DPolyhedron] = List[MeshUtilities.Mesh3DPolyhedron]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def import_mesh3_d_from_file(self, vtk_file_path: str) -> VtkMeshInterface.VtkMesh3D:
            pass

# </submodule gedim>
####################    </generated_from:VtkMeshInterface.hpp>    ####################

# </litgen_stub> // Autogenerated code end!
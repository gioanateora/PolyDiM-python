# type: ignore
import sys
from typing import Literal, List, Any, Optional, Tuple, Dict
import numpy as np
import enum
import numpy

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# <litgen_stub> // Autogenerated code below! Do not edit!
####################    <generated_from:StringsUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __StringsUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class StringsUtilities:
        @staticmethod
        @overload
        def split(string_to_split: str, character: str = ' ') -> List[str]:
            """/ Divide a string by a character in a vector of strings
            / @example stringToSplit="pippo_pe" character='_' -> result=["pippo", "pe"]
            """
            pass

        @staticmethod
        @overload
        def split(string_to_split: str, characters: List[char] = List[char](' ')) -> List[str]:
            """/ Divide a string by a set of characters in a vector of strings
            / @example stringToSplit="pippo_pe:pu" characters={'_',':'} -> result=["pippo", "pe", "pu"]
            """
            pass

        @staticmethod
        def find_separator(string_to_search: str, key_one: str, key_two: str) -> char:
            """/ Find inside a string a separator between two keys
            / @example stringToSearch="id:value" keyOne="id" keyTwo="value" -> separator=':'
            """
            pass

        @staticmethod
        def to_lower(input: str) -> str:
            """/ Convert string to lower"""
            pass

        @staticmethod
        def to_upper(input: str) -> str:
            """/ Convert string to upper"""
            pass

        def __init__(self) -> None:
            """Autogenerated default constructor"""
            pass

# </submodule gedim>
####################    </generated_from:StringsUtilities.hpp>    ####################


####################    <generated_from:GeometryUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __GEOMETRYUTILITIES_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class GeometryUtilitiesConfig:
        """
        (final class)
        """
        @staticmethod
        def default_min_tolerance() -> float:
            pass

        min_tolerance: float = Gedim.GeometryUtilitiesConfig.DefaultMinTolerance()
        tolerance1_d: float = Gedim.GeometryUtilitiesConfig.DefaultMinTolerance()
        tolerance2_d: float = Gedim.GeometryUtilitiesConfig.DefaultMinTolerance()
        tolerance3_d: float = Gedim.GeometryUtilitiesConfig.DefaultMinTolerance()
        def __init__(
            self,
            min_tolerance: float = GeometryUtilitiesConfig.DefaultMinTolerance(),
            tolerance1_d: float = GeometryUtilitiesConfig.DefaultMinTolerance(),
            tolerance2_d: float = GeometryUtilitiesConfig.DefaultMinTolerance(),
            tolerance3_d: float = GeometryUtilitiesConfig.DefaultMinTolerance()
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

    class GeometryUtilities:
        """/ \brief The GeometryUtilities class intersects 3D segments
        (final class)
        """
        class CompareTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            first_before_second = enum.auto()                                                                                                                                                                                             # (= 1)
            coincident = enum.auto()                                                                                                                                                                                                      # (= 2)
            second_before_first = enum.auto()                                                                                                                                                                                             # (= 3)

        class PolygonTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            triangle = enum.auto()                                                                                                                                                                                                        # (= 1)
            quadrilateral_convex = enum.auto()                                                                                                                                                                                            # (= 2)
            quadrilateral_concave = enum.auto()                                                                                                                                                                                           # (= 3)
            generic_convex = enum.auto()                                                                                                                                                                                                  # (= 4)
            generic_concave = enum.auto()                                                                                                                                                                                                 # (= 5)

        class PolygonOrientations(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            clockwise = enum.auto()                                                                                                                                                                                                       # (= 1)
            counter_clockwise = enum.auto()                                                                                                                                                                                               # (= 2)

        class PointSegmentPositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            on_segment_line_before_origin = enum.auto()                                                                                                                                                                                   # (= 1)
            on_segment_origin = enum.auto()                                                                                                                                                                                               # (= 2)
            inside_segment = enum.auto()                                                                                                                                                                                                  # (= 3)
            on_segment_end = enum.auto()                                                                                                                                                                                                  # (= 4)
            on_segment_line_after_end = enum.auto()                                                                                                                                                                                       # (= 5)
            left_the_segment = enum.auto()                                                                                                                                                                                                # (= 6)
            right_the_segment = enum.auto()                                                                                                                                                                                               # (= 7)

        class PointPlanePositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            negative = enum.auto()                                                                                                                                                                                                        # (= 1)
            on_plane = enum.auto()                                                                                                                                                                                                        # (= 2)
            positive = enum.auto()                                                                                                                                                                                                        # (= 3)

        class PolygonCirclePositionTypes(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            polygon_outside_circle_no_intersection = enum.auto()                                                                                                                                                                          # (= 1)
            polygon_outside_circle_one_intersection_on_vertex = enum.auto()                                                                                                                                                               # (= 2)
            polygon_outside_circle_one_intersection_tangent_on_edge = enum.auto()                                                                                                                                                         # (= 3)
            circle_inside_polygon_no_intersection = enum.auto()                                                                                                                                                                           # (= 4)
            circle_inside_polygon_one_intersection_tangent_on_edge = enum.auto()                                                                                                                                                          # (= 5)
            polygon_inside_circle_no_intersection = enum.auto()                                                                                                                                                                           # (= 6)
            polygon_inside_circle_one_vertex_intersection = enum.auto()                                                                                                                                                                   # (= 7)
            polygon_inside_circle_intersection_only_on_vertices = enum.auto()                                                                                                                                                             # (= 8)
            circle_polygon_multiple_intersections = enum.auto()                                                                                                                                                                           # (= 9)

        class IntersectionPolygonCircleResult:
            """
            (final class)
            """
            class Intersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    secant = enum.auto()                                                                                                                                                                                                  # (= 1)
                    tangent = enum.auto()                                                                                                                                                                                                 # (= 2)

                class IndexTypes(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    vertex = enum.auto()                                                                                                                                                                                                  # (= 1)
                    edge = enum.auto()                                                                                                                                                                                                    # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection.Types = Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection.Types.unknown
                index_type: Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection.IndexTypes = Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection.IndexTypes.unknown
                index: int
                curvilinear_coordinate: float                                                                                                                                                                                             #/< Valid only in IndexType Edge
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolygonCircleResult.Intersection.Types = GeometryUtilities.IntersectionPolygonCircleResult.Intersection.Types.unknown,
                    index_type: GeometryUtilities.IntersectionPolygonCircleResult.Intersection.IndexTypes = GeometryUtilities.IntersectionPolygonCircleResult.Intersection.IndexTypes.unknown,
                    curvilinear_coordinate: float = float()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            intersections: List[Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection] = List[Gedim.GeometryUtilities.IntersectionPolygonCircleResult.Intersection]()                                                      #/< ordered
            #/< by
            #/< edge
            #/< order
            def __init__(
                self,
                intersections: List[GeometryUtilities.IntersectionPolygonCircleResult.Intersection] = List[GeometryUtilities.IntersectionPolygonCircleResult.Intersection]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PolygonDivisionByAngleQuadrantResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                external_origin = enum.auto()                                                                                                                                                                                             # (= 1)
                internal = enum.auto()                                                                                                                                                                                                    # (= 2)
                external_end = enum.auto()                                                                                                                                                                                                # (= 3)

            points: Eigen.MatrixXd                                                                                                                                                                                                        #/< Coordinates of generated points
            sub_polygons: List[List[int]]                                                                                                                                                                                                 #/< Subpolygon formed
            sub_polygon_types: List[Gedim.GeometryUtilities.PolygonDivisionByAngleQuadrantResult.Types]                                                                                                                                   #/< SubPolygon
            #/< types
            def __init__(
                self,
                points: Eigen.MatrixXd = Eigen.MatrixXd(),
                sub_polygon_types: List[GeometryUtilities.PolygonDivisionByAngleQuadrantResult.Types] = List[GeometryUtilities.PolygonDivisionByAngleQuadrantResult.Types]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PolygonDivisionByCircleResult:
            """
            (final class)
            """
            points: Eigen.MatrixXd                                                                                                                                                                                                        #/< Coordinates of generated points
            sub_triangles: List[List[int]]                                                                                                                                                                                                #/< Triangle formed with sub-polygons and circle Center
            internal_triangles: List[List[int]]                                                                                                                                                                                           #/< Triangle formed with circle Center and new points
            sub_polygons: List[List[int]]                                                                                                                                                                                                 #/< Subpolygon formed
            def __init__(self, points: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CircleDivisionByPolygonResult:
            """
            (final class)
            """
            points: Eigen.MatrixXd                                                                                                                                                                                                        #/< Coordinates of generated points
            sub_triangles: List[List[int]]                                                                                                                                                                                                #/< Triangle formed with sub-polygons and circle Center
            internal_triangles: List[List[int]]                                                                                                                                                                                           #/< Triangle formed with circle Center and new points
            sub_polygons: List[List[int]]                                                                                                                                                                                                 #/< Subpolygon formed
            def __init__(self, points: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonInput:
            """
            (final class)
            """
            class AlignedEdge:
                origin_vertex_index: int
                end_vertex_index: int
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            class SplitSegment:
                class Vertex:
                    """
                    (final class)
                    """
                    class Types(enum.IntEnum):
                        unknown = enum.auto()                                                                                                                                                                                             # (= 0)
                        vertex = enum.auto()                                                                                                                                                                                              # (= 1)
                        edge = enum.auto()                                                                                                                                                                                                # (= 2)

                    type: Gedim.GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex.Types
                    index: int
                    def __init__(
                        self,
                        type: GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex.Types = GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex.Types()
                        ) -> None:
                        """Auto-generated default constructor with named params"""
                        pass

                origin: Gedim.GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex
                end: Gedim.GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex
                def __init__(
                    self,
                    origin: GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex = GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex(),
                    end: GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex = GeometryUtilities.SplitPolygonInput.SplitSegment.Vertex()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            number_polygon_vertices: int
            aligned_edges: List[Gedim.GeometryUtilities.SplitPolygonInput.AlignedEdge]
            segment: Gedim.GeometryUtilities.SplitPolygonInput.SplitSegment
            def __init__(
                self,
                aligned_edges: List[GeometryUtilities.SplitPolygonInput.AlignedEdge] = List[GeometryUtilities.SplitPolygonInput.AlignedEdge](),
                segment: GeometryUtilities.SplitPolygonInput.SplitSegment = GeometryUtilities.SplitPolygonInput.SplitSegment()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithSegmentResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                no_action = enum.auto()                                                                                                                                                                                                   # (= 1)
                polygon_update = enum.auto()                                                                                                                                                                                              # (= 2)
                polygon_creation = enum.auto()                                                                                                                                                                                            # (= 3)

            class NewVertex:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    segment_origin = enum.auto()                                                                                                                                                                                          # (= 1)
                    segment_end = enum.auto()                                                                                                                                                                                             # (= 2)

                type: Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex.Types = Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex.Types.unknown
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex.Types = GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdge:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    edge_new = enum.auto()                                                                                                                                                                                                # (= 1)
                    edge_update = enum.auto()                                                                                                                                                                                             # (= 2)

                type: Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge.Types = Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge.Types.unknown
                old_edge_id: int = 0
                origin_id: int = 0
                end_id: int = 0
                cell2_d_neighbours: List[int] = List[int]()
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge.Types = GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolygon:
                """
                (final class)
                """
                vertices: std.list[int] = std.list<int>()
                edges: std.list[int] = std.list<int>()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            type: Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.Types = Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.Types.unknown
            new_vertices: std.list[Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex] = std.list<Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex>()
            new_edges: std.list[Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge] = std.list<Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge>()
            new_polygons: List[Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewPolygon] = List[Gedim.GeometryUtilities.SplitPolygonWithSegmentResult.NewPolygon]()
            def __init__(
                self,
                type: GeometryUtilities.SplitPolygonWithSegmentResult.Types = GeometryUtilities.SplitPolygonWithSegmentResult.Types.unknown,
                new_vertices: std.list[GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex] = std.list<GeometryUtilities.SplitPolygonWithSegmentResult.NewVertex>(),
                new_edges: std.list[GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge] = std.list<GeometryUtilities.SplitPolygonWithSegmentResult.NewEdge>(),
                new_polygons: List[GeometryUtilities.SplitPolygonWithSegmentResult.NewPolygon] = List[GeometryUtilities.SplitPolygonWithSegmentResult.NewPolygon]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithCircleResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                no_action = enum.auto()                                                                                                                                                                                                   # (= 1)
                polygon_update = enum.auto()                                                                                                                                                                                              # (= 2)
                polygon_creation = enum.auto()                                                                                                                                                                                            # (= 3)

            class NewVertex:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    polygon_vertex = enum.auto()                                                                                                                                                                                          # (= 1)
                    circle_intersection = enum.auto()                                                                                                                                                                                     # (= 2)
                    both = enum.auto()                                                                                                                                                                                                    # (= 3)

                type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewVertex.Types = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewVertex.Types.unknown
                polygon_index: int                                                                                                                                                                                                        #/< Index in polygon vertices
                intersection_index: int                                                                                                                                                                                                   #/< Index in circle intersections
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithCircleResult.NewVertex.Types = GeometryUtilities.SplitPolygonWithCircleResult.NewVertex.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdge:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    segment = enum.auto()                                                                                                                                                                                                 # (= 1)
                    arc = enum.auto()                                                                                                                                                                                                     # (= 2)

                class ArcTypes(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    inside_polygon = enum.auto()                                                                                                                                                                                          # (= 1)
                    outside_polygon = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.Types = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.Types.unknown
                arc_type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.ArcTypes = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.ArcTypes.unknown                                                           #/< Valid only if
                #/< Type is Arc
                vertex_indices: List[int]                                                                                                                                                                                                 #/< Index of vertices in NewVertices
                polygon_index: int                                                                                                                                                                                                        #/< Index of Edge in polygon intersections
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.Types = GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.Types.unknown,
                    arc_type: GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.ArcTypes = GeometryUtilities.SplitPolygonWithCircleResult.NewEdge.ArcTypes.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolygon:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    inside_only_circle = enum.auto()                                                                                                                                                                                      # (= 1)
                    inside_only_polygon = enum.auto()                                                                                                                                                                                     # (= 2)
                    inside_circle_and_polygon = enum.auto()                                                                                                                                                                               # (= 3)

                type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon.Types = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon.Types.unknown
                vertices: List[int] = List[int]()
                edges: List[int] = List[int]()
                def __init__(
                    self,
                    type: GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon.Types = GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.SplitPolygonWithCircleResult.Types = Gedim.GeometryUtilities.SplitPolygonWithCircleResult.Types.unknown
            polygon_vertices_new_vertices_position: List[int] = List[int]()
            circle_intersections_new_vertices_position: List[int] = List[int]()
            new_vertices: List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewVertex] = List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewVertex]()
            new_edges: List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge] = List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewEdge]()
            new_polygons: List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon] = List[Gedim.GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon]()
            def __init__(
                self,
                type: GeometryUtilities.SplitPolygonWithCircleResult.Types = GeometryUtilities.SplitPolygonWithCircleResult.Types.unknown,
                new_vertices: List[GeometryUtilities.SplitPolygonWithCircleResult.NewVertex] = List[GeometryUtilities.SplitPolygonWithCircleResult.NewVertex](),
                new_edges: List[GeometryUtilities.SplitPolygonWithCircleResult.NewEdge] = List[GeometryUtilities.SplitPolygonWithCircleResult.NewEdge](),
                new_polygons: List[GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon] = List[GeometryUtilities.SplitPolygonWithCircleResult.NewPolygon]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentSegmentResult:
            """
            (final class)
            """
            class IntersectionLineTypes(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                on_different_planes = enum.auto()                                                                                                                                                                                         # (= 1)
                co_planar_parallel = enum.auto()                                                                                                                                                                                          # (= 2)
                co_planar_intersecting = enum.auto()                                                                                                                                                                                      # (= 3)

            class IntersectionSegmentTypes(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                no_intersection = enum.auto()                                                                                                                                                                                             # (= 1)
                single_intersection = enum.auto()                                                                                                                                                                                         # (= 2)
                multiple_intersections = enum.auto()                                                                                                                                                                                      # (= 3)

            class IntersectionPosition:
                type: Gedim.GeometryUtilities.PointSegmentPositionTypes = Gedim.GeometryUtilities.PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: GeometryUtilities.PointSegmentPositionTypes = GeometryUtilities.PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            intersection_lines_type: Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionLineTypes = Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionLineTypes.unknown
            intersection_segments_type: Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionSegmentTypes = Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionSegmentTypes.unknown
            #/ \brief relation between first and second intersection.
            #/ Values are the indeces of the SecondSegmentIntersections vector respect the FirstSegmentIntersections vector
            #/ \example in MultipleIntersection case, if SecondIntersectionRelation[0] = 1,
            #/ then the second intersection point SecondSegmentIntersections[1] is equal to FirstSegmentIntersections[0]
            #/ point
            second_intersection_relation: List[int]
            #/ \brief intersections of the first segment,
            #/ \note if multiple intersections are found, than the origin and the end coordinate are stored
            first_segment_intersections: List[Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition]
            #/ \brief intersections of the second segment,
            #/ \note if multiple intersections are found, than the origin and the end coordinate are stored
            second_segment_intersections: List[Gedim.GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition]                                                                                                             #/ intersections of the second segment
            def __init__(
                self,
                intersection_lines_type: GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionLineTypes = GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionLineTypes.unknown,
                intersection_segments_type: GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionSegmentTypes = GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionSegmentTypes.unknown,
                first_segment_intersections: List[GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition] = List[GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition](),
                second_segment_intersections: List[GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition] = List[GeometryUtilities.IntersectionSegmentSegmentResult.IntersectionPosition]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentCircleResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                no_intersection = enum.auto()                                                                                                                                                                                             # (= 1)
                tangent_intersection = enum.auto()                                                                                                                                                                                        # (= 2)
                two_intersections = enum.auto()                                                                                                                                                                                           # (= 3)

            class IntersectionPosition:
                type: Gedim.GeometryUtilities.PointSegmentPositionTypes = Gedim.GeometryUtilities.PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: GeometryUtilities.PointSegmentPositionTypes = GeometryUtilities.PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.IntersectionSegmentCircleResult.Types = Gedim.GeometryUtilities.IntersectionSegmentCircleResult.Types.unknown
            #/ \brief intersections of the segment,
            segment_intersections: List[Gedim.GeometryUtilities.IntersectionSegmentCircleResult.IntersectionPosition] = List[Gedim.GeometryUtilities.IntersectionSegmentCircleResult.IntersectionPosition]()
            def __init__(
                self,
                type: GeometryUtilities.IntersectionSegmentCircleResult.Types = GeometryUtilities.IntersectionSegmentCircleResult.Types.unknown,
                segment_intersections: List[GeometryUtilities.IntersectionSegmentCircleResult.IntersectionPosition] = List[GeometryUtilities.IntersectionSegmentCircleResult.IntersectionPosition]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionSegmentPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                single_intersection = enum.auto()                                                                                                                                                                                         # (= 1)
                no_intersection = enum.auto()                                                                                                                                                                                             # (= 2)
                multiple_intersections = enum.auto()                                                                                                                                                                                      # (= 3)

            class Intersection:
                type: Gedim.GeometryUtilities.PointSegmentPositionTypes = Gedim.GeometryUtilities.PointSegmentPositionTypes.unknown
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: GeometryUtilities.PointSegmentPositionTypes = GeometryUtilities.PointSegmentPositionTypes.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.IntersectionSegmentPlaneResult.Types = Gedim.GeometryUtilities.IntersectionSegmentPlaneResult.Types.unknown                                                                                     #/< The intersection type
            single_intersection: Gedim.GeometryUtilities.IntersectionSegmentPlaneResult.Intersection                                                                                                                                      #/< The single
            #/< intersection,
            #/< available only
            #/< is Type is
            #/< SingleIntersection
            def __init__(
                self,
                type: GeometryUtilities.IntersectionSegmentPlaneResult.Types = GeometryUtilities.IntersectionSegmentPlaneResult.Types.unknown,
                single_intersection: GeometryUtilities.IntersectionSegmentPlaneResult.Intersection = GeometryUtilities.IntersectionSegmentPlaneResult.Intersection()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronLineResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                none = enum.auto()                                                                                                                                                                                                        # (= 1)  #/< No intersection found
                one_intersection = enum.auto()                                                                                                                                                                                            # (= 2)  #/< One intersection found
                two_intersections = enum.auto()                                                                                                                                                                                           # (= 3)  #/< Two intersection found
                multiple_intersections = enum.auto()                                                                                                                                                                                      # (= 4)  #/< Multiple intersection found

            class PolyhedronFaceIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection.Types.unknown
                line_intersection_index: int = 0                                                                                                                                                                                          #/< Index of line intersection collection
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection.Types = GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class PolyhedronEdgeIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection.Types.unknown
                line_intersection_index: int = 0                                                                                                                                                                                          #/< Index of line intersection collection
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection.Types = GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class PolyhedronVertexIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection.Types.unknown
                line_intersection_index: int = 0                                                                                                                                                                                          #/< Index of line intersection collection
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection.Types = GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class LineIntersection:
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    on_vertex = enum.auto()                                                                                                                                                                                               # (= 1)  #/< On polyhedron vertex
                    on_edge = enum.auto()                                                                                                                                                                                                 # (= 2)  #/< On polyhedron edge
                    on_face = enum.auto()                                                                                                                                                                                                 # (= 3)  #/< On polyhedron face
                    inside = enum.auto()                                                                                                                                                                                                  # (= 4)  #/< Inside polyhedron

                polyhedron_type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection.Types.unknown                                #/< Type
                #/< of
                #/< intersection
                polyhedron_index: int = 0                                                                                                                                                                                                 #/<  Index of the intersecting element of the Polyhedron (face, edge or
                #/<  vertex index)
                curvilinear_coordinate: float = 0.0                                                                                                                                                                                       #/< Curvilinear coordinate in the line
                def __init__(
                    self,
                    polyhedron_type: GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection.Types = GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection.Types.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.Types = Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.Types.unknown
            line_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection]                                                                                                                           #/< The line intersections
            polyhedron_vertex_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection]()  #/< Polyhedron Vertex
            #/< intersections, size
            #/< polyhedron num vertices
            polyhedron_edge_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection]()        #/< Polyhedron Edge intersections,
            #/< size polyhedron num edges
            polyhedron_face_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection]()        #/< Polyhedron Face intersections,
            #/< size polyhedron num faces
            def __init__(
                self,
                type: GeometryUtilities.IntersectionPolyhedronLineResult.Types = GeometryUtilities.IntersectionPolyhedronLineResult.Types.unknown,
                line_intersections: List[GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection] = List[GeometryUtilities.IntersectionPolyhedronLineResult.LineIntersection](),
                polyhedron_vertex_intersections: List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection] = List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronVertexIntersection](),
                polyhedron_edge_intersections: List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection] = List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronEdgeIntersection](),
                polyhedron_face_intersections: List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection] = List[GeometryUtilities.IntersectionPolyhedronLineResult.PolyhedronFaceIntersection]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronsSegmentResult:
            """
            (final class)
            """
            class IntersectionPoint:
                """
                (final class)
                """
                cell3_d_indices: List[int] = List[int]()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            class IntersectionSegment:
                """
                (final class)
                """
                points: List[float] = List[float]()
                cell3_d_indices: List[int] = List[int]()
                def __init__(self, points: List[float] = List[float]()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            points: Dict[float, Gedim.GeometryUtilities.IntersectionPolyhedronsSegmentResult.IntersectionPoint]
            segments: List[Gedim.GeometryUtilities.IntersectionPolyhedronsSegmentResult.IntersectionSegment]
            def __init__(
                self,
                segments: List[GeometryUtilities.IntersectionPolyhedronsSegmentResult.IntersectionSegment] = List[GeometryUtilities.IntersectionPolyhedronsSegmentResult.IntersectionSegment]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class IntersectionPolyhedronPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                none = enum.auto()                                                                                                                                                                                                        # (= 1)  #/< No intersection found
                on_vertex = enum.auto()                                                                                                                                                                                                   # (= 2)  #/< On polyhedron vertex
                on_edge = enum.auto()                                                                                                                                                                                                     # (= 3)  #/< On polyhedron edge
                on_face = enum.auto()                                                                                                                                                                                                     # (= 4)  #/< On polyhedron face
                new_polygon = enum.auto()                                                                                                                                                                                                 # (= 5)  #/< New polygon intersection

            class FaceIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection.Types.unknown
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection.Types = GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class EdgeIntersection:
                """
                (final class)
                """
                intersection: Gedim.GeometryUtilities.IntersectionSegmentPlaneResult                                                                                                                                                      #/< Intersection between edge and
                #/< plane
                def __init__(
                    self,
                    intersection: GeometryUtilities.IntersectionSegmentPlaneResult = GeometryUtilities.IntersectionSegmentPlaneResult()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VertexIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    intersection = enum.auto()                                                                                                                                                                                            # (= 1)
                    no_intersection = enum.auto()                                                                                                                                                                                         # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection.Types.unknown
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection.Types = GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class Intersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    vertex = enum.auto()                                                                                                                                                                                                  # (= 1)
                    edge = enum.auto()                                                                                                                                                                                                    # (= 2)

                type: Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection.Types = Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection.Types.unknown
                edge_id: int = 0                                                                                                                                                                                                          #/<  Edge index of the Polyhedron
                vertex_id: int = 0                                                                                                                                                                                                        #/<  Vertex index of the Polyhedron, available only if Type is Types::Vertex
                def __init__(
                    self,
                    type: GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection.Types = GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            type: Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Types = Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Types.unknown                                                                               #/< The intersection type
            intersection_id: int = 0                                                                                                                                                                                                      #/< The geometry id of the intersection, available only with Types::OnVertex,
            #/< Types::OnEdge and Types::OnFace
            vertex_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection]()                               #/< Vertex intersections
            edge_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.EdgeIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.EdgeIntersection]()                                     #/< Edge intersections
            face_intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection]()                                     #/< Face intersections
            intersections: List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection] = List[Gedim.GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection]()                                                  #/< The resulting intersections
            intersection_coordinates: Eigen.MatrixXd                                                                                                                                                                                      #/< The resulting intersection coordinates
            def __init__(
                self,
                type: GeometryUtilities.IntersectionPolyhedronPlaneResult.Types = GeometryUtilities.IntersectionPolyhedronPlaneResult.Types.unknown,
                vertex_intersections: List[GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection] = List[GeometryUtilities.IntersectionPolyhedronPlaneResult.VertexIntersection](),
                edge_intersections: List[GeometryUtilities.IntersectionPolyhedronPlaneResult.EdgeIntersection] = List[GeometryUtilities.IntersectionPolyhedronPlaneResult.EdgeIntersection](),
                face_intersections: List[GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection] = List[GeometryUtilities.IntersectionPolyhedronPlaneResult.FaceIntersection](),
                intersections: List[GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection] = List[GeometryUtilities.IntersectionPolyhedronPlaneResult.Intersection](),
                intersection_coordinates: Eigen.MatrixXd = Eigen.MatrixXd()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PointCirclePositionResult(enum.IntEnum):
            unknown = enum.auto()                                                                                                                                                                                                         # (= 0)
            outside = enum.auto()                                                                                                                                                                                                         # (= 1)
            on_border = enum.auto()                                                                                                                                                                                                       # (= 2)
            inside = enum.auto()                                                                                                                                                                                                          # (= 3)

        class PointPolygonPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                outside = enum.auto()                                                                                                                                                                                                     # (= 1)
                border_edge = enum.auto()                                                                                                                                                                                                 # (= 2)
                border_vertex = enum.auto()                                                                                                                                                                                               # (= 3)
                inside = enum.auto()                                                                                                                                                                                                      # (= 4)

            border_index: int = 0                                                                                                                                                                                                         #/< index of vertex/edge of border
            type: Gedim.GeometryUtilities.PointPolygonPositionResult.Types = Gedim.GeometryUtilities.PointPolygonPositionResult.Types.unknown
            def __init__(
                self,
                type: GeometryUtilities.PointPolygonPositionResult.Types = GeometryUtilities.PointPolygonPositionResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class LinePolygonPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                outside = enum.auto()                                                                                                                                                                                                     # (= 1)
                intersecting = enum.auto()                                                                                                                                                                                                # (= 2)

            class EdgeIntersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                                                                                                                                                 # (= 0)
                    on_edge_origin = enum.auto()                                                                                                                                                                                          # (= 1)
                    inside_edge = enum.auto()                                                                                                                                                                                             # (= 2)
                    on_edge_end = enum.auto()                                                                                                                                                                                             # (= 3)
                    parallel = enum.auto()                                                                                                                                                                                                # (= 4)

                type: Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection.Types = Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection.Types.unknown
                index: int = 0
                curvilinear_coordinate: float = 0.0
                def __init__(
                    self,
                    type: GeometryUtilities.LinePolygonPositionResult.EdgeIntersection.Types = GeometryUtilities.LinePolygonPositionResult.EdgeIntersection.Types.unknown,
                    curvilinear_coordinate: float = 0.0
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            edge_intersections: List[Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection] = List[Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection]()
            type: Gedim.GeometryUtilities.LinePolygonPositionResult.Types = Gedim.GeometryUtilities.LinePolygonPositionResult.Types.unknown
            def __init__(
                self,
                edge_intersections: List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection] = List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection](),
                type: GeometryUtilities.LinePolygonPositionResult.Types = GeometryUtilities.LinePolygonPositionResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class PointPolyhedronPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                outside = enum.auto()                                                                                                                                                                                                     # (= 1)
                border_face = enum.auto()                                                                                                                                                                                                 # (= 2)
                border_edge = enum.auto()                                                                                                                                                                                                 # (= 3)
                border_vertex = enum.auto()                                                                                                                                                                                               # (= 4)
                inside = enum.auto()                                                                                                                                                                                                      # (= 5)

            border_index: int = 0                                                                                                                                                                                                         #/< index of vertex/edge/face of border
            internal_indices: List[int]                                                                                                                                                                                                   #/< list of index of internal cell (usually tetrahedrons)
            type: Gedim.GeometryUtilities.PointPolyhedronPositionResult.Types = Gedim.GeometryUtilities.PointPolyhedronPositionResult.Types.unknown
            def __init__(
                self,
                type: GeometryUtilities.PointPolyhedronPositionResult.Types = GeometryUtilities.PointPolyhedronPositionResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SegmentPolyhedronPositionResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                outside = enum.auto()                                                                                                                                                                                                     # (= 1)
                border_face = enum.auto()                                                                                                                                                                                                 # (= 2)
                border_edge = enum.auto()                                                                                                                                                                                                 # (= 3)
                inside = enum.auto()                                                                                                                                                                                                      # (= 4)

            border_index: int = 0                                                                                                                                                                                                         #/< index of edge/face of border
            type: Gedim.GeometryUtilities.SegmentPolyhedronPositionResult.Types = Gedim.GeometryUtilities.SegmentPolyhedronPositionResult.Types.unknown
            def __init__(
                self,
                type: GeometryUtilities.SegmentPolyhedronPositionResult.Types = GeometryUtilities.SegmentPolyhedronPositionResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Polyhedron:
            """
            (final class)
            """
            vertices: Eigen.MatrixXd                                                                                                                                                                                                      #/< vertices, size 3 x numVertices
            edges: Eigen.MatrixXi                                                                                                                                                                                                         #/< edges, size 2 x numEdges
            faces: List[Eigen.MatrixXi]                                                                                                                                                                                                   #/< faces vertices and edges, size numFaces x 2 x numFaceVertices
            def __init__(
                self,
                vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                edges: Eigen.MatrixXi = Eigen.MatrixXi(),
                faces: List[Eigen.MatrixXi] = List[Eigen.MatrixXi]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolygonWithPlaneResult:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                split = enum.auto()                                                                                                                                                                                                       # (= 1)
                positive = enum.auto()                                                                                                                                                                                                    # (= 2)
                negative = enum.auto()                                                                                                                                                                                                    # (= 3)
                on_plane = enum.auto()                                                                                                                                                                                                    # (= 4)

            positive_vertices: List[int]                                                                                                                                                                                                  #/ vertices indices of the positive sub-polygon
            negative_vertices: List[int]                                                                                                                                                                                                  #/ vertices indices of the negative sub-polygon
            points_on_plane: List[int]                                                                                                                                                                                                    #/ vertices indices of the points on plane
            new_vertices: List[Eigen.Vector3d]                                                                                                                                                                                            #/ new vertices coordinates
            new_vertices_edge_index: List[int]                                                                                                                                                                                            #/ new vertices edge indices
            type: Gedim.GeometryUtilities.SplitPolygonWithPlaneResult.Types = Gedim.GeometryUtilities.SplitPolygonWithPlaneResult.Types.unknown                                                                                           #/ type of split
            def __init__(
                self,
                new_vertices: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                type: GeometryUtilities.SplitPolygonWithPlaneResult.Types = GeometryUtilities.SplitPolygonWithPlaneResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitPolyhedronWithPlaneResult:
            class Types(enum.IntEnum):
                unknown = enum.auto()                                                                                                                                                                                                     # (= 0)
                split = enum.auto()                                                                                                                                                                                                       # (= 1)
                none = enum.auto()                                                                                                                                                                                                        # (= 2)

            class NewVertices:
                vertices: Eigen.MatrixXd                                                                                                                                                                                                  #/< all vertices contained in the new polyhedra
                new_vertices_original_edge: List[int]                                                                                                                                                                                     #/< For each new vertex the index of the original edge
                #/< to which is located
                def __init__(self, vertices: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewEdges:
                edges: Eigen.MatrixXi                                                                                                                                                                                                     #/< all edges contained in the new polyhedra
                new_edges_original_edges: List[int]                                                                                                                                                                                       #/< indices of original edges for new edges, -1 means no original
                #/< edge
                new_edges_original_face: List[int]                                                                                                                                                                                        #/< For each new vertex the index of the original edge to which is
                #/< located
                def __init__(
                    self,
                    edges: Eigen.MatrixXi = Eigen.MatrixXi(),
                    new_edges_original_edges: List[int] = List[int](),
                    new_edges_original_face: List[int] = List[int]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewFaces:
                faces: List[Eigen.MatrixXi]
                new_faces_original_faces: List[int]                                                                                                                                                                                       #/< indices of original faces for new faces, -1 means no original
                #/< face
                def __init__(
                    self,
                    faces: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                    new_faces_original_faces: List[int] = List[int]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class NewPolyhedron:
                vertices: List[int]
                edges: List[int]
                faces: List[int]
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            original_edges_new_edges: List[List[int]]
            original_faces_new_faces: List[List[int]]
            vertices: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewVertices
            edges: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewEdges
            faces: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewFaces
            positive_polyhedron: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron
            negative_polyhedron: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron
            type: Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.Types = Gedim.GeometryUtilities.SplitPolyhedronWithPlaneResult.Types.unknown                                                                                     #/ type of split
            def __init__(
                self,
                vertices: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewVertices = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewVertices(),
                edges: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewEdges = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewEdges(),
                faces: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewFaces = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewFaces(),
                positive_polyhedron: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron(),
                negative_polyhedron: GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron = GeometryUtilities.SplitPolyhedronWithPlaneResult.NewPolyhedron(),
                type: GeometryUtilities.SplitPolyhedronWithPlaneResult.Types = GeometryUtilities.SplitPolyhedronWithPlaneResult.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class AlignedPolyhedronEdgesResult:
            aligned_edges_vertices: List[List[int]]
            aligned_edges_edges: List[List[int]]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class MergePolyhedronsInput:
            none: int = std.numeric_limits<int>.max()                                                                                                                                                                                     # (C++ static member) # (const)
            class MergeTypes(enum.IntEnum):
                none = enum.auto()                                                                                                                                                                                                        # (= 0)
                common = enum.auto()                                                                                                                                                                                                      # (= 1)
                remove = enum.auto()                                                                                                                                                                                                      # (= 2)

            vertices_type: List[List[Tuple[Gedim.GeometryUtilities.MergePolyhedronsInput.MergeTypes]
            edges_type: List[List[Tuple[Gedim.GeometryUtilities.MergePolyhedronsInput.MergeTypes]
            faces_type: List[List[Tuple[Gedim.GeometryUtilities.MergePolyhedronsInput.MergeTypes]
            common_vertices: List[List[int]]
            common_edges: List[List[int]]
            common_faces: List[List[int]]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class MergePolyhedronsResult:
            none: int = std.numeric_limits<int>.max()                                                                                                                                                                                     # (C++ static member) # (const)
            original_to_merged_vertices: List[List[int]]
            original_to_merged_edges: List[List[int]]
            original_to_merged_faces: List[List[int]]
            merged_to_original_vertices: List[List[int]]
            merged_to_original_edges: List[List[int]]
            merged_to_original_faces: List[List[int]]
            merged_polyhedron: Gedim.GeometryUtilities.Polyhedron
            def __init__(
                self,
                merged_polyhedron: GeometryUtilities.Polyhedron = GeometryUtilities.Polyhedron()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self, configuration: GeometryUtilitiesConfig) -> None:
            pass

        def tolerance1_d(self) -> float:
            """/ \return tolerance used for segment length"""
            pass
        def tolerance1_d_squared(self) -> float:
            """/ \return tolerance used for squared segment length"""
            pass
        def tolerance2_d(self) -> float:
            """/ \return tolerance used for polygon area"""
            pass
        def tolerance3_d(self) -> float:
            """/ \return tolerance used for polyhedron volume"""
            pass

        def relative_difference(self, first: float, second: float, tolerance: float) -> float:
            """/ \param first the first value
            / \param second the second value
            / \return the relative difference between the two values according the first
            """
            pass

        def compare_values(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> GeometryUtilities.CompareTypes:
            """/ \brief Compare two values according to tolerance
            / \param first the first value
            / \param second the second value
            / \return the result
            / \note the interval [-tolerance, tolerance] is considered 0.0
            """
            pass

        def are_values_equal(self, first: float, second: float, tolerance: float) -> bool:
            """/ \brief Check if two values are equal according to tolerance
            / \param first the first value
            / \param second the second value
            / \return the result
            """
            pass

        def is_value_greater(self, first: float, second: float, tolerance: float) -> bool:
            """/ \param first the first value
            / \param second the second value
            / \return True if first is greater than second
            """
            pass

        def is_value_greater_or_equal(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> bool:
            """/ \param first the first value
            / \param second the second value
            / \return True if first is greater or equal than second
            """
            pass

        def is_value_lower(self, first: float, second: float, tolerance: float) -> bool:
            pass

        def is_value_lower_or_equal(
            self,
            first: float,
            second: float,
            tolerance: float
            ) -> bool:
            pass

        def is_value_positive(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is positive
            """
            pass

        def is_value_negative(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is negative
            """
            pass

        def is_value_zero(self, value: float, tolerance: float) -> bool:
            """/ \param value the value
            / \return True if value is zero
            """
            pass

        def fibonacci_sphere(self, num_points: int) -> Eigen.MatrixXd:
            pass
        def generate_uniform_random_points_in_sphere(
            self,
            num_points: int,
            radius: float = 1.0
            ) -> Eigen.MatrixXd:
            pass

        @overload
        def equispace_coordinates(self, step: float, insert_extremes: bool) -> List[float]:
            """/ \param step the distance between each coordinate
            / \param insertExtremes if True keeps the extremes
            / \return the equispace coordinates between [0.0, 1.0], size 1 x numCoordinates
            """
            pass

        @overload
        def equispace_coordinates(
            self,
            size: int,
            origin: float,
            end: float,
            insert_extremes: bool
            ) -> List[float]:
            """/ \param size the number of resulting coordinates
            / \param origin the starting curvilinear coordinate
            / \param end the ending curvilinear coordinate
            / \param insertExtremes if True keeps the extremes
            / \return equispaced curvilinear coordinates in the interval [origin, end]
            / \note if size < 2 then size will be considered as 2
            """
            pass
        def random_coordinates(
            self,
            size: int,
            insert_extremes: bool,
            min_distance: float,
            seed: int = time(None)
            ) -> List[float]:
            """/ \param size the number of resulting coordinates
            / \param origin the starting curvilinear coordinate
            / \param end the ending curvilinear coordinate
            / \param insertExtremes if True keeps the extremes
            / \return random curvilinear coordinates in the interval [0.0, 1.0], size 1 x numCoordinates
            / \note if size < 2 then size will be considered as 2
            """
            pass

        def polar_angle(
            self,
            v_prev: Eigen.Vector3d,
            v: Eigen.Vector3d,
            v_next: Eigen.Vector3d,
            norm_v_prev_v: float,
            norm_v_next_v: float
            ) -> float:
            """/ \param v_prev the previous point
            / \param v the middle point
            / \param v_next the next point
            / \return the polar angle between the three points, computed as the cross product (v_next-v) x (v_prev-v)
            / \note positive is convex (counter-clockwise), negative is concave (clockwise), zero is collinear
            """
            pass

        def point_distance(
            self,
            first_point: Eigen.Vector3d,
            second_point: Eigen.Vector3d
            ) -> float:
            """/ \brief compute the Point distance
            / \param firstPoint the first point
            / \param secondPoint the second point
            / \return the distance
            """
            pass

        def point_distances(
            self,
            points: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> Eigen.VectorXd:
            """/ \brief compute the distance between a point and a list of points
            / \param points the point collection, size 3 x numPoints
            / \param point the point
            / \return the collection of distances, size 1 x numPoints
            """
            pass

        def points_distance(self, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \param points the point collection, size 3 x numPoints
            / \return the distances between the points collected in matrix, size numPoints x numPoints.
            """
            pass

        def points_bounding_box(self, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \param points the point collection, size 3 x numPoints
            / \return the extreme bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints
            """
            pass

        def is_point_in_bounding_box(
            self,
            point: Eigen.Vector3d,
            bouding_box: Eigen.MatrixXd
            ) -> bool:
            """/ \param point the point
            / \param boudingBox the bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints
            / \return False if the point is outside the bounding box, True otherwise (border or inside)
            """
            pass

        def bounding_boxes_intersects(
            self,
            bouding_box_1: Eigen.MatrixXd,
            bouding_box_2: Eigen.MatrixXd
            ) -> bool:
            pass

        def points_max_distance(self, points: Eigen.MatrixXd) -> float:
            """/ \param points the point collection, size 3 x numPoints
            / \return the maximum distance between the points.
            """
            pass

        def is_point_zero(self, point: Eigen.Vector3d) -> bool:
            pass

        def points_are_coincident(
            self,
            first_point: Eigen.Vector3d,
            second_point: Eigen.Vector3d
            ) -> bool:
            """/ \param firstPoint the first point
            / \param secondPoint the second point
            / \return True if the points are coincident
            """
            pass

        def find_point_in_points(
            self,
            points: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Find a point in point list
            / \param points the point list, size 3 x numPoints
            / \param point the point to find
            / \return the collection of point found
            """
            pass

        def point_line_distance(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            normal_to_line: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the distance between a point and a line
            / \param point a point P
            / \param lineOrigin the line origin O
            / \param normalToLine a normal vector n to the line, in the same plane of P and the line
            / \return the distance d
            / \note The distance is computed as d = n^T * (P - O) / ||n||
            """
            pass

        def point_is2_d(self, point: Eigen.Vector3d) -> bool:
            """/ \param point the point
            / \return True if the point is 2D (z == 0)
            """
            pass

        def points_are2_d(self, points: Eigen.MatrixXd) -> bool:
            """/ \param points the points to test, size 3 x numPoints
            / \return True if the points are 2D (z == 0)
            """
            pass

        def point_curvilinear_coordinate(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief compute the Point Curvilinear Coordinate of segment
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the curvilinear coordinate computed
            """
            pass

        def point_line_curvilinear_coordinate(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d,
            line_tangent_squared_length: float
            ) -> float:
            """/ \brief compute the Point Curvilinear Coordinate of line
            / \param point the point
            / \param lineOrigin the line origin
            / \param lineTangent the line tangent
            / \param lineTangentSquaredLength the line tangent length squared
            / \return the curvilinear coordinate computed
            """
            pass

        def is_point_on_line(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d,
            line_tangent_squared_length: float
            ) -> bool:
            """/ \param point the point
            / \param lineOrigin the line origin
            / \param lineTangent the line tangent
            / \param lineTangentSquaredLength the line tangent length squared
            / \return True if the point belongs on line
            """
            pass

        @overload
        def point_segment_position(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> GeometryUtilities.PointSegmentPositionTypes:
            """/ \brief Compute point position respect to a segment
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return result the point position
            / \warning left and right point positions work only in xy plane
            """
            pass

        @overload
        def point_segment_position(
            self,
            curvilinear_coordinate: float
            ) -> GeometryUtilities.PointSegmentPositionTypes:
            """/ \brief Compute point position on a segment line given the curvilinear Coordinate
            / \param curvilinearCoordinate the curvilinear coordinate, segment is between 0.0 and 1.0
            / \param result the point position on the line
            """
            pass

        def point_segment_projection(
            self,
            point: Eigen.Vector3d,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Project point on a segment line
            / \param point the point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the projected point curvilinear coordinate
            """
            pass

        @overload
        def point_plane_distance(
            self,
            point: Eigen.Vector3d,
            plane_points: List[Eigen.Vector3d]
            ) -> float:
            """/ \brief Compute point position respect to a plane formed by 3 points
            / \param planePoints the 3 plane points
            / \param point the point
            / \return the signed point distance, 0.0 on plane, positive above, negative bottom
            """
            pass
        @overload
        def point_plane_distance(
            self,
            point: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute point position respect to a plane normal
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \param point the point
            / \return the signed point distance, 0.0 on plane, positive above, negative bottom
            """
            pass

        def point_plane_position(
            self,
            point_plane_distance: float
            ) -> GeometryUtilities.PointPlanePositionTypes:
            """/ \brief Compute point position respect to a plane
            / \param pointPlaneDistance the point plane distance
            / \return result the point position
            """
            pass

        @overload
        def is_point_on_plane(self, point_plane_distance: float) -> bool:
            """/ \param pointPlaneDistance the point plane distance
            / \return True if point is on the plane
            """
            pass

        @overload
        def is_point_on_plane(
            self,
            point: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> bool:
            """/ \param point the point
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \return True if point is on the plane
            """
            pass

        def segment_length(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment length
            """
            pass

        def segment_tangent(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment tangent
            """
            pass

        def segment_normal(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment normal normalized, rotation of the normalized tangent (x,y,0) with 90 clockwise (y, -x,0)
            / \note the segment shall be 2D
            """
            pass

        def segment_slope(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the segment slope m of line y = m * x + q
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment slope
            / \note the segment shall be 2D
            """
            pass

        def segment_intercept(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> float:
            """/ \brief Compute the segment intercept q of line y = m * x + q
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \return the segment intercept
            / \note the segment shall be 2D
            """
            pass

        def make_concatenation(
            self,
            segments: Eigen.MatrixXi,
            starting_vertex: int
            ) -> Eigen.MatrixXi:
            pass

        def check_no_spheres_intersection(
            self,
            first_sphere_center: Eigen.Vector3d,
            second_sphere_center: Eigen.Vector3d,
            first_sphere_diameter: float,
            second_sphere_diameter: float
            ) -> bool:
            """/ \brief Check if two spheres do not intersect
            / \param firstSphereCenter the first sphere center
            / \param secondSphereCenter the second sphere center
            / \param firstSphereDiameter the first sphere diameter
            / \param secondSphereDiameter the second sphere diameter
            / \return True if the two segments do not intersect
            / \note if the function returns True it does not mean that the two segments intersects
            """
            pass

        def check_triangles_intersection(
            self,
            triangle_one: Eigen.MatrixX3d,
            triangle_two: Eigen.MatrixX3d,
            admit_boundary: bool = True
            ) -> bool:
            """/ \note works only for 2D triangles
            / \see https://rosettacode.org/wiki/Determine_if_two_triangles_overlap                                                                                                                                                        #C++
            """
            pass

        def are_line_coplanar(
            self,
            first_line_origin: Eigen.Vector3d,
            first_line_tangent: Eigen.Vector3d,
            second_line_origin: Eigen.Vector3d,
            second_line_tangent: Eigen.Vector3d
            ) -> bool:
            """/ \param firstLineOrigin first line origin
            / \param firstLineTangent first line tangent
            / \param secondLineOrigin second line origin
            / \param secondLineTangent second line tangent
            / \return line coplanarity
            """
            pass

        def is_polygon_coplanar(
            self,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd,
            polygon_unaligned_vertices: List[int]
            ) -> bool:
            """/ \brief verify if the polygon is in the coplana to a plane"""
            pass

        def intersection_segment_segment(
            self,
            first_segment_origin: Eigen.Vector3d,
            first_segment_end: Eigen.Vector3d,
            second_segment_origin: Eigen.Vector3d,
            second_segment_end: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionSegmentSegmentResult:
            """/ \brief Compute the intersection between the two segments
            / \param firstSegmentOrigin first segment origin
            / \param firstSegmentEnd first segment end
            / \param secondSegmentOrigin second segment origin
            / \param secondSegmentEnd second segment end
            / \return the resulting intersection
            / \note no check is performed
            """
            pass

        def intersections_between_segments(
            self,
            segments_vertices: List[Eigen.MatrixXd],
            segments_tangent: List[Eigen.Vector3d],
            segments_barycenter: List[Eigen.Vector3d],
            segments_length: List[float]
            ) -> List[std.list[float]]:
            """/ \brief Compute the intersection between a collection of segments
            / \param segmentsVertices the segments vertices
            / \param segmentsTangent the segments tangent
            / \param segmentsBarycenter the segments barycenter
            / \param segmentsLength the segments length
            / \return for each segment the list of intersections curvilinear coordinate
            """
            pass

        def intersection_segment_circle(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.IntersectionSegmentCircleResult:
            """/ \brief Compute the intersection between the a segment and a circle
            / \param segmentOrigin first segment origin
            / \param segmentEnd first segment end
            / \param circleCenter circle center
            / \param circleRadius circle radius
            / \return the resulting intersection
            / \note tested only in 2D
            """
            pass

        def intersection_segment_plane(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionSegmentPlaneResult:
            """/ \brief Intersection between a Segment, represented by origin and end and a plane
            / represented by the normal and a point
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segement end
            / \param planeNormal the plane normal normalized
            / \param planeOrigin a plane point
            / \return the resulting intersection
            """
            pass

        def intersection_polyhedron_plane(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            plane_rotation_matrix: Eigen.Matrix3d,
            plane_translation: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronPlaneResult:
            """/ \brief Intersection between a Polyhedron and a Plane
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param planeNormal the plane normal normalized
            / \param planeOrigin the plane origin
            / \param planeRotationMatrix the plane rotation from 3D to 2D
            / \param planeTranslation the plane translation vector
            / \return the intersection result
            / \note works only with convex polyhedra
            """
            pass

        def split_polyhedron_with_plane(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_edge_tangents: List[Eigen.MatrixXd],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            plane_rotation_matrix: Eigen.Matrix3d,
            plane_translation: Eigen.Vector3d
            ) -> GeometryUtilities.SplitPolyhedronWithPlaneResult:
            pass

        def split_polyhedron_with_plane_result_to_polyhedra(
            self,
            result: GeometryUtilities.SplitPolyhedronWithPlaneResult
            ) -> List[GeometryUtilities.Polyhedron]:
            pass

        def intersection_polyhedron_line(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            line_tangent: Eigen.Vector3d,
            line_origin: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronLineResult:
            """/ \brief Intersection between a Polyhedron and a line
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return the intersection result
            / \warning NOT TESTED PROPERLY
            """
            pass

        def intersection_polyhedron_segment(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            polyhedron_line_intersections: GeometryUtilities.IntersectionPolyhedronLineResult
            ) -> GeometryUtilities.IntersectionPolyhedronLineResult:
            """/ \brief Intersection between a Polyhedron and a segment
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \param segmentTangent the segment tangent
            / \param polyhedronLineIntersections the intersection between the polyhedron and the line of the segment
            / \return the intersection result
            / /// \warning NOT TESTED PROPERLY
            """
            pass

        def intersection_polyhedrons_segment(
            self,
            polyhedrons: List[GeometryUtilities.Polyhedron],
            polyhedron_face_normals: List[List[Eigen.Vector3d]],
            polyhedron_face_normal_directions: List[List[bool]],
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d
            ) -> GeometryUtilities.IntersectionPolyhedronsSegmentResult:
            """/ \brief Intersection between a collectio of Polyhedrons and a segment
            / \param polyhedrons the polyhedron collection
            / \param polyhedronFaceNormals polyhedron face normals
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            / \param segmentTangent the segment tangent
            / \return the intersection result
            / \warning NOT TESTED PROPERLY
            """
            pass

        def point_polygon_position(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.PointPolygonPositionResult:
            """/ \brief Check if point is inside a polygon
            / \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting position
            / \warning works only in 2D with convex polygons
            """
            pass

        def point_polygon_position_ray_casting(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.PointPolygonPositionResult:
            pass

        def is_point_inside_polygon(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> bool:
            """/ \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return False if it is outside, True the other cases
            / \warning works only in 2D with convex polygons
            """
            pass

        def is_point_inside_polygon_ray_casting(
            self,
            point: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> bool:
            """/ \brief IsPointInsidePolygon using RayCasting algorithm
            / (see https://en.wikipedia.org/wiki/Point_in_polygon)
            / \param point the point
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return False if it is outside, True the other cases
            """
            pass

        def line_polygon_position(
            self,
            line_tangent: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            polygon_vertices: Eigen.MatrixXd
            ) -> GeometryUtilities.LinePolygonPositionResult:
            pass

        #/ \brief Check if point is inside a polygon
        #/ \param point the point
        #/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
        #/ \param result the resulting position

        @overload
        def point_polyhedron_position(
            self,
            point: Eigen.Vector3d,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> GeometryUtilities.PointPolyhedronPositionResult:
            """/ \brief Check if point is inside a polyhedron
            / \param point the point
            / \param polyhedronFaces the polyhedron faces, size numPolyhedronFaces
            / \param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces
            / \param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces
            / \param polyhedronFaceNormals the polyhedron face normals
            / \param polyhedronFaceNormalDirections the polyhedron face normal directions
            / \param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return the point position respect the polyhedron
            / \note works only for convex polyhedrons
            """
            pass
        @overload
        def point_polyhedron_position(
            self,
            point: Eigen.Vector3d,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_faces_3_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_2_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_normals: List[Eigen.Vector3d],
            polyhedron_faces_normal_direction: List[bool],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_tetrahedrons: List[Eigen.MatrixXd]
            ) -> GeometryUtilities.PointPolyhedronPositionResult:
            """/ \brief Check if point is inside a polyhedron
            / \param point the point
            / \param polyhedronFaces the polyhedron faces, size numPolyhedronFaces
            / \param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces
            / \param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces
            / \param polyhedronFaceNormals the polyhedron face normals
            / \param polyhedronFaceNormalDirections the polyhedron face normal directions
            / \param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return the point position respect the polyhedron
            / \note works for concave and convex polyhedrons
            """
            pass

        def is_point_inside_tetrahedron(
            self,
            tetrahedron: Eigen.MatrixXd,
            point: Eigen.Vector3d
            ) -> bool:
            pass

        def point_circle_position(
            self,
            point: Eigen.Vector3d,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.PointCirclePositionResult:
            """/ \brief Check if point is inside a circle
            / \param point the point
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param result the resulting position
            / \note tested only in 2D
            """
            pass

        def point_circle_positions(
            self,
            points: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> List[GeometryUtilities.PointCirclePositionResult]:
            """/ \brief Check if points are inside a circle
            / \param points the matrix of points (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param result the resulting positions
            / \note tested only in 2D
            """
            pass

        def polygon_circle_position(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            vertex_positions: List[GeometryUtilities.PointCirclePositionResult],
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult
            ) -> GeometryUtilities.PolygonCirclePositionTypes:
            """/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param vertexPositions the polygon vertices positions respect the circle
            / \param polygonCircleIntersections the polygon center intersections
            / \return the Polygon Circle reciprocal position
            / \note tested only in 2D
            """
            pass

        def intersection_polygon_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float
            ) -> GeometryUtilities.IntersectionPolygonCircleResult:
            """/ \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \return the Polygon Circle reciprocal intersections
            / \note tested only in 2D
            """
            pass

        def polygon_triangulation_by_first_vertex(
            self,
            polygon_vertices: Eigen.MatrixXd
            ) -> List[int]:
            """/ \brief Convex Polygon simple Triangulation from the first vertex
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the sub-division triangulation, size 1 x 3 * numTriangles
            / \note works only for convex polygon
            """
            pass

        def polygon_triangulation_by_ear_clipping(
            self,
            polygon_vertices: Eigen.MatrixXd
            ) -> List[int]:
            """/ \brief Concave Polygon Triangulation with ear clipping algorithm
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the sub-division triangulation, size 1 x 3 * numTriangles
            """
            pass

        def polygon_triangulation_by_internal_point(
            self,
            polygon_vertices: Eigen.MatrixXd,
            internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Convex Polygon simple Triangulation from an internal point
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param point internal polygon point
            / \return the sub-division triangulation, size 1 x 3 * numPolygonVertices,
            / \note the internal point index is numPolygonVertices
            """
            pass

        def polygon_outside_circle_division_by_angle_quadrant(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByAngleQuadrantResult:
            """/ \brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            """
            pass

        def polygon_inside_circle_division_by_angle_quadrant(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByAngleQuadrantResult:
            """/ \brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            """
            pass

        def polygon_division_by_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.PolygonDivisionByCircleResult:
            """/ \brief Convex Polygon sub division from a circle which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division polygons result
            / \note the polygon should be inside the angle quadrant formed by the curved edge
            / \note otherwise use PolygonDivisionByAngleQuadrant function to split the polygon
            """
            pass

        def circle_division_by_polygon(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            curved_edge_index: int
            ) -> GeometryUtilities.CircleDivisionByPolygonResult:
            """/ \brief Circle division from Convex Polygon sub division which intersects a polygon in a curved edge
            / \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \param circleCenter the circle center from which the curved edge derives
            / \param circleRadius the radius of the circle from which the curved edge derives
            / \param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices
            / \return the sub-division circle result
            / \note the polygon should be inside the angle quadrant formed by the curved edge
            """
            pass

        def polygon_area(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the polygon area
            / \note the polygon shall be 2D
            """
            pass

        def polygon_area3_d(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \param polygonVertices the polygon vertices, size 3 x numPolygonVertices
            / \return the polygon area
            """
            pass

        def polygon_mass(
            self,
            polygon_centroid: Eigen.Vector3d,
            polygon_triangulation_points: List[Eigen.Matrix3d]
            ) -> Eigen.Matrix2d:
            """/ \param polygonCentroid the centroid
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \return the polygon mass matrix
            """
            pass

        def polygon_inertia(
            self,
            polygon_centroid: Eigen.Vector3d,
            polygon_triangulation_points: List[Eigen.Matrix3d]
            ) -> Eigen.Matrix3d:
            """/ \param polygonCentroid the centroid
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \return the polygon intertia tensor
            """
            pass

        def split_polygon_with_segment(
            self,
            input: GeometryUtilities.SplitPolygonInput
            ) -> GeometryUtilities.SplitPolygonWithSegmentResult:
            """/ \brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a segment contained inside
            / \param input the input data
            / \param result the resulting split
            / \note only indices are threated in this function, no space points
            """
            pass

        def split_polygon_with_circle(
            self,
            polygon_vertices: Eigen.MatrixXd,
            circle_center: Eigen.Vector3d,
            circle_radius: float,
            vertex_positions: List[GeometryUtilities.PointCirclePositionResult],
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult,
            polygon_circle_position: GeometryUtilities.PolygonCirclePositionTypes
            ) -> GeometryUtilities.SplitPolygonWithCircleResult:
            """/ \brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a cirle
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param circleCenter the circle center
            / \param circleRadius the circle radius
            / \param vertexPositions the polygon vertices positions respect the circle
            / \param polygonCircleIntersections the polygon center intersections
            / \param polygonCirclePosition the polygon position respect the circle
            / \note tested only in 2D
            / \return the split result
            / \note only indices are threated in this function, no space points
            """
            pass

        def split_polygon_with_circle_build_sub_polygon(
            self,
            split_result: GeometryUtilities.SplitPolygonWithCircleResult,
            sub_polygon_index: int,
            polygon_vertices: Eigen.MatrixXd,
            polygon_circle_intersections: GeometryUtilities.IntersectionPolygonCircleResult
            ) -> Eigen.MatrixXd:
            """/ \brief Build the subpolygon coordinates from split result
            / \param splitResult the split result
            / \param subPolygonIndex the subpolygon index, from 0 to SplitPolygonWithCircleResult::NewPolygons.size()
            / \param polygonVertices the original polygon vertices
            / \param polygonCircleIntersections the polygon circle intersection
            / \return the resulting subpolygon coordinates
            """
            pass

        def split_polygon_with_plane(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_edge_tangents: Eigen.MatrixXd,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            polygon_translation: Eigen.Vector3d,
            polygon_rotation_matrix: Eigen.Matrix3d
            ) -> GeometryUtilities.SplitPolygonWithPlaneResult:
            """/ \brief Split 3 Polygon With Plane
            / \param polygonVertices the 3D polygon vertices
            / \param polygonEdgeTangents the 3D polygon edge tangents
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \param polygonTranslation the polygon translation vector for rotation
            / \param polygonRotationMatrix the polygon rotation matrix from 2D to 3D
            / \return the splitted polygons
            """
            pass

        def polygon_normal(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon tridimensional normalized Normal
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting normalized normal
            """
            pass

        def polygon_tangents(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_normal: Eigen.Vector3d
            ) -> List[Eigen.Vector3d]:
            pass

        def polygon_edges_centroid(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edges centroid
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edges centroid, size 3 x numVertices
            """
            pass

        def polygon_edge_lengths(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.VectorXd:
            """/ \brief Compute the Polygon edge lengths
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge lengths, size 1 x numVertices
            """
            pass

        def polygon_edge_tangents(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edge tangents
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge tangents, size 3 x numVertices
            """
            pass

        def polygon_edge_normals(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ \brief Compute the Polygon edge normals outgoing the polygon
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \return the resulting edge normals outgoing the polygon, size 3 x numVertices
            """
            pass

        def simplex_barycenter(self, vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the simplex barycenter as a mean of all vertices
            / \param vertices the matrix of vertices of the simplex (size 3 x numVertices)
            """
            pass

        def simplex_measure(self, vertices: Eigen.MatrixXd) -> float:
            pass

        def segment_barycenter(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            """/ \brief Compute the segment barycenter as a mean of all vertices
            / \param segmentOrigin the segment origin
            / \param segmentEnd the segment end
            """
            pass

        def polygon_barycenter(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon barycenter as a mean of all vertices
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            """
            pass

        def polyhedron_barycenter(self, polyhedron_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the polyhedron barycenter as a mean of all vertices
            / \param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)
            """
            pass

        @overload
        def polygon_centroid(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon centroid as described in https://en.wikipedia.org/wiki/Centroid
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            / \param polygonArea the area of the polygon
            / \note the polygon shall be 2D
            """
            pass

        @overload
        def polygon_centroid(
            self,
            sub_polygon_centroids: Eigen.MatrixXd,
            sub_polygon_areas: Eigen.VectorXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polygon centroid using polygon sub-division
            / \param subPolygonCentroids the centroid of each subPolygon (size 3 x numSubPolygons)
            / \param subPolygonAreas the areas of each subPolygon, size 1 x numSubPolygons
            / \param polygonArea the total area of the polygon
            """
            pass

        def polygon_area_by_boundary_integral(
            self,
            polygon_vertices: Eigen.MatrixXd,
            edge_lengths: Eigen.VectorXd,
            edge_tangents: Eigen.MatrixXd,
            edge_normals: Eigen.MatrixXd,
            reference_quadrature_points: Eigen.MatrixXd = (Eigen.MatrixXd(3, 1) << 0.5, 0.0, 0.0).finished(),
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Ones(1)
            ) -> float:
            """/ \brief Polygon Area By Integral on edges
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param edgeLengths the edge lengths, size numEdges
            / \param edgeTangents the edge tangents, size 3 x numEdges
            / \param edgeNormals the edge outgoint normals, size 3 x numEdges
            / \param referenceQuadraturePoints quadrature points on reference segment [0,1]
            / \param referenceQuadratureWeights quadrature weights on reference segment [0,1]
            / \return the polygon area
            / \note the area is computed as integral_edges x dot n_x with gauss formula on edges of order 1
            """
            pass

        def polygon_area_by_internal_integral(
            self,
            polygon_triangulation_points: List[Eigen.Matrix3d],
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 0.5)
            ) -> float:
            """/ \brief Polygon Area By Internal Integral
            / \param polygonTriangulationPoints the internal polygon sub-triangulation
            / \param referenceQuadratureWeights the reference triangle quadrature weights [0,1]x[0,1]
            / \return the area computed as integral on sub-triangles
            """
            pass

        def polygon_centroid_by_integral(
            self,
            polygon_vertices: Eigen.MatrixXd,
            edge_lengths: Eigen.VectorXd,
            edge_tangents: Eigen.MatrixXd,
            edge_normals: Eigen.MatrixXd,
            polygon_area: float
            ) -> Eigen.Vector3d:
            """/ \brief Polygon Area By Integral on edges
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param edgeLengths the edge lengths, size numEdges
            / \param edgeTangents the edge tangents, size 3 x numEdges
            / \param edgeNormals the edge outgoint normals, size 3 x numEdges
            / \param polygonArea the polygon area
            / \return the polygon centroid
            / \note the area is computed as integral_edges (x^2, y^2) dot n with gauss formula on edges of order 2
            """
            pass

        def polygon_centroid_edges_distance(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_centroid: Eigen.Vector3d,
            polygon_edge_normals: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            """/ \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param polygonCentroid the polygon centroid
            / \param polygonEdgeNormals the polygon edge normals outgoing the polygon, size 3 x numEdges
            / \return the distance between the centroid and all the polygon edges, size 1 x numEdges
            """
            pass

        def polygon_centroid_vertices_distance(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_centroid: Eigen.Vector3d
            ) -> Eigen.VectorXd:
            """/ \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param polygonCentroid the polygon centroid
            / \return the distance between the centroid and all the polygon vertices, size 1 x numEdges
            """
            pass

        def polygon_in_radius(self, polygon_centroid_edges_distance: Eigen.VectorXd) -> float:
            """/ \param polygonCentroidEdgesDistance the polygon centroid edges distance, size 1 x numEdges
            / \return the polygon in radius, as the minimum distance between the polygon centroid and the edges
            """
            pass

        def polygon_aspect_ratio(
            self,
            polygon_diameter: float,
            polygon_in_radius: float
            ) -> float:
            """/ \param polygonDiameter the polygon diameter
            / \param polygonInRadius the polygon in radius
            / \return the polygon aspect ratio, defined as the ratio bewteen the in and out diameter
            """
            pass

        def polygon_diameter(self, polygon_vertices: Eigen.MatrixXd) -> float:
            """/ \brief Compute the Polygon diameter defined as the maximum distance between the vertices
            / \param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)
            """
            pass

        def polygon_translation(self, polygon_vertices: Eigen.MatrixXd) -> Eigen.Vector3d:
            """/ \brief Compute the translation vector of a tridimensional Polygon
            / \param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)
            / \return the resulting translation vector t which corresponds to the first vertex of the polygon
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def polygon_rotation_matrix(
            self,
            polygon_vertices: Eigen.MatrixXd,
            polygon_normal: Eigen.Vector3d,
            polygon_translation: Eigen.Vector3d
            ) -> Eigen.Matrix3d:
            """/ \brief Compute the rotation matrix and translation vector of a tridimensional Polygon
            / \param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)
            / \param polygonNormal the normalized normal of the plane which contains the polygon
            / \param polygonTranslation the translation vector t
            / \return the resulting rotation matrix Q which rotates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def polygon_is_convex(
            self,
            polygon_vertices: Eigen.MatrixXd,
            convex_hull: Eigen.MatrixXd
            ) -> bool:
            """/ \brief Check if Polygon is Convex
            / \param polygonVertices the polygon vertices, size 3 x numVertices
            / \param convexHull the convex hull vertices counterclockwise
            / \return True if polygon is convex, False otherwise
            / \note works only in 2D-plane
            """
            pass

        def polygon_type(
            self,
            num_polygon_vertices: int,
            is_polygon_convex: bool
            ) -> GeometryUtilities.PolygonTypes:
            """/ \param numPolygonVertices the number of polygon vertices
            / \param isPolygonConvex True if the polygon is convex
            / \return the polygon type
            """
            pass

        def polygon_orientation(
            self,
            convex_hull: List[int]
            ) -> GeometryUtilities.PolygonOrientations:
            """/ \param convexHull the polygon convex hull vertices indices counterclockwise
            / \return the polygon 2D orientation
            / \note works only in 2D-plane
            """
            pass

        def change_polygon_orientation(self, num_polygon_vertices: int) -> List[int]:
            """/ \param numPolygonVertices the number of polygon vertices
            / \return the new polygon vertices indices oriented in the opposite direction
            """
            pass

        def plane_rotation_matrix(self, plane_normal: Eigen.Vector3d) -> Eigen.Matrix3d:
            """/ \brief Compute the rotation matrix of a plane from 2D to 3D
            / \param planeNormal the normalized normal of the plane
            / \return the resulting rotation matrix Q which rotates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def plane_translation(self, plane_origin: Eigen.Vector3d) -> Eigen.Vector3d:
            """/ \brief Compute the translation vector of a plane from 2D to 3D
            / \param planeNormal the normalized normal of the plane
            / \param planeOrigin the 3D plane origin
            / \return the resulting translation vector t which translates 2D points to 3D points
            / \note to rotate some point P from 2D to 3D use Q * P + t
            / \note to rotate some point P from 3D to 2D use Q^T * (P - t)
            """
            pass

        def plane_reflection_matrix(self, plane_normal: Eigen.Vector3d) -> Eigen.Matrix3d:
            pass
        def plane_reflection_translation(
            self,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d
            ) -> Eigen.Vector3d:
            pass

        def rotate_points(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P using rotation matrix Q and translation t: Q * P + t
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix, size 3x3
            / \param translation the translation vector, size 1x3
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t
            """
            pass

        def rotate_points_from2_d_to3_d(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P From 2D To 3D using rotation matrix Q and translation t: Q * P + t
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix from 2D to 3D
            / \param translation the translation vector
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t
            """
            pass
        def rotate_points_from3_d_to2_d(
            self,
            points: Eigen.MatrixXd,
            rotation_matrix: Eigen.Matrix3d,
            translation: Eigen.Vector3d = Eigen.Vector3d.Zero()
            ) -> Eigen.MatrixXd:
            """/ \brief Rotate Points P From 3D To 2D using rotation matrix Q and translation t: Q * (P - t)
            / \param points the points (size 3 x numPoints)
            / \param rotationMatrix the rotation matrix from 3D to 2D
            / \param translation the translation vector
            / \param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * (P - t)
            """
            pass

        def convex_hull(
            self,
            points: Eigen.MatrixXd,
            include_collinear: bool = True
            ) -> List[int]:
            """/ \brief Compute the Convex Hull of 2D points
            / \param points the points, size 3 x numPoints
            / \param includeCollinear include the collinear points, default True
            / \return the convex hull indices counterclockwise, size numConvexHullPoints, numConvexHullPoints <= numPoints
            / \note works in 2D, use the Graham_scan algorithm https://en.wikipedia.org/wiki/Graham_scan
            """
            pass

        def points_are_aligned(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            points: Eigen.MatrixXd
            ) -> List[bool]:
            """/ \brief Check if a set of points are aligned to a line identified by a segment
            / \param segmentOrigin segment origin of the line
            / \param segmentEnd segment end of the line
            / \param points the points, size 3 x numPoints
            / \return True if the i-th point is aligned, size 1 x numPoints
            """
            pass

        def points_are_on_line(
            self,
            points: Eigen.MatrixXd,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d
            ) -> List[bool]:
            """/ \brief Check if a set of points are on a line
            / \param points the points, size 3 x numPoints
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return True if the i-th point is aligned, size 1 x numPoints
            """
            pass

        def point_is_aligned(
            self,
            segment_origin: Eigen.Vector3d,
            segment_end: Eigen.Vector3d,
            point: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if a point is aligned to a line identified by a segment
            / \param segmentOrigin segment origin of the line
            / \param segmentEnd segment end of the line
            / \param point the point
            / \return True if the point is aligned
            """
            pass

        def point_is_on_line(
            self,
            point: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if a point is on a line
            / \param point the point
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \return True if the point is aligned
            """
            pass

        def point_to_barycentric_coordinates2_d(
            self,
            triangle: Eigen.Matrix3d,
            point: Eigen.Vector3d
            ) -> List[float]:
            pass
        def barycentric_coordinates_to_point2_d(
            self,
            triangle: Eigen.Matrix3d,
            barycentric_coordinates: List[float]
            ) -> Eigen.Vector3d:
            pass

        def unaligned_points(
            self,
            points: Eigen.MatrixXd,
            num_desired_unaligned_points: int = 0
            ) -> List[int]:
            """/ \brief Extract the circumscribed unaligned points (minimum 2) in a set of points
            / \param points the points, size 3 x numPoints
            / \param numDesiredUnalignedPoints the number of desired unaligned points, if 0 all the points are computed
            / \return the unaligned points indices counterclockwise, size numUnalignedPoints, 2 <= numUnalignedPoints <=
            / numPoints
            """
            pass

        def unaligned_polyhedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_unaliged_faces: List[List[int]],
            polyhedron_faces_unaligned_vertices: List[List[int]]
            ) -> List[int]:
            """/ \brief Extract the circumscribed unaligned points (minimum 4) in a polyhedron
            / \return the unaligned points, size numUnalignedPoints, 4 <= numUnalignedPoints <= numPoints
            / \warning works only for convex polyhedron
            """
            pass

        def aligned_polyhedron_edges(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            vertices_adjacency: List[List[int]],
            edges_adjacency: List[List[int]],
            adjacency_vertices_map: List[std.unordered_map[int, int]],
            polyhedron_edge_tangents: Eigen.MatrixXd,
            polyhedron_edge_squared_lenghts: Eigen.VectorXd
            ) -> GeometryUtilities.AlignedPolyhedronEdgesResult:
            pass

        def extract_points(self, points: Eigen.MatrixXd, filter: List[int]) -> Eigen.MatrixXd:
            """/ \param points the points, size 3 x numPoints
            / \param filter indices counterclockwise, size numFilterPoints, numFilterPoints <= numPoints
            / \return the points coordinates filtered, size 3 x numFilterPoints
            """
            pass

        def extract_triangulation_points(
            self,
            points: Eigen.MatrixXd,
            points_triangulation: List[int]
            ) -> List[Eigen.Matrix3d]:
            """/ \param points the points, size 3 x numPoints
            / \param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles
            / \return the triangles coordinates, size 1 x numTriangles
            """
            pass

        def extract_triangulation_points_by_internal_point(
            self,
            points: Eigen.MatrixXd,
            internal_point: Eigen.Vector3d,
            points_triangulation: List[int]
            ) -> List[Eigen.Matrix3d]:
            """/ \param points the points, size 3 x numPoints
            / \param externalPoint the external point coordinates
            / \param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles
            / \return the triangles coordinates, size 1 x numTriangles
            """
            pass

        def create_ellipse(
            self,
            axis_major_length: float,
            axis_minor_length: float,
            resolution: int
            ) -> Eigen.MatrixXd:
            """/ \brief Create 2D Ellipse approximation with 2D polygon
            / \param axisMajorLength the ellipse axis major length
            / \param axisMinorLength the ellipse axis minor length
            / \param resolution the number of points on each ellipse quadrant
            / \return the polygon which approximate the ellipse
            / \note the ellipse is centered in the origin and parallel to xy-axis
            """
            pass

        def create_triangle(
            self,
            p1: Eigen.Vector3d,
            p2: Eigen.Vector3d,
            p3: Eigen.Vector3d
            ) -> Eigen.MatrixXd:
            """/ \brief Create a triangle with points"""
            pass
        def create_parallelogram(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> Eigen.MatrixXd:
            """/ \brief Create a parallelogram with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param widthVector the width vector
            """
            pass
        def create_rectangle(
            self,
            origin: Eigen.Vector3d,
            base: float,
            height: float
            ) -> Eigen.MatrixXd:
            """/ \brief Create a rectangle with origin and dimensions parallel to axis
            / \param origin the origin
            / \param base the base length
            / \param height the height length
            """
            pass

        def create_square(self, origin: Eigen.Vector3d, edge_length: float) -> Eigen.MatrixXd:
            """/ \brief Create a square with origin and dimensions parallel to axis
            / \param origin the origin
            / \param edgeLength the edge length
            """
            pass

        def create_tetrahedron_with_origin(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            height_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Tetrahedron with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param heightVector the heigth vector
            / \param widthVector the width vector
            / \return the tetrahedron created
            """
            pass

        def create_tetrahedron_with_vertices(
            self,
            v1: Eigen.Vector3d,
            v2: Eigen.Vector3d,
            v3: Eigen.Vector3d,
            v4: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Tetrahedron with the four vertices
            / \param v1 the first vertex
            / \param v2 the second vertex
            / \param v3 the third vertex
            / \param v4 the fourth vertex
            / \return the tetrahedron created
            """
            pass

        def create_parallelepiped_with_origin(
            self,
            origin: Eigen.Vector3d,
            length_vector: Eigen.Vector3d,
            height_vector: Eigen.Vector3d,
            width_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Parallelepiped with origin and dimension
            / \param origin the origin
            / \param lengthVector the length vector
            / \param heightVector the heigth vector
            / \param widthVector the width vector
            / \return the parallelepiped created
            """
            pass

        @overload
        def create_polyhedron_with_extrusion(
            self,
            polygon_vertices: Eigen.MatrixXd,
            height_vector: Eigen.Vector3d
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create Polyhedron With Extrusion
            / \param polygon the 2D polygon vertices
            / \param heightVector  the height vector
            / \return the polyhedron created
            """
            pass

        @overload
        def create_polyhedron_with_extrusion(
            self,
            polygon_vertices: Eigen.MatrixXd,
            height_vectors: List[Eigen.Vector3d]
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create Polyhedron With Extrusion
            / \param polygon the 2D polygon vertices, size 3 x numPolygonVertices
            / \param heightVectors the height vector to be used for each polygon vertex, size numPolygonVertices
            / \return the polyhedron created
            """
            pass

        def create_cube_with_origin(
            self,
            origin: Eigen.Vector3d,
            edge_length: float
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Create a Cube with origin aligned to axis
            / \param origin the origin
            / \param edgeLength the edge length
            / \return the cube created
            """
            pass

        def polyhedron_volume_by_boundary_integral(
            self,
            polyhedron_face_rotated_triangulation_points: List[List[Eigen.Matrix3d]],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            reference_quadrature_points: Eigen.MatrixXd = (Eigen.MatrixXd(3, 1) << 1.0 / 3.0, 1.0 / 3.0, 0.0).finished(),
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 0.5)
            ) -> float:
            """/ \brief Compute the Polyhedron Volume
            / \param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces
            / x numTrianglesPerFace \param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \param
            / polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \param
            / polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \param
            / polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \param referenceQuadraturePoints
            / the reference tetrahedron quadrature points [0,1]x[0,1]x[0,1] \param referenceQuadratureWeights the reference
            / tetrahedron quadrature weights [0,1]x[0,1]x[0,1] \return the polyhedron volume \note use the divergence theorem,
            / with F = 1/3 (x, y, z), see https://en.wikipedia.org/wiki/Divergence_theorem
            """
            pass

        def polyhedron_volume_by_internal_integral(
            self,
            polyhedron_tetrahedron_vertices: List[Eigen.MatrixXd],
            reference_quadrature_weights: Eigen.VectorXd = Eigen.VectorXd.Constant(1, 1.0 / 6.0)
            ) -> float:
            """/ \brief Polyhedron Volume By Internal Integral
            / \param polyhedronTetrahedronVertices the internal polyhedron sub-tetrahedra
            / \param referenceQuadratureWeights the reference tetrahedron quadrature weights [0,1]x[0,1]x[0,1]
            / \return the area computed as integral on sub-tetrahedra
            """
            pass

        def polyhedron_centroid(
            self,
            polyhedron_face_rotated_triangulation_points: List[List[Eigen.Matrix3d]],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d],
            polyhedron_volume: float
            ) -> Eigen.Vector3d:
            """/ \brief Compute the Polyhedron centroid
            / \param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces
            / x numTrianglesPerFace \param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \param
            / polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \param
            / polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \param
            / polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \param polyhedronVolume the
            / polyhedron volume \return the polyhedron centroid \note use the divergence theorem, with F_x = 1/2 (x^2, 0, 0),
            / F_y = 1/2 (0, y^2, 0), F_z = 1/2 (0, 0, z^2), see https://en.wikipedia.org/wiki/Divergence_theorem
            """
            pass

        def polyhedron_diameter(self, polyhedron_vertices: Eigen.MatrixXd) -> float:
            """/ \brief Compute the Polyhedron diameter defined as the maximum distance between the vertices
            / \param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)
            """
            pass

        def polyhedron_edges_centroid(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.MatrixXd:
            """/ \brief Compute Polyhedron Edges Centroid
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the centroid, size 3xnumEdges
            """
            pass

        def polyhedron_edges_length(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.VectorXd:
            """/ \brief Compute Polyhedron Edges Lenght
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the length, size 1xnumEdges
            """
            pass

        def polyhedron_edge_tangents(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> Eigen.MatrixXd:
            """/ \brief Compute Polyhedron Edges Tangent
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return for each edge the tangent, size 3xnumEdges
            """
            pass

        def polyhedron_face_vertices(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi]
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Vertices
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \return for each face the vertices, size 1xnumFaces
            """
            pass

        def polyhedron_face_edge_directions(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi]
            ) -> List[List[bool]]:
            """/ \brief Compute Polyhedron Faces Edge Direction
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \return for each face the edge direction compare to polyhedron edge directions, size 1xnumFaces
            """
            pass

        def polyhedron_face_edge_tangents(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_edge_directions: List[List[bool]],
            polyhedron_edge_tangents: Eigen.MatrixXd
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Edge Tangents
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronEdgeTangents for each polyhedron edge the tangent, size 3xnumEdges
            / \return for each face the edge tangents, size 1xnumFaces
            """
            pass

        def polyhedron_face_rotation_matrices(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_translations: List[Eigen.Vector3d]
            ) -> List[Eigen.Matrix3d]:
            """/ \brief Compute Polyhedron Faces Rotation matrix
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the rotation matrix from 2D to 3D
            """
            pass

        def polyhedron_face_translations(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces translation vectors
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the translation vector
            """
            pass

        def polyhedron_face_rotated_vertices(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> List[Eigen.MatrixXd]:
            """/ \brief Compute Polyhedron Faces Rotated Vertices 2D
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaceTranslations the polyhedron face translations from 2D to 3D
            / \param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D
            / \return for each face the 2D vertices, size 1xnumFaces
            """
            pass

        def polyhedron_faces_unaligned_vertices(
            self,
            polyhedron_faces_rotated_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Compute Polyhedron Faces Unaligned Vertices Indices
            / \param polyhedronFacesRotatedVertices the polyhedron faces 2D vertices
            / \return for each face the unaligned vertices indices, size 1 x numFaces
            """
            pass

        def polyhedron_face_normals(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces Normals
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the normal
            """
            pass

        def polyhedron_face_tangents(
            self,
            polyhedron_faces_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_normal: List[Eigen.Vector3d],
            polyhedron_faces_normal_direction: List[bool]
            ) -> List[List[Eigen.Vector3d]]:
            pass

        def polyhedron_face_barycenter(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[Eigen.Vector3d]:
            """/ \brief Compute Polyhedron Faces barycenters
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each polyhedron face the barycenter
            """
            pass

        def polyhedron_mass(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_tetrahedron_points: List[Eigen.MatrixXd]
            ) -> Eigen.Matrix3d:
            pass

        def polyhedron_inertia(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_tetrahedra_points: List[Eigen.MatrixXd]
            ) -> Eigen.Matrix3d:
            pass

        def polyhedron_centroid_faces_distance(
            self,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_faces_normal: List[Eigen.Vector3d],
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> Eigen.VectorXd:
            pass

        def polyhedron_in_radius(
            self,
            polyhedron_centroid_faces_distance: Eigen.VectorXd
            ) -> float:
            pass

        def polyhedron_is_convex(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_normal_directions: List[bool],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> bool:
            """/ \brief Check if Polyhedron is Convex
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param polyhedronFaceNormals the normal of each face
            / \param polyhedronFaceNormalDirections the normal outgoing direction
            / \param pointInsidePolyhedron a point inside polyhedron
            / \return True if polyhedron is convex, False otherwise
            / \warning still not working
            """
            pass

        @overload
        def polyhedron_face_normal_directions(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            point_inside_polyhedron: Eigen.Vector3d,
            polyhedron_face_normals: List[Eigen.Vector3d]
            ) -> List[bool]:
            """/ \brief Compute Polyhedron Face Normal Directions
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param pointInsidePolyhedron a point inside polyhedron
            / \param polyhedronFaceNormals the normal of each face
            / \return True if the face has normal outgoing
            / \warning works only for convex polyhedrons
            """
            pass
        @overload
        def polyhedron_face_normal_directions(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_face_normals: List[Eigen.Vector3d],
            polyhedron_face_translations: List[Eigen.Vector3d],
            polyhedron_face_rotation_matrices: List[Eigen.Matrix3d]
            ) -> List[bool]:
            """/ \brief Compute Polyhedron Face Normal Directions for generic polyhedron (slower)
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param pointInsidePolyhedron a point inside polyhedron
            / \param polyhedronFaceNormals the normal of each face
            / \return True if the face has normal outgoing
            / \warning NOT WORKING in all cases
            """
            pass

        def polyhedron_face_triangulations(
            self,
            polyhedron_faces: List[Eigen.MatrixXi],
            local_face_triangulations: List[List[int]]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations of each face
            / \param polyhedronFaces the polyhedron faces
            / \param localFaceTriangulations the local faces triangulations indices, size 1xnumFaces x (3xnumTriangles)
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass
        def polyhedron_face_triangulations_by_first_vertex(
            self,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by first vertex of each face
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass

        def polyhedron_face_triangulations_by_ear_clipping(
            self,
            num_polyhedron_faces: int,
            polyhedron_faces2_d_vertices: List[Eigen.MatrixXd]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by ear clipping of each face
            / \param numPolyhedronFaces the number of polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            """
            pass

        def polyhedron_face_extract_triangulation_points(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_triangulations: List[List[int]]
            ) -> List[List[Eigen.Matrix3d]]:
            pass

        def polyhedron_face_triangulation_points_by_internal_point(
            self,
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_face_triangulations: List[List[int]]
            ) -> List[List[Eigen.Matrix3d]]:
            pass

        def polyhedron_face_triangulations_by_internal_point(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_vertices: List[Eigen.MatrixXd],
            polyhedron_face_internal_points: List[Eigen.Vector3d]
            ) -> List[List[int]]:
            """/ \brief Polyhedron Face Triangulations by internal point of each face
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param polyhedronFaceVertices the polyhedron faces vertices
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)
            / \note the internal point index is polyhedronVertices.size()
            """
            pass

        @overload
        def polyhedron_tetrahedrons_by_face_triangulations(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_triangulations: List[List[int]],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Polyhedron Tetrahedrons By Face Triangulations
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param faceTriangulations the triangulation on face vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)
            / \note the polyhedron internal point index is polyhedronVertices.size() + f
            """
            pass

        @overload
        def polyhedron_tetrahedrons_by_face_triangulations(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_face_triangulations: List[List[int]],
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            polyhedron_internal_point: Eigen.Vector3d
            ) -> List[int]:
            """/ \brief Polyhedron Tetrahedrons By Face Triangulations with face internal points
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronFaces the polyhedron faces
            / \param faceTriangulations the triangulation on face vertices by internal points
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param polyhedronInternalPoint a polyhedron internal point
            / \return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)
            / \note the polyhedron face internal points are polyhedronVertices.size() + f
            / \note the polyhedron internal point index is polyhedronVertices.size() + polyhedronFaceInternalPoints.size()
            """
            pass

        @overload
        def extract_tetrahedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_internal_point: Eigen.Vector3d,
            point_tetrahedrons: List[int]
            ) -> List[Eigen.MatrixXd]:
            """/ \param polyhedronVertices the polyhedron vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra
            / \return the tetrahedrons coordinates, size 1 x numTetra
            """
            pass
        @overload
        def extract_tetrahedron_points(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_internal_point: Eigen.Vector3d,
            polyhedron_face_internal_points: List[Eigen.Vector3d],
            point_tetrahedrons: List[int]
            ) -> List[Eigen.MatrixXd]:
            """/ \param polyhedronVertices the polyhedron vertices
            / \param polyhedronInternalPoint a polyhedron internal point
            / \param polyhedronFaceInternalPoints the polyhedron face internal points
            / \param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra
            / \return the tetrahedrons coordinates, size 1 x numTetra
            """
            pass

        def polyhedron_coordinate_system(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi
            ) -> List[int]:
            """/ \brief Get Polyhedron Coordinate System
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \return the four vertices indices forming a coordinate system for the polyhedron, size 1x4
            """
            pass

        @overload
        def export_polyhedron_to_vtu(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            export_folder: str
            ) -> None:
            """/ \brief Export Polyhedron To VTU
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param exportFolder the folder in which to export
            """
            pass

        @overload
        def export_polyhedron_to_vtu(
            self,
            polyhedron: GeometryUtilities.Polyhedron,
            export_folder: str
            ) -> None:
            pass

        @overload
        def export_polyhedron_to_vtu(
            self,
            index: int,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_tetra: List[Eigen.MatrixXd],
            polyhedron_volume: float,
            polyhedron_centroid: Eigen.Vector3d,
            polyhedron_faces3_d_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_area: List[float],
            polyhedron_faces2_d_centroid: List[Eigen.Vector3d],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_faces3_d_triangles: List[List[Eigen.Matrix3d]],
            polyhedron_faces3_d_internal_point: List[Eigen.Vector3d],
            polyhedron_faces3_d_normal: List[Eigen.Vector3d],
            polyhedron_faces3_d_normal_direction: List[bool],
            export_folder: str
            ) -> None:
            """/ \brief Export Polyhedron To VTU
            / \param polyhedronVertices the polyhedron vertices
            / \param polyhedronEdges the polyhedron edges
            / \param polyhedronFaces the polyhedron faces
            / \param exportFolder the folder in which to export
            """
            pass

        def export_polygon_to_vtu(
            self,
            index: int,
            polygon: Eigen.MatrixXd,
            polygon_triangles: List[Eigen.Matrix3d],
            polygon_volume: float,
            polygon_centroid: Eigen.Vector3d,
            polygon_edges_centroid: Eigen.MatrixXd,
            polygon_edges_normal: Eigen.MatrixXd,
            polygon_edges_normal_direction: List[bool],
            export_folder: str
            ) -> None:
            pass

        def merge_polyhedron_by_face(
            self,
            polyhedrons: List[GeometryUtilities.Polyhedron],
            polyhedrons_common_face_index: List[int],
            remove_common_face: bool
            ) -> GeometryUtilities.MergePolyhedronsInput:
            pass

        def merge_polyhedrons(
            self,
            polyhedrons: List[GeometryUtilities.Polyhedron],
            merge_information: GeometryUtilities.MergePolyhedronsInput = GeometryUtilities.MergePolyhedronsInput()
            ) -> GeometryUtilities.MergePolyhedronsResult:
            pass

        def facets_to_polyhedron(
            self,
            points: Eigen.MatrixXd,
            facets: List[List[int]]
            ) -> GeometryUtilities.Polyhedron:
            pass
        def polyhedron_to_facets(
            self,
            polyhedron: GeometryUtilities.Polyhedron
            ) -> List[List[int]]:
            pass


# </submodule gedim>
####################    </generated_from:GeometryUtilities.hpp>    ####################


####################    <generated_from:MapParallelepiped.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapParallelepiped_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapParallelepiped:
        class MapParallelepipedData:
            """
            (final class)
            """
            q: Eigen.Matrix3d
            b: Eigen.Vector3d
            q_inv: Eigen.Matrix3d
            det_q: float
            det_q_inv: float
            def __init__(
                self,
                q: Eigen.Matrix3d = Eigen.Matrix3d(),
                b: Eigen.Vector3d = Eigen.Vector3d(),
                q_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                det_q: float = float(),
                det_q_inv: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        reference_vertices: Eigen.MatrixXd

        def __init__(self, geometry_utilities: GeometryUtilities) -> None:
            pass


        @staticmethod
        def q(
            first_vertex: Eigen.Vector3d,
            second_vertex: Eigen.Vector3d,
            third_vertex: Eigen.Vector3d,
            fourth_vertex: Eigen.Vector3d
            ) -> Eigen.Matrix3d:
            """/ Matrix Q for linear map x = Q * x_r + b from reference Hexahedron [0,1]x[0,1]x[0,1] to Hexahedron with x points
            / vertices the Hexahedron to map vertices, size 3 x 4
            / return the resulting value, size 3 x 3
            """
            pass

        @staticmethod
        def b(first_vertex: Eigen.Vector3d) -> Eigen.Vector3d:
            """/ Matrix Q for linear map x = Q * x_r + b from reference Hexahedron [0,1]x[0,1]x[0,1] to Hexahedron with x points
            / vertices the Hexahedron to map vertices, size 3 x 4
            / return the resulting value, size 3 x 3
            """
            pass

        def compute(
            self,
            vertices: Eigen.MatrixXd,
            coordinate_system: List[int]
            ) -> MapParallelepiped.MapParallelepipedData:
            """/ Map from the hexahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b
            / \param vertices the hexahedron to map vertices, size 3 x 4
            / \param edges the hexahedron edges
            / \return the map data
            """
            pass

        @staticmethod
        def f(
            map_data: MapParallelepiped.MapParallelepipedData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Map from the Hexahedron reference element [0,1]x[0,1]x[0,1] to the polygon x = F(x_r) = Q * x_r + b
            / \param mapData the map data computed
            / \param x points in reference Hexahedron, size 3 x numPoints
            / \return the mapped points, size 3 x numPoints
            """
            pass

        @staticmethod
        def f_inv(
            map_data: MapParallelepiped.MapParallelepipedData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j(
            map_data: MapParallelepiped.MapParallelepipedData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Compute the jacobian matrix of the transformation F
            / \param mapData the map data computed
            / \param x points in reference Hexahedron, size 3 x numPoints
            / \return the Q matrix for each points, size 2 x (2 * numPoints)
            """
            pass

        @staticmethod
        def det_j(
            map_data: MapParallelepiped.MapParallelepipedData,
            x: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data computed
            / \param x points in reference Hexahedron, size 3 x numPoints
            / \return the determinant of Jacobian matrix for each points, size 1 x numPoints
            """
            pass

# </submodule gedim>
####################    </generated_from:MapParallelepiped.hpp>    ####################


####################    <generated_from:MapHexahedron.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapHexahedron_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapHexahedron:
        class MapHexahedronData:
            """
            (final class)
            """
            reference_vertices: Eigen.MatrixXd
            a: Eigen.MatrixXd
            coefficients: Eigen.MatrixXd
            vertices: Eigen.MatrixXd
            vertex_order: Dict[int, int]
            def __init__(
                self,
                reference_vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                a: Eigen.MatrixXd = Eigen.MatrixXd(),
                coefficients: Eigen.MatrixXd = Eigen.MatrixXd(),
                vertices: Eigen.MatrixXd = Eigen.MatrixXd()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        @staticmethod
        def compute(
            vertices: Eigen.MatrixXd,
            faces: List[Eigen.MatrixXi]
            ) -> MapHexahedron.MapHexahedronData:
            pass

        @staticmethod
        def f(
            map_data: MapHexahedron.MapHexahedronData,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def f_inv(
            map_data: MapHexahedron.MapHexahedronData,
            points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j(
            map_data: MapHexahedron.MapHexahedronData,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j_inv(
            map_data: MapHexahedron.MapHexahedronData,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def det_j(
            map_data: MapHexahedron.MapHexahedronData,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            pass

# </submodule gedim>
####################    </generated_from:MapHexahedron.hpp>    ####################


####################    <generated_from:MapTriangle.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapTriangle_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapTriangle:
        class MapTriangleData:
            """
            (final class)
            """
            b: Eigen.Matrix3d
            b_inv: Eigen.Matrix3d
            b: Eigen.Vector3d
            det_b: float
            det_b_inv: float
            def __init__(
                self,
                b: Eigen.Matrix3d = Eigen.Matrix3d(),
                b_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                b: Eigen.Vector3d = Eigen.Vector3d(),
                det_b: float = float(),
                det_b_inv: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def compute(self, vertices: Eigen.Matrix3d) -> MapTriangle.MapTriangleData:
            """/ Map from the triangle reference element [0,1]x[0,1]/2 to the polygon x = F(x_r) = B * x_r + b
            / \param vertices the triangle 2D to map vertices, size 3 x 3
            / \return the map data
            """
            pass

        @staticmethod
        def f(map_data: MapTriangle.MapTriangleData, x: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ Map from the triangle reference element [0,1]x[0,1] to the polygon x = F(x_r) = B * x_r + b
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the mapped polygon points, size 3 x numPoints
            """
            pass
        @staticmethod
        def f_inv(map_data: MapTriangle.MapTriangleData, x: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ Map from the polygon x to the triangle reference element [0,1]x[0,1] x_r = F^-1(x_r) = B^-1 * (x - b)
            / \param mapData the map data
            / \param x points in polygon, size 3 x numPoints
            / \return the mapped reference points, size 3 x numPoints
            """
            pass
        @staticmethod
        def j(map_data: MapTriangle.MapTriangleData, x: Eigen.MatrixXd) -> Eigen.MatrixXd:
            """/ Compute the jacobian matrix of the transformation F
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the B matrix for each points, size 3 x (3 * numPoints)
            """
            pass

        @staticmethod
        @overload
        def det_j(map_data: MapTriangle.MapTriangleData, x: Eigen.MatrixXd) -> Eigen.VectorXd:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the determinant of Jacobian matrix for each points, size 1 x numPoints
            """
            pass

        @staticmethod
        @overload
        def det_j(map_data: MapTriangle.MapTriangleData) -> float:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the determinant of Jacobian matrix
            """
            pass

# </submodule gedim>
####################    </generated_from:MapTriangle.hpp>    ####################


####################    <generated_from:MapParallelogram.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapParallelogram_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapParallelogram:
        class MapParallelogramData:
            """
            (final class)
            """
            b: Eigen.Matrix3d
            b_inv: Eigen.Matrix3d
            b: Eigen.Vector3d
            det_b: float
            det_b_inv: float
            def __init__(
                self,
                b: Eigen.Matrix3d = Eigen.Matrix3d(),
                b_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                b: Eigen.Vector3d = Eigen.Vector3d(),
                det_b: float = float(),
                det_b_inv: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass
        reference_vertices: Eigen.MatrixXd

        def __init__(self) -> None:
            pass

        def compute(self, vertices: Eigen.MatrixXd) -> MapParallelogram.MapParallelogramData:
            pass

        @staticmethod
        def f(
            map_data: MapParallelogram.MapParallelogramData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def f_inv(
            map_data: MapParallelogram.MapParallelogramData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j(
            map_data: MapParallelogram.MapParallelogramData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Compute the jacobian matrix of the transformation F
            / \param mapData the map data
            / \param x points in reference triangle, size 3 x numPoints
            / \return the B matrix for each points, size 3 x (3 * numPoints)
            """
            pass

        @staticmethod
        @overload
        def det_j(
            map_data: MapParallelogram.MapParallelogramData,
            x: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            pass

        @staticmethod
        @overload
        def det_j(map_data: MapParallelogram.MapParallelogramData) -> float:
            pass

# </submodule gedim>
####################    </generated_from:MapParallelogram.hpp>    ####################


####################    <generated_from:MapTetrahedron.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapTetrahedron_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapTetrahedron:
        class MapTetrahedronData:
            """
            (final class)
            """
            q: Eigen.Matrix3d
            b: Eigen.Vector3d
            q_inv: Eigen.Matrix3d
            det_q: float
            det_q_inv: float
            def __init__(
                self,
                q: Eigen.Matrix3d = Eigen.Matrix3d(),
                b: Eigen.Vector3d = Eigen.Vector3d(),
                q_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                det_q: float = float(),
                det_q_inv: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self, geometry_utilities: GeometryUtilities) -> None:
            pass


        @staticmethod
        def q(
            first_vertex: Eigen.Vector3d,
            second_vertex: Eigen.Vector3d,
            third_vertex: Eigen.Vector3d,
            fourth_vertex: Eigen.Vector3d
            ) -> Eigen.Matrix3d:
            """/ Matrix Q for linear map x = Q * x_r + b from reference tetrahedron [0,1]x[0,1]x[0,1]/2 to tetrahedron with x
            / points vertices the tetrahedron to map vertices, size 3 x 4 return the resulting value, size 3 x 3
            """
            pass

        @staticmethod
        def b(first_vertex: Eigen.Vector3d) -> Eigen.Vector3d:
            """/ Matrix Q for linear map x = Q * x_r + b from reference tetrahedron [0,1]x[0,1]x[0,1]/2 to tetrahedron with x
            / points vertices the tetrahedron to map vertices, size 3 x 4 return the resulting value, size 3 x 3
            """
            pass

        def compute(self, vertices: Eigen.MatrixXd) -> MapTetrahedron.MapTetrahedronData:
            """/ Map from the tetrahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b
            / \param vertices the tetrahedron to map vertices, size 3 x 4
            / \return the map data
            """
            pass

        @staticmethod
        def f(
            map_data: MapTetrahedron.MapTetrahedronData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Map from the tetrahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b
            / \param mapData the map data computed
            / \param x points in reference tetrahedron, size 3 x numPoints
            / \return the mapped points, size 3 x numPoints
            """
            pass

        @staticmethod
        def f_inv(
            map_data: MapTetrahedron.MapTetrahedronData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        @staticmethod
        def j(
            map_data: MapTetrahedron.MapTetrahedronData,
            x: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            """/ Compute the jacobian matrix of the transformation F
            / \param mapData the map data computed
            / \param x points in reference tetrahedron, size 3 x numPoints
            / \return the Q matrix for each points, size 2 x (2 * numPoints)
            """
            pass
        @staticmethod
        @overload
        def det_j(
            map_data: MapTetrahedron.MapTetrahedronData,
            x: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data computed
            / \param x points in reference tetrahedron, size 3 x numPoints
            / \return the determinant of Jacobian matrix for each points, size 1 x numPoints
            """
            pass

        @staticmethod
        @overload
        def det_j(map_data: MapTetrahedron.MapTetrahedronData) -> float:
            """/ Compute the determinant of the jacobian matrix of the trasformation
            / \param mapData the map data computed
            / \return the determinant of Jacobian matrix
            """
            pass

# </submodule gedim>
####################    </generated_from:MapTetrahedron.hpp>    ####################


####################    <generated_from:MapQuadrilateral.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MapQuadrilateral_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MapQuadrilateral:
        reference_points: Eigen.MatrixXd

        def __init__(self) -> None:
            pass

        def f(
            self,
            vertices: Eigen.MatrixXd,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        def f_inv(self, vertices: Eigen.MatrixXd, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
            pass

        def j(
            self,
            vertices: Eigen.MatrixXd,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        def j_inv(
            self,
            vertices: Eigen.MatrixXd,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.MatrixXd:
            pass

        def det_j(
            self,
            vertices: Eigen.MatrixXd,
            reference_points: Eigen.MatrixXd
            ) -> Eigen.VectorXd:
            pass

# </submodule gedim>
####################    </generated_from:MapQuadrilateral.hpp>    ####################


####################    <generated_from:IMeshDAO.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __IMeshWrapper_H
#




# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class IMeshDAO:
        """/ \brief The IMeshDAO (mesh data access object) class to read and write mesh data"""

        def initialize_dimension(self, dimension: int) -> None:    # overridable (pure virtual)
            """/ \brief Initialize the mesh dimension"""
            pass
        def dimension(self) -> int:                                # overridable (pure virtual)
            """/ \return the geometric dimension of the mesh"""
            pass

        def cell0_ds_initialize(                                   # overridable (pure virtual)
            self,
            number_cell0_ds: int
            ) -> None:
            """/ \brief Initialize the Cell0Ds container
            / \param numberCell0Ds the total number of Cell0Ds
            / \note No reset of Cell0Ds is performed
            """
            pass
        def cell0_d_append(self, number_cell0_ds: int) -> int:     # overridable (pure virtual)
            """/ \brief Append Cell0Ds to the Cell0Ds container
            / \param numberCell0Ds the number of Cell0Ds to append
            / \return the previous number of Cell0Ds before the append operation
            """
            pass

        def cell0_d_remove(self, cell0_d_index: int) -> None:      # overridable (pure virtual)
            """/ \brief Remove the Cell0D from the mesh
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \note the cell0D is removed and no integrity check in the mesh are performed
            """
            pass
        def cell0_d_insert_coordinates(                            # overridable (pure virtual)
            self,
            cell0_d_index: int,
            coordinates: Eigen.Vector3d
            ) -> None:
            """/ \brief Add the Cell0D Coordinates
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param coordinates the coordinates of the Cell0D
            """
            pass
        def cell0_ds_insert_coordinates(                           # overridable (pure virtual)
            self,
            coordinates: Eigen.MatrixXd
            ) -> None:
            """/ \brief Add the Cell0Ds Coordinates
            / \param coordinates the coordinates of the Cell0Ds, size 3 x Cell0DTotalNumber()
            """
            pass
        def cell0_d_set_marker(                                    # overridable (pure virtual)
            self,
            cell0_d_index: int,
            marker: int
            ) -> None:
            """/ \brief Set the Cell0D Marker
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param marker the marker of the Cell0D
            """
            pass
        def cell0_d_set_state(                                     # overridable (pure virtual)
            self,
            cell0_d_index: int,
            state: bool
            ) -> None:
            """/ \brief Set the Cell0D state
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param state True if Cell0D is active, False otherwise
            """
            pass
        def cell0_d_total_number(self) -> int:                     # overridable (pure virtual)
            """/ \return the total number of Cell0Ds"""
            pass
        def cell0_d_coordinate_x(                                  # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> float:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the X coordinate of cell0D
            """
            pass
        def cell0_d_coordinate_y(                                  # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> float:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the Y coordinate of cell0D
            """
            pass
        def cell0_d_coordinate_z(                                  # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> float:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the Z coordinate of cell0D
            """
            pass
        def cell0_d_coordinates(                                   # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> Eigen.Vector3d:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the coordinates as Eigen Vector3 of cell0D, size 3x1
            """
            pass
        #/ \return the coordinates as Eigen MatrixXd of cell0D, size 3xCell0DTotalNumber()
        @overload
        def cell0_ds_coordinates(self) -> Eigen.MatrixXd:          # overridable (pure virtual)
            pass
        @overload
        def cell0_ds_coordinates(                                  # overridable (pure virtual)
            self,
            cell0_ds: List[int]
            ) -> Eigen.MatrixXd:
            pass
        def cell0_d_is_active(self, cell0_d_index: int) -> bool:   # overridable (pure virtual)
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return if the cell0D is active
            """
            pass
        def cell0_ds_state(self) -> List[bool]:                    # overridable (pure virtual)
            """/ \return the activation state of all cell0Ds"""
            pass
        #/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
        #/ \return the cell0D marker
        def cell0_d_marker(self, cell0_d_index: int) -> int:       # overridable (pure virtual)
            pass
        def cell0_ds_marker(self) -> List[int]:                    # overridable (pure virtual)
            pass
        def cell0_d_has_updated_cell0_ds(                          # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return if the cell0D has new cell0Ds associated
            """
            pass
        def cell0_d_number_updated_cell0_ds(                       # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the number of new cell0Ds associated to cell0DIndex
            """
            pass
        def cell0_d_has_updated_cell0_d(                           # overridable (pure virtual)
            self,
            cell0_d_index: int,
            updated_cell0_d_idex: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param updatedCell0DIdex the index of the new cell0D from 0 to Cell0DTotalNumber()
            / \return if the cell0D has the updatedCell0DIdex associated
            """
            pass
        def cell0_d_insert_updated_cell0_d(                        # overridable (pure virtual)
            self,
            cell0_d_index: int,
            updated_cell0_d_idex: int
            ) -> None:
            """/ \brief Add the new Cell0D to an existing Cell0D
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param updatedCell0DIdex the index of the new cell0D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell0_d_updated_cell0_ds(                              # overridable (pure virtual)
            self,
            cell0_d_index: int,
            updated_cell0_d_ids: std.list[int]
            ) -> bool:
            """/ \brief return the updated Cell0D Ids for cell0DIndex
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param updatedCell0DIds the list of the new Cell0D Ids associated to cell0DIndex
            / \return True if the cell0DIndex is contained in the updatedCell0DIds list, False otherwise
            """
            pass

        def cell0_ds_neighbour_cell1_ds(self) -> List[List[int]]:  # overridable (pure virtual)
            pass
        def cell0_ds_initialize_neighbour_cell1_ds(                # overridable (pure virtual)
            self,
            numbers_neighbour_cell1_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell0Ds Cell1D neighbours number
            / \param numbersNeighbourCell1Ds the number of Cell1D neighbours of each Cell0D, size 1 x Cell0DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell0D Cell1D neighbours number
        #/ \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
        #/ \param numberNeighbourCell1Ds the number of Cell1D neighbours of the Cell0D
        @overload
        def cell0_d_initialize_neighbour_cell1_ds(                 # overridable (pure virtual)
            self,
            cell0_d_index: int,
            number_neighbour_cell1_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell1_ds(                 # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_cell1_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell1_d(                      # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell1_d_index: int
            ) -> None:
            """/ \brief Insert the Cell0D Cell1D neighbour
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell1D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell1D(cell0DIndex) \param neigbourCell1DIndex the Cell1D neighbour index from 0 to
            / Cell1DTotalNumber() \note Cell0DInitializeNeighbourCell1Ds() shall be called before
            """
            pass
        def cell0_d_number_neighbour_cell1_d(                      # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the number of Neighbour Cell1Ds of Cell0D
            """
            pass
        def cell0_d_neighbour_cell1_d(                             # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell1D from 0 to Cell0DNumberNeighbourCell1D(cell0DIndex)
            / \return the Cell1D index of Neighbour Cell1Ds of Cell0D from 0 to Cell1DTotalNumber()
            """
            pass

        def cell0_d_neighbour_cell1_ds(                            # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> List[int]:
            pass

        def cell0_d_has_neighbour_cell1_d(                         # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell1D from 0 to Cell0DNumberNeighbourCell1D(cell0DIndex)
            / \return True if Neighbour Cell1Ds of Cell0D at position neighbourIndex exists
            """
            pass

        def cell0_d_reset_neighbour_cell1_d(                       # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell0D Cell1D neighbour to empty value (Cell0DHasNeighbourCell1D is False)
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell1D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell1D(cell0DIndex)
            """
            pass

        def cell0_ds_neighbour_cell2_ds(self) -> List[List[int]]:  # overridable (pure virtual)
            pass
        def cell0_ds_initialize_neighbour_cell2_ds(                # overridable (pure virtual)
            self,
            numbers_neighbour_cell2_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell0Ds Cell2D neighbours number
            / \param numbersNeighbourCell2Ds the number of Cell2D neighbours of each Cell0D, size 1 x Cell0DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell0D Cell2D neighbours number
        #/ \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
        #/ \param numberNeighbourCell2Ds the number of Cell2D neighbours of the Cell0D
        @overload
        def cell0_d_initialize_neighbour_cell2_ds(                 # overridable (pure virtual)
            self,
            cell0_d_index: int,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell2_ds(                 # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell2_d(                      # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell2_d_index: int
            ) -> None:
            """/ \brief Insert the Cell0D Cell2D neighbour
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell2D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell2D(cell0DIndex) \param neigbourCell2DIndex the Cell2D neighbour index from 0 to
            / Cell2DTotalNumber() \note Cell0DInitializeNeighbourCell2Ds() shall be called before
            """
            pass
        def cell0_d_number_neighbour_cell2_d(                      # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the number of Neighbour Cell2Ds of Cell0D
            """
            pass
        def cell0_d_neighbour_cell2_d(                             # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell2D from 0 to Cell0DNumberNeighbourCell2D(cell0DIndex)
            / \return the Cell2D index of Neighbour Cell2Ds of Cell0D from 0 to Cell2DTotalNumber()
            """
            pass

        def cell0_d_neighbour_cell2_ds(                            # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> List[int]:
            pass

        def cell0_d_has_neighbour_cell2_d(                         # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell2D from 0 to Cell0DNumberNeighbourCell2D(cell0DIndex)
            / \return True if Neighbour Cell2Ds of Cell0D at position neighbourIndex exists
            """
            pass
        def cell0_d_reset_neighbour_cell2_d(                       # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell0D Cell2D neighbour to empty value (Cell0DHasNeighbourCell2D is False)
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell2D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell2D(cell0DIndex)
            """
            pass

        def cell0_ds_neighbour_cell3_ds(self) -> List[List[int]]:  # overridable (pure virtual)
            pass
        def cell0_ds_initialize_neighbour_cell3_ds(                # overridable (pure virtual)
            self,
            numbers_neighbour_cell3_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell0Ds Cell3D neighbours number
            / \param numbersNeighbourCell3Ds the number of Cell3D neighbours of each Cell0D, size 1 x Cell0DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell0D Cell3D neighbours number
        #/ \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
        #/ \param numberNeighbourCell3Ds the number of Cell3D neighbours of the Cell0D
        @overload
        def cell0_d_initialize_neighbour_cell3_ds(                 # overridable (pure virtual)
            self,
            cell0_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell3_ds(                 # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell3_d(                      # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            """/ \brief Insert the Cell0D Cell3D neighbour
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell3D(cell0DIndex) \param neigbourCell3DIndex the Cell3D neighbour index from 0 to
            / Cell3DTotalNumber() \note Cell0DInitializeNeighbourCell3Ds() shall be called before
            """
            pass
        def cell0_d_number_neighbour_cell3_d(                      # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> int:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the number of Neighbour Cell3Ds of Cell0D
            """
            pass
        #/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
        #/ \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell0DNumberNeighbourCell3D(cell0DIndex)
        #/ \return the Cell3D index of Neighbour Cell3Ds of Cell0D from 0 to Cell3DTotalNumber()
        def cell0_d_neighbour_cell3_d(                             # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> int:
            pass
        def cell0_d_neighbour_cell3_ds(                            # overridable (pure virtual)
            self,
            cell0_d_index: int
            ) -> List[int]:
            pass
        def cell0_d_has_neighbour_cell3_d(                         # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell0DNumberNeighbourCell3D(cell0DIndex)
            / \return True if Neighbour Cell3Ds of Cell0D at position neighbourIndex exists
            """
            pass
        def cell0_d_reset_neighbour_cell3_d(                       # overridable (pure virtual)
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell0D Cell3D neighbour to empty value (Cell0DHasNeighbourCell3D is False)
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell0D from 0 to
            / Cell0DNumberNeighbourCell3D(cell0DIndex)
            """
            pass

        def cell0_d_initialize_double_properties(                  # overridable (pure virtual)
            self,
            number_double_properties: int
            ) -> None:
            """/ \brief Initialize the Cell0Ds double properties
            / \param numberDoubleProperties the total number of Cell0Ds properties
            / \note No reset of Cell0Ds is performed
            """
            pass
        def cell0_d_add_double_property(                           # overridable (pure virtual)
            self,
            property_id: str
            ) -> int:
            """/ \brief Add the Cell0Ds double property identified by id
            / \param propertyId the id of Cell0Ds property
            / \return the double property position
            """
            pass
        def cell0_ds_initialize_double_property_values(            # overridable (pure virtual)
            self,
            property_index: int,
            porperty_sizes: List[int]
            ) -> None:
            """/ \brief Initialize the Cell0Ds double property sizes
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            / \param porpertySize the double property size of each Cell0D, size 1 x Cell0DTotalNumber()
            """
            pass
        def cell0_d_initialize_double_property_values(             # overridable (pure virtual)
            self,
            cell0_d_index: int,
            property_index: int,
            porperty_size: int
            ) -> None:
            """/ \brief Initialize the Cell0Ds double property size
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            / \param porpertySize the double property size of Cell0D
            """
            pass
        def cell0_d_insert_double_property_value(                  # overridable (pure virtual)
            self,
            cell0_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            """/ \brief Insert the Cell0Ds double property value at position
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            """
            pass

        def cell0_d_number_double_properties(self) -> int:         # overridable (pure virtual)
            """/ \return the total number of double properties of Cell0Ds"""
            pass
        def cell0_d_double_property_id(                            # overridable (pure virtual)
            self,
            property_index: int
            ) -> str:
            """/ \return the id of the double property of Cell0Ds
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            """
            pass
        def cell0_d_double_property_exists(                        # overridable (pure virtual)
            self,
            property_id: str
            ) -> bool:
            """/ \return True if the double propertyId of Cell0Ds exists
            / \param propertyId the id of Cell0D double property
            """
            pass
        def cell0_d_double_property_index(                         # overridable (pure virtual)
            self,
            property_id: str
            ) -> int:
            """/ \return the propertyIndex of the double property of Cell0Ds from 0 to Cell0DNumberProperties()
            / \param propertyId the id of Cell0D double property
            """
            pass
        def cell0_d_double_property_size(                          # overridable (pure virtual)
            self,
            cell0_d_index: int,
            property_index: int
            ) -> int:
            """/ \return the size of the double property of Cell0D
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            """
            pass
        def cell0_d_double_property_value(                         # overridable (pure virtual)
            self,
            cell0_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            """/ \return the value of the double property at valueIndex of Cell0D
            / \param cell0DIndex the index of Cell0D from 0 to Cell0DTotalNumber()
            / \param propertyIndex the index of Cell0D double property from 0 to Cell0DNumberProperties()
            / \param propertyValueIndex the index of Cell0D double property value from 0 to Cell0DDoublePropertySize()
            """
            pass

        def cell1_ds_initialize(                                   # overridable (pure virtual)
            self,
            number_cell1_ds: int
            ) -> None:
            """/ \brief Initialize the Cell1Ds container
            / \param numberCell1Ds the total number of Cell1Ds
            / \note No reset of Cell1Ds is performed
            """
            pass
        def cell1_d_append(self, number_cell1_ds: int) -> int:     # overridable (pure virtual)
            """/ \brief Append Cell1Ds to the Cell1Ds container
            / \param numberCell1Ds the number of Cell1Ds to append
            / \return the previous number of Cell1Ds before the append operation
            """
            pass
        def cell1_d_remove(self, cell1_d_index: int) -> None:      # overridable (pure virtual)
            """/ \brief Remove the Cell1D from the mesh
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \note the cell1D is removed and no integrity check in the mesh are performed
            """
            pass
        def cell1_d_insert_extremes(                               # overridable (pure virtual)
            self,
            cell1_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> None:
            """/ \brief Set the Cell1D Origin and End
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param originCell0DIndex the Cell0D index of Cell1D origin from 0 to Cell0DTotalNumber()
            / \param endCell0DIndex the Cell0D index of Cell1D end from 0 to Cell0DTotalNumber()
            """
            pass

        def cell1_ds_insert_extremes(                              # overridable (pure virtual)
            self,
            cell1_d_extremes: Eigen.MatrixXi
            ) -> None:
            """/ \brief Set the Cell1D Extremes for the whole mesh edges
            / \param cell1DExtremes the origin and end indices of all the edges, size 2 x Cell1DTotalNumber()
            """
            pass

        @overload
        def cell1_ds_extremes(self) -> Eigen.MatrixXi:             # overridable (pure virtual)
            """/ \return the extrems as Eigen MatrixXi of cell1Ds, size 2xCell1DTotalNumber()"""
            pass
        #/ \return the extrems as Eigen MatrixXi of cell1D, size 2
        #/ \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
        def cell1_d_extremes(                                      # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> Eigen.VectorXi:
            pass
        @overload
        def cell1_ds_extremes(                                     # overridable (pure virtual)
            self,
            cell1_ds: List[int]
            ) -> Eigen.MatrixXi:
            pass
        def cell1_d_by_extremes(                                   # overridable (pure virtual)
            self,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            """/ \return the Cell1D Index if Cell1D (origin->end) exists, Cell1DTotalNumber() otherwise
            / \param originCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \param endCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            """
            pass
        def cell1_d_set_marker(                                    # overridable (pure virtual)
            self,
            cell1_d_index: int,
            marker: int
            ) -> None:
            """/ \brief Set the Cell1D Marker
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param marker the marker of the Cell1D
            """
            pass
        def cell1_d_set_state(                                     # overridable (pure virtual)
            self,
            cell1_d_index: int,
            state: bool
            ) -> None:
            """/ \brief Set the Cell1D state
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param state True if Cell1D is active, False otherwise
            """
            pass
        def cell1_d_total_number(self) -> int:                     # overridable (pure virtual)
            """/ \return the total number of Cell1Ds"""
            pass
        def cell1_d_vertex(                                        # overridable (pure virtual)
            self,
            cell1_d_index: int,
            vertex_index: int
            ) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param vertexIndex the index of the vertex from 0 to 2
            / \return Cell0D index of the vertex of Cell1D
            """
            pass
        def cell1_d_coordinates(                                   # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> Eigen.MatrixXd:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the coordinates of Cell1D, size 3x2
            """
            pass
        def cell1_d_origin_coordinates(                            # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> Eigen.Vector3d:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the origin coordinates of Cell1D
            """
            pass
        def cell1_d_end_coordinates(                               # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> Eigen.Vector3d:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the end coordinates of Cell1D
            """
            pass
        def cell1_d_origin(self, cell1_d_index: int) -> int:       # overridable (pure virtual)
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the origin Cell0D index of Cell1D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell1_d_end(self, cell1_d_index: int) -> int:          # overridable (pure virtual)
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the end Cell0D index of Cell1D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell1_d_find_extreme(                                  # overridable (pure virtual)
            self,
            cell1_d_index: int,
            cell0_d_index: int
            ) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the index of the cell0DIndex on the cell1D from 0 to 1, 2 if not found
            """
            pass
        #/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
        #/ \return the cell1D marker
        def cell1_d_marker(self, cell1_d_index: int) -> int:       # overridable (pure virtual)
            pass
        def cell1_ds_marker(self) -> List[int]:                    # overridable (pure virtual)
            pass
        def cell1_d_is_active(self, cell1_d_index: int) -> bool:   # overridable (pure virtual)
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return if the cell1D is active
            """
            pass
        def cell1_ds_state(self) -> List[bool]:                    # overridable (pure virtual)
            """/ \return the activation state of all cell1Ds"""
            pass

        def cell1_d_has_original_cell1_d(                          # overridable (pure virtual)
            self,
            updated_cell1_d_index: int
            ) -> bool:
            """/ \param updatedCell1DIndex the updated cell1D index, from 0 to Cell1DTotalNumber()
            / \return True if has an original cell, False otherwise (the original cell is itself)
            """
            pass
        def cell1_d_original_cell1_d(                              # overridable (pure virtual)
            self,
            updated_cell1_d_index: int
            ) -> int:
            """/ \param updatedCell1DIndex the updated cell1D index, from 0 to Cell1DTotalNumber()
            / \return the original cell1D index, from 0 to Cell1DTotalNumber()
            """
            pass
        def cell1_d_has_updated_cell1_ds(                          # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return if the cell1D has new cell1Ds associated
            """
            pass
        def cell1_d_number_updated_cell1_ds(                       # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the number of new cell1Ds associated to cell1DIndex
            """
            pass
        def cell1_d_has_updated_cell1_d(                           # overridable (pure virtual)
            self,
            cell1_d_index: int,
            updated_cell1_d_idex: int
            ) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param updatedCell1DIdex the index of the new Cell1D from 0 to Cell1DTotalNumber()
            / \return if the Cell1D has the updatedCell1DIdex associated
            """
            pass
        def cell1_d_insert_updated_cell1_d(                        # overridable (pure virtual)
            self,
            cell1_d_index: int,
            updated_cell1_d_idex: int
            ) -> None:
            """/ \brief Add the new Cell1D to an existing Cell1D
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param updatedCell1DIdex the index of the new Cell1D from 0 to Cell1DTotalNumber()
            """
            pass
        def cell1_d_updated_cell1_ds(                              # overridable (pure virtual)
            self,
            cell1_d_index: int,
            updated_cell1_d_ids: std.list[int]
            ) -> bool:
            """/ \brief return the updated Cell1D Ids for cell1DIndex
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param updatedCell1DIds the list of the new Cell1D Ids associated to cell1DIndex
            / \return True if the cell1DIndex is contained in the updatedCell1DIds list, False otherwise
            """
            pass

        def cell1_ds_neighbour_cell2_ds(self) -> List[List[int]]:  # overridable (pure virtual)
            pass
        @overload
        def cell1_ds_initialize_neighbour_cell2_ds(                # overridable (pure virtual)
            self,
            numbers_neighbour_cell2_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell1Ds Cell2D neighbours number
            / \param numbersNeighbourCell2Ds the number of Cell2D neighbours of each Cell1D, size 1 x Cell1DTotalNumber()
            """
            pass
        @overload
        def cell1_ds_initialize_neighbour_cell2_ds(                # overridable (pure virtual)
            self,
            number_neighbour_cell2_ds: int
            ) -> None:
            """/ \brief Initialize the Cell1Ds Cell2D neighbours number
            / \param numberNeighbourCell2Ds the number of Cell2D neighbours of the Cell1D
            """
            pass

        #/ \brief Initialize the Cell1D Cell2D neighbours number
        #/ \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
        #/ \param numberNeighbourCell2Ds the number of Cell2D neighbours of the Cell1D
        @overload
        def cell1_d_initialize_neighbour_cell2_ds(                 # overridable (pure virtual)
            self,
            cell1_d_index: int,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell2_ds(                 # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        def cell1_d_insert_neighbour_cell2_d(                      # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_index: int,
            neigbour_cell2_d_index: int
            ) -> None:
            """/ \brief Insert the Cell1D Cell2D neighbour
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of Cell2D neighbour of the Cell1D from 0 to
            / Cell1DNumberNeighbourCell2D(cell1DIndex) \param neigbourCell2DIndex the Cell2D neighbour index from 0 to
            / Cell2DTotalNumber() \note Cell1DInitializeNeighbourCell2Ds() shall be called before
            """
            pass
        def cell1_d_number_neighbour_cell2_d(                      # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the number of Neighbour Cell2Ds of Cell1D
            """
            pass
        def cell1_d_neighbour_cell2_d(                             # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell2D from 0 to Cell1DNumberNeighbourCell2D(cell1DIndex)
            / \return the Cell2D index of Neighbour Cell2Ds of Cell1D from 0 to Cell2DTotalNumber()
            """
            pass

        def cell1_d_neighbour_cell2_ds(                            # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> List[int]:
            pass

        def cell1_d_has_neighbour_cell2_d(                         # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell2D from 0 to Cell1DNumberNeighbourCell2D(cell1DIndex)
            / \return True if Neighbour Cell2Ds of Cell1D at position neighbourIndex exists
            """
            pass
        def cell1_d_reset_neighbour_cell2_d(                       # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell1D Cell2D neighbour to empty value (Cell1DHasNeighbourCell2D is False)
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of Cell2D neighbour of the Cell1D from 0 to
            / Cell1DNumberNeighbourCell2D(cell1DIndex)
            """
            pass

        def cell1_ds_neighbour_cell3_ds(self) -> List[List[int]]:  # overridable (pure virtual)
            pass
        def cell1_ds_initialize_neighbour_cell3_ds(                # overridable (pure virtual)
            self,
            numbers_neighbour_cell3_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell1Ds Cell3D neighbours number
            / \param numbersNeighbourCell3Ds the number of Cell2D neighbours of each Cell1D, size 1 x Cell1DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell1D Cell3D neighbours number
        #/ \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
        #/ \param numberNeighbourCell3Ds the number of Cell3D neighbours of the Cell1D
        @overload
        def cell1_d_initialize_neighbour_cell3_ds(                 # overridable (pure virtual)
            self,
            cell1_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell3_ds(                 # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell1_d_insert_neighbour_cell3_d(                      # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            """/ \brief Insert the Cell1D Cell3D neighbour
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell1D from 0 to
            / Cell1DNumberNeighbourCell3D(cell1DIndex) \param neigbourCell3DIndex the Cell3D neighbour index from 0 to
            / Cell3DTotalNumber() \note Cell1DInitializeNeighbourCell3Ds() shall be called before
            """
            pass
        def cell1_d_number_neighbour_cell3_d(                      # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> int:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the number of Neighbour Cell3Ds of Cell1D
            """
            pass
        #/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
        #/ \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell1DNumberNeighbourCell3D(cell1DIndex)
        #/ \return the Cell3D index of Neighbour Cell3Ds of Cell1D from 0 to Cell3DTotalNumber()
        def cell1_d_neighbour_cell3_d(                             # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> int:
            pass
        def cell1_d_neighbour_cell3_ds(                            # overridable (pure virtual)
            self,
            cell1_d_index: int
            ) -> List[int]:
            pass
        def cell1_d_has_neighbour_cell3_d(                         # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell1DNumberNeighbourCell3D(cell1DIndex)
            / \return True if Neighbour Cell3Ds of Cell1D at position neighbourIndex exists
            """
            pass
        def cell1_d_reset_neighbour_cell3_d(                       # overridable (pure virtual)
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell1D Cell3D neighbour to empty value (Cell1DHasNeighbourCell3D is False)
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell1D from 0 to
            / Cell1DNumberNeighbourCell3D(cell1DIndex)
            """
            pass

        def cell1_d_initialize_double_properties(                  # overridable (pure virtual)
            self,
            number_double_properties: int
            ) -> None:
            """/ \brief Initialize the Cell1Ds double properties
            / \param numberDoubleProperties the total number of Cell1Ds properties
            / \note No reset of Cell1Ds is performed
            """
            pass
        def cell1_d_add_double_property(                           # overridable (pure virtual)
            self,
            property_id: str
            ) -> int:
            """/ \brief Add the Cell1Ds double property identified by id
            / \param propertyId the id of Cell1Ds property
            / \return the double property position
            """
            pass
        def cell1_ds_initialize_double_property_values(            # overridable (pure virtual)
            self,
            property_index: int,
            porperty_sizes: List[int]
            ) -> None:
            """/ \brief Initialize the Cell1Ds double property sizes
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            / \param porpertySize the double property size of each Cell1D, size 1 x Cell1DTotalNumber()
            """
            pass
        def cell1_d_initialize_double_property_values(             # overridable (pure virtual)
            self,
            cell1_d_index: int,
            property_index: int,
            porperty_size: int
            ) -> None:
            """/ \brief Initialize the Cell1Ds double property size
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            / \param porpertySize the double property size of Cell1D
            """
            pass
        def cell1_d_insert_double_property_value(                  # overridable (pure virtual)
            self,
            cell1_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            """/ \brief Insert the Cell1Ds double property value at position
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            """
            pass

        def cell1_d_number_double_properties(self) -> int:         # overridable (pure virtual)
            """/ \return the total number of double properties of Cell1Ds"""
            pass
        def cell1_d_double_property_id(                            # overridable (pure virtual)
            self,
            property_index: int
            ) -> str:
            """/ \return the id of the double property of Cell1Ds
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            """
            pass
        def cell1_d_double_property_exists(                        # overridable (pure virtual)
            self,
            property_id: str
            ) -> bool:
            """/ \return True if the double propertyId of Cell1Ds exists
            / \param propertyId the id of Cell1D double property
            """
            pass
        def cell1_d_double_property_index(                         # overridable (pure virtual)
            self,
            property_id: str
            ) -> int:
            """/ \return the propertyIndex of the double property of Cell1Ds from 0 to Cell1DNumberProperties()
            / \param propertyId the id of Cell1D double property
            """
            pass
        def cell1_d_double_property_size(                          # overridable (pure virtual)
            self,
            cell1_d_index: int,
            property_index: int
            ) -> int:
            """/ \return the size of the double property of Cell1D
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            """
            pass
        def cell1_d_double_property_value(                         # overridable (pure virtual)
            self,
            cell1_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            """/ \return the value of the double property at valueIndex of Cell1D
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param propertyIndex the index of Cell1D double property from 0 to Cell1DNumberProperties()
            / \param propertyValueIndex the index of Cell1D double property value from 0 to Cell1DDoublePropertySize()
            """
            pass

        def cell2_ds_initialize(                                   # overridable (pure virtual)
            self,
            number_cell2_ds: int
            ) -> None:
            """/ \brief Initialize the Cell2Ds container
            / \param numberCell2Ds the total number of Cell2Ds
            / \note No reset of Cell2Ds is performed
            """
            pass
        def cell2_d_append(self, number_cell2_ds: int) -> int:     # overridable (pure virtual)
            """/ \brief Append Cell2Ds to the Cell2Ds container
            / \param numberCell2Ds the number of Cell2Ds to append
            / \return the previous number of Cell2Ds before the append operation
            """
            pass
        def cell2_d_remove(self, cell2_d_index: int) -> None:      # overridable (pure virtual)
            """/ \brief Remove the Cell2D from the mesh
            / \param cell2DIndex the index of Cell0D from 0 to Cell2DTotalNumber()
            / \note the cell2D is removed and no integrity check in the mesh are performed
            """
            pass
        @overload
        def cell2_ds_initialize_vertices(                          # overridable (pure virtual)
            self,
            number_cell2_d_vertices: int
            ) -> None:
            """/ \brief Initialize the Cell2Ds vertices number
            / \param numberCell2DVertices the number of vertices of all Cell2Ds
            """
            pass
        @overload
        def cell2_ds_initialize_vertices(                          # overridable (pure virtual)
            self,
            number_cell2_ds_vertices: List[int]
            ) -> None:
            """/ \brief Initialize the Cell2Ds vertices number
            / \param numberCell2DsVertices the number of vertices of each Cell2D
            """
            pass
        def cell2_d_initialize_vertices(                           # overridable (pure virtual)
            self,
            cell2_d_index: int,
            number_cell2_d_vertices: int
            ) -> None:
            """/ \brief Initialize the Cell2D vertices  number
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param numberCell2DVertices the number of vertices of Cell2D
            """
            pass
        @overload
        def cell2_ds_initialize_edges(                             # overridable (pure virtual)
            self,
            number_cell2_d_edges: int
            ) -> None:
            """/ \brief Initialize the Cell2Ds edges number
            / \param numberCell2DEdges the number of edges of all Cell2Ds
            """
            pass
        @overload
        def cell2_ds_initialize_edges(                             # overridable (pure virtual)
            self,
            number_cell2_ds_edges: List[int]
            ) -> None:
            """/ \brief Initialize the Cell2Ds edges number
            / \param numberCell2DsEdges the number of edges of each Cell2D
            """
            pass
        def cell2_d_initialize_edges(                              # overridable (pure virtual)
            self,
            cell2_d_index: int,
            number_cell2_d_edges: int
            ) -> None:
            """/ \brief Initialize the Cell2D edges number
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param numberCell2DEdges the number of edges of Cell2D
            """
            pass
        def cell2_d_insert_vertices(                               # overridable (pure virtual)
            self,
            cell2_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Insert the Cell2D vertex
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param verticesCell0DIndices the Cell0D vertices index from 0 to Cell0DTotalNumber()
            / \note Cell2DInitializeVertices() should be called before using this method
            """
            pass
        def cell2_d_insert_vertex(                                 # overridable (pure virtual)
            self,
            cell2_d_index: int,
            vertex_index: int,
            vertex_cell0_d_index: int
            ) -> None:
            """/ \brief Insert the Cell2D vertex
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param vertexIndex the number of vertex of the Cell2D from 0 to Cell2DNumberVertices(cell2DIndex)
            / \param vertexCell0DIndex the Cell0D vertex index from 0 to Cell0DTotalNumber()
            / \note Cell2DInitializeVertices() should be called before using this method
            """
            pass
        def cell2_d_add_vertices(                                  # overridable (pure virtual)
            self,
            cell2_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell2D vertices
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param vertexCell0DIndices the Cell0D vertices indices from 0 to Cell0DTotalNumber()
            / \note No itialization is necessary
            """
            pass
        def cell2_d_insert_edges(                                  # overridable (pure virtual)
            self,
            cell2_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            """/ \brief Insert the Cell2D edge
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param edgesCell1DIndices the Cell1D edges indices from 0 to Cell1DTotalNumber()
            / \note Cell2DInitializeEdges() should be called before using this method
            """
            pass
        def cell2_d_insert_edge(                                   # overridable (pure virtual)
            self,
            cell2_d_index: int,
            edge_index: int,
            edge_cell1_d_index: int
            ) -> None:
            """/ \brief Insert the Cell2D edge
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param edgeIndex the number of edge of the Cell2D from 0 to Cell2DNumberEdges(cell2DIndex)
            / \param edgeCell0DIndex the Cell1D edge index from 0 to Cell1DTotalNumber()
            / \note Cell2DInitializeEdges() should be called before using this method
            """
            pass
        def cell2_d_add_edges(                                     # overridable (pure virtual)
            self,
            cell2_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell2D edges
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param edgesCell1DIndices the Cell1D edges indices from 0 to Cell1DTotalNumber()
            / \note No itialization is necessary
            """
            pass

        def cell2_d_add_vertices_and_edges(                        # overridable (pure virtual)
            self,
            cell2_d_index: int,
            vertices_and_edges_indices: Eigen.MatrixXi
            ) -> None:
            """/ \brief Cell2D Add Vertices And Edges
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param verticesAndEdgesIndices the matrix of Cell0Ds and Cell1Ds indices
            / \note No itialization is necessary
            """
            pass

        def cell2_d_set_marker(                                    # overridable (pure virtual)
            self,
            cell2_d_index: int,
            marker: int
            ) -> None:
            """/ \brief Set the Cell2D Marker
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param marker the marker of the Cell2D
            """
            pass
        def cell2_d_set_state(                                     # overridable (pure virtual)
            self,
            cell2_d_index: int,
            state: bool
            ) -> None:
            """/ \brief Set the Cell1D state
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param state True if Cell1D is active, False otherwise
            """
            pass
        def cell2_d_total_number(self) -> int:                     # overridable (pure virtual)
            """/ \return the total number of Cell2Ds"""
            pass
        def cell2_d_number_vertices(                               # overridable (pure virtual)
            self,
            cell2_d_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the number of vertices of Cell2D
            """
            pass
        def cell2_d_number_edges(self, cell2_d_index: int) -> int: # overridable (pure virtual)
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the number of edges of Cell2D
            """
            pass
        def cell2_ds_vertices(self) -> List[List[int]]:            # overridable (pure virtual)
            """/ \return the Cell0D index collections of all Cell2Ds, size Cell2DTotalNumber() x
            / Cell2DNumberVertices(cell2DIndex)
            """
            pass
        def cell2_ds_extremes(self) -> List[Eigen.MatrixXi]:       # overridable (pure virtual)
            """/ \return the Cell0Ds and Cell1Ds index collections of all Cell2Ds, size Cell2DTotalNumber() x (2 x
            / Cell2DNumberVertices(cell2DIndex))
            """
            pass
        def cell2_d_vertices(                                      # overridable (pure virtual)
            self,
            cell2_d_index: int
            ) -> List[int]:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the Cell0D index collections of Cell2D from 0 to Cell0DTotalNumber(), size
            / Cell2DNumberVertices(cell2DIndex)
            """
            pass
        def cell2_d_vertex(                                        # overridable (pure virtual)
            self,
            cell2_d_index: int,
            vertex_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param vertexIndex the index of cell0D vertex from 0 to NumberCell2DVertices(cell2DIndex)
            / \return the Cell0D index of vertex of Cell2D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell2_d_vertex_coordinates(                            # overridable (pure virtual)
            self,
            cell2_d_index: int,
            vertex_index: int
            ) -> Eigen.Vector3d:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param vertexIndex the index of cell0D vertex from 0 to NumberCell2DVertices(cell2DIndex)
            / \return the Cell0D coordinates of vertex of Cell2D, size 3 x 1
            """
            pass
        def cell2_d_vertices_coordinates(                          # overridable (pure virtual)
            self,
            cell2_d_index: int
            ) -> Eigen.MatrixXd:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the Cell0D coordinates of all the vertices of Cell2D, size 3 x NumberCell2DVertices(cell2DIndex)
            """
            pass
        def cell2_d_find_vertex(                                   # overridable (pure virtual)
            self,
            cell2_d_index: int,
            cell0_d_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the index of the cell0DIndex on the cell2D from 0 to NumberCell2DVertices(cell2DIndex),
            / NumberCell2DVertices(cell2DIndex) if not found
            """
            pass
        def cell2_d_edges(self, cell2_d_index: int) -> List[int]:  # overridable (pure virtual)
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the Cell1D index collections of Cell2D from 0 to Cell1DTotalNumber(), size
            / Cell2DNumberEdges(cell2DIndex)
            """
            pass
        def cell2_d_edge(                                          # overridable (pure virtual)
            self,
            cell2_d_index: int,
            edge_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param edgeIndex the index of cell1D edge from 0 to NumberCell2DEdges(cell2DIndex)
            / \return the Cell1D index of edge of Cell2D from 0 to Cell1DTotalNumber()
            """
            pass
        def cell2_d_find_edge(                                     # overridable (pure virtual)
            self,
            cell2_d_index: int,
            cell1_d_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the index of the cell1DIndex on the cell2D from 0 to NumberCell2DEdges(cell2DIndex),
            / NumberCell2DEdges(cell2DIndex) if not found
            """
            pass
        def cell2_d_find_edge_by_extremes(                         # overridable (pure virtual)
            self,
            cell2_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param originCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \param endCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \return the index of the cell1DIndex on the cell2D from 0 to NumberCell2DEdges(cell2DIndex),
            / NumberCell2DEdges(cell2DIndex) otherwise
            """
            pass
        #/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
        #/ \return the cell2D marker
        def cell2_d_marker(self, cell2_d_index: int) -> int:       # overridable (pure virtual)
            pass
        def cell2_ds_marker(self) -> List[int]:                    # overridable (pure virtual)
            pass
        def cell2_d_is_active(self, cell2_d_index: int) -> bool:   # overridable (pure virtual)
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return if the cell2D is active
            """
            pass
        def cell2_ds_state(self) -> List[bool]:                    # overridable (pure virtual)
            """/ \return the activation state of all cell2Ds"""
            pass

        def cell2_d_has_updated_cell2_ds(                          # overridable (pure virtual)
            self,
            cell2_d_index: int
            ) -> bool:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return if the cell2D has new cell2Ds associated
            """
            pass
        def cell2_d_number_updated_cell2_ds(                       # overridable (pure virtual)
            self,
            cell2_d_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the number of new cell2Ds associated to cell2DIndex
            """
            pass
        def cell2_d_has_updated_cell2_d(                           # overridable (pure virtual)
            self,
            cell2_d_index: int,
            updated_cell2_d_index: int
            ) -> bool:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param updatedCell2DIndex the index of the new Cell2D from 0 to Cell2DTotalNumber()
            / \return if the Cell2D has the updatedCell2DIdex associated
            """
            pass
        def cell2_d_insert_updated_cell2_d(                        # overridable (pure virtual)
            self,
            cell2_d_index: int,
            updated_cell2_d_idex: int
            ) -> None:
            """/ \brief Add the new Cell2D to an existing Cell2D
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param updatedCell2DIdex the index of the new Cell2D from 0 to Cell2DTotalNumber()
            """
            pass

        def cell2_d_has_original_cell2_d(                          # overridable (pure virtual)
            self,
            updated_cell2_d_index: int
            ) -> bool:
            """/ \param updatedCell2DIndex the updated cell2D index, from 0 to Cell2DTotalNumber()
            / \return True if has an original cell, False otherwise (the original cell is itself)
            """
            pass
        def cell2_d_original_cell2_d(                              # overridable (pure virtual)
            self,
            updated_cell2_d_index: int
            ) -> int:
            """/ \param updatedCell2DIndex the updated cell2D index, from 0 to Cell2DTotalNumber()
            / \return the original cell2D index, from 0 to Cell2DTotalNumber()
            """
            pass
        def cell2_d_updated_cell2_ds(                              # overridable (pure virtual)
            self,
            cell2_d_index: int,
            updated_cell2_d_ids: std.list[int]
            ) -> bool:
            """/ \brief return the updated Cell2D Ids for cell2DIndex
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param updatedCell2DIds the list of the new Cell2D Ids associated to cell2DIndex
            / \return True if the cell2DIndex is contained in the updatedCell2DIds list, False otherwise
            """
            pass

        def cell2_ds_neighbour_cell3_ds(self) -> List[List[int]]:  # overridable (pure virtual)
            pass
        def cell2_ds_initialize_neighbour_cell3_ds(                # overridable (pure virtual)
            self,
            numbers_neighbour_cell3_ds: List[int]
            ) -> None:
            """/ \brief Initialize the Cell2Ds Cell3D neighbours number
            / \param numbersNeighbourCell3Ds the number of Cell3D neighbours of each Cell2D, size 1 x Cell2DTotalNumber()
            """
            pass
        #/ \brief Initialize the Cell2D Cell3D neighbours number
        #/ \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
        #/ \param numberNeighbourCell3Ds the number of Cell3D neighbours of the Cell2D
        @overload
        def cell2_d_initialize_neighbour_cell3_ds(                 # overridable (pure virtual)
            self,
            cell2_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell2_d_initialize_neighbour_cell3_ds(                 # overridable (pure virtual)
            self,
            cell2_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell2_d_insert_neighbour_cell3_d(                      # overridable (pure virtual)
            self,
            cell2_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            """/ \brief Insert the Cell2D Cell3D neighbour
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell2D from 0 to
            / Cell2DNumberNeighbourCell3D(cell2DIndex) \param neigbourCell3DIndex the Cell3D neighbour index from 0 to
            / Cell3DTotalNumber() \note Cell2DInitializeNeighbourCell3Ds() shall be called before
            """
            pass
        def cell2_d_number_neighbour_cell3_d(                      # overridable (pure virtual)
            self,
            cell2_d_index: int
            ) -> int:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the number of Neighbour Cell3Ds of Cell2D
            """
            pass
        #/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
        #/ \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell2DNumberNeighbourCell3D(cell2DIndex)
        #/ \return the Cell3D index of Neighbour Cell3Ds of Cell2D from 0 to Cell3DTotalNumber()
        def cell2_d_neighbour_cell3_d(                             # overridable (pure virtual)
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> int:
            pass
        def cell2_d_neighbour_cell3_ds(                            # overridable (pure virtual)
            self,
            cell2_d_index: int
            ) -> List[int]:
            pass
        def cell2_d_has_neighbour_cell3_d(                         # overridable (pure virtual)
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> bool:
            """/ \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \param neighbourIndex the number of neigbourh Cell3D from 0 to Cell2DNumberNeighbourCell3D(cell2DIndex)
            / \return True if Neighbour Cell3Ds of Cell2D at position neighbourIndex exists
            """
            pass
        def cell2_d_reset_neighbour_cell3_d(                       # overridable (pure virtual)
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> None:
            """/ \brief Reset the Cell2D Cell3D neighbour to empty value (Cell2DHasNeighbourCell3D is False)
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param neighbourIndex the number of Cell3D neighbour of the Cell2D from 0 to
            / Cell2DNumberNeighbourCell3D(cell2DIndex)
            """
            pass

        def cell2_d_initialize_double_properties(                  # overridable (pure virtual)
            self,
            number_double_properties: int
            ) -> None:
            """/ \brief Initialize the Cell2Ds double properties
            / \param numberDoubleProperties the total number of Cell2Ds properties
            / \note No reset of Cell2Ds is performed
            """
            pass
        def cell2_d_add_double_property(                           # overridable (pure virtual)
            self,
            property_id: str
            ) -> int:
            """/ \brief Add the Cell2Ds double property identified by id
            / \param propertyId the id of Cell2Ds property
            / \return the double property position
            """
            pass
        def cell2_ds_initialize_double_property_values(            # overridable (pure virtual)
            self,
            property_index: int,
            porperty_sizes: List[int]
            ) -> None:
            """/ \brief Initialize the Cell2Ds double property sizes
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            / \param porpertySize the double property size of each Cell2D, size 1 x Cell2DTotalNumber()
            """
            pass
        def cell2_d_initialize_double_property_values(             # overridable (pure virtual)
            self,
            cell2_d_index: int,
            property_index: int,
            porperty_size: int
            ) -> None:
            """/ \brief Initialize the Cell2Ds double property size
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            / \param porpertySize the double property size of Cell2D
            """
            pass
        def cell2_d_insert_double_property_value(                  # overridable (pure virtual)
            self,
            cell2_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            """/ \brief Insert the Cell2Ds double property value at position
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            """
            pass

        def cell2_d_number_double_properties(self) -> int:         # overridable (pure virtual)
            """/ \return the total number of double properties of Cell2Ds"""
            pass
        def cell2_d_double_property_id(                            # overridable (pure virtual)
            self,
            property_index: int
            ) -> str:
            """/ \return the id of the double property of Cell2Ds
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            """
            pass
        def cell2_d_double_property_exists(                        # overridable (pure virtual)
            self,
            property_id: str
            ) -> bool:
            """/ \return True if the double propertyId of Cell2Ds exists
            / \param propertyId the id of Cell2D double property
            """
            pass
        def cell2_d_double_property_index(                         # overridable (pure virtual)
            self,
            property_id: str
            ) -> int:
            """/ \return the propertyIndex of the double property of Cell2Ds from 0 to Cell2DNumberProperties()
            / \param propertyId the id of Cell2D double property
            """
            pass
        def cell2_d_double_property_size(                          # overridable (pure virtual)
            self,
            cell2_d_index: int,
            property_index: int
            ) -> int:
            """/ \return the size of the double property of Cell2D
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            """
            pass
        def cell2_d_double_property_value(                         # overridable (pure virtual)
            self,
            cell2_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            """/ \return the value of the double property at valueIndex of Cell2D
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param propertyIndex the index of Cell2D double property from 0 to Cell2DNumberProperties()
            / \param propertyValueIndex the index of Cell2D double property value from 0 to Cell2DDoublePropertySize()
            """
            pass

        def cell2_ds_initialize_sub_division(                      # overridable (pure virtual)
            self,
            number_sub_divisions: List[int]
            ) -> None:
            """/ \brief Initialize the Cell2D subdivision number for each Cell2D
            / \param numberSubDivisions the number of sub-polygons for each Cell2D, size 1 x Cell2DTotalNumber()
            / \note each subdivision is a triangle, thus numberSubDivision shall be a multiple of 3
            """
            pass
        def cell2_d_initialize_sub_division(                       # overridable (pure virtual)
            self,
            cell2_d_index: int,
            number_sub_division: int
            ) -> None:
            """/ \brief Initialize the Cell2D subdivision number
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param numberSubDivision the number of sub-polygons of the Cell2D
            / \note each subdivision is a triangle, thus numberSubDivision shall be a multiple of 3
            """
            pass
        def cell2_d_insert_sub_division(                           # overridable (pure virtual)
            self,
            cell2_d_index: int,
            sub_division_index: int,
            cell2_d_vertex_index: int
            ) -> None:
            """/ \brief Insert the subDivision vertex index
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param subDivisionIndex the subDivision index, from 0 to Cell2DNumberSubDivision(cell2DIndex)
            / \param cell2DVertexIndex the Cell2D vertex index of the subDivision, from 0 to Cell0DTotalNumber()
            / \note each subdivision is a triangle
            """
            pass

        def cell2_d_number_sub_division(                           # overridable (pure virtual)
            self,
            cell2_d_index: int
            ) -> int:
            """/ \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \return the total number of vertices of sub-polygons contained in the subdivision, a multiple of 3
            / \note each subdivision is a triangle
            """
            pass

        def cell2_d_sub_division_cell0_d(                          # overridable (pure virtual)
            self,
            cell2_d_index: int,
            sub_division_index: int
            ) -> int:
            """/ \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param subDivisionIndex the subDivision index, from 0 to Cell2DNumberSubDivision(cell2DIndex)
            / \return the Cell0D index of sub-polygons contained in the subdivision, from 0 to Cell0DTotalNumber()
            / \note each sub-division shall be a triangle
            """
            pass

        def cell3_ds_initialize(                                   # overridable (pure virtual)
            self,
            number_cell3_ds: int
            ) -> None:
            """/ \brief Initialize the Cell3Ds container
            / \param numberCell3Ds the total number of Cell3Ds
            / \note No reset of Cell3Ds is performed
            """
            pass
        def cell3_d_append(self, number_cell3_ds: int) -> int:     # overridable (pure virtual)
            """/ \brief Append Cell3Ds to the Cell3Ds container
            / \param numberCell3Ds the number of Cell3Ds to append
            / \return the previous number of Cell3Ds before the append operation
            """
            pass
        def cell3_d_remove(self, cell3_d_index: int) -> None:      # overridable (pure virtual)
            """/ \brief Remove the Cell3D from the mesh
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \note the cell3D is removed and no integrity check in the mesh are performed
            """
            pass
        def cell3_ds_initialize_vertices(                          # overridable (pure virtual)
            self,
            number_cell3_ds_vertices: List[int]
            ) -> None:
            """/ \brief Initialize the Cell3Ds vertices number
            / \param numberCell3DsVertices the number of vertices of each Cell3D
            """
            pass
        def cell3_d_initialize_vertices(                           # overridable (pure virtual)
            self,
            cell3_d_index: int,
            number_cell3_d_vertices: int
            ) -> None:
            """/ \brief Initialize the Cell3D vertices  number
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param numberCell3DVertices the number of vertices of Cell3D
            """
            pass
        def cell3_ds_initialize_edges(                             # overridable (pure virtual)
            self,
            number_cell3_ds_edges: List[int]
            ) -> None:
            """/ \brief Initialize the Cell3Ds edges number
            / \param numberCell3DsEdges the number of edges of each Cell3D
            """
            pass
        def cell3_d_initialize_edges(                              # overridable (pure virtual)
            self,
            cell3_d_index: int,
            number_cell3_d_edges: int
            ) -> None:
            """/ \brief Initialize the Cell3D edges number
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param numberCell3DEdges the number of edges of Cell3D
            """
            pass
        def cell3_ds_initialize_faces(                             # overridable (pure virtual)
            self,
            number_cell3_ds_faces: List[int]
            ) -> None:
            """/ \brief Initialize the Cell3Ds faces number
            / \param numberCell3DsFaces the number of faces of each Cell3D
            """
            pass
        def cell3_d_initialize_faces(                              # overridable (pure virtual)
            self,
            cell3_d_index: int,
            number_cell3_d_faces: int
            ) -> None:
            """/ \brief Initialize the Cell3D faces number
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param numberCell3DFaces the number of faces of Cell3D
            """
            pass
        def cell3_d_insert_vertex(                                 # overridable (pure virtual)
            self,
            cell3_d_index: int,
            vertex_index: int,
            vertex_cell0_d_index: int
            ) -> None:
            """/ \brief Insert the Cell3D vertex
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param vertexIndex the number of vertex of the Cell3D from 0 to Cell3DNumberVertices(cell3DIndex)
            / \param vertexCell0DIndex the Cell0D vertex index from 0 to Cell0DTotalNumber()
            / \note Cell3DInitializeVertices() should be called before using this method
            """
            pass
        def cell3_d_add_vertices(                                  # overridable (pure virtual)
            self,
            cell3_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell3D vertices
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param vertexCell0DIndices the Cell0D vertices indices from 0 to Cell0DTotalNumber()
            / \note No itialization is necessary
            """
            pass
        def cell3_d_insert_edge(                                   # overridable (pure virtual)
            self,
            cell3_d_index: int,
            edge_index: int,
            edge_cell1_d_index: int
            ) -> None:
            """/ \brief Insert the Cell3D edge
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param edgeIndex the number of edge of the Cell3D from 0 to Cell3DNumberEdges(cell3DIndex)
            / \param edgeCell0DIndex the Cell1D edge index from 0 to Cell1DTotalNumber()
            / \note Cell3DInitializeEdges() should be called before using this method
            """
            pass
        def cell3_d_add_edges(                                     # overridable (pure virtual)
            self,
            cell3_d_index: int,
            edges_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell3D edges
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param edgesCell0DIndices the Cell1D edges indices from 0 to Cell1DTotalNumber()
            / \note No itialization is necessary
            """
            pass
        def cell3_d_find_vertex(                                   # overridable (pure virtual)
            self,
            cell3_d_index: int,
            cell0_d_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param cell0DIndex the index of cell0D from 0 to Cell0DTotalNumber()
            / \return the index of the cell0DIndex on the cell3D from 0 to NumberCell3DVertices(cell3DIndex),
            / NumberCell3DVertices(cell3DIndex) if not found
            """
            pass
        def cell3_d_find_edge(                                     # overridable (pure virtual)
            self,
            cell3_d_index: int,
            cell1_d_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param cell1DIndex the index of cell1D from 0 to Cell1DTotalNumber()
            / \return the index of the cell1DIndex on the cell3D from 0 to NumberCell3DEdges(cell3DIndex),
            / NumberCell3DEdges(cell3DIndex) if not found
            """
            pass
        def cell3_d_find_face(                                     # overridable (pure virtual)
            self,
            cell3_d_index: int,
            cell2_d_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param cell2DIndex the index of cell2D from 0 to Cell2DTotalNumber()
            / \return the index of the cell2DIndex on the cell3D from 0 to NumberCell3DFaces(cell3DIndex),
            / NumberCell3DFaces(cell3DIndex) if not found
            """
            pass

        def cell3_d_find_edge_by_extremes(                         # overridable (pure virtual)
            self,
            cell3_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param originCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \param endCell0DIndex the Cell0D Id of origin from 0 to Cell0DTotalNumber()
            / \return the index of the cell1DIndex on the cell2D from 0 to NumberCell2DEdges(cell3DIndex),
            / NumberCell2DEdges(cell2DIndex) otherwise
            """
            pass
        def cell3_d_insert_face(                                   # overridable (pure virtual)
            self,
            cell3_d_index: int,
            face_index: int,
            face_cell2_d_index: int
            ) -> None:
            """/ \brief Insert the Cell3D face
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param faceIndex the number of face of the Cell3D from 0 to Cell3DNumberFaces(cell3DIndex)
            / \param faceCell0DIndex the Cell2D face index from 0 to Cell2DTotalNumber()
            / \note Cell3DInitializeFaces() should be called before using this method
            """
            pass
        def cell3_d_add_faces(                                     # overridable (pure virtual)
            self,
            cell3_d_index: int,
            faces_cell0_d_indices: List[int]
            ) -> None:
            """/ \brief Add the Cell3D faces
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param facesCell0DIndices the Cell2D faces indices from 0 to Cell2DTotalNumber()
            / \note No itialization is necessary
            """
            pass
        def cell3_d_set_marker(                                    # overridable (pure virtual)
            self,
            cell3_d_index: int,
            marker: int
            ) -> None:
            """/ \brief Set the Cell1D Marker
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param marker the marker of the Cell3D
            """
            pass
        def cell3_d_set_state(                                     # overridable (pure virtual)
            self,
            cell3_d_index: int,
            state: bool
            ) -> None:
            """/ \brief Set the Cell3D state
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param state True if Cell3D is active, False otherwise
            """
            pass
        def cell3_d_total_number(self) -> int:                     # overridable (pure virtual)
            """/ \return the total number of Cell3Ds"""
            pass
        def cell3_d_number_vertices(                               # overridable (pure virtual)
            self,
            cell3_d_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the number of vertices of Cell3D
            """
            pass
        def cell3_d_number_edges(self, cell3_d_index: int) -> int: # overridable (pure virtual)
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the number of edges of Cell3D
            """
            pass
        def cell3_d_number_faces(self, cell3_d_index: int) -> int: # overridable (pure virtual)
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the number of faces of Cell3D
            """
            pass
        def cell3_d_vertices(                                      # overridable (pure virtual)
            self,
            cell3_d_index: int
            ) -> List[int]:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the Cell0D index collections of Cell3D from 0 to Cell0DTotalNumber(), size
            / Cell3DNumberVertices(cell3DIndex)
            """
            pass
        def cell3_d_vertex(                                        # overridable (pure virtual)
            self,
            cell3_d_index: int,
            vertex_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param vertexIndex the index of cell0D vertex from 0 to NumberCell3DVertices(cell3DIndex)
            / \return the Cell0D index of vertex of Cell3D from 0 to Cell0DTotalNumber()
            """
            pass
        def cell3_d_vertex_coordinates(                            # overridable (pure virtual)
            self,
            cell3_d_index: int,
            vertex_index: int
            ) -> Eigen.Vector3d:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param vertexIndex the index of cell0D vertex from 0 to NumberCell3DVertices(cell3DIndex)
            / \return the Cell0D coordinates of vertex of Cell3D, size 3 x 1
            """
            pass
        def cell3_d_vertices_coordinates(                          # overridable (pure virtual)
            self,
            cell3_d_index: int
            ) -> Eigen.MatrixXd:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the Cell0D coordinates of all the vertices of Cell3D, size 3 x NumberCell3DVertices(cell3DIndex)
            """
            pass

        def cell3_d_edges(self, cell3_d_index: int) -> List[int]:  # overridable (pure virtual)
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the Cell1D index collections of Cell3D from 0 to Cell1DTotalNumber(), size
            / Cell3DNumberEdges(cell3DIndex)
            """
            pass

        def cell3_d_edge(                                          # overridable (pure virtual)
            self,
            cell3_d_index: int,
            edge_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param edgeIndex the index of cell1D edge from 0 to NumberCell3DEdges(edgeIndex)
            / \return the Cell1D index of edge of Cell3D from 0 to Cell1DTotalNumber()
            """
            pass

        def cell3_d_faces(self, cell3_d_index: int) -> List[int]:  # overridable (pure virtual)
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the Cell2D index collections of Cell3D from 0 to Cell2DTotalNumber(), size
            / Cell3DNumberFaces(cell3DIndex)
            """
            pass

        def cell3_ds_faces_vertices(                               # overridable (pure virtual)
            self
            ) -> List[List[List[int]]]:
            """/ \return the Cell0D index collections of all the faces of all Cell3Ds, size Cell3DTotalNumber() x
            / Cell3DNumberFaces(cell3DIndex) x Cell2DNumberVertices(cell2DIndex)
            """
            pass
        def cell3_ds_vertices(self) -> List[List[int]]:            # overridable (pure virtual)
            """/ \return the Cell0D index collections of all Cell3Ds, size Cell3DTotalNumber() x
            / Cell3DNumberVertices(cell3DIndex)
            """
            pass
        def cell3_ds_edges(self) -> List[List[int]]:               # overridable (pure virtual)
            """/ \return the Cell1D index collections of all Cell3Ds, size Cell3DTotalNumber() x Cell3DNumberEdges(cell3DIndex)"""
            pass
        def cell3_ds_faces(self) -> List[List[int]]:               # overridable (pure virtual)
            """/ \return the Cell2D index collections of all Cell3Ds, size Cell3DTotalNumber() x Cell3DNumberFaces(cell3DIndex)"""
            pass

        def cell3_d_face(                                          # overridable (pure virtual)
            self,
            cell3_d_index: int,
            face_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param faceIndex the index of cell2D face from 0 to NumberCell3DFaces(cell3DIndex)
            / \return the Cell2D index of face of Cell3D from 0 to Cell2DTotalNumber()
            """
            pass
        #/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
        #/ \return the cell3D marker
        def cell3_d_marker(self, cell3_d_index: int) -> int:       # overridable (pure virtual)
            pass
        def cell3_ds_marker(self) -> List[int]:                    # overridable (pure virtual)
            pass
        def cell3_d_is_active(self, cell3_d_index: int) -> bool:   # overridable (pure virtual)
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return if the cell3D is active
            """
            pass
        def cell3_ds_state(self) -> List[bool]:                    # overridable (pure virtual)
            """/ \return the activation state of all cell3Ds"""
            pass

        def cell3_d_has_original_cell3_d(                          # overridable (pure virtual)
            self,
            updated_cell3_d_index: int
            ) -> bool:
            """/ \param updatedCell3DIndex the updated cell3D index, from 0 to Cell3DTotalNumber()
            / \return True if has an original cell, False otherwise (the original cell is itself)
            """
            pass
        def cell3_d_original_cell3_d(                              # overridable (pure virtual)
            self,
            updated_cell3_d_index: int
            ) -> int:
            """/ \param updatedCell3DIndex the updated cell3D index, from 0 to Cell3DTotalNumber()
            / \return the original cell3D index, from 0 to Cell3DTotalNumber()
            """
            pass
        def cell3_d_has_updated_cell3_ds(                          # overridable (pure virtual)
            self,
            cell3_d_index: int
            ) -> bool:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return if the cell3D has new cell3Ds associated
            """
            pass
        def cell3_d_number_updated_cell3_ds(                       # overridable (pure virtual)
            self,
            cell3_d_index: int
            ) -> int:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \return the number of new cell3Ds associated to cell3DIndex
            """
            pass
        def cell3_d_has_updated_cell3_d(                           # overridable (pure virtual)
            self,
            cell3_d_index: int,
            updated_cell3_d_idex: int
            ) -> bool:
            """/ \param cell3DIndex the index of cell3D from 0 to Cell3DTotalNumber()
            / \param updatedCell3DIdex the index of the new Cell3D from 0 to Cell3DTotalNumber()
            / \return if the Cell3D has the updatedCell3DIdex associated
            """
            pass
        def cell3_d_insert_updated_cell3_d(                        # overridable (pure virtual)
            self,
            cell3_d_index: int,
            updated_cell3_d_idex: int
            ) -> None:
            """/ \brief Add the new Cell3D to an existing Cell3D
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param updatedCell3DIdex the index of the new Cell3D from 0 to Cell3DTotalNumber()
            """
            pass
        def cell3_d_updated_cell3_ds(                              # overridable (pure virtual)
            self,
            cell3_d_index: int,
            updated_cell3_d_ids: std.list[int]
            ) -> bool:
            """/ \brief return the updated Cell3D Ids for cell3DIndex
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param updatedCell3DIds the list of the new Cell3D Ids associated to cell3DIndex
            / \return True if the cell3DIndex is contained in the updatedCell3DIds list, False otherwise
            """
            pass

        def cell3_d_initialize_double_properties(                  # overridable (pure virtual)
            self,
            number_double_properties: int
            ) -> None:
            """/ \brief Initialize the Cell3Ds double properties
            / \param numberDoubleProperties the total number of Cell3Ds properties
            / \note No reset of Cell3Ds is performed
            """
            pass
        def cell3_d_add_double_property(                           # overridable (pure virtual)
            self,
            property_id: str
            ) -> int:
            """/ \brief Add the Cell3Ds double property identified by id
            / \param propertyId the id of Cell3Ds property
            / \return the double property position
            """
            pass
        def cell3_ds_initialize_double_property_values(            # overridable (pure virtual)
            self,
            property_index: int,
            porperty_sizes: List[int]
            ) -> None:
            """/ \brief Initialize the Cell3Ds double property sizes
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            / \param porpertySize the double property size of each Cell3D, size 1 x Cell3DTotalNumber()
            """
            pass
        def cell3_d_initialize_double_property_values(             # overridable (pure virtual)
            self,
            cell3_d_index: int,
            property_index: int,
            porperty_size: int
            ) -> None:
            """/ \brief Initialize the Cell3Ds double property size
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            / \param porpertySize the double property size of Cell3D
            """
            pass
        def cell3_d_insert_double_property_value(                  # overridable (pure virtual)
            self,
            cell3_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            """/ \brief Insert the Cell3Ds double property value at position
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            """
            pass

        def cell3_d_number_double_properties(self) -> int:         # overridable (pure virtual)
            """/ \return the total number of double properties of Cell3Ds"""
            pass
        def cell3_d_double_property_id(                            # overridable (pure virtual)
            self,
            property_index: int
            ) -> str:
            """/ \return the id of the double property of Cell3Ds
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            """
            pass
        def cell3_d_double_property_exists(                        # overridable (pure virtual)
            self,
            property_id: str
            ) -> bool:
            """/ \return True if the double propertyId of Cell3Ds exists
            / \param propertyId the id of Cell3D double property
            """
            pass
        def cell3_d_double_property_index(                         # overridable (pure virtual)
            self,
            property_id: str
            ) -> int:
            """/ \return the propertyIndex of the double property of Cell3Ds from 0 to Cell3DNumberProperties()
            / \param propertyId the id of Cell3D double property
            """
            pass
        def cell3_d_double_property_size(                          # overridable (pure virtual)
            self,
            cell3_d_index: int,
            property_index: int
            ) -> int:
            """/ \return the size of the double property of Cell3D
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            """
            pass
        def cell3_d_double_property_value(                         # overridable (pure virtual)
            self,
            cell3_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            """/ \return the value of the double property at valueIndex of Cell3D
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param propertyIndex the index of Cell3D double property from 0 to Cell3DNumberProperties()
            / \param propertyValueIndex the index of Cell3D double property value from 0 to Cell3DDoublePropertySize()
            """
            pass

        def compress(self) -> None:                                # overridable (pure virtual)
            """/ \brief Compact the mesh to save memory"""
            pass

        def to_string(self) -> str:                                # overridable (pure virtual)
            """/ \return The mesh converted to string"""
            pass
        def __init__(self) -> None:
            """Autogenerated default constructor"""
            pass
    class MeshMatricesDAO(Gedim.IMeshDAO):
        def __init__(self, mesh: MeshMatrices) -> None:
            pass

        @overload
        def mesh_data(self) -> MeshMatrices:
            pass
        @overload
        def mesh_data(self) -> MeshMatrices:
            pass

        def initialize_dimension(self, dimension: int) -> None:
            pass
        def dimension(self) -> int:
            pass

        def cell0_ds_initialize(self, number_cell0_ds: int) -> None:
            pass
        def cell0_d_append(self, number_cell0_ds: int) -> int:
            pass
        def cell0_d_remove(self, cell0_d_index: int) -> None:
            pass

        def cell0_d_insert_coordinates(
            self,
            cell0_d_index: int,
            coordinates: Eigen.Vector3d
            ) -> None:
            pass
        def cell0_ds_insert_coordinates(self, coordinates: Eigen.MatrixXd) -> None:
            pass
        def cell0_d_set_marker(self, cell0_d_index: int, marker: int) -> None:
            pass
        def cell0_d_set_state(self, cell0_d_index: int, state: bool) -> None:
            pass

        def cell0_d_total_number(self) -> int:
            pass
        def cell0_d_coordinate_x(self, cell0_d_index: int) -> float:
            pass
        def cell0_d_coordinate_y(self, cell0_d_index: int) -> float:
            pass
        def cell0_d_coordinate_z(self, cell0_d_index: int) -> float:
            pass
        def cell0_d_coordinates(self, cell0_d_index: int) -> Eigen.Vector3d:
            pass
        @overload
        def cell0_ds_coordinates(self) -> Eigen.MatrixXd:
            pass
        @overload
        def cell0_ds_coordinates(self, cell0_ds: List[int]) -> Eigen.MatrixXd:
            pass
        def cell0_d_marker(self, cell0_d_index: int) -> int:
            pass
        def cell0_ds_marker(self) -> List[int]:
            pass
        def cell0_d_is_active(self, cell0_d_index: int) -> bool:
            pass
        def cell0_ds_state(self) -> List[bool]:
            pass

        def cell0_d_has_updated_cell0_ds(self, cell0_d_index: int) -> bool:
            pass
        def cell0_d_number_updated_cell0_ds(self, cell0_d_index: int) -> int:
            pass
        def cell0_d_has_updated_cell0_d(
            self,
            cell0_d_index: int,
            updated_cell0_d_idex: int
            ) -> bool:
            pass
        def cell0_d_insert_updated_cell0_d(
            self,
            cell0_d_index: int,
            updated_cell0_d_idex: int
            ) -> None:
            pass
        def cell0_d_updated_cell0_ds(
            self,
            cell0_d_index: int,
            updated_cell0_d_ids: std.list[int]
            ) -> bool:
            pass

        def cell0_ds_neighbour_cell1_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell1_ds(
            self,
            number_neighbour_cell1_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell1_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell1_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell1_ds(
            self,
            cell0_d_index: int,
            neighbour_cell1_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell1_d_index: int
            ) -> None:
            pass
        def cell0_d_number_neighbour_cell1_d(self, cell0_d_index: int) -> int:
            pass
        def cell0_d_neighbour_cell1_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            pass
        def cell0_d_neighbour_cell1_ds(self, cell0_d_index: int) -> List[int]:
            pass
        def cell0_d_has_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell0_d_reset_neighbour_cell1_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            pass

        def cell0_ds_neighbour_cell2_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell2_ds(
            self,
            number_neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell2_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell2_ds(
            self,
            cell0_d_index: int,
            neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell2_d_index: int
            ) -> None:
            pass
        def cell0_d_number_neighbour_cell2_d(self, cell0_d_index: int) -> int:
            pass
        def cell0_d_neighbour_cell2_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            pass
        def cell0_d_neighbour_cell2_ds(self, cell0_d_index: int) -> List[int]:
            pass
        def cell0_d_has_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell0_d_reset_neighbour_cell2_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            pass
        def cell0_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell0_ds_initialize_neighbour_cell3_ds(
            self,
            number_neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell3_ds(
            self,
            cell0_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell0_d_initialize_neighbour_cell3_ds(
            self,
            cell0_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell0_d_insert_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            pass
        def cell0_d_number_neighbour_cell3_d(self, cell0_d_index: int) -> int:
            pass
        def cell0_d_neighbour_cell3_d(self, cell0_d_index: int, neighbour_index: int) -> int:
            pass
        def cell0_d_neighbour_cell3_ds(self, cell0_d_index: int) -> List[int]:
            pass
        def cell0_d_has_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell0_d_reset_neighbour_cell3_d(
            self,
            cell0_d_index: int,
            neighbour_index: int
            ) -> None:
            pass

        def cell0_d_initialize_double_properties(self, number_double_properties: int) -> None:
            pass
        def cell0_d_add_double_property(self, property_id: str) -> int:
            pass
        def cell0_ds_initialize_double_property_values(
            self,
            property_index: int,
            property_sizes: List[int]
            ) -> None:
            pass
        def cell0_d_initialize_double_property_values(
            self,
            cell0_d_index: int,
            property_index: int,
            property_size: int
            ) -> None:
            pass
        def cell0_d_insert_double_property_value(
            self,
            cell0_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            pass
        def cell0_d_number_double_properties(self) -> int:
            pass
        def cell0_d_double_property_id(self, property_index: int) -> str:
            pass
        def cell0_d_double_property_exists(self, property_id: str) -> bool:
            pass
        def cell0_d_double_property_index(self, property_id: str) -> int:
            pass
        def cell0_d_double_property_size(self, cell0_d_index: int, property_index: int) -> int:
            pass
        def cell0_d_double_property_value(
            self,
            cell0_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            pass

        def cell1_ds_initialize(self, number_cell1_ds: int) -> None:
            pass
        def cell1_d_append(self, number_cell1_ds: int) -> int:
            pass
        def cell1_d_remove(self, cell1_d_index: int) -> None:
            pass
        def cell1_d_insert_extremes(
            self,
            cell1_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> None:
            pass

        def cell1_ds_insert_extremes(self, cell1_d_extremes: Eigen.MatrixXi) -> None:
            pass

        @overload
        def cell1_ds_extremes(self) -> Eigen.MatrixXi:
            pass
        @overload
        def cell1_ds_extremes(self, cell1_ds: List[int]) -> Eigen.MatrixXi:
            pass
        def cell1_d_extremes(self, cell1_d_index: int) -> Eigen.VectorXi:
            """/ \return the extrems as Eigen MatrixXi of cell1D, size 2
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            """
            pass

        def cell1_d_by_extremes(
            self,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            pass

        def cell1_d_set_marker(self, cell1_d_index: int, marker: int) -> None:
            pass
        def cell1_d_set_state(self, cell1_d_index: int, state: bool) -> None:
            pass
        def cell1_ds_neighbour_cell2_ds(self) -> List[List[int]]:
            pass
        @overload
        def cell1_ds_initialize_neighbour_cell2_ds(
            self,
            number_neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell1_ds_initialize_neighbour_cell2_ds(
            self,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell2_ds(
            self,
            cell1_d_index: int,
            number_neighbour_cell2_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell2_ds(
            self,
            cell1_d_index: int,
            neighbour_cell2_ds: List[int]
            ) -> None:
            pass
        def cell1_d_insert_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int,
            neigbour_cell2_d_index: int
            ) -> None:
            pass
        def cell1_d_total_number(self) -> int:
            pass
        def cell1_d_vertex(self, cell1_d_index: int, vertex_index: int) -> int:
            pass
        def cell1_d_origin(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_end(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_find_extreme(self, cell1_d_index: int, cell0_d_index: int) -> int:
            pass
        def cell1_d_coordinates(self, cell1_d_index: int) -> Eigen.MatrixXd:
            pass
        def cell1_d_origin_coordinates(self, cell1_d_index: int) -> Eigen.Vector3d:
            pass
        def cell1_d_end_coordinates(self, cell1_d_index: int) -> Eigen.Vector3d:
            pass
        def cell1_d_number_neighbour_cell2_d(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_neighbour_cell2_d(self, cell1_d_index: int, neighbour_index: int) -> int:
            pass
        def cell1_d_neighbour_cell2_ds(self, cell1_d_index: int) -> List[int]:
            pass
        def cell1_d_has_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell1_d_reset_neighbour_cell2_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> None:
            pass

        def cell1_d_marker(self, cell1_d_index: int) -> int:
            pass
        def cell1_ds_marker(self) -> List[int]:
            pass
        def cell1_d_is_active(self, cell1_d_index: int) -> bool:
            pass
        def cell1_ds_state(self) -> List[bool]:
            pass
        def cell1_d_has_original_cell1_d(self, updated_cell1_d_index: int) -> bool:
            pass
        def cell1_d_original_cell1_d(self, updated_cell1_d_index: int) -> int:
            pass
        def cell1_d_has_updated_cell1_ds(self, cell1_d_index: int) -> bool:
            pass
        def cell1_d_number_updated_cell1_ds(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_has_updated_cell1_d(
            self,
            cell1_d_index: int,
            updated_cell1_d_idex: int
            ) -> bool:
            pass
        def cell1_d_insert_updated_cell1_d(
            self,
            cell1_d_index: int,
            updated_cell1_d_idex: int
            ) -> None:
            pass
        def cell1_d_updated_cell1_ds(
            self,
            cell1_d_index: int,
            updated_cell1_d_ids: std.list[int]
            ) -> bool:
            pass
        def cell1_d_initialize_double_properties(self, number_double_properties: int) -> None:
            pass

        def cell1_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell1_ds_initialize_neighbour_cell3_ds(
            self,
            number_neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell3_ds(
            self,
            cell1_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell1_d_initialize_neighbour_cell3_ds(
            self,
            cell1_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell1_d_insert_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            pass
        def cell1_d_number_neighbour_cell3_d(self, cell1_d_index: int) -> int:
            pass
        def cell1_d_neighbour_cell3_d(self, cell1_d_index: int, neighbour_index: int) -> int:
            pass
        def cell1_d_neighbour_cell3_ds(self, cell1_d_index: int) -> List[int]:
            pass
        def cell1_d_has_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell1_d_reset_neighbour_cell3_d(
            self,
            cell1_d_index: int,
            neighbour_index: int
            ) -> None:
            pass

        def cell1_d_add_double_property(self, property_id: str) -> int:
            pass
        def cell1_ds_initialize_double_property_values(
            self,
            property_index: int,
            property_sizes: List[int]
            ) -> None:
            pass
        def cell1_d_initialize_double_property_values(
            self,
            cell1_d_index: int,
            property_index: int,
            property_size: int
            ) -> None:
            pass
        def cell1_d_insert_double_property_value(
            self,
            cell1_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            pass
        def cell1_d_number_double_properties(self) -> int:
            pass
        def cell1_d_double_property_id(self, property_index: int) -> str:
            pass
        def cell1_d_double_property_exists(self, property_id: str) -> bool:
            pass
        def cell1_d_double_property_index(self, property_id: str) -> int:
            pass
        def cell1_d_double_property_size(self, cell1_d_index: int, property_index: int) -> int:
            pass
        def cell1_d_double_property_value(
            self,
            cell1_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            pass

        def cell2_ds_initialize(self, number_cell2_ds: int) -> None:
            pass
        def cell2_d_append(self, number_cell2_ds: int) -> int:
            pass
        def cell2_d_remove(self, cell2_d_index: int) -> None:
            pass
        def cell2_d_set_marker(self, cell2_d_index: int, marker: int) -> None:
            pass
        def cell2_d_set_state(self, cell2_d_index: int, state: bool) -> None:
            pass
        @overload
        def cell2_ds_initialize_vertices(self, number_cell2_d_vertices: int) -> None:
            pass
        @overload
        def cell2_ds_initialize_vertices(self, number_cell2_ds_vertices: List[int]) -> None:
            pass
        def cell2_d_initialize_vertices(
            self,
            cell2_d_index: int,
            number_cell2_d_vertices: int
            ) -> None:
            pass
        @overload
        def cell2_ds_initialize_edges(self, number_cell2_d_edges: int) -> None:
            pass
        @overload
        def cell2_ds_initialize_edges(self, number_cell2_ds_edges: List[int]) -> None:
            pass
        def cell2_d_initialize_edges(
            self,
            cell2_d_index: int,
            number_cell2_d_edges: int
            ) -> None:
            pass
        def cell2_d_insert_vertices(
            self,
            cell2_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            pass
        def cell2_d_insert_vertex(
            self,
            cell2_d_index: int,
            vertex_index: int,
            vertex_cell0_d_index: int
            ) -> None:
            pass
        def cell2_d_insert_edges(
            self,
            cell2_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            pass
        def cell2_d_insert_edge(
            self,
            cell2_d_index: int,
            edge_index: int,
            edge_cell1_d_index: int
            ) -> None:
            pass
        def cell2_d_add_vertices(
            self,
            cell2_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            pass
        def cell2_d_add_edges(
            self,
            cell2_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            pass
        def cell2_d_add_vertices_and_edges(
            self,
            cell2_d_index: int,
            vertices_and_edges_indices: Eigen.MatrixXi
            ) -> None:
            pass

        def cell2_d_total_number(self) -> int:
            pass
        def cell2_d_number_vertices(self, cell2_d_index: int) -> int:
            pass
        def cell2_d_number_edges(self, cell2_d_index: int) -> int:
            pass

        def cell2_d_vertices(self, cell2_d_index: int) -> List[int]:
            pass
        def cell2_ds_vertices(self) -> List[List[int]]:
            pass
        def cell2_ds_extremes(self) -> List[Eigen.MatrixXi]:
            pass

        def cell2_d_vertex(self, cell2_d_index: int, vertex_index: int) -> int:
            pass
        def cell2_d_vertex_coordinates(
            self,
            cell2_d_index: int,
            vertex_index: int
            ) -> Eigen.Vector3d:
            pass
        def cell2_d_vertices_coordinates(self, cell2_d_index: int) -> Eigen.MatrixXd:
            pass
        def cell2_d_find_vertex(self, cell2_d_index: int, cell0_d_index: int) -> int:
            pass

        def cell2_d_edges(self, cell2_d_index: int) -> List[int]:
            pass

        def cell2_d_edge(self, cell2_d_index: int, edge_index: int) -> int:
            pass
        def cell2_d_find_edge(self, cell2_d_index: int, cell1_d_index: int) -> int:
            pass
        def cell2_d_find_edge_by_extremes(
            self,
            cell2_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            pass
        def cell2_d_marker(self, cell2_d_index: int) -> int:
            pass
        def cell2_ds_marker(self) -> List[int]:
            pass
        def cell2_d_is_active(self, cell2_d_index: int) -> bool:
            pass
        def cell2_ds_state(self) -> List[bool]:
            pass

        def cell2_d_has_updated_cell2_ds(self, cell2_d_index: int) -> bool:
            pass
        def cell2_d_number_updated_cell2_ds(self, cell2_d_index: int) -> int:
            pass
        def cell2_d_has_updated_cell2_d(
            self,
            cell2_d_index: int,
            updated_cell2_d_index: int
            ) -> bool:
            pass
        def cell2_d_insert_updated_cell2_d(
            self,
            cell2_d_index: int,
            updated_cell2_d_idex: int
            ) -> None:
            pass
        def cell2_d_has_original_cell2_d(self, updated_cell2_d_index: int) -> bool:
            pass
        def cell2_d_original_cell2_d(self, updated_cell2_d_index: int) -> int:
            pass
        def cell2_d_updated_cell2_ds(
            self,
            cell2_d_index: int,
            updated_cell2_d_ids: std.list[int]
            ) -> bool:
            pass

        def cell2_ds_neighbour_cell3_ds(self) -> List[List[int]]:
            pass
        def cell2_ds_initialize_neighbour_cell3_ds(
            self,
            number_neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        @overload
        def cell2_d_initialize_neighbour_cell3_ds(
            self,
            cell2_d_index: int,
            number_neighbour_cell3_ds: int
            ) -> None:
            pass
        @overload
        def cell2_d_initialize_neighbour_cell3_ds(
            self,
            cell2_d_index: int,
            neighbour_cell3_ds: List[int]
            ) -> None:
            pass
        def cell2_d_insert_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int,
            neigbour_cell3_d_index: int
            ) -> None:
            pass
        def cell2_d_number_neighbour_cell3_d(self, cell2_d_index: int) -> int:
            pass
        def cell2_d_neighbour_cell3_d(self, cell2_d_index: int, neighbour_index: int) -> int:
            pass
        def cell2_d_neighbour_cell3_ds(self, cell2_d_index: int) -> List[int]:
            pass
        def cell2_d_has_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> bool:
            pass
        def cell2_d_reset_neighbour_cell3_d(
            self,
            cell2_d_index: int,
            neighbour_index: int
            ) -> None:
            pass
        def cell2_d_initialize_double_properties(self, number_double_properties: int) -> None:
            pass
        def cell2_d_add_double_property(self, property_id: str) -> int:
            pass
        def cell2_ds_initialize_double_property_values(
            self,
            property_index: int,
            property_sizes: List[int]
            ) -> None:
            pass
        def cell2_d_initialize_double_property_values(
            self,
            cell2_d_index: int,
            property_index: int,
            property_size: int
            ) -> None:
            pass
        def cell2_d_insert_double_property_value(
            self,
            cell2_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            pass
        def cell2_d_number_double_properties(self) -> int:
            pass
        def cell2_d_double_property_id(self, property_index: int) -> str:
            pass
        def cell2_d_double_property_exists(self, property_id: str) -> bool:
            pass
        def cell2_d_double_property_index(self, property_id: str) -> int:
            pass
        def cell2_d_double_property_size(self, cell2_d_index: int, property_index: int) -> int:
            pass
        def cell2_d_double_property_value(
            self,
            cell2_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            pass

        def cell2_ds_initialize_sub_division(self, number_sub_divisions: List[int]) -> None:
            pass

        def cell2_d_initialize_sub_division(
            self,
            cell2_d_index: int,
            number_sub_division: int
            ) -> None:
            pass
        def cell2_d_insert_sub_division(
            self,
            cell2_d_index: int,
            sub_division_index: int,
            cell0_d_index: int
            ) -> None:
            pass
        def cell2_d_number_sub_division(self, cell2_d_index: int) -> int:
            pass
        def cell2_d_sub_division_cell0_d(
            self,
            cell2_d_index: int,
            sub_division_index: int
            ) -> int:
            pass

        def cell3_ds_initialize(self, number_cell3_ds: int) -> None:
            pass
        def cell3_d_append(self, number_cell3_ds: int) -> int:
            pass
        def cell3_d_remove(self, cell3_d_index: int) -> None:
            pass
        def cell3_d_set_marker(self, cell3_d_index: int, marker: int) -> None:
            pass
        def cell3_d_set_state(self, cell3_d_index: int, state: bool) -> None:
            pass
        def cell3_ds_initialize_vertices(self, number_cell3_ds_vertices: List[int]) -> None:
            pass
        def cell3_ds_initialize_edges(self, number_cell3_ds_edges: List[int]) -> None:
            pass
        def cell3_ds_initialize_faces(self, number_cell3_ds_faces: List[int]) -> None:
            pass
        def cell3_d_initialize_vertices(
            self,
            cell3_d_index: int,
            number_cell3_d_vertices: int
            ) -> None:
            pass
        def cell3_d_initialize_edges(
            self,
            cell3_d_index: int,
            number_cell3_d_edges: int
            ) -> None:
            pass
        def cell3_d_initialize_faces(
            self,
            cell3_d_index: int,
            number_cell3_d_faces: int
            ) -> None:
            pass
        def cell3_d_insert_vertex(
            self,
            cell3_d_index: int,
            vertex_index: int,
            vertex_cell0_d_index: int
            ) -> None:
            pass
        def cell3_d_insert_edge(
            self,
            cell3_d_index: int,
            edge_index: int,
            edge_cell1_d_index: int
            ) -> None:
            pass
        def cell3_d_insert_face(
            self,
            cell3_d_index: int,
            face_index: int,
            face_cell2_d_index: int
            ) -> None:
            pass
        def cell3_d_add_vertices(
            self,
            cell3_d_index: int,
            vertices_cell0_d_indices: List[int]
            ) -> None:
            pass
        def cell3_d_add_edges(
            self,
            cell3_d_index: int,
            edges_cell1_d_indices: List[int]
            ) -> None:
            pass
        def cell3_d_add_faces(
            self,
            cell3_d_index: int,
            faces_cell2_d_indices: List[int]
            ) -> None:
            pass

        def cell3_d_find_vertex(self, cell3_d_index: int, cell0_d_index: int) -> int:
            pass
        def cell3_d_find_edge(self, cell3_d_index: int, cell1_d_index: int) -> int:
            pass
        def cell3_d_find_face(self, cell3_d_index: int, cell2_d_index: int) -> int:
            pass

        def cell3_d_find_edge_by_extremes(
            self,
            cell3_d_index: int,
            origin_cell0_d_index: int,
            end_cell0_d_index: int
            ) -> int:
            pass

        def cell3_d_total_number(self) -> int:
            pass
        def cell3_d_number_vertices(self, cell3_d_index: int) -> int:
            pass
        def cell3_d_number_edges(self, cell3_d_index: int) -> int:
            pass
        def cell3_d_number_faces(self, cell3_d_index: int) -> int:
            pass
        def cell3_d_vertices(self, cell3_d_index: int) -> List[int]:
            pass
        def cell3_d_vertex(self, cell3_d_index: int, vertex_index: int) -> int:
            pass
        def cell3_d_vertex_coordinates(
            self,
            cell3_d_index: int,
            vertex_index: int
            ) -> Eigen.Vector3d:
            pass
        def cell3_d_vertices_coordinates(self, cell3_d_index: int) -> Eigen.MatrixXd:
            pass
        def cell3_d_edges(self, cell3_d_index: int) -> List[int]:
            pass
        def cell3_d_edge(self, cell3_d_index: int, edge_index: int) -> int:
            pass
        def cell3_d_faces(self, cell3_d_index: int) -> List[int]:
            pass
        def cell3_d_face(self, cell3_d_index: int, face_index: int) -> int:
            pass
        def cell3_ds_faces_vertices(self) -> List[List[List[int]]]:
            pass
        def cell3_ds_vertices(self) -> List[List[int]]:
            pass
        def cell3_ds_edges(self) -> List[List[int]]:
            pass
        def cell3_ds_faces(self) -> List[List[int]]:
            pass
        def cell3_d_marker(self, cell3_d_index: int) -> int:
            pass
        def cell3_ds_marker(self) -> List[int]:
            pass
        def cell3_d_is_active(self, cell3_d_index: int) -> bool:
            pass
        def cell3_ds_state(self) -> List[bool]:
            pass

        def cell3_d_has_updated_cell3_ds(self, cell3_d_index: int) -> bool:
            pass
        def cell3_d_number_updated_cell3_ds(self, cell3_d_index: int) -> int:
            pass
        def cell3_d_has_updated_cell3_d(
            self,
            cell3_d_index: int,
            updated_cell3_d_idex: int
            ) -> bool:
            pass
        def cell3_d_insert_updated_cell3_d(
            self,
            cell3_d_index: int,
            updated_cell3_d_idex: int
            ) -> None:
            pass
        def cell3_d_updated_cell3_ds(
            self,
            cell3_d_index: int,
            updated_cell3_d_ids: std.list[int]
            ) -> bool:
            pass
        def cell3_d_has_original_cell3_d(self, updated_cell3_d_index: int) -> bool:
            pass
        def cell3_d_original_cell3_d(self, updated_cell3_d_index: int) -> int:
            pass

        def cell3_d_initialize_double_properties(self, number_double_properties: int) -> None:
            pass
        def cell3_d_add_double_property(self, property_id: str) -> int:
            pass
        def cell3_ds_initialize_double_property_values(
            self,
            property_index: int,
            property_sizes: List[int]
            ) -> None:
            pass
        def cell3_d_initialize_double_property_values(
            self,
            cell3_d_index: int,
            property_index: int,
            property_size: int
            ) -> None:
            pass
        def cell3_d_insert_double_property_value(
            self,
            cell3_d_index: int,
            property_index: int,
            property_value_index: int,
            property_value: float
            ) -> None:
            pass
        def cell3_d_number_double_properties(self) -> int:
            pass
        def cell3_d_double_property_id(self, property_index: int) -> str:
            pass
        def cell3_d_double_property_exists(self, property_id: str) -> bool:
            pass
        def cell3_d_double_property_index(self, property_id: str) -> int:
            pass
        def cell3_d_double_property_size(self, cell3_d_index: int, property_index: int) -> int:
            pass
        def cell3_d_double_property_value(
            self,
            cell3_d_index: int,
            property_index: int,
            property_value_index: int
            ) -> float:
            pass

        def compress(self) -> None:
            pass

        def to_string(self) -> str:
            pass

# </submodule gedim>
####################    </generated_from:IMeshDAO.hpp>    ####################


####################    <generated_from:MeshMatrices.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshMatrices_H
#



# #endif
#

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshMatrices:
        """
        (final class)
        """
        dimension: int = 0                                                                                                   #/< Geometric dimension
        number_cell0_d: int = 0                                                                                              #/< number of Cell0D
        cell0_d_coordinates: List[float] = List[float]()                                                                     #/< Cell0D coordinates, size 3 x NumberCell0D (x,y,z)
        cell0_d_markers: List[int] = List[int]()                                                                             #/< Cell0D markers, size 1 x NumberCell0D (marker)
        number_cell0_d_neighbour_cell1_d: List[int] = List[int](0)                                                           #/< Cell0D neighbour Cell1D indices per cell, size  1
        #/< x NumberCell0D + 1
        cell0_d_neighbour_cell1_ds: List[int] = List[int]()                                                                  #/< Cell0D neighbour Cell1D indices, size 1 x
        #/< NumberCell0DNeighbourCell1D[NumberCell0D]
        number_cell0_d_neighbour_cell2_d: List[int] = List[int](0)                                                           #/< Cell0D neighbour Cell2D indices per cell, size  1
        #/< x NumberCell0D + 1
        cell0_d_neighbour_cell2_ds: List[int] = List[int]()                                                                  #/< Cell0D neighbour Cell2D indices, size 1 x
        #/< NumberCell0DNeighbourCell2D[NumberCell0D]
        number_cell0_d_neighbour_cell3_d: List[int] = List[int](0)                                                           #/< Cell0D neighbour Cell2D indices per cell, size  1
        #/< x NumberCell0D + 1
        cell0_d_neighbour_cell3_ds: List[int] = List[int]()                                                                  #/< Cell0D neighbour Cell3D indices, size 1 x
        #/< NumberCell0DNeighbourCell3D[NumberCell0D]
        active_cell0_d: List[bool] = List[bool]()                                                                            #/< active Cell0D
        updated_cell0_ds: std.unordered_map[int, std.unordered_set[int]] = std.unordered_map<int, std.unordered_set<int>>()  #/< for each cell0D the
        #/< list to the new cell0Ds
        cell0_d_double_property_ids: List[str] = List[str]()                                                                 #/< Cell0D double property id - double property index
        cell0_d_double_property_indices: std.unordered_map[str, int] = std.unordered_map<str, int>()                         #/< Cell0D double property id -
        #/< double property index
        cell0_d_double_property_sizes: List[List[int]] = List[List[int]]()                                                   #/< Cell0D double property sizes
        cell0_d_double_property_values: List[List[float]] = List[List[float]]()                                              #/< Cell0D double property values
        number_cell1_d: int = 0                                                                                              #/< number of Cell1D
        cell1_d_vertices: List[int] = List[int]()                                                                            #/< Cell1D vertices indices, size 2 x NumberCell1D (fromId,toId)
        number_cell1_d_neighbour_cell2_d: List[int] = List[int](0)                                                           #/< Cell1D neighbour Cell2D indices per cell, size  1
        #/< x NumberCell1D + 1
        number_cell1_d_neighbour_cell3_d: List[int] = List[int](0)                                                           #/< Cell1D neighbour Cell3D indices per cell, size  1
        #/< x NumberCell1D + 1
        cell1_d_neighbour_cell2_ds: List[int] = List[int]()                                                                  #/< Cell1D neighbour Cell2D indices, size 1 x
        #/< NumberCell1DNeighbourCell2D[NumberCell1D]
        cell1_d_neighbour_cell3_ds: List[int] = List[int]()                                                                  #/< Cell1D neighbour Cell3D indices, size 1 x
        #/< NumberCell1DNeighbourCell3D[NumberCell1D]
        cell1_d_markers: List[int] = List[int]()                                                                             #/< Cell1D propertoes, size 1 x NumberCell1D (marker)
        active_cell1_d: List[bool] = List[bool]()                                                                            #/< active Cell1D
        cell1_d_original_cell1_ds: List[int] = List[int]()                                                                   #/< for each cell1D the index of original cell1D,
        #/< NumberCell1D is the default value (no original cell),
        #/< size 1 x NumberCell1D
        updated_cell1_ds: std.unordered_map[int, std.unordered_set[int]] = std.unordered_map<int, std.unordered_set<int>>()  #/< for each cell1D the
        #/< list to the new cell1Ds
        cell1_d_double_property_ids: List[str] = List[str]()                                                                 #/< Cell1D double property id - double property index
        cell1_d_double_property_indices: std.unordered_map[str, int] = std.unordered_map<str, int>()                         #/< Cell1D double property id -
        #/< double property index
        cell1_d_double_property_sizes: List[List[int]] = List[List[int]]()                                                   #/< Cell1D double property sizes
        cell1_d_double_property_values: List[List[float]] = List[List[float]]()                                              #/< Cell1D double property values
        number_cell2_d: int = 0                                                                                              #/< number of Cell2D
        number_cell2_d_vertices: List[int] = List[int](0)                                                                    #/< number of Vertices per Cell2D, size 1 x NumberCell2D + 1
        number_cell2_d_edges: List[int] = List[int](0)                                                                       #/< number of Edges per Cell2D, size 1 x NumberCell2D + 1
        cell2_d_vertices: List[int] = List[int]()                                                                            #/< Cell2D Vertices indices, size 1 x
        #/< NumberCell2DVertices[NumberCell2D]
        cell2_d_edges: List[int] = List[int]()                                                                               #/< Cell2D Cell1D indices, size 1 x NumberCell2DEdges[NumberCell2D]
        number_cell2_d_neighbour_cell3_d: List[int] = List[int](0)                                                           #/< Cell2D neighbour Cell3D indices per cell, size  1
        #/< x NumberCell2D + 1
        cell2_d_neighbour_cell3_ds: List[int] = List[int]()                                                                  #/< Cell2D neighbour Cell3D indices, size 1 x
        #/< NumberCell2DNeighbourCell3D[NumberCell2D]
        cell2_d_markers: List[int] = List[int]()                                                                             #/< Cell2D markers, size 1 x NumberCell2D (marker)
        active_cell2_d: List[bool] = List[bool]()                                                                            #/< active Cell2D
        number_cell2_d_subdivision: List[int] = List[int](0)                                                                 #/< number of sub-division per Cell2D, size 1 x
        #/< NumberCell2D + 1
        cell2_d_subdivision: List[int] = List[int]()                                                                         #/< Sub-division of Cell2Ds, used for Concave polygons, size 1 x
        #/< NumberCell2DSubdivision[NumberCell2D]
        cell2_d_original_cell2_ds: List[int] = List[int]()                                                                   #/< for each cell2D the index of original cell2D,
        #/< NumberCell2D is the default value (no original cell),
        #/< size 1 x NumberCell2D
        updated_cell2_ds: std.unordered_map[int, std.unordered_set[int]] = std.unordered_map<int, std.unordered_set<int>>()  #/< for each cell2D the
        #/< list to the new cell2Ds
        cell2_d_double_property_ids: List[str] = List[str]()                                                                 #/< Cell2D double property id - double property index
        cell2_d_double_property_indices: std.unordered_map[str, int] = std.unordered_map<str, int>()                         #/< Cell2D double property id -
        #/< double property index
        cell2_d_double_property_sizes: List[List[int]] = List[List[int]]()                                                   #/< Cell2D double property sizes
        cell2_d_double_property_values: List[List[float]] = List[List[float]]()                                              #/< Cell2D double property values
        number_cell3_d: int = 0                                                                                              #/< number of Cell3D
        number_cell3_d_vertices: List[int] = List[int](0)                                                                    #/< number of Vertices per Cell3D, size 1 x NumberCell3D + 1
        number_cell3_d_edges: List[int] = List[int](0)                                                                       #/< number of Edges per Cell3D, size 1 x NumberCell3D + 1
        number_cell3_d_faces: List[int] = List[int](0)                                                                       #/< number of Faces per Cell3D, size 1 x NumberCell3D + 1
        cell3_d_vertices: List[int] = List[int]()                                                                            #/< Cell3D Cell0D indices, size 1 x
        #/< NumberCell3DVertices[NumberCell3D]
        cell3_d_edges: List[int] = List[int]()                                                                               #/< Cell3D Cell1D indices, size 1 x NumberCell3DEdges[NumberCell3D]
        cell3_d_faces: List[int] = List[int]()                                                                               #/< Cell3D Cell2D indices, size 1 x NumberCell3DFaces[NumberCell3D]
        cell3_d_markers: List[int] = List[int]()                                                                             #/< Cell3D markers, size 1 x NumberCell3D (marker)
        active_cell3_d: List[bool] = List[bool]()                                                                            #/< active Cell3D
        cell3_d_original_cell3_ds: List[int] = List[int]()                                                                   #/< for each cell3D the index of original cell3D,
        #/< NumberCell3D is the default value (no original cell),
        #/< size 1 x NumberCell3D
        updated_cell3_ds: std.unordered_map[int, std.unordered_set[int]] = std.unordered_map<int, std.unordered_set<int>>()  #/< for each cell3D the
        #/< list to the new cell3Ds
        cell3_d_double_property_ids: List[str] = List[str]()                                                                 #/< Cell3D double property id - double property index
        cell3_d_double_property_indices: std.unordered_map[str, int] = std.unordered_map<str, int>()                         #/< Cell3D double property id -
        #/< double property index
        cell3_d_double_property_sizes: List[List[int]] = List[List[int]]()                                                   #/< Cell3D double property sizes
        cell3_d_double_property_values: List[List[float]] = List[List[float]]()                                              #/< Cell3D double property values
        def __init__(
            self,
            cell0_d_coordinates: List[float] = List[float](),
            active_cell0_d: List[bool] = List[bool](),
            cell0_d_double_property_ids: List[str] = List[str](),
            cell0_d_double_property_values: List[List[float]] = List[List[float]](),
            active_cell1_d: List[bool] = List[bool](),
            cell1_d_double_property_ids: List[str] = List[str](),
            cell1_d_double_property_values: List[List[float]] = List[List[float]](),
            active_cell2_d: List[bool] = List[bool](),
            cell2_d_double_property_ids: List[str] = List[str](),
            cell2_d_double_property_values: List[List[float]] = List[List[float]](),
            active_cell3_d: List[bool] = List[bool](),
            cell3_d_double_property_ids: List[str] = List[str](),
            cell3_d_double_property_values: List[List[float]] = List[List[float]]()
            ) -> None:
            """Auto-generated default constructor with named params"""
            pass

# </submodule gedim>
####################    </generated_from:MeshMatrices.hpp>    ####################


####################    <generated_from:MeshMatricesDAO.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshMatricesWrapper_H
#


# #endif
#
####################    </generated_from:MeshMatricesDAO.hpp>    ####################


####################    <generated_from:MeshDAOExporterToCsv.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshDAOExporterToCsv_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshDAOExporterToCsv:
        """/ \brief MeshDAOExporterToCsv
        / \copyright See top level LICENSE file for details.
        (final class)
        """
        def __init__(self, utilities: MeshFromCsvUtilities) -> None:
            pass

        def export(
            self,
            configuration: MeshFromCsvUtilities.Configuration,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export the mesh in all parts
            / \param configuration the configuration for export
            / \param mesh the mesh to be exported
            """
            pass


# </submodule gedim>
####################    </generated_from:MeshDAOExporterToCsv.hpp>    ####################


####################    <generated_from:MeshDAOImporterFromCsv.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshDAOImporterFromCsv_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshDAOImporterFromCsv:
        """/ \brief MeshDAOImporterFromCsv
        / \note each file could be EmptyFileReader if not necessary
        / \copyright See top level LICENSE file for details
        (final class)
        """
        def __init__(self, utilities: MeshFromCsvUtilities) -> None:
            pass

        def import_(
            self,
            configuration: MeshFromCsvUtilities.Configuration,
            mesh: IMeshDAO
            ) -> None:
            pass

        def import_mesh2_d(
            self,
            configuration: MeshFromCsvUtilities.Configuration,
            mesh: IMeshDAO
            ) -> None:
            pass


# </submodule gedim>
####################    </generated_from:MeshDAOImporterFromCsv.hpp>    ####################


####################    <generated_from:MeshFromCsvUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshImporterFromCsvUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshFromCsvUtilities:
        """/ \brief MeshImporterFromCsvUtilities
        / \note each file could be EmptyFileReader if not necessary
        / \copyright See top level LICENSE file for details
        (final class)
        """
        class Configuration:
            folder: str = "./"
            file_cell0_ds_name: str = "Cell0Ds"
            file_cell1_ds_name: str = "Cell1Ds"
            file_cell2_ds_name: str = "Cell2Ds"
            file_cell3_ds_name: str = "Cell3Ds"
            file_cell0_d_neighbours_name: str = "Cell0DNeighbours"
            file_cell1_d_neighbours_name: str = "Cell1DNeighbours"
            file_cell2_d_neighbours_name: str = "Cell2DNeighbours"
            file_cell0_d_properties_name: str = "Cell0DProperties"
            file_cell1_d_properties_name: str = "Cell1DProperties"
            file_cell2_d_properties_name: str = "Cell2DProperties"
            file_cell3_d_properties_name: str = "Cell3DProperties"
            file_cell2_d_sub_divisions_name: str = "Cell2DSubDivisions"
            file_cell0_d_updated_cells_name: str = "Cell0DUpdatedCells"
            file_cell1_d_updated_cells_name: str = "Cell1DUpdatedCells"
            file_cell2_d_updated_cells_name: str = "Cell2DUpdatedCells"
            file_cell3_d_updated_cells_name: str = "Cell3DUpdatedCells"
            separator: char = ';'
            file_extension: str = "csv"
            def __init__(
                self,
                folder: str = "./",
                file_cell0_ds_name: str = "Cell0Ds",
                file_cell1_ds_name: str = "Cell1Ds",
                file_cell2_ds_name: str = "Cell2Ds",
                file_cell3_ds_name: str = "Cell3Ds",
                file_cell0_d_neighbours_name: str = "Cell0DNeighbours",
                file_cell1_d_neighbours_name: str = "Cell1DNeighbours",
                file_cell2_d_neighbours_name: str = "Cell2DNeighbours",
                file_cell0_d_properties_name: str = "Cell0DProperties",
                file_cell1_d_properties_name: str = "Cell1DProperties",
                file_cell2_d_properties_name: str = "Cell2DProperties",
                file_cell3_d_properties_name: str = "Cell3DProperties",
                file_cell2_d_sub_divisions_name: str = "Cell2DSubDivisions",
                file_cell0_d_updated_cells_name: str = "Cell0DUpdatedCells",
                file_cell1_d_updated_cells_name: str = "Cell1DUpdatedCells",
                file_cell2_d_updated_cells_name: str = "Cell2DUpdatedCells",
                file_cell3_d_updated_cells_name: str = "Cell3DUpdatedCells",
                separator: char = ';',
                file_extension: str = "csv"
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CellDoubleProperty:
            class Value:
                cell_id: int
                values: List[float]
                def __init__(self, values: List[float] = List[float]()) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            id: str
            file_path: str
            values: List[Gedim.MeshFromCsvUtilities.CellDoubleProperty.Value]
            def __init__(
                self,
                id: str = "",
                file_path: str = "",
                values: List[MeshFromCsvUtilities.CellDoubleProperty.Value] = List[MeshFromCsvUtilities.CellDoubleProperty.Value]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell0D:
            id: int
            x: float
            y: float
            z: float
            marker: int
            active: bool
            def __init__(
                self,
                x: float = float(),
                y: float = float(),
                z: float = float(),
                active: bool = bool()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell0DNeighbours:
            id: int
            cell1_d_neighbours: List[int]
            cell2_d_neighbours: List[int]
            cell3_d_neighbours: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class CellUpdatedCells:
            id: int
            updated_cells: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class Cell1D:
            id: int
            origin: int
            end: int
            marker: int
            active: bool
            def __init__(self, active: bool = bool()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell1DNeighbours:
            id: int
            cell2_d_neighbours: List[int]
            cell3_d_neighbours: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class Cell2D:
            id: int
            vertices: List[int]
            edges: List[int]
            marker: int
            active: bool
            def __init__(self, active: bool = bool()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell2DNeighbours:
            id: int
            cell3_d_neighbours: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class Cell2DSubDivision:
            id: int
            sub_division: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class Cell3D:
            id: int
            vertices: List[int]
            edges: List[int]
            faces: List[int]
            marker: int
            active: bool
            def __init__(self, active: bool = bool()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def convert_mesh2_d(
            self,
            cell0_ds: List[MeshFromCsvUtilities.Cell0D],
            cell1_ds: List[MeshFromCsvUtilities.Cell1D],
            cell2_ds: List[MeshFromCsvUtilities.Cell2D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert a 2D Mesh
            / \param cell0Ds the container of cell0Ds
            / \param cell1Ds the container of cell1Ds
            / \param cell2Ds the container of cell2Ds
            / \param mesh the resulting mesh
            """
            pass

        def convert_cell0_ds(
            self,
            cell0_ds: List[MeshFromCsvUtilities.Cell0D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell0Ds to mesh
            / \param cell0Ds the container of cell0Ds
            / \param mesh the mesh
            """
            pass
        def convert_cell1_ds(
            self,
            cell1_ds: List[MeshFromCsvUtilities.Cell1D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell1Ds to mesh
            / \param cell1Ds the container of cell1Ds
            / \param mesh the mesh
            """
            pass
        def convert_cell2_ds(
            self,
            cell2_ds: List[MeshFromCsvUtilities.Cell2D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2Ds to mesh
            / \param cell2Ds the container of cell2Ds
            / \param mesh the mesh
            """
            pass
        def convert_cell3_ds(
            self,
            cell3_ds: List[MeshFromCsvUtilities.Cell3D],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell3Ds to mesh
            / \param cell3Ds the container of cell3Ds
            / \param mesh the mesh
            """
            pass

        def convert_cell0_d_neighbours(
            self,
            cell0_d_neighbours: List[MeshFromCsvUtilities.Cell0DNeighbours],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell0D neighbours to mesh
            / \param cell0DNeighbours the container of cell0D neighbours
            / \param mesh the mesh
            """
            pass
        def convert_cell1_d_neighbours(
            self,
            cell1_d_neighbours: List[MeshFromCsvUtilities.Cell1DNeighbours],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell1D neighbours to mesh
            / \param cell1DNeighbours the container of cell1D neighbours
            / \param mesh the mesh
            """
            pass
        def convert_cell2_d_neighbours(
            self,
            cell2_d_neighbours: List[MeshFromCsvUtilities.Cell2DNeighbours],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2D neighbours to mesh
            / \param cell2DNeighbours the container of cell2D neighbours
            / \param mesh the mesh
            """
            pass

        def convert_cell2_d_sub_divisions(
            self,
            cell2_d_sub_divisions: List[MeshFromCsvUtilities.Cell2DSubDivision],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2D subdivision to mesh
            / \param cell2DSubDivisions the container of cell2D neighbours
            / \param mesh the mesh
            """
            pass

        def convert_cell0_d_double_properties(
            self,
            cell0_d_double_properties: List[MeshFromCsvUtilities.CellDoubleProperty],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell0D double properties to mesh
            / \param cell0DDoubleProperties the container of cell0D double properties
            / \param mesh the mesh
            """
            pass
        def convert_cell1_d_double_properties(
            self,
            cell1_d_double_properties: List[MeshFromCsvUtilities.CellDoubleProperty],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell1D double properties to mesh
            / \param cell1DDoubleProperties the container of cell1D double properties
            / \param mesh the mesh
            """
            pass
        def convert_cell2_d_double_properties(
            self,
            cell2_d_double_properties: List[MeshFromCsvUtilities.CellDoubleProperty],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2D double properties to mesh
            / \param cell2DDoubleProperties the container of cell2D double properties
            / \param mesh the mesh
            """
            pass
        def convert_cell3_d_double_properties(
            self,
            cell3_d_double_properties: List[MeshFromCsvUtilities.CellDoubleProperty],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell3D double properties to mesh
            / \param cell3DDoubleProperties the container of cell3D double properties
            / \param mesh the mesh
            """
            pass

        def convert_cell0_d_updated_cells(
            self,
            cell0_d_updated_cells: List[MeshFromCsvUtilities.CellUpdatedCells],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell0D updated cells to mesh
            / \param cell0DUpdatedCells the container of cell0D updated cells
            / \param mesh the mesh
            """
            pass
        def convert_cell1_d_updated_cells(
            self,
            cell1_d_updated_cells: List[MeshFromCsvUtilities.CellUpdatedCells],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell1D updated cells to mesh
            / \param cell1DUpdatedCells the container of cell1D updated cells
            / \param mesh the mesh
            """
            pass
        def convert_cell2_d_updated_cells(
            self,
            cell2_d_updated_cells: List[MeshFromCsvUtilities.CellUpdatedCells],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell2D updated cells to mesh
            / \param cell2DUpdatedCells the container of cell2D updated cells
            / \param mesh the mesh
            """
            pass
        def convert_cell3_d_updated_cells(
            self,
            cell3_d_updated_cells: List[MeshFromCsvUtilities.CellUpdatedCells],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Convert the imported Cell3D updated cells to mesh
            / \param cell3DUpdatedCells the container of cell3D updated cells
            / \param mesh the mesh
            """
            pass

        def import_cell0_ds(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell0D]:
            """/ \brief Import Cell0Ds; format: Id, Marker, Active, X, Y, Z
            / \param csvFileReader the file reader
            / \param separator the file separator
            / \param mesh the mesh to be Imported
            """
            pass
        def import_cell1_ds(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell1D]:
            """/ \brief Import Cell1Ds; format: Id, Marker, Active, Origin, End
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass
        def import_cell2_ds(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell2D]:
            """/ \brief Import Cell2Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass
        def import_cell3_ds(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell3D]:
            """/ \brief Import Cell3Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges, NumFaces, Faces
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell0_d_neighbours(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell0DNeighbours]:
            """/ \brief Import Cell0DNeighbours; format: Id, Num1DNeighbours, 1DNeighbours, Num2DNeighbours, 2DNeighbours,
            / Num3DNeighbours, 3DNeighbours \param csvFileReader the file reader \param separator the file separator
            """
            pass
        def import_cell1_d_neighbours(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell1DNeighbours]:
            """/ \brief Import Cell1DNeighbours; format: Id, Num2DNeighbours, 2DNeighbours, Num3DNeighbours, 3DNeighbours
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell2_d_neighbours(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell2DNeighbours]:
            """/ \brief Import Cell2DNeighbours; format: Id, Num3DNeighbours, 3DNeighbours
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell2_d_sub_division(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.Cell2DSubDivision]:
            """/ \brief Import Cell2DSubDivision; format: Id, NumSubDivision, SubDivisions
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell_double_properties(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.CellDoubleProperty]:
            """/ \brief Import CellProperties; format: Id, FilePath
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def import_cell_updated_cells(
            self,
            csv_file_reader: IFileReader,
            separator: str
            ) -> List[MeshFromCsvUtilities.CellUpdatedCells]:
            """/ \brief Import CellUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param csvFileReader the file reader
            / \param separator the file separator
            """
            pass

        def export_cell0_ds(self, file_path: str, separator: str, mesh: IMeshDAO) -> None:
            """/ \brief Export Cell0Ds; format: Id, Marker, Active, X, Y, Z
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell1_ds(self, file_path: str, separator: str, mesh: IMeshDAO) -> None:
            """/ \brief Export Cell1Ds; format: Id, Marker, Active, Origin, End
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell2_ds(self, file_path: str, separator: str, mesh: IMeshDAO) -> None:
            """/ \brief Export Cell2Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell3_ds(self, file_path: str, separator: str, mesh: IMeshDAO) -> None:
            """/ \brief Export Cell3Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges, NumFaces, Faces
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell0_d_properties(
            self,
            export_folder: str,
            property_file_name: str,
            property_file_extension: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell0DProperties; format: Id, FilePath
            / \param exportFolder the folder where to export the files
            / \param propertyFileName the name of property file
            / \param propertyFileExtension the extension of the files
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell0_d_property(
            self,
            property_index: int,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell0DProperty identified by index; format: Id, PropertySize, PropertyValues
            / \param propertyIndex the property index
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell1_d_properties(
            self,
            export_folder: str,
            property_file_name: str,
            property_file_extension: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell1DProperties; format: Id, FilePath
            / \param exportFolder the folder where to export the files
            / \param propertyFileName the name of property file
            / \param propertyFileExtension the extension of the files
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell1_d_property(
            self,
            property_index: int,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell1DProperty identified by index; format: Id, PropertySize, PropertyValues
            / \param propertyIndex the property index
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell2_d_properties(
            self,
            export_folder: str,
            property_file_name: str,
            property_file_extension: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DProperties; format: Id, FilePath
            / \param exportFolder the folder where to export the files
            / \param propertyFileName the name of property file
            / \param propertyFileExtension the extension of the files
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell2_d_property(
            self,
            property_index: int,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DProperty identified by index; format: Id, PropertySize, PropertyValues
            / \param propertyIndex the property index
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell3_d_properties(
            self,
            export_folder: str,
            property_file_name: str,
            property_file_extension: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell3DProperties; format: Id, FilePath
            / \param exportFolder the folder where to export the files
            / \param propertyFileName the name of property file
            / \param propertyFileExtension the extension of the files
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell3_d_property(
            self,
            property_index: int,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell3DProperty identified by index; format: Id, PropertySize, PropertyValues
            / \param propertyIndex the property index
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell0_d_neighbours(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell0DNeighbours; format: Id, Num1DNeighbours, 1DNeighbours, Num2DNeighbours, 2DNeighbours,
            / Num3DNeighbours, 3DNeighbours \param filePath the path of the file \param separator the file separator \param
            / mesh the mesh to be exported
            """
            pass
        def export_cell1_d_neighbours(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell1DNeighbours; format: Id, Num2DNeighbours, 2DNeighbours, Num3DNeighbours, 3DNeighbours
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell2_d_neighbours(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DNeighbours; format: Id, Num3DNeighbours, 3DNeighbours
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell2_d_sub_divisions(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DSubDivisions; format: Id, NumSubDivision, SubDivisions
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass

        def export_cell0_d_updated_cells(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell0DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell1_d_updated_cells(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell1DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell2_d_updated_cells(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell2DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass
        def export_cell3_d_updated_cells(
            self,
            file_path: str,
            separator: str,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Export Cell3DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells
            / \param filePath the path of the file
            / \param separator the file separator
            / \param mesh the mesh to be exported
            """
            pass


# </submodule gedim>
####################    </generated_from:MeshFromCsvUtilities.hpp>    ####################


####################    <generated_from:MeshUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __MeshUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class MeshUtilities:
        """/ \brief MeshUtilities
        / \copyright See top level LICENSE file for details.
        (final class)
        """
        class CheckMesh2DConfiguration:
            """
            (final class)
            """
            cell0_d_check_coordinates2_d: bool = True
            cell0_d_check_duplications: bool = True
            cell1_d_check_duplications: bool = True
            cell1_d_check_neighbours: bool = True
            cell1_d_check_measure: bool = True
            cell2_d_check_edges: bool = True
            cell2_d_check_duplications: bool = True
            cell2_d_check_convexity: bool = True
            cell2_d_check_measure: bool = True
            def __init__(
                self,
                cell0_d_check_coordinates2_d: bool = True,
                cell0_d_check_duplications: bool = True,
                cell1_d_check_duplications: bool = True,
                cell1_d_check_neighbours: bool = True,
                cell1_d_check_measure: bool = True,
                cell2_d_check_edges: bool = True,
                cell2_d_check_duplications: bool = True,
                cell2_d_check_convexity: bool = True,
                cell2_d_check_measure: bool = True
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CheckMesh3DConfiguration:
            """
            (final class)
            """
            cell0_d_check_duplications: bool = True
            cell1_d_check_duplications: bool = True
            cell1_d_check_measure: bool = True
            cell2_d_check_edges: bool = True
            cell2_d_check_duplications: bool = True
            cell2_d_check_convexity: bool = True
            cell2_d_check_measure: bool = True
            cell3_d_check_duplications: bool = True
            cell3_d_check_edges: bool = True
            cell3_d_check_edges_are_active: bool = True
            cell3_d_check_convexity: bool = True
            cell3_d_check_measure: bool = True
            def __init__(
                self,
                cell0_d_check_duplications: bool = True,
                cell1_d_check_duplications: bool = True,
                cell1_d_check_measure: bool = True,
                cell2_d_check_edges: bool = True,
                cell2_d_check_duplications: bool = True,
                cell2_d_check_convexity: bool = True,
                cell2_d_check_measure: bool = True,
                cell3_d_check_duplications: bool = True,
                cell3_d_check_edges: bool = True,
                cell3_d_check_edges_are_active: bool = True,
                cell3_d_check_convexity: bool = True,
                cell3_d_check_measure: bool = True
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CheckMeshGeometricData2DConfiguration:
            """
            (final class)
            """
            cell1_d_check_measure: bool = True
            cell1_d_check_normals: bool = True
            cell2_d_check_measure: bool = True
            cell2_d_check_triangles: bool = True
            cell1_d_quadrature_order: int = 0
            cell2_d_quadrature_order: int = 0
            def __init__(
                self,
                cell1_d_check_measure: bool = True,
                cell1_d_check_normals: bool = True,
                cell2_d_check_measure: bool = True,
                cell2_d_check_triangles: bool = True
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CheckMeshGeometricData3DConfiguration:
            """
            (final class)
            """
            cell1_d_check_measure: bool = True
            cell1_d_check_normals: bool = True
            cell2_d_check_measure: bool = True
            cell2_d_check_triangles: bool = True
            cell2_d_check_normals: bool = True
            cell3_d_check_measure: bool = True
            cell3_d_check_tetrahedra: bool = True
            cell1_d_quadrature_order: int = 0
            cell2_d_quadrature_order: int = 0
            cell3_d_quadrature_order: int = 0
            def __init__(
                self,
                cell1_d_check_measure: bool = True,
                cell1_d_check_normals: bool = True,
                cell2_d_check_measure: bool = True,
                cell2_d_check_triangles: bool = True,
                cell2_d_check_normals: bool = True,
                cell3_d_check_measure: bool = True,
                cell3_d_check_tetrahedra: bool = True
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class ExtractActiveMeshData:
            """
            (final class)
            """
            old_cell0_d_to_new_cell0_d: std.unordered_map[int, int]                                             #/< each pair is {old Cell0D index, new
            #/< Cell0D index}
            old_cell1_d_to_new_cell1_d: std.unordered_map[int, int]                                             #/< each pair is {old Cell1D index, new
            #/< Cell1D index}
            old_cell2_d_to_new_cell2_d: std.unordered_map[int, int]                                             #/< each pair is {old Cell2D index, new
            #/< Cell2D index}
            old_cell3_d_to_new_cell3_d: std.unordered_map[int, int]                                             #/< each pair is {old Cell3D index, new
            #/< Cell3D index}
            new_cell0_d_to_old_cell0_d: std.unordered_map[int, int]                                             #/< each pair is {new Cell0D index, old
            #/< Cell0D index}
            new_cell1_d_to_old_cell1_d: std.unordered_map[int, int]                                             #/< each pair is {new Cell1D index, old
            #/< Cell1D index}
            new_cell2_d_to_old_cell2_d: std.unordered_map[int, int]                                             #/< each pair is {new Cell2D index, old
            #/< Cell2D index}
            new_cell3_d_to_old_cell3_d: std.unordered_map[int, int]                                             #/< each pair is {new Cell3D index, old
            #/< Cell3D index}
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class FilterMeshData:
            """
            (final class)
            """
            cell0_ds: List[int]
            cell1_ds: List[int]
            cell2_ds: List[int]
            cell3_ds: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class ExtractMeshData:
            """
            (final class)
            """
            old_cell0_d_to_new_cell0_d: List[int] = List[int]()                                                 #/< each element is [old Cell0D index] = new Cell0D index
            old_cell1_d_to_new_cell1_d: List[int] = List[int]()                                                 #/< each element is [old Cell1D index] = new Cell1D index
            old_cell2_d_to_new_cell2_d: List[int] = List[int]()                                                 #/< each element is [old Cell2D index] = new Cell2D index
            old_cell3_d_to_new_cell3_d: List[int] = List[int]()                                                 #/< each element is [old Cell3D index] = new Cell3D index
            new_cell0_d_to_old_cell0_d: List[int] = List[int]()                                                 #/< each element is [new Cell0D index] = old Cell0D index
            new_cell1_d_to_old_cell1_d: List[int] = List[int]()                                                 #/< each element is [new Cell1D index] = old Cell1D index
            new_cell2_d_to_old_cell2_d: List[int] = List[int]()                                                 #/< each element is [new Cell2D index] = old Cell2D index
            new_cell3_d_to_old_cell3_d: List[int] = List[int]()                                                 #/< each element is [new Cell3D index] = old Cell3D index
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class ComputeMesh2DCell1DsResult:
            """
            (final class)
            """
            cell1_ds: Eigen.MatrixXi                                                                            #/ Cell1Ds vertices, size 2 x Cell1DTotalNumber()
            cell2_ds: List[Eigen.MatrixXi]                                                                      #/< Cell2Ds vertices and edges, size
            #/< Cell2DTotalNumber()x2xCell2DNumberVertices()
            def __init__(
                self,
                cell1_ds: Eigen.MatrixXi = Eigen.MatrixXi(),
                cell2_ds: List[Eigen.MatrixXi] = List[Eigen.MatrixXi]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class ComputeMesh3DAlignedCell1DsResult:
            """
            (final class)
            """

            aligned_cell1_ds: Eigen.MatrixXi
            cell0_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi]
            cell1_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi]
            cell3_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi]
            aligned_cell1_ds_sub_cell0_ds: List[List[int]]
            aligned_cell1_ds_sub_cell1_ds: List[List[int]]
            aligned_cell1_ds_cell3_ds: List[List[int]]
            def __init__(
                self,
                aligned_cell1_ds: Eigen.MatrixXi = Eigen.MatrixXi(),
                cell0_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                cell1_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                cell3_ds_aligned_cell1_ds_index: List[Eigen.MatrixXi] = List[Eigen.MatrixXi]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class MeshGeometricData1D:
            """
            (final class)
            """
            cell1_ds_bounding_box: List[Eigen.MatrixXd]
            cell1_ds_vertices: List[Eigen.MatrixXd]                                                             #/< cell1D vertices coordinates
            cell1_ds_tangents: List[Eigen.Vector3d]                                                             #/< cell1D tangents
            cell1_ds_lengths: List[float]                                                                       #/< cell1D lengths
            cell1_ds_squared_lengths: List[float]                                                               #/< cell1D squared lengths
            cell1_ds_centroids: List[Eigen.Vector3d]                                                            #/< cell1D centroids
            def __init__(
                self,
                cell1_ds_bounding_box: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell1_ds_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell1_ds_tangents: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                cell1_ds_lengths: List[float] = List[float](),
                cell1_ds_squared_lengths: List[float] = List[float](),
                cell1_ds_centroids: List[Eigen.Vector3d] = List[Eigen.Vector3d]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class MeshGeometricData2D:
            """
            (final class)
            """
            cell2_ds_bounding_box: List[Eigen.MatrixXd]
            cell2_ds_vertices: List[Eigen.MatrixXd]                                                             #/< cell2D vertices coordinates
            cell2_ds_triangulations: List[List[Eigen.Matrix3d]]                                                 #/< cell2D triangulations
            cell2_ds_areas: List[float]                                                                         #/< cell2D areas
            cell2_ds_centroids: List[Eigen.Vector3d]                                                            #/< cell2D centroids
            cell2_ds_diameters: List[float]                                                                     #/< cell2D diameters
            cell2_ds_edge_directions: List[List[bool]]                                                          #/< cell2D edge directions
            cell2_ds_edges_centroid: List[Eigen.MatrixXd]                                                       #/< cell2D edge centroid
            cell2_ds_edge_lengths: List[Eigen.VectorXd]                                                         #/< cell2D edge lengths
            cell2_ds_edge_tangents: List[Eigen.MatrixXd]                                                        #/< cell2D edge tangents
            cell2_ds_edge_normals: List[Eigen.MatrixXd]                                                         #/< cell2D edge normals
            def __init__(
                self,
                cell2_ds_bounding_box: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell2_ds_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell2_ds_triangulations: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]](),
                cell2_ds_areas: List[float] = List[float](),
                cell2_ds_centroids: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                cell2_ds_diameters: List[float] = List[float](),
                cell2_ds_edge_directions: List[List[bool]] = List[List[bool]](),
                cell2_ds_edges_centroid: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell2_ds_edge_lengths: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                cell2_ds_edge_tangents: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell2_ds_edge_normals: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class MeshGeometricData3D:
            """
            (final class)
            """
            cell3_ds_vertices: List[Eigen.MatrixXd]
            cell3_ds_edges: List[Eigen.MatrixXi]
            cell3_ds_faces: List[List[Eigen.MatrixXi]]
            cell3_ds_bounding_box: List[Eigen.MatrixXd]
            cell3_ds_volumes: List[float]
            cell3_ds_diameters: List[float]
            cell3_ds_centroids: List[Eigen.Vector3d]
            cell3_ds_edges_centroid: List[Eigen.MatrixXd]
            cell3_ds_edge_lengths: List[Eigen.VectorXd]
            cell3_ds_edge_tangents: List[Eigen.MatrixXd]
            cell3_ds_edge_directions: List[List[bool]]
            cell3_ds_tetrahedron_points: List[List[Eigen.MatrixXd]]
            cell3_ds_faces_translations: List[List[Eigen.Vector3d]]
            cell3_ds_faces_rotation_matrices: List[List[Eigen.Matrix3d]]
            cell3_ds_faces_normals: List[List[Eigen.Vector3d]]
            cell3_ds_faces_tangents: List[List[List[Eigen.Vector3d]]]
            cell3_ds_faces_normal_directions: List[List[bool]]
            cell3_ds_faces_normal_global_direction: List[List[bool]]
            cell3_ds_faces_tangents_global_direction: List[List[List[bool]]]
            cell3_ds_faces_edge_directions: List[List[List[bool]]]
            cell3_ds_faces3_d_vertices: List[List[Eigen.MatrixXd]]                                              #/< faces vertices 3D coordinates
            cell3_ds_faces2_d_vertices: List[List[Eigen.MatrixXd]]                                              #/< faces vertices 2D coordinates
            cell3_ds_faces3_d_triangulations: List[List[List[Eigen.Matrix3d]]]                                  #/< faces triangulations
            #/< 2D
            cell3_ds_faces2_d_triangulations: List[List[List[Eigen.Matrix3d]]]                                  #/< faces triangulations
            #/< 2D
            cell3_ds_faces_areas: List[List[float]]                                                             #/< faces areas
            cell3_ds_faces2_d_centroids: List[List[Eigen.Vector3d]]                                             #/< faces centroids
            cell3_ds_faces_diameters: List[List[float]]                                                         #/< faces diameters
            cell3_ds_faces_edge_lengths: List[List[Eigen.VectorXd]]                                             #/< faces edge lengths
            cell3_ds_faces_edge3_d_tangents: List[List[Eigen.MatrixXd]]                                         #/< faces edge 3D tangents
            cell3_ds_faces_edges3_d_centroid: List[List[Eigen.MatrixXd]]
            cell3_ds_faces_edge2_d_tangents: List[List[Eigen.MatrixXd]]                                         #/< faces edge 2D tangents
            cell3_ds_faces_edges2_d_centroid: List[List[Eigen.MatrixXd]]
            cell3_ds_faces_edge2_d_normals: List[List[Eigen.MatrixXd]]                                          #/< faces edge normals
            def __init__(
                self,
                cell3_ds_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell3_ds_edges: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                cell3_ds_faces: List[List[Eigen.MatrixXi]] = List[List[Eigen.MatrixXi]](),
                cell3_ds_bounding_box: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell3_ds_volumes: List[float] = List[float](),
                cell3_ds_diameters: List[float] = List[float](),
                cell3_ds_centroids: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                cell3_ds_edges_centroid: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell3_ds_edge_lengths: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                cell3_ds_edge_tangents: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                cell3_ds_edge_directions: List[List[bool]] = List[List[bool]](),
                cell3_ds_tetrahedron_points: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_translations: List[List[Eigen.Vector3d]] = List[List[Eigen.Vector3d]](),
                cell3_ds_faces_rotation_matrices: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]](),
                cell3_ds_faces_normals: List[List[Eigen.Vector3d]] = List[List[Eigen.Vector3d]](),
                cell3_ds_faces_normal_directions: List[List[bool]] = List[List[bool]](),
                cell3_ds_faces_normal_global_direction: List[List[bool]] = List[List[bool]](),
                cell3_ds_faces_edge_directions: List[List[List[bool]]] = List[List[List[bool]]](),
                cell3_ds_faces3_d_vertices: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces2_d_vertices: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces3_d_triangulations: List[List[List[Eigen.Matrix3d]]] = List[List[List[Eigen.Matrix3d]]](),
                cell3_ds_faces2_d_triangulations: List[List[List[Eigen.Matrix3d]]] = List[List[List[Eigen.Matrix3d]]](),
                cell3_ds_faces_areas: List[List[float]] = List[List[float]](),
                cell3_ds_faces2_d_centroids: List[List[Eigen.Vector3d]] = List[List[Eigen.Vector3d]](),
                cell3_ds_faces_diameters: List[List[float]] = List[List[float]](),
                cell3_ds_faces_edge_lengths: List[List[Eigen.VectorXd]] = List[List[Eigen.VectorXd]](),
                cell3_ds_faces_edge3_d_tangents: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_edges3_d_centroid: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_edge2_d_tangents: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_edges2_d_centroid: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                cell3_ds_faces_edge2_d_normals: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class VTPPolyhedron:
            """
            (final class)
            """
            vertices: Eigen.MatrixXd                                                                            #/ size 3xnumVertices
            polyhedron_faces: List[List[int]]                                                                   #/ size numFaces x numFaceVertices
            def __init__(self, vertices: Eigen.MatrixXd = Eigen.MatrixXd()) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class AgglomerateTrianglesResult:
            """
            (final class)
            """
            removed_edges: List[int]
            vertices_index: List[int]
            edges_index: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class AgglomerateMeshFromTriangularMeshResult:
            """
            (final class)
            """
            class ConcaveCell2D:
                cell2_d_index: int
                convex_cell2_ds_index: List[int]
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            concave_cell2_ds: List[Gedim.MeshUtilities.AgglomerateMeshFromTriangularMeshResult.ConcaveCell2D]
            removed_cell1_ds: List[int]
            removed_cell2_ds: List[int]
            def __init__(
                self,
                concave_cell2_ds: List[MeshUtilities.AgglomerateMeshFromTriangularMeshResult.ConcaveCell2D] = List[MeshUtilities.AgglomerateMeshFromTriangularMeshResult.ConcaveCell2D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class AgglomerationInformation:
            """
            (final class)
            """
            original_cell0_d_to_agglomerated_cell0_ds: List[int] = List[int]()
            original_cell1_d_to_agglomerated_cell1_ds: List[int] = List[int]()
            original_cell2_d_to_agglomerated_cell2_ds: List[int] = List[int]()
            agglomerated_cell0_d_to_original_cell0_ds: List[int] = List[int]()
            agglomerated_cell1_d_to_original_cell1_ds: List[List[int]] = List[List[int]]()
            agglomerated_cell2_d_to_original_cell2_ds: List[List[int]] = List[List[int]]()
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class AgglomerateCell1DInformation:
            """
            (final class)
            """
            agglomerate_cell1_d_vertices: List[int]
            sub_cell1_ds_removed_vertices: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class AgglomerateCell2DInformation:
            """
            (final class)
            """
            agglomerate_cell2_d_vertices: List[int]
            agglomerate_cell2_d_edges: List[int]
            sub_cell2_ds_removed_vertices: List[int]
            sub_cell2_ds_removed_edges: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class AgglomerateCell3DInformation:
            """
            (final class)
            """
            agglomerate_cell3_d_vertices: List[int]
            agglomerate_cell3_d_edges: List[int]
            agglomerate_cell3_d_faces: List[int]
            sub_cell3_ds_removed_vertices: List[int]
            sub_cell3_ds_removed_edges: List[int]
            sub_cell3_ds_removed_faces: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class FindConcaveCell3DFacesConvexCell2DResult:
            """
            (final class)
            """
            class ConvexCell2D:
                """
                (final class)
                """
                convex_cell3_d_index: int = 0
                convex_cell3_d_face_index: int = 0
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            concave_cell3_d_faces_convex_cell2_d: List[Gedim.MeshUtilities.FindConcaveCell3DFacesConvexCell2DResult.ConvexCell2D] = List[Gedim.MeshUtilities.FindConcaveCell3DFacesConvexCell2DResult.ConvexCell2D]()
            def __init__(
                self,
                concave_cell3_d_faces_convex_cell2_d: List[MeshUtilities.FindConcaveCell3DFacesConvexCell2DResult.ConvexCell2D] = List[MeshUtilities.FindConcaveCell3DFacesConvexCell2DResult.ConvexCell2D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Mesh3DPolyhedron:
            """
            (final class)
            """
            vertices_index: List[int]
            edges_index: List[int]
            faces_index: List[int]
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class FindPointMeshPositionResult:
            """
            (final class)
            """
            class PointMeshPosition:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                                                                       # (= 0)
                    outside = enum.auto()                                                                       # (= 1)
                    cell0_d = enum.auto()                                                                       # (= 2)
                    cell1_d = enum.auto()                                                                       # (= 3)
                    cell2_d = enum.auto()                                                                       # (= 4)
                    cell3_d = enum.auto()                                                                       # (= 5)

                type: Gedim.MeshUtilities.FindPointMeshPositionResult.PointMeshPosition.Types
                cell_index: int
                def __init__(
                    self,
                    type: MeshUtilities.FindPointMeshPositionResult.PointMeshPosition.Types = MeshUtilities.FindPointMeshPositionResult.PointMeshPosition.Types()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            mesh_positions: List[Gedim.MeshUtilities.FindPointMeshPositionResult.PointMeshPosition]
            def __init__(
                self,
                mesh_positions: List[MeshUtilities.FindPointMeshPositionResult.PointMeshPosition] = List[MeshUtilities.FindPointMeshPositionResult.PointMeshPosition]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class FindPointCell2DResult:
            """
            (final class)
            """
            class PointCell2DFound:
                """
                (final class)
                """
                cell2_d_index: int
                cell2_d_position: Gedim.GeometryUtilities.PointPolygonPositionResult
                def __init__(
                    self,
                    cell2_d_position: GeometryUtilities.PointPolygonPositionResult = GeometryUtilities.PointPolygonPositionResult()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            cell2_ds_found: List[Gedim.MeshUtilities.FindPointCell2DResult.PointCell2DFound]
            def __init__(
                self,
                cell2_ds_found: List[MeshUtilities.FindPointCell2DResult.PointCell2DFound] = List[MeshUtilities.FindPointCell2DResult.PointCell2DFound]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class FindPointCell3DResult:
            """
            (final class)
            """
            class PointCell3DFound:
                """
                (final class)
                """
                cell3_d_index: int
                cell3_d_position: Gedim.GeometryUtilities.PointPolyhedronPositionResult
                def __init__(
                    self,
                    cell3_d_position: GeometryUtilities.PointPolyhedronPositionResult = GeometryUtilities.PointPolyhedronPositionResult()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            cell3_ds_found: List[Gedim.MeshUtilities.FindPointCell3DResult.PointCell3DFound]
            def __init__(
                self,
                cell3_ds_found: List[MeshUtilities.FindPointCell3DResult.PointCell3DFound] = List[MeshUtilities.FindPointCell3DResult.PointCell3DFound]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Intersect_mesh_polyhedron_result:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                none = enum.auto()                                                                              # (= 1)  #/< No intersection found
                vertices = enum.auto()                                                                          # (= 2)  #/< Vertices

            class Polyhedron_Intersection:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    vertex = enum.auto()                                                                        # (= 1)
                    edge = enum.auto()                                                                          # (= 2)
                    face = enum.auto()                                                                          # (= 3)
                    polyhedron = enum.auto()                                                                    # (= 4)

                type: Gedim.MeshUtilities.Intersect_mesh_polyhedron_result.Polyhedron_Intersection.Types
                geometry_index: int
                cell0_ds_index: List[int]
                cell1_ds_index: List[int]
                cell2_ds_index: List[int]
                cell3_ds_index: List[int]
                def __init__(
                    self,
                    type: MeshUtilities.Intersect_mesh_polyhedron_result.Polyhedron_Intersection.Types = MeshUtilities.Intersect_mesh_polyhedron_result.Polyhedron_Intersection.Types()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class Mesh_Intersections:
                """
                (final class)
                """
                cell0_ds_intersections: Dict[int, int]
                cell1_ds_intersections: Dict[int, List[int]]
                cell2_ds_intersections: Dict[int, List[int]]
                cell3_ds_intersections: Dict[int, List[int]]
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            type: Gedim.MeshUtilities.Intersect_mesh_polyhedron_result.Types
            intersections_coordinates: Eigen.MatrixXd
            polyhedron_intersections: List[Gedim.MeshUtilities.Intersect_mesh_polyhedron_result.Polyhedron_Intersection]
            mesh_intersections: Gedim.MeshUtilities.Intersect_mesh_polyhedron_result.Mesh_Intersections
            def __init__(
                self,
                type: MeshUtilities.Intersect_mesh_polyhedron_result.Types = MeshUtilities.Intersect_mesh_polyhedron_result.Types(),
                intersections_coordinates: Eigen.MatrixXd = Eigen.MatrixXd(),
                polyhedron_intersections: List[MeshUtilities.Intersect_mesh_polyhedron_result.Polyhedron_Intersection] = List[MeshUtilities.Intersect_mesh_polyhedron_result.Polyhedron_Intersection](),
                mesh_intersections: MeshUtilities.Intersect_mesh_polyhedron_result.Mesh_Intersections = MeshUtilities.Intersect_mesh_polyhedron_result.Mesh_Intersections()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(self) -> None:
            pass

        def extract_active_mesh(
            self,
            mesh: IMeshDAO,
            extraction_data: MeshUtilities.ExtractActiveMeshData
            ) -> None:
            """/ \brief Extract Active Cells from mesh
            / \note the resulting mesh has no inactive elements
            """
            pass

        def filter_active_mesh(self, mesh: IMeshDAO) -> MeshUtilities.FilterMeshData:
            pass

        def filter_mesh1_d(
            self,
            cell1_ds_filter: List[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.FilterMeshData:
            """/ \brief Extract mesh1D cells from a mesh"""
            pass

        def filter_mesh2_d(
            self,
            cell2_ds_filter: List[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.FilterMeshData:
            """/ \brief Extract mesh2D cells from a mesh"""
            pass

        def filter_mesh3_d(
            self,
            cell3_ds_filter: List[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.FilterMeshData:
            """/ \brief Extract mesh3D cells from a mesh"""
            pass

        def extract_mesh1_d(
            self,
            cell0_ds_filter: List[int],
            cell1_ds_filter: List[int],
            original_mesh: IMeshDAO,
            mesh: IMeshDAO
            ) -> MeshUtilities.ExtractMeshData:
            pass

        def extract_mesh2_d(
            self,
            cell0_ds_filter: List[int],
            cell1_ds_filter: List[int],
            cell2_ds_filter: List[int],
            original_mesh: IMeshDAO,
            mesh: IMeshDAO
            ) -> MeshUtilities.ExtractMeshData:
            pass

        def extract_mesh3_d(
            self,
            cell0_ds_filter: List[int],
            cell1_ds_filter: List[int],
            cell2_ds_filter: List[int],
            cell3_ds_filter: List[int],
            original_mesh: IMeshDAO,
            mesh: IMeshDAO
            ) -> MeshUtilities.ExtractMeshData:
            pass

        def fill_mesh1_d(
            self,
            geometry_utilities: GeometryUtilities,
            segment_origin: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            coordinates: List[float],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Fill Mesh 1D From segment Coordinates
            / \param segmentOrigin the segment origin
            / \param segmentTangent the segment tangent vector
            / \param coordinates relative coordinates between [0.0, 1.0]
            / \param mesh the resulting mesh
            """
            pass

        def fill_mesh2_d(
            self,
            cell0_ds: Eigen.MatrixXd,
            cell1_ds: Eigen.MatrixXi,
            cell2_ds: List[Eigen.MatrixXi],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Fill a Mesh 2D with vertices, edges and polygons
            / \param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()
            / \param cell1Ds the origin and end as Eigen MatrixXd of cell1Ds, size 2xCell1DTotalNumber()
            / \param cell2Ds the vertices and edges indices of the cell2Ds ordered counterclockwise, size
            / Cell2DTotalNumber()x2xCell2DNumberVertices()
            """
            pass

        def fill_mesh3_d(
            self,
            cell0_ds: Eigen.MatrixXd,
            cell1_ds: Eigen.MatrixXi,
            cell2_ds: List[Eigen.MatrixXi],
            cell3_ds: List[MeshUtilities.Mesh3DPolyhedron],
            mesh: IMeshDAO
            ) -> None:
            pass

        def compute_mesh2_d_cell1_ds(
            self,
            cell0_ds: Eigen.MatrixXd,
            cell2_ds: List[Eigen.VectorXi]
            ) -> MeshUtilities.ComputeMesh2DCell1DsResult:
            """/ \brief Compute edges in a Mesh 2D with vertices and polygons
            / \param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()
            / \param cell2Ds the vertices indices of the cell2Ds ordered counterclockwise, size
            / Cell2DTotalNumber()xCell2DNumberVertices() \return the Cell1Ds data
            """
            pass

        def check_mesh2_d(
            self,
            configuration: MeshUtilities.CheckMesh2DConfiguration,
            geometry_utilities: GeometryUtilities,
            convex_mesh: IMeshDAO
            ) -> None:
            """/ \brief Check Mesh2D correctness
            / \param Gedim::GeometryUtilities the geometry utilities
            / \param convexMesh a convex 2D mesh
            """
            pass

        def check_mesh3_d(
            self,
            configuration: MeshUtilities.CheckMesh3DConfiguration,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Check Mesh3D correctness
            / \param Gedim::GeometryUtilities the geometry utilities
            / \param mesh a 3D mesh
            """
            pass

        def compute_mesh3_d_aligned_cell1_ds(
            self,
            cell3_ds_aligned_edges_vertices: List[List[List[int]]],
            cell3_ds_aligned_edges_edges: List[List[List[int]]],
            mesh: IMeshDAO
            ) -> MeshUtilities.ComputeMesh3DAlignedCell1DsResult:
            """/ \brief Compute edges in a Mesh 2D with vertices and polygons
            / \param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()
            / \param cell2Ds the vertices indices of the cell2Ds ordered counterclockwise, size
            / Cell2DTotalNumber()xCell2DNumberVertices() \return the Cell1Ds data
            """
            pass

        def check_mesh_geometric_data3_d(
            self,
            configuration: MeshUtilities.CheckMeshGeometricData3DConfiguration,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            geometric_data: MeshUtilities.MeshGeometricData3D
            ) -> None:
            """/ \brief Check MeshGeometricData3D correctness
            / \param Gedim::GeometryUtilities the geometry utilities
            / \param mesh the 3D mesh
            / \param geometricData the mesh geometric data
            """
            pass

        def mesh1_d_from_segment(
            self,
            geometry_utilities: GeometryUtilities,
            segment_vertices: Eigen.MatrixXd,
            vertex_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Create a Mesh 1D with a segment
            / \param segmentVertices the segment coordinates, size 3x2
            / \param vertexMarkers mesh markers of vertices, size 1xNumPolygonVertices()
            """
            pass

        def mesh2_d_from_polygon(
            self,
            polygon_vertices: Eigen.MatrixXd,
            vertex_markers: List[int],
            edge_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Create a Mesh 2D with a polygon
            / \param polygonVertices the polygon coordinates, size 3xNumPolygonVertices()
            / \param vertexMarkers mesh markers of vertices, size 1xNumPolygonVertices()
            / \param edgeMarkers mesh markers of edges, size 1xNumPolygonVertices()
            """
            pass

        def set_mesh_markers_on_line(
            self,
            geometry_utilities: GeometryUtilities,
            line_origin: Eigen.Vector3d,
            line_tangent: Eigen.Vector3d,
            line_tangent_squared_length: float,
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Set the marker on all the mesh 2D elements laying on the line
            / \param Gedim::GeometryUtilities the geometry utilities
            / \param lineTangent the line tangent
            / \param lineOrigin the line origin
            / \param lineTangentSquaredLength the line tangent squared length
            / \param marker the marker
            / \param mesh the mesh
            """
            pass

        def set_mesh_markers_on_segment(
            self,
            geometry_utilities: GeometryUtilities,
            segment_origin: Eigen.Vector3d,
            segment_tangent: Eigen.Vector3d,
            segment_tangent_squared_length: float,
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            pass

        def mesh3_d_from_polyhedron(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            vertex_markers: List[int],
            edge_markers: List[int],
            face_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Create a Mesh 3D with a polyhedron
            / \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
            / \param polyhedronEdges the polyhedron edges, size 2 x numEdges
            / \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
            / \param vertexMarkers mesh markers of vertices, size 1xnumVertices
            / \param edgeMarkers mesh markers of edges, size 1xnumEdges
            / \param faceMarkers mesh markers of faces, size 1xnumFaces
            """
            pass

        def set_mesh_markers_on_plane(
            self,
            geometry_utilities: GeometryUtilities,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Set the marker on all the mesh 3D elements laying on the plane
            / \param Gedim::GeometryUtilities the geometry utilities
            / \param planeNormal the plane normal
            / \param planeOrigin the plane origin
            / \param marker the marker
            / \param mesh the mesh
            """
            pass

        def set_mesh_markers_by_face_normal(
            self,
            geometry_utilities: GeometryUtilities,
            normal: Eigen.Vector3d,
            cell2_ds_normal: List[Eigen.Vector3d],
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            pass

        @overload
        def set_mesh_markers_on_polygon(
            self,
            geometry_utilities: GeometryUtilities,
            polygon_plane_normal: Eigen.Vector3d,
            polygon_plane_origin: Eigen.Vector3d,
            polygon_vertices_2_d: Eigen.MatrixXd,
            polygon_translation: Eigen.Vector3d,
            polygon_rotation_matrix: Eigen.Matrix3d,
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            """/ \warning Only for convex points"""
            pass

        @overload
        def set_mesh_markers_on_polygon(
            self,
            geometry_utilities: GeometryUtilities,
            polygon_plane_normal: Eigen.Vector3d,
            polygon_plane_origin: Eigen.Vector3d,
            polygon_vertices_2_d: Eigen.MatrixXd,
            polygon_translation: Eigen.Vector3d,
            polygon_rotation_matrix: Eigen.Matrix3d,
            cell1_ds_centroid: List[Eigen.Vector3d],
            cell2_ds_centroid: List[Eigen.Vector3d],
            marker: int,
            mesh: IMeshDAO
            ) -> None:
            pass

        def mesh_cell2_d_roots(self, mesh: IMeshDAO) -> List[int]:
            """/ \brief Extract the mesh Cell2D Roots
            / \param mesh the mesh
            / \return the root cell for each cell2D, size 1xCell2DTotalNumber()
            """
            pass

        def fill_mesh1_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            convex_mesh: IMeshDAO
            ) -> MeshUtilities.MeshGeometricData1D:
            """/ \brief Fill Mesh1D Geometric Data given a mesh with convex mesh cells
            / \param convexMesh the convex mesh
            / \return the MeshGeometricData computed
            """
            pass

        def import_mesh_geometric_data1_d_from_txt(
            self,
            file_path: str
            ) -> MeshUtilities.MeshGeometricData1D:
            pass
        def export_mesh_geometric_data1_d_to_txt(
            self,
            mesh_geometric_data: MeshUtilities.MeshGeometricData1D,
            file_path: str
            ) -> None:
            pass

        @overload
        def fill_mesh2_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            convex_mesh: IMeshDAO
            ) -> MeshUtilities.MeshGeometricData2D:
            """/ \brief Fill Mesh2D Geometric Data given a mesh with convex mesh cells
            / \param convexMesh the convex mesh
            / \return the MeshGeometricData computed
            """
            pass

        @overload
        def fill_mesh2_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            mesh_cell2_ds_polygon_type: List[GeometryUtilities.PolygonTypes]
            ) -> MeshUtilities.MeshGeometricData2D:
            """/ \brief Fill Mesh2D Geometric Data given a mesh with mesh cells type
            / \param mesh the mesh
            / \param meshCell2DsPolygonType the cell2D polygon type
            / \return the MeshGeometricData computed
            """
            pass

        @overload
        def fill_mesh2_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            convex_mesh: IMeshDAO,
            mesh_cell2_d_to_convex_cell2_d_indices: List[List[int]]
            ) -> MeshUtilities.MeshGeometricData2D:
            """/ \brief Fill Mesh2D Geometric Data starting given a mesh with non convex mesh cells and its convex sub-mesh cells
            / \param mesh the mesh
            / \param convexMesh the convex mesh cells of mesh
            / \param meshCell2DToConvexCell2DIndices the collection of convex cell2Ds for each mesh cell2D
            / \return the MeshGeometricData computed
            """
            pass

        def import_mesh_geometric_data2_d_from_txt(
            self,
            file_path: str
            ) -> MeshUtilities.MeshGeometricData2D:
            pass
        def export_mesh_geometric_data2_d_to_txt(
            self,
            mesh_geometric_data: MeshUtilities.MeshGeometricData2D,
            file_path: str
            ) -> None:
            pass

        @overload
        def fill_mesh3_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            convex_mesh: IMeshDAO
            ) -> MeshUtilities.MeshGeometricData3D:
            """/ \brief Fill Mesh3D Geometric Data given a mesh with convex mesh cells
            / \param convexMesh the convex mesh
            / \return the MeshGeometricData computed
            """
            pass

        @overload
        def fill_mesh3_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            convex_mesh: IMeshDAO,
            mesh_cell3_d_to_convex_cell3_d_indices: List[List[int]]
            ) -> MeshUtilities.MeshGeometricData3D:
            """/ \brief Fill Mesh3D Geometric Data starting given a mesh with non convex mesh cells and its convex sub-mesh cells
            / \param mesh the mesh
            / \param convexMesh the convex mesh
            / \param meshCell2DToConvexCell2DIndices the collection of convex cell2Ds for each mesh cell2D
            / \param meshCell3DToConvexCell3DIndices the collection of convex cell3Ds for each mesh cell3D
            / \return the MeshGeometricData computed
            """
            pass

        @overload
        def fill_mesh3_d_geometric_data(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            cell3_ds_tetra_vertices: List[List[Eigen.MatrixXd]],
            cell2_ds_triangles_3_d_vertices: List[List[Eigen.Matrix3d]]
            ) -> MeshUtilities.MeshGeometricData3D:
            pass

        def import_mesh_geometric_data3_d_from_txt(
            self,
            file_path: str
            ) -> MeshUtilities.MeshGeometricData3D:
            pass
        def export_mesh_geometric_data3_d_to_txt(
            self,
            mesh_geometric_data: MeshUtilities.MeshGeometricData3D,
            file_path: str
            ) -> None:
            pass

        def compute_cell0_d_cell1_d_neighbours(self, mesh: IMeshDAO) -> None:
            pass
        def compute_cell0_d_cell2_d_neighbours(self, mesh: IMeshDAO) -> None:
            pass
        def compute_cell0_d_cell3_d_neighbours(self, mesh: IMeshDAO) -> None:
            pass

        def compute_cell1_d_cell2_d_neighbours(self, mesh: IMeshDAO) -> None:
            """/ \brief Compute Cell1D Cell2DNeighbours with given mesh data
            / \param mesh the resulting mesh
            """
            pass

        def compute_cell1_d_cell3_d_neighbours(self, mesh: IMeshDAO) -> None:
            """/ \brief Compute Cell1D Cell3DNeighbours with given mesh data
            / \param mesh the resulting mesh
            """
            pass

        def compute_cell2_d_cell3_d_neighbours(self, mesh: IMeshDAO) -> None:
            """/ \brief Compute Cell2D Cell3DNeighbours with given mesh data
            / \param mesh the resulting mesh
            """
            pass

        def create_rectangle_mesh(
            self,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            base_mesh_curvilinear_coordinates: List[float],
            height_mesh_curvilinear_coordinates: List[float],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Crete rectange Mesh on rectangle base x height
            / \param rectangleOrigin the rectangle origin point
            / \param rectangleBaseTangent the rectangle base tangent vector
            / \param rectangleHeightTangent the rectangle height tangent vector
            / \param baseMeshCurvilinearCoordinates the base mesh 1D curvilinear coordinates
            / \param heightMeshCurvilinearCoordinates the height mesh 1D curvilinear coordinates
            / \note markers on border are set as { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *
            / numVertices } for cell1Ds
            """
            pass

        def create_parallelepiped_mesh(
            self,
            rectangle_origin: Eigen.Vector3d,
            rectangle_length_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            rectangle_width_tangent: Eigen.Vector3d,
            length_mesh_curvilinear_coordinates: List[float],
            height_mesh_curvilinear_coordinates: List[float],
            width_mesh_curvilinear_coordinates: List[float],
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_triangle_plus_hanging_nodes_mesh(
            self,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            base_mesh_curvilinear_coordinates: List[float],
            height_mesh_curvilinear_coordinates: List[float],
            number_of_added_vertices_for_each_rectangle: List[int],
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_rectangle_plus_hanging_nodes_mesh(
            self,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            base_mesh_curvilinear_coordinates: List[float],
            height_mesh_curvilinear_coordinates: List[float],
            number_of_added_vertices_for_each_rectangle: List[int],
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_triangular_mesh(
            self,
            polygon_vertices: Eigen.MatrixXd,
            max_triangle_area: float,
            mesh: IMeshDAO,
            options: str = "-QDzpqnea"
            ) -> None:
            """/ \brief Create triangular mesh on 2D polygon
            / \param polygonVertices the 2D polygon vertices, size 3xnumVertices
            / \param maxTriangleArea the maximum triangular area
            / \param options mesh options, see https://www.cs.cmu.edu/~quake/triangle.switch.html
            / \note markers on border are set as { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *
            / numVertices } for cell1Ds \note use triangle library
            """
            pass

        def create_polygonal_mesh(
            self,
            geometry_utilities: GeometryUtilities,
            polygon_vertices: Eigen.MatrixXd,
            num_points: int,
            num_iterations: int,
            mesh: IMeshDAO,
            random_seed: int = 0
            ) -> None:
            pass

        #/ \brief Create tetrahedral mesh on 3D polyhedron
        #/ \param polyhedronVertices the polyhedron vertices, size 3 x numVertices
        #/ \param polyhedronEdges the polyhedron edges, size 2 x numEdges
        #/ \param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices
        #/ \param maxTetrahedronVolume the maximum tetrahedron area
        #/ \param options mesh options, see https://wias-berlin.de/software/tetgen/1.5/doc/manual/manual005.html#cmd-q
        #/ \note markers on border are set as { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *
        #/ numVertices } for cell1Ds \note use tetgen library
        @overload
        def create_tetrahedral_mesh(
            self,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            max_tetrahedron_volume: float,
            mesh: IMeshDAO,
            options: str = "Qpqfezna"
            ) -> None:
            pass
        @overload
        def create_tetrahedral_mesh(
            self,
            points: Eigen.MatrixXd,
            facets: List[List[int]],
            max_tetrahedron_volume: float,
            mesh: IMeshDAO,
            options: str = "Qpqfezna"
            ) -> None:
            pass

        def create_delaunay_mesh3_d(
            self,
            points: Eigen.MatrixXd,
            points_marker: List[int],
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_polyhedral_mesh(
            self,
            geometry_utilities: GeometryUtilities,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            num_points: int,
            num_iterations: int,
            mesh: IMeshDAO,
            random_seed: int = 0
            ) -> None:
            pass

        def make_mesh_triangular_faces(
            self,
            faces_triangulation: List[List[int]],
            mesh: IMeshDAO
            ) -> None:
            pass

        def import_open_volume_mesh(
            self,
            ovm_file_path: str,
            mesh: IMeshDAO,
            mesh_cell3_ds_faces_orientation: List[List[bool]]
            ) -> None:
            """/ \brief Import 3D mesh from OVM file"""
            pass

        def export_mesh_to_open_volume(
            self,
            mesh: IMeshDAO,
            mesh_cell3_ds_faces_orientation: List[List[bool]],
            ovm_file_path: str
            ) -> None:
            """/ \brief Export 3D mesh to OVM file"""
            pass

        def import_vtk_mesh3_d(self, vtk_file_path: str, mesh: IMeshDAO) -> None:
            """/ \brief Import 3D mesh from VTK file"""
            pass

        def import_object_file_format(self, off_file_path: str, mesh: IMeshDAO) -> None:
            """/ \brief Import 2D mesh from OFF file"""
            pass

        def export_mesh_to_object_file_format(
            self,
            mesh: IMeshDAO,
            off_file_path: str
            ) -> None:
            """/ \brief Export 2D mesh to OFF file"""
            pass

        def change_polygon_mesh_markers(
            self,
            polygon_vertices: Eigen.MatrixXd,
            cell0_d_markers: List[int],
            cell1_d_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Change Polygon Mesh Markers from { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *
            / numVertices } for cell1Ds to cell0DMarkers and cell1DMarkers \param polygonVertices the 2D polygon vertices,
            / size 3xnumVertices \param cell0DMarkers the new cell0D markers, size 1xnumPolygonVertices \param cell1DMarkers
            / the new cell1D markers, size 1xnumPolygonVertices \param mesh the mesh
            """
            pass

        def change_polyhedron_mesh_markers(
            self,
            geometry_utilities: GeometryUtilities,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_edges_tangent: Eigen.MatrixXd,
            polyhedron_edges_length: Eigen.VectorXd,
            polyhedron_faces_normal: List[Eigen.Vector3d],
            polyhedron_faces_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_vertices_2_d: List[Eigen.MatrixXd],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_vertices_marker: List[int],
            polyhedron_edges_marker: List[int],
            polyhedron_faces_marker: List[int],
            cell1_ds_centroid: List[Eigen.Vector3d],
            cell2_ds_centroid: List[Eigen.Vector3d],
            mesh: IMeshDAO
            ) -> None:
            pass

        def export_mesh_to_vtu(
            self,
            mesh: IMeshDAO,
            export_folder: str,
            file_name: str,
            separate_file: bool = False
            ) -> None:
            """/ \brief Export Mesh To VTU
            / \param mesh the mesh
            / \param exportFolder the folder in which the mesh is exported
            """
            pass

        def export_mesh_to_ucd(
            self,
            mesh: IMeshDAO,
            export_folder: str,
            file_name: str,
            separate_file: bool = False
            ) -> None:
            """/ \brief Export Mesh To UCD
            / \param mesh the mesh
            / \param exportFolder the folder in which the mesh is exported
            """
            pass

        def export_cell2_d_to_vtu(
            self,
            mesh: IMeshDAO,
            cell2_d_index: int,
            cell2_d_vertices: Eigen.MatrixXd,
            cell2_d_triangulations: List[Eigen.Matrix3d],
            cell2_d_area: float,
            cell2_d_centroid: Eigen.Vector3d,
            export_folder: str
            ) -> None:
            """/ \brief Export Cell2D To VTU
            / \param mesh the mesh
            / \param cell2DIndex the cell2D index
            / \param cell2DVertices the cell2D vertices
            / \param cell2DTriangulations the cell2D triangulation
            / \param cell2DArea the cell2D area
            / \param cell2DCentroid the cell2D centroid
            / \param exportFolder the folder in which to export
            """
            pass

        def export_cell3_d_to_vtu(
            self,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            cell3_d_index: int,
            cell3_d_vertices: Eigen.MatrixXd,
            cell3_d_tetrahedrons: List[Eigen.MatrixXd],
            cell3_d_faces3_d_triangulations: List[List[Eigen.Matrix3d]],
            cell3_d_volume: float,
            cell3_d_centroid: Eigen.Vector3d,
            cell3_d_faces_translation: List[Eigen.Vector3d],
            cell3_d_faces_rotation_matrix: List[Eigen.Matrix3d],
            cell3_d_faces_area: List[float],
            cell3_d_faces2_d_vertices: List[Eigen.MatrixXd],
            cell3_d_faces3_d_vertices: List[Eigen.MatrixXd],
            cell3_d_faces_edge_lengths: List[Eigen.VectorXd],
            cell3_d_faces_edge_directions: List[List[bool]],
            cell3_d_faces_edges2_d_tangent: List[Eigen.MatrixXd],
            cell3_d_faces_edges2_d_normal: List[Eigen.MatrixXd],
            cell3_d_faces_normals: List[Eigen.Vector3d],
            cell3_d_faces_normal_directions: List[bool],
            cell3_d_faces2_d_centroids: List[Eigen.Vector3d],
            export_folder: str
            ) -> None:
            pass

        def mesh_cell3_d_to_polyhedron(
            self,
            mesh: IMeshDAO,
            cell3_d_index: int
            ) -> GeometryUtilities.Polyhedron:
            """/ \brief Convert a mesh cell3D to a geometric polydheron
            / \param mesh a mesh
            / \param cell3DIndex the cell3D index
            / \return polyhedron from mesh 3D cell
            """
            pass

        def mesh_cell3_d_to_vtp_polyhedron(
            self,
            mesh: IMeshDAO,
            cell3_d_index: int
            ) -> MeshUtilities.VTPPolyhedron:
            """/ \brief Convert a mesh cell3D to a VTP polydheron
            / \param mesh a mesh
            / \param cell3DIndex the cell3D index
            / \return VTP polyhedron from mesh 3D cell
            """
            pass

        def split_cell1_d(
            self,
            cell1_d_index: int,
            sub_cell1_ds: Eigen.MatrixXi,
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Split cell2D into subcells
            / \param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()
            / \param subCell1Ds the list of sub-cells 1D mesh vertices indices, size 2 x numSubCells)
            / \param mesh the mesh to update
            / \return the list of new cell1Ds indices, from 0 to Cell1DTotalNumber()
            """
            pass

        def split_cell2_d(
            self,
            cell2_d_index: int,
            sub_cell2_ds: List[Eigen.MatrixXi],
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Split cell2D into subcells
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param subCell2Ds the list of sub-cells 2D mesh vertices and edges indices, size numSubCells x (2 x numVertices)
            / \param mesh the mesh to update
            / \return the list of new cell2Ds indices, from 0 to Cell2DTotalNumber()
            """
            pass

        def split_cell3_d(
            self,
            cell3_d_index: int,
            sub_cell3_ds_vertices: List[List[int]],
            sub_cell3_ds_edges: List[List[int]],
            sub_cell3_ds_faces: List[List[int]],
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Split cell3D into subcells
            / \param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()
            / \param subCell3Ds the list of sub-cells 3D mesh vertices and edges indices, size numSubCells x (2 x numVertices)
            / \param mesh the mesh to update
            / \return the list of new cell3Ds indices, from 0 to Cell3DTotalNumber()
            """
            pass

        @overload
        def agglomerate_cell1_ds(
            self,
            cell1_ds_index: std.unordered_set[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateCell1DInformation:
            pass

        @overload
        def agglomerate_cell2_ds(
            self,
            geometry_utilities: GeometryUtilities,
            cell2_ds_index: std.unordered_set[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateCell2DInformation:
            pass

        @overload
        def agglomerate_cell3_ds(
            self,
            cell3_ds_index: std.unordered_set[int],
            mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateCell3DInformation:
            pass

        @overload
        def agglomerate_cell1_ds(
            self,
            sub_cell1_ds_index: std.unordered_set[int],
            agglomerate_cell1_d_vertices: List[int],
            sub_cell1_ds_removed_cell0_ds: List[int],
            mesh: IMeshDAO,
            mesh_cell1_ds_original_cell1_ds: List[List[int]],
            mantain_neigh2_d_order: bool = False
            ) -> int:
            pass

        @overload
        def agglomerate_cell2_ds(
            self,
            sub_cell2_ds_index: std.unordered_set[int],
            agglomerate_cell2_d_vertices: List[int],
            agglomerate_cell2_d_edges: List[int],
            sub_cell2_ds_removed_cell0_ds: List[int],
            sub_cell2_ds_removed_cell1_ds: List[int],
            mesh: IMeshDAO,
            mesh_cell2_ds_original_cell2_ds: List[List[int]]
            ) -> int:
            pass

        @overload
        def agglomerate_cell3_ds(
            self,
            sub_cell3_ds_index: std.unordered_set[int],
            agglomerate_cell3_d_vertices: List[int],
            agglomerate_cell3_d_edges: List[int],
            agglomerate_cell3_d_faces: List[int],
            sub_cell3_ds_removed_cell0_ds: List[int],
            sub_cell3_ds_removed_cell1_ds: List[int],
            sub_cell3_ds_removed_cell2_ds: List[int],
            mesh: IMeshDAO,
            mesh_cell3_ds_original_cell3_ds: List[List[int]]
            ) -> int:
            pass

        def create_randomly_deformed_quadrilaterals(
            self,
            geometry_utilities: GeometryUtilities,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            num_quadrilaterals_base_tangent: int,
            num_quadrilaterals_height_tangent: int,
            max_deforming_percentage_base: float,
            max_deforming_percentage_height: float,
            mesh: IMeshDAO
            ) -> None:
            pass

        def create_distorted_quadrilaterals(
            self,
            geometry_utilities: GeometryUtilities,
            rectangle_origin: Eigen.Vector3d,
            rectangle_base_tangent: Eigen.Vector3d,
            rectangle_height_tangent: Eigen.Vector3d,
            num_quadrilaterals_base_tangent: int,
            num_quadrilaterals_height_tangent: int,
            mesh: IMeshDAO
            ) -> None:
            pass
        def find_cell2_ds_common_vertices(
            self,
            cell2_ds_index: List[int],
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Given a set of Cell2Ds find the common Cell0Ds
            / \param cell2DsIndex the cell2Ds index
            / \param mesh the mesh
            / \return the Cell0D indices
            """
            pass

        def find_cell2_ds_common_edges(
            self,
            cell2_ds_index: List[int],
            mesh: IMeshDAO
            ) -> List[int]:
            """/ \brief Given a set of Cell2Ds find the common Cell1Ds
            / \param cell2DsIndex the cell2Ds index
            / \param mesh the mesh
            / \return the Cell1D indices
            """
            pass

        @overload
        def find_concave_cell3_d_faces_convex_cell2_d(
            self,
            geometry_utilities: GeometryUtilities,
            concave_cell3_d_index: int,
            mesh: IMeshDAO,
            convex_mesh: IMeshDAO,
            convex_cell3_d_indices: List[int],
            concave_cell3_d_faces3_d_vertices: List[Eigen.MatrixXd],
            concave_cell3_d_faces2_d_vertices: List[Eigen.MatrixXd],
            concave_cell3_d_faces_translation: List[Eigen.Vector3d],
            concave_cell3_d_faces_rotation_matrix: List[Eigen.Matrix3d],
            concave_cell3_d_faces_normal: List[Eigen.Vector3d],
            convex_cell3_ds_faces3_d_vertices: List[List[Eigen.MatrixXd]],
            convex_cell3_ds_faces_unaligned_vertices: List[List[List[int]]]
            ) -> MeshUtilities.FindConcaveCell3DFacesConvexCell2DResult:
            pass

        @overload
        def find_concave_cell3_d_faces_convex_cell2_d(
            self,
            geometry_utilities: GeometryUtilities,
            concave_cell3_d_index: int,
            mesh: IMeshDAO,
            concave_cell3_d_tetra: List[Eigen.MatrixXd],
            concave_cell3_d_faces_2_d_triangles: List[List[Eigen.Matrix3d]],
            concave_cell3_d_faces3_d_vertices: List[Eigen.MatrixXd],
            concave_cell3_d_faces_translation: List[Eigen.Vector3d],
            concave_cell3_d_faces_rotation_matrix: List[Eigen.Matrix3d],
            concave_cell3_d_faces_normal: List[Eigen.Vector3d],
            convex_cell3_ds_faces3_d_vertices: List[List[Eigen.MatrixXd]],
            convex_cell3_ds_faces_unaligned_vertices: List[List[List[int]]]
            ) -> MeshUtilities.FindConcaveCell3DFacesConvexCell2DResult:
            pass

        @overload
        def find_point_mesh_position(
            self,
            find_cell2_d_result: MeshUtilities.FindPointCell2DResult,
            mesh: IMeshDAO
            ) -> MeshUtilities.FindPointMeshPositionResult:
            pass

        @overload
        def find_point_mesh_position(
            self,
            find_cell3_d_result: MeshUtilities.FindPointCell3DResult,
            mesh: IMeshDAO
            ) -> MeshUtilities.FindPointMeshPositionResult:
            pass

        def find_point_cell2_d(
            self,
            geometry_utilities: GeometryUtilities,
            point: Eigen.Vector3d,
            mesh: IMeshDAO,
            cell2_ds_vertices: List[Eigen.MatrixXd],
            cell2_ds_bounding_box: List[Eigen.MatrixXd],
            find_only_first_cell2_d: bool = True,
            starting_cell2_d_index: int = 0
            ) -> MeshUtilities.FindPointCell2DResult:
            pass

        @overload
        def find_point_cell3_d(
            self,
            geometry_utilities: GeometryUtilities,
            point: Eigen.Vector3d,
            mesh: IMeshDAO,
            cell3_ds_faces: List[List[Eigen.MatrixXi]],
            cell3_ds_face_vertices: List[List[Eigen.MatrixXd]],
            cell3_ds_face_rotated_vertices: List[List[Eigen.MatrixXd]],
            cell3_ds_face_normals: List[List[Eigen.Vector3d]],
            cell3_ds_face_normal_directions: List[List[bool]],
            cell3_ds_face_translations: List[List[Eigen.Vector3d]],
            cell3_ds_face_rotation_matrices: List[List[Eigen.Matrix3d]],
            cell3_ds_bounding_box: List[Eigen.MatrixXd],
            find_only_first_cell3_d: bool = True,
            starting_cell3_d_index: int = 0
            ) -> MeshUtilities.FindPointCell3DResult:
            pass

        @overload
        def find_point_cell3_d(
            self,
            geometry_utilities: GeometryUtilities,
            point: Eigen.Vector3d,
            mesh: IMeshDAO,
            cell3_ds_faces: List[List[Eigen.MatrixXi]],
            cell3_ds_face_vertices: List[List[Eigen.MatrixXd]],
            cell3_ds_face_rotated_vertices: List[List[Eigen.MatrixXd]],
            cell3_ds_face_normals: List[List[Eigen.Vector3d]],
            cell3_ds_face_normal_directions: List[List[bool]],
            cell3_ds_face_translations: List[List[Eigen.Vector3d]],
            cell3_ds_face_rotation_matrices: List[List[Eigen.Matrix3d]],
            cell3_ds_bounding_box: List[Eigen.MatrixXd],
            cell3_ds_tetrahedra: List[List[Eigen.MatrixXd]],
            find_only_first_cell3_d: bool,
            starting_cell3_d_index: int
            ) -> MeshUtilities.FindPointCell3DResult:
            pass

        def agglomerate_triangles(
            self,
            triangles_index_to_agglomerate: List[int],
            triangular_mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateTrianglesResult:
            """/ \brief Agglomerate Triangles with one vertex in common
            / \param trianglesIndexToAgglomerate the cell2Ds triangular index in the mesh
            / \param triangularMesh the triangular mesh
            / \return the agglomearted polygon indices
            / \note the triangular index shall be done counterclockwise
            """
            pass

        def agglomerate_mesh_from_triangular_mesh(
            self,
            triangles_indices_to_agglomerate: List[List[int]],
            triangular_mesh: IMeshDAO
            ) -> MeshUtilities.AgglomerateMeshFromTriangularMeshResult:
            pass

        def import_agglomeration_information_from_csv(
            self,
            geometry_utilities: GeometryUtilities,
            original_mesh: IMeshDAO,
            agglomerated_mesh: IMeshDAO,
            file_name: str,
            separator: str
            ) -> MeshUtilities.AgglomerationInformation:
            """/ \brief Import Agglomeration mesh Information From file Csv
            / \param Gedim::GeometryUtilities the geometry utilities
            / \param originalMesh the original mesh
            / \param agglomeratedMesh the agglomerated mesh
            / \param fileName the csv file name
            / \param separator the csv file separator
            / \param originalCell0DToAgglomeratedCell0Ds original Cell0Ds to agglomerated Cell0Ds
            / \param originalCell1DToAgglomeratedCell1Ds original Cell1Ds to agglomerated Cell1Ds
            / \param originalCell2DToAgglomeratedCell2Ds original Cell2Ds to agglomerated Cell2Ds
            / \param agglomeratedCell0DToOriginalCell0Ds agglomerated Cell0Ds to original Cell0Ds
            / \param agglomeratedCell1DToOriginalCell1Ds agglomerated Cell1Ds to original Cell1Ds
            / \param agglomeratedCell2DToOriginalCell2Ds agglomerated Cell2Ds to original Cell2Ds
            """
            pass

        def import_agglomeration_information_from_off(
            self,
            geometry_utilities: GeometryUtilities,
            original_mesh: IMeshDAO,
            agglomerated_mesh: IMeshDAO,
            file_name: str,
            separator: str
            ) -> MeshUtilities.AgglomerationInformation:
            """/ \brief Import Agglomeration mesh Information From file OFF
            / \param Gedim::GeometryUtilities the geometry utilities
            / \param originalMesh the original mesh
            / \param agglomeratedMesh the agglomerated mesh
            / \param fileName the csv file name
            / \param separator the csv file separator
            / \param originalCell0DToAgglomeratedCell0Ds original Cell0Ds to agglomerated Cell0Ds
            / \param originalCell1DToAgglomeratedCell1Ds original Cell1Ds to agglomerated Cell1Ds
            / \param originalCell2DToAgglomeratedCell2Ds original Cell2Ds to agglomerated Cell2Ds
            / \param agglomeratedCell0DToOriginalCell0Ds agglomerated Cell0Ds to original Cell0Ds
            / \param agglomeratedCell1DToOriginalCell1Ds agglomerated Cell1Ds to original Cell1Ds
            / \param agglomeratedCell2DToOriginalCell2Ds agglomerated Cell2Ds to original Cell2Ds
            """
            pass

        def export_mesh_to_csv(
            self,
            mesh: IMeshDAO,
            separator: str,
            export_folder_path: str
            ) -> None:
            """/ \brief Export mesh to csv file"""
            pass

        def export_concave_mesh2_d_to_csv(
            self,
            mesh: IMeshDAO,
            convex_cell2_ds_index: List[List[int]],
            separator: str,
            export_folder_path: str
            ) -> None:
            """/ \brief Export 2D concave mesh to csv file"""
            pass

        def mark_cells(
            self,
            marking_function: Callable[[ Eigen.MatrixXd ], Eigen.VectorXi],
            cells_points: List[Eigen.MatrixXd],
            default_mark: int
            ) -> List[int]:
            pass

        def intersect_mesh_polyhedron(
            self,
            geometry_utilities: GeometryUtilities,
            polyhedron_vertices: Eigen.MatrixXd,
            polyhedron_edges: Eigen.MatrixXi,
            polyhedron_edges_vertices: List[Eigen.MatrixXd],
            polyhedron_edges_tangent: Eigen.MatrixXd,
            polyhedron_edges_bouding_box: List[Eigen.MatrixXd],
            polyhedron_faces: List[Eigen.MatrixXi],
            polyhedron_faces_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_rotated_vertices: List[Eigen.MatrixXd],
            polyhedron_faces_normals: List[Eigen.Vector3d],
            polyhedron_faces_normal_direction: List[bool],
            polyhedron_faces_translation: List[Eigen.Vector3d],
            polyhedron_faces_rotation_matrix: List[Eigen.Matrix3d],
            polyhedron_faces_bouding_box: List[Eigen.MatrixXd],
            polyhedron_bouding_box: Eigen.MatrixXd,
            mesh: IMeshDAO,
            mesh_cell1_ds_bouding_box: List[Eigen.MatrixXd],
            mesh_cell1_ds_vertices: List[Eigen.MatrixXd],
            mesh_cell1_ds_tangent: List[Eigen.Vector3d],
            mesh_cell2_ds_vertices: List[Eigen.MatrixXd],
            mesh_cell2_ds_normal: List[Eigen.Vector3d],
            mesh_cell2_ds_2_d_vertices: List[Eigen.MatrixXd],
            mesh_cell2_ds_translation: List[Eigen.Vector3d],
            mesh_cell2_ds_rotation_matrix: List[Eigen.Matrix3d],
            mesh_cell2_ds_bouding_box: List[Eigen.MatrixXd],
            mesh_cell3_ds_bouding_box: List[Eigen.MatrixXd],
            mesh_cell3_ds_faces: List[List[Eigen.MatrixXi]],
            mesh_cell3_ds_faces_vertices: List[List[Eigen.MatrixXd]],
            mesh_cell3_ds_faces_2_d_vertices: List[List[Eigen.MatrixXd]],
            mesh_cell3_ds_faces_normal: List[List[Eigen.Vector3d]],
            mesh_cell3_ds_faces_normal_directions: List[List[bool]],
            mesh_cell3_ds_faces_translation: List[List[Eigen.Vector3d]],
            mesh_cell3_ds_faces_rotation_matrix: List[List[Eigen.Matrix3d]]
            ) -> MeshUtilities.Intersect_mesh_polyhedron_result:
            pass

        def set_polygon_mesh_markers(
            self,
            geometry_utilities: GeometryUtilities,
            polygon_vertices: Eigen.MatrixXd,
            cell0_d_markers: List[int],
            cell1_d_markers: List[int],
            mesh: IMeshDAO
            ) -> None:
            pass

        def check_mesh_geometric_data2_d(
            self,
            configuration: MeshUtilities.CheckMeshGeometricData2DConfiguration,
            geometry_utilities: GeometryUtilities,
            mesh: IMeshDAO,
            geometric_data: MeshUtilities.MeshGeometricData2D
            ) -> None:
            pass

        def create_polygon_intersection_mesh(
            self,
            geometry_utilities: GeometryUtilities,
            interface_vertices: Eigen.MatrixXd,
            mesh: IMeshDAO
            ) -> None:
            pass


# </submodule gedim>
####################    </generated_from:MeshUtilities.hpp>    ####################


####################    <generated_from:PlatonicSolid.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __PlatonicSolid_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class PlatonicSolid:
        """/ \brief MeshUtilities
        / \copyright See top level LICENSE file for details.
        /
        / https://danielsieger.com/blog/2021/01/03/generating-platonic-solids.html
        (final class)
        """
        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            mesh_utilities: MeshUtilities
            ) -> None:
            pass


        def project_to_unit_sphere(self, polyhedron: GeometryUtilities.Polyhedron) -> None:
            pass

        def project_to_unit_sphere_geodesic(
            self,
            mesh_data: MeshMatrices,
            mesh: MeshMatricesDAO
            ) -> None:
            pass

        def project_to_unit_sphere_goldberg(
            self,
            mesh_data: MeshMatrices,
            mesh: MeshMatricesDAO
            ) -> None:
            pass

        def dual_polyhedron(
            self,
            polyhedron: GeometryUtilities.Polyhedron
            ) -> GeometryUtilities.Polyhedron:
            pass

        def first_class_geodesic_polyhedron(
            self,
            starting_polyhedron: GeometryUtilities.Polyhedron,
            frequency: int,
            filter_mesh: MeshMatricesDAO
            ) -> None:
            pass

        def second_class_geodesic_polyhedron(
            self,
            starting_polyhedron: GeometryUtilities.Polyhedron,
            frequency: int,
            filter_mesh: MeshMatricesDAO
            ) -> None:
            pass

        def goldberg_polyhedron(
            self,
            p: int,
            q: int,
            b: int,
            c: int
            ) -> GeometryUtilities.Polyhedron:
            pass

        def geodesic_polyhedron(
            self,
            p: int,
            q: int,
            b: int,
            c: int
            ) -> GeometryUtilities.Polyhedron:
            pass

        def tetrahedron(self) -> GeometryUtilities.Polyhedron:
            pass

        def hexahedron(self) -> GeometryUtilities.Polyhedron:
            pass

        def octahedron(self) -> GeometryUtilities.Polyhedron:
            pass

        def icosahedron(self) -> GeometryUtilities.Polyhedron:
            pass

        def dodecahedron(self) -> GeometryUtilities.Polyhedron:
            pass


# </submodule gedim>
####################    </generated_from:PlatonicSolid.hpp>    ####################


####################    <generated_from:RefinementUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __RefinementUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class RefinementUtilities:
        """/ \brief RefinementUtilities
        / \copyright See top level LICENSE file for details.
        (final class)
        """
        class TriangleMaxEdgeDirection:
            """
            (final class)
            """
            max_edge_index: int = 0
            opposite_vertex_index: int = 0
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class TetrahedronMaxEdgeDirection:
            """
            (final class)
            """
            max_edge_index: int = 0
            opposite_vertices_index: List[int] = List[int]()
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class PolygonDirection:
            """
            (final class)
            """
            line_origin: Eigen.Vector3d
            line_tangent: Eigen.Vector3d
            def __init__(
                self,
                line_origin: Eigen.Vector3d = Eigen.Vector3d(),
                line_tangent: Eigen.Vector3d = Eigen.Vector3d()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class MeshQuality:
            """
            (final class)
            """
            cell2_ds_quality: List[float]
            cell1_ds_quality: List[float]
            def __init__(
                self,
                cell2_ds_quality: List[float] = List[float](),
                cell1_ds_quality: List[float] = List[float]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class SplitCell1D_Result:
            """
            (final class)
            """
            new_cell0_d_index: int = 0
            new_cell1_ds_index: List[int] = List[int]()
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass

        class SplitPolygon_Result:
            """
            (final class)
            """
            class Types(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                split = enum.auto()                              # (= 1)
                no_split = enum.auto()                           # (= 2)

            type: Gedim.RefinementUtilities.SplitPolygon_Result.Types = Gedim.RefinementUtilities.SplitPolygon_Result.Types.unknown
            new_cell1_d_index: int = 0
            new_cell2_ds_index: List[int] = List[int]()
            def __init__(
                self,
                type: RefinementUtilities.SplitPolygon_Result.Types = RefinementUtilities.SplitPolygon_Result.Types.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolygon_CheckResult:
            """
            (final class)
            """
            class ResultTypes(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                cell2_d_to_be_splitted = enum.auto()             # (= 1)
                cell2_d_already_splitted = enum.auto()           # (= 2)
                cell2_d_split_under_tolerance = enum.auto()      # (= 3)
                split_direction_not_inside_cell2_d = enum.auto() # (= 4)

            class Cell1DToSplit:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                        # (= 0)
                    not_inside = enum.auto()                     # (= 1)
                    edge_length_not_enough = enum.auto()         # (= 2)
                    only_local_quality_not_enough = enum.auto()  # (= 3)
                    only_neigh_quality_not_enough = enum.auto()  # (= 4)
                    both_quality_not_enough = enum.auto()        # (= 5)
                    only_local_aligned_not_respect = enum.auto() # (= 6)
                    only_neigh_aligned_not_respect = enum.auto() # (= 7)
                    both_aligned_not_respect = enum.auto()       # (= 8)
                    to_split = enum.auto()                       # (= 9)

                is_intersection_inside: bool = False
                is_edge_length_enough: bool = False
                is_local_quality_enough: bool = False
                is_quality_enough: bool = False
                is_neigh_quality_enough: List[bool] = List[bool]()
                is_local_aligned_respect: bool = False
                is_aligned_respect: bool = False
                is_neigh_aligned_respect: List[bool] = List[bool]()
                is_to_split: bool = False
                cell2_d_edge_index: int = 0
                type: Gedim.RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit.Types = Gedim.RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit.Types.unknown
                def __init__(
                    self,
                    is_intersection_inside: bool = False,
                    is_edge_length_enough: bool = False,
                    is_local_quality_enough: bool = False,
                    is_quality_enough: bool = False,
                    is_neigh_quality_enough: List[bool] = List[bool](),
                    is_local_aligned_respect: bool = False,
                    is_aligned_respect: bool = False,
                    is_neigh_aligned_respect: List[bool] = List[bool](),
                    is_to_split: bool = False,
                    type: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit.Types = RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            cell1_ds_index: List[int] = List[int]()
            cell1_ds_intersection: List[Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection] = List[Gedim.GeometryUtilities.LinePolygonPositionResult.EdgeIntersection]()
            cell1_ds_to_split: List[Gedim.RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit] = List[Gedim.RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit]()
            result_type: Gedim.RefinementUtilities.RefinePolygon_CheckResult.ResultTypes = Gedim.RefinementUtilities.RefinePolygon_CheckResult.ResultTypes.unknown
            def __init__(
                self,
                cell1_ds_intersection: List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection] = List[GeometryUtilities.LinePolygonPositionResult.EdgeIntersection](),
                cell1_ds_to_split: List[RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit] = List[RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit](),
                result_type: RefinementUtilities.RefinePolygon_CheckResult.ResultTypes = RefinementUtilities.RefinePolygon_CheckResult.ResultTypes.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class CheckSplitType_Result:
            """
            (final class)
            """
            class SplitTypes(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                no_split = enum.auto()                           # (= 1)
                no_new_vertices = enum.auto()                    # (= 2)
                new_vertex_from = enum.auto()                    # (= 3)
                new_vertex_to = enum.auto()                      # (= 4)
                new_vertices = enum.auto()                       # (= 5)

            no_new_vertices_index: List[int] = List[int]()       #/< valid only for NoNewVertices type
            type: Gedim.RefinementUtilities.CheckSplitType_Result.SplitTypes = Gedim.RefinementUtilities.CheckSplitType_Result.SplitTypes.unknown
            def __init__(
                self,
                type: RefinementUtilities.CheckSplitType_Result.SplitTypes = RefinementUtilities.CheckSplitType_Result.SplitTypes.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolyhedron_Result:
            """
            (final class)
            """
            class ResultTypes(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                successfull = enum.auto()                        # (= 1)
                cell3_d_already_splitted = enum.auto()           # (= 2)
                cell3_d_split_under_tolerance = enum.auto()      # (= 3)
                cell3_d_split_none = enum.auto()                 # (= 4)

            class RefinedCell1D:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                        # (= 0)
                    updated = enum.auto()                        # (= 1)
                    new = enum.auto()                            # (= 2)

                type: Gedim.RefinementUtilities.RefinePolyhedron_Result.RefinedCell1D.Types = Gedim.RefinementUtilities.RefinePolyhedron_Result.RefinedCell1D.Types.unknown
                new_cell1_ds_index: List[int] = List[int]()
                original_cell1_d_index: int = 0
                new_cell0_d_index: int = 0
                original_cell3_d_edge_index: int = 0
                def __init__(
                    self,
                    type: RefinementUtilities.RefinePolyhedron_Result.RefinedCell1D.Types = RefinementUtilities.RefinePolyhedron_Result.RefinedCell1D.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class RefinedCell2D:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                        # (= 0)
                    updated = enum.auto()                        # (= 1)
                    new = enum.auto()                            # (= 2)

                type: Gedim.RefinementUtilities.RefinePolyhedron_Result.RefinedCell2D.Types = Gedim.RefinementUtilities.RefinePolyhedron_Result.RefinedCell2D.Types.unknown
                new_cell2_ds_index: List[int] = List[int]()
                original_cell2_d_index: int = 0
                new_cell1_d_index: int = 0
                new_cell1_ds_position: List[int] = List[int]()   #/< Position in NewCell1DsIndex array
                original_cell3_d_face_index: int = 0
                def __init__(
                    self,
                    type: RefinementUtilities.RefinePolyhedron_Result.RefinedCell2D.Types = RefinementUtilities.RefinePolyhedron_Result.RefinedCell2D.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            result_type: Gedim.RefinementUtilities.RefinePolyhedron_Result.ResultTypes = Gedim.RefinementUtilities.RefinePolyhedron_Result.ResultTypes.unknown
            new_cell0_ds_index: List[int] = List[int]()
            new_cell1_ds_index: List[Gedim.RefinementUtilities.RefinePolyhedron_Result.RefinedCell1D] = List[Gedim.RefinementUtilities.RefinePolyhedron_Result.RefinedCell1D]()
            new_cell2_ds_index: List[Gedim.RefinementUtilities.RefinePolyhedron_Result.RefinedCell2D] = List[Gedim.RefinementUtilities.RefinePolyhedron_Result.RefinedCell2D]()
            new_cell3_ds_index: List[int] = List[int]()
            def __init__(
                self,
                result_type: RefinementUtilities.RefinePolyhedron_Result.ResultTypes = RefinementUtilities.RefinePolyhedron_Result.ResultTypes.unknown,
                new_cell1_ds_index: List[RefinementUtilities.RefinePolyhedron_Result.RefinedCell1D] = List[RefinementUtilities.RefinePolyhedron_Result.RefinedCell1D](),
                new_cell2_ds_index: List[RefinementUtilities.RefinePolyhedron_Result.RefinedCell2D] = List[RefinementUtilities.RefinePolyhedron_Result.RefinedCell2D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolygon_Result:
            """
            (final class)
            """
            class ResultTypes(enum.IntEnum):
                unknown = enum.auto()                            # (= 0)
                successfull = enum.auto()                        # (= 1)
                cell2_d_already_splitted = enum.auto()           # (= 2)
                cell2_d_split_under_tolerance = enum.auto()      # (= 3)
                split_direction_not_inside_cell2_d = enum.auto() # (= 4)
                split_quality_check_cell2_d_failed = enum.auto() # (= 5)

            class RefinedCell1D:
                """
                (final class)
                """
                class Types(enum.IntEnum):
                    unknown = enum.auto()                        # (= 0)
                    updated = enum.auto()                        # (= 1)
                    new = enum.auto()                            # (= 2)

                type: Gedim.RefinementUtilities.RefinePolygon_Result.RefinedCell1D.Types = Gedim.RefinementUtilities.RefinePolygon_Result.RefinedCell1D.Types.unknown
                new_cell1_ds_index: List[int] = List[int]()
                original_cell1_d_index: int = 0
                new_cell0_d_index: int = 0
                original_cell2_d_edge_index: int = 0
                def __init__(
                    self,
                    type: RefinementUtilities.RefinePolygon_Result.RefinedCell1D.Types = RefinementUtilities.RefinePolygon_Result.RefinedCell1D.Types.unknown
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            new_cell0_ds_index: List[int] = List[int]()
            new_cell1_ds_index: List[Gedim.RefinementUtilities.RefinePolygon_Result.RefinedCell1D] = List[Gedim.RefinementUtilities.RefinePolygon_Result.RefinedCell1D]()
            new_cell2_ds_index: List[int] = List[int]()

            split_type: Gedim.RefinementUtilities.CheckSplitType_Result.SplitTypes = Gedim.RefinementUtilities.CheckSplitType_Result.SplitTypes.unknown
            result_type: Gedim.RefinementUtilities.RefinePolygon_Result.ResultTypes = Gedim.RefinementUtilities.RefinePolygon_Result.ResultTypes.unknown
            def __init__(
                self,
                new_cell1_ds_index: List[RefinementUtilities.RefinePolygon_Result.RefinedCell1D] = List[RefinementUtilities.RefinePolygon_Result.RefinedCell1D](),
                split_type: RefinementUtilities.CheckSplitType_Result.SplitTypes = RefinementUtilities.CheckSplitType_Result.SplitTypes.unknown,
                result_type: RefinementUtilities.RefinePolygon_Result.ResultTypes = RefinementUtilities.RefinePolygon_Result.ResultTypes.unknown
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolygon_UpdateNeighbour_Result:
            """
            (final class)
            """
            class UpdatedCell2D:
                """
                (final class)
                """
                original_cell2_d_index: int = 0
                new_cell2_d_index: int = 0
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            updated_cell2_ds: List[Gedim.RefinementUtilities.RefinePolygon_UpdateNeighbour_Result.UpdatedCell2D] = List[Gedim.RefinementUtilities.RefinePolygon_UpdateNeighbour_Result.UpdatedCell2D]()
            def __init__(
                self,
                updated_cell2_ds: List[RefinementUtilities.RefinePolygon_UpdateNeighbour_Result.UpdatedCell2D] = List[RefinementUtilities.RefinePolygon_UpdateNeighbour_Result.UpdatedCell2D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class RefinePolyhedron_UpdateNeighbour_Result:
            """
            (final class)
            """
            class UpdatedCell3D:
                """
                (final class)
                """
                original_cell3_d_index: int = 0
                new_cell3_d_index: int = 0
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            updated_cell3_ds: List[Gedim.RefinementUtilities.RefinePolyhedron_UpdateNeighbour_Result.UpdatedCell3D] = List[Gedim.RefinementUtilities.RefinePolyhedron_UpdateNeighbour_Result.UpdatedCell3D]()
            def __init__(
                self,
                updated_cell3_ds: List[RefinementUtilities.RefinePolyhedron_UpdateNeighbour_Result.UpdatedCell3D] = List[RefinementUtilities.RefinePolyhedron_UpdateNeighbour_Result.UpdatedCell3D]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Cell2Ds_GeometricData:
            """
            (final class)
            """
            class Cell2D_GeometricData:
                """
                (final class)
                """
                unaligned_vertices_index: List[List[int]] = List[List[int]]()
                vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                area: List[float] = List[float]()
                centroid: List[Eigen.Vector3d] = List[Eigen.Vector3d]()
                edges_direction: List[List[bool]] = List[List[bool]]()
                edges_normal: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                edges_length: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                triangulations: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]]()
                inertia: List[Eigen.Matrix3d] = List[Eigen.Matrix3d]()
                unaligned_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                unaligned_edges_length: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                centroid_edges_distance: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                centroid_vertices_distance: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                in_radius: List[float] = List[float]()
                quality: List[float] = List[float]()
                def __init__(
                    self,
                    vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    area: List[float] = List[float](),
                    centroid: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                    edges_direction: List[List[bool]] = List[List[bool]](),
                    edges_normal: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    edges_length: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                    triangulations: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]](),
                    inertia: List[Eigen.Matrix3d] = List[Eigen.Matrix3d](),
                    unaligned_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    unaligned_edges_length: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                    centroid_edges_distance: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                    centroid_vertices_distance: List[Eigen.VectorXd] = List[Eigen.VectorXd](),
                    in_radius: List[float] = List[float](),
                    quality: List[float] = List[float]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class Cell1D_GeometricData:
                """
                (final class)
                """
                max_aligned: int = 0
                aligned: List[int] = List[int]()
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

            cell1_ds: Gedim.RefinementUtilities.Cell2Ds_GeometricData.Cell1D_GeometricData
            cell2_ds: Gedim.RefinementUtilities.Cell2Ds_GeometricData.Cell2D_GeometricData
            def __init__(
                self,
                cell1_ds: RefinementUtilities.Cell2Ds_GeometricData.Cell1D_GeometricData = RefinementUtilities.Cell2Ds_GeometricData.Cell1D_GeometricData(),
                cell2_ds: RefinementUtilities.Cell2Ds_GeometricData.Cell2D_GeometricData = RefinementUtilities.Cell2Ds_GeometricData.Cell2D_GeometricData()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            mesh_utilities: MeshUtilities
            ) -> None:
            pass

        def split_cell1_d(
            self,
            cell1_d_index: int,
            new_vertex_coordinate: Eigen.Vector3d,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitCell1D_Result:
            pass
        def update_cell2_d_new_vertex(
            self,
            cell2_d_index: int,
            cell2_d_edge_direction: bool,
            cell2_d_edge_position: int,
            new_cell1_ds_index: List[int],
            new_cell0_d_index: int,
            mesh: IMeshDAO
            ) -> int:
            """/ \brief update cell2DIndex with a new splitted edge cell1DIndex by newCell0DIndex"""
            pass

        def split_cell1_d_middle_point(
            self,
            cell1_d_index: int,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitCell1D_Result:
            pass

        def are_vertices_aligned(
            self,
            cell2_d_vertices: Eigen.MatrixXd,
            from_vertex: int,
            to_vertex: int
            ) -> bool:
            pass

        def split_polygon_check_split_type(
            self,
            cell2_d_polygon_type: GeometryUtilities.PolygonTypes,
            cell2_d_unaligned_polygon_type: GeometryUtilities.PolygonTypes,
            cell2_d_vertices: Eigen.MatrixXd,
            cell2_d_check_to_refine: RefinementUtilities.RefinePolygon_CheckResult
            ) -> RefinementUtilities.CheckSplitType_Result:
            pass

        def split_polygon_check_is_not_to_extend(
            self,
            cell1_d_split_one: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit,
            cell1_d_split_two: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit
            ) -> bool:
            pass
        def split_polygon_check_is_to_split_relaxed(
            self,
            cell1_d_split_one: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit,
            cell1_d_split_two: RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit
            ) -> bool:
            pass

        def split_polygon_is_area_positive(
            self,
            new_cell2_d_indices: Eigen.VectorXi,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            mesh: IMeshDAO
            ) -> bool:
            pass

        def split_polygon_no_new_vertices(
            self,
            cell2_d_index: int,
            cell2_d_num_vertices: int,
            from_vertex: int,
            to_vertex: int,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitPolygon_Result:
            pass
        def split_polygon_new_vertex_from(
            self,
            cell2_d_index: int,
            cell2_d_num_vertices: int,
            from_edge: int,
            to_vertex: int,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            from_new_cell0_d_index: int,
            from_split_cell1_ds_index: List[int],
            from_edge_direction: bool,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitPolygon_Result:
            pass
        def split_polygon_new_vertex_to(
            self,
            cell2_d_index: int,
            cell2_d_num_vertices: int,
            from_vertex: int,
            to_edge: int,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            to_new_cell0_d_index: int,
            to_split_cell1_ds_index: List[int],
            to_edge_direction: bool,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitPolygon_Result:
            pass
        def split_polygon_new_vertices(
            self,
            cell2_d_index: int,
            cell2_d_num_vertices: int,
            from_edge: int,
            to_edge: int,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            from_new_cell0_d_index: int,
            to_new_cell0_d_index: int,
            from_split_cell1_ds_index: List[int],
            to_split_cell1_ds_index: List[int],
            from_edge_direction: bool,
            to_edge_direction: bool,
            mesh: IMeshDAO
            ) -> RefinementUtilities.SplitPolygon_Result:
            pass

        def compute_triangle_max_edge_direction(
            self,
            edges_length: Eigen.VectorXd
            ) -> RefinementUtilities.TriangleMaxEdgeDirection:
            pass

        def compute_polygon_max_diameter_direction(
            self,
            unaligned_vertices: Eigen.MatrixXd,
            centroid: Eigen.Vector3d
            ) -> RefinementUtilities.PolygonDirection:
            pass
        def compute_polygon_max_inertia_direction(
            self,
            unaligned_vertices: Eigen.MatrixXd,
            unaligned_edges_length: Eigen.VectorXd,
            centroid: Eigen.Vector3d,
            inertia: Eigen.Matrix3d
            ) -> RefinementUtilities.PolygonDirection:
            pass

        def compute_tetrahedron_max_edge_direction(
            self,
            polyhedron_edges: Eigen.MatrixXi,
            edges_length: Eigen.VectorXd
            ) -> RefinementUtilities.TetrahedronMaxEdgeDirection:
            pass

        def refine_triangle_cell_by_edge(
            self,
            cell2_d_index: int,
            edge_index: int,
            opposite_vertex_index: int,
            cell2_d_edges_direction: List[bool],
            cell2_d_area: float,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            cell2_d_edges_length: Eigen.VectorXd,
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_Result:
            """/ \brief Refine Triangle Cell2D By Edge
            / \param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()
            / \param cell2DVertices the cell2D 2D vertices
            / \param edgeIndex the edge local index to split
            / \param oppositeVertexIndex the vertex opposite to edge local index
            / \param mesh the mesh to be updated
            """
            pass

        def refine_polyhedron_cell_by_plane(
            self,
            cell3_d_index: int,
            cell3_d_vertices: Eigen.MatrixXd,
            cell3_d_edges: Eigen.MatrixXi,
            cell3_d_edges_length: Eigen.VectorXd,
            cell3_d_faces: List[Eigen.MatrixXi],
            cell3_d_faces3_d_vertices: List[Eigen.MatrixXd],
            cell3_d_faces_edges3_d_tangent: List[Eigen.MatrixXd],
            cell3_d_faces_translation: List[Eigen.Vector3d],
            cell3_d_faces_rotation_matrix: List[Eigen.Matrix3d],
            cell3_d_volume: float,
            plane_normal: Eigen.Vector3d,
            plane_origin: Eigen.Vector3d,
            plane_rotation_matrix: Eigen.Matrix3d,
            plane_translation: Eigen.Vector3d,
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolyhedron_Result:
            """/ \brief Refine Polyhedral Cell3D By Plane"""
            pass

        def refine_polyhedron_cell_update_face_neighbours(
            self,
            cell3_d_index: int,
            cell2_d_index: int,
            new_cell1_d_index: int,
            split_cell1_ds_original_index: List[int],
            split_cell1_ds_new_cell0_d_index: List[int],
            split_cell1_ds_updated_indices: List[List[int]],
            split_cell2_ds_index: List[int],
            cell3_ds_faces_edges_direction: List[List[List[bool]]],
            updated_cell2_ds: Dict[int, int],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolyhedron_UpdateNeighbour_Result:
            pass

        def refine_polyhedron_cell_update_edge_neighbours(
            self,
            cell3_d_index: int,
            cell1_d_index: int,
            new_cell1_ds_index: List[int],
            new_cell0_d_index: int,
            cell3_ds_faces_edges_direction: List[List[List[bool]]],
            updated_cell2_ds: Dict[int, int],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolyhedron_UpdateNeighbour_Result:
            pass

        def refine_triangle_cell_update_neighbours(
            self,
            cell2_d_index: int,
            cell1_d_index: int,
            new_cell0_d_index: int,
            split_cell1_ds_index: List[int],
            cell2_d_edge_direction: bool,
            cell2_ds_rotation: List[Eigen.Matrix3d],
            cell2_ds_translation: List[Eigen.Vector3d],
            mesh: IMeshDAO
            ) -> None:
            """/ \brief Update Cell1D neighbours of refined triangle by edge with refine by edge
            / \param cell2DIndex the index of Cell2D refined, from 0 to Cell2DTotalNumber()
            / \param cell1DIndex the index of Cell1D splitted by the refinement, from 0 to Cell1DTotalNumber()
            / \param newCell0DIndex the index of Cell0D created by the cell1D splitting process, from 0 to Cell0DTotalNumber()
            / \param splitCell1DsIndex the indices of the new Cell1Ds created by the splitting process, from 0 to
            / Cell1DTotalNumber() \param cell2DEdgeDirection the direction of the Cell1D splitted in the Cell2D \param mesh
            / the mesh to be updated
            """
            pass

        def refine_polygon_cell_check_refinement(
            self,
            cell2_d_index: int,
            cell2_d_vertices: Eigen.MatrixXd,
            line_tangent: Eigen.Vector3d,
            line_origin: Eigen.Vector3d,
            cell2_ds_quality: List[float],
            cell1_ds_aligned: List[int],
            cell1_ds_quality_weight: float,
            cell1_ds_aligned_weight: float,
            cell2_d_area: float,
            cell2_ds_edges_length: List[Eigen.VectorXd],
            cell2_d_edges_direction: List[bool],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_CheckResult:
            """/ \brief Refine Polygon Cell2D By Direction"""
            pass

        def refine_polygon_cell_by_direction(
            self,
            cell2_d_index: int,
            cell2_d_polygon_type: GeometryUtilities.PolygonTypes,
            cell2_d_unaligned_polygon_type: GeometryUtilities.PolygonTypes,
            cell2_d_vertices: Eigen.MatrixXd,
            cell2_d_check_to_refine: RefinementUtilities.RefinePolygon_CheckResult,
            cell2_d_rotation: Eigen.Matrix3d,
            cell2_d_translation: Eigen.Vector3d,
            cell2_d_edges_direction: List[bool],
            extend_to_neighbours: bool,
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_Result:
            """/ \brief Refine Polygon Cell2D By Direction"""
            pass

        def refine_polygon_cell_update_neighbours(
            self,
            cell2_d_index: int,
            cell1_d_index: int,
            new_cell0_d_index: int,
            split_cell1_ds_index: List[int],
            cell2_ds_edges_direction: List[List[bool]],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_UpdateNeighbour_Result:
            pass

        def refine_polygon_cell_initialize_geometric_data(
            self,
            mesh: IMeshDAO
            ) -> RefinementUtilities.Cell2Ds_GeometricData:
            """/ Compute the geometric data for all the mesh"""
            pass

        def refine_polygon_cell_update_geometric_data(
            self,
            mesh: IMeshDAO,
            cell2_ds_index: List[int],
            geometric_data: RefinementUtilities.Cell2Ds_GeometricData
            ) -> None:
            """/ \brief Update the geometric data for only cell2Ds"""
            pass

        def refine_polygon_cell_is_cell1_d_to_split(
            self,
            cell1_d_index: int,
            cell2_d_index: int,
            edge_intersection: GeometryUtilities.LinePolygonPositionResult.EdgeIntersection,
            cell2_ds_edges_length: List[Eigen.VectorXd],
            cell1_ds_quality_weight: float,
            cell1_ds_aligned_weight: float,
            cell2_ds_quality: List[float],
            cell1_ds_aligned: List[int],
            mesh: IMeshDAO
            ) -> RefinementUtilities.RefinePolygon_CheckResult.Cell1DToSplit:
            pass


# </submodule gedim>
####################    </generated_from:RefinementUtilities.hpp>    ####################


####################    <generated_from:SphereMeshUtilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __SphereMeshUtilities_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""
    class SphereMeshUtilities:
        """/ \brief MeshUtilities
        / \copyright See top level LICENSE file for details.
        /
        / https://danielsieger.com/blog/2021/03/27/generating-spheres.html
        (final class)
        """
        def __init__(
            self,
            geometry_utilities: GeometryUtilities,
            mesh_utilities: MeshUtilities
            ) -> None:
            pass


        def circle(
            self,
            center: Eigen.Vector3d,
            radius: float,
            num_points: int
            ) -> Eigen.MatrixXd:
            pass

        def ellipse(
            self,
            center: Eigen.Vector3d,
            radius_1: float,
            radius_2: float,
            rotation_angle: float,
            num_points: int
            ) -> Eigen.MatrixXd:
            pass

        def uv_sphere(self, meridians: int, parallels: int) -> GeometryUtilities.Polyhedron:
            pass


# </submodule gedim>
####################    </generated_from:SphereMeshUtilities.hpp>    ####################


####################    <generated_from:Quadrature_Gauss2D_Triangle.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Quadrature_Gauss2D_Triangle_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""

    # <submodule quadrature>
    class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Quadrature"""
        class Quadrature_Gauss2D_Triangle:
            """/ Gauss quadrature rule for triangles"""
            @staticmethod
            def fill_points_and_weights(order: int) -> QuadratureData:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule quadrature>

# </submodule gedim>
####################    </generated_from:Quadrature_Gauss2D_Triangle.hpp>    ####################


####################    <generated_from:Quadrature_Gauss2D_Square.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Quadrature_Gauss2D_Square_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""

    # <submodule quadrature>
    class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Quadrature"""
        class Quadrature_Gauss2D_Square:
            """/ Gauss quadrature rule for Squares"""
            @staticmethod
            def fill_points_and_weights(order: int) -> QuadratureData:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule quadrature>

# </submodule gedim>
####################    </generated_from:Quadrature_Gauss2D_Square.hpp>    ####################


####################    <generated_from:Quadrature_Gauss3D_Hexahedron.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Quadrature_Gauss3D_Hexahedron_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""

    # <submodule quadrature>
    class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Quadrature"""
        class Quadrature_Gauss3D_Hexahedron:
            """/ Gauss quadrature rule for Hexahedrons"""
            @staticmethod
            def fill_points_and_weights(order: int) -> QuadratureData:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule quadrature>

# </submodule gedim>
####################    </generated_from:Quadrature_Gauss3D_Hexahedron.hpp>    ####################


####################    <generated_from:Quadrature_GaussLobatto1D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Quadrature_GaussLobatto1D_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""

    # <submodule quadrature>
    class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Quadrature"""
        class Quadrature_GaussLobatto1D:
            """/ Gauss quadrature rule for segments"""
            @staticmethod
            def fill_points_and_weights(order: int) -> QuadratureData:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule quadrature>

# </submodule gedim>
####################    </generated_from:Quadrature_GaussLobatto1D.hpp>    ####################


####################    <generated_from:Quadrature_Gauss1D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Quadrature_Gauss1D_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""

    # <submodule quadrature>
    class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Quadrature"""
        class Quadrature_Gauss1D:
            """/ Gauss quadrature rule for segments"""
            @staticmethod
            def fill_points_and_weights(order: int) -> QuadratureData:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule quadrature>

# </submodule gedim>
####################    </generated_from:Quadrature_Gauss1D.hpp>    ####################


####################    <generated_from:QuadratureData.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __QuadratureData_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""

    # <submodule quadrature>
    class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Quadrature"""
        class QuadratureData:
            """
            (final class)
            """
            points: Eigen.MatrixXd
            weights: Eigen.VectorXd
            def __init__(
                self,
                points: Eigen.MatrixXd = Eigen.MatrixXd(),
                weights: Eigen.VectorXd = Eigen.VectorXd()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

    # </submodule quadrature>

# </submodule gedim>
####################    </generated_from:QuadratureData.hpp>    ####################


####################    <generated_from:Quadrature_Gauss3D_Tetrahedron_PositiveWeights.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Quadrature_Gauss3D_Tetrahedron_PositiveWeights_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""

    # <submodule quadrature>
    class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Quadrature"""
        class Quadrature_Gauss3D_Tetrahedron_PositiveWeights:
            """/ Gauss quadrature rule for Tetrahedrons"""
            @staticmethod
            def fill_points_and_weights(order: int) -> QuadratureData:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule quadrature>

# </submodule gedim>
####################    </generated_from:Quadrature_Gauss3D_Tetrahedron_PositiveWeights.hpp>    ####################


####################    <generated_from:Quadrature_Gauss3D_Tetrahedron.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Quadrature_Gauss3D_Tetrahedron_H
#



# #endif

# <submodule gedim>
class gedim:  # Proxy class that introduces typings for the *submodule* gedim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Gedim"""

    # <submodule quadrature>
    class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Quadrature"""
        class Quadrature_Gauss3D_Tetrahedron:
            """/ Gauss quadrature rule for Tetrahedrons"""
            @staticmethod
            def fill_points_and_weights(order: int) -> QuadratureData:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule quadrature>

# </submodule gedim>
####################    </generated_from:Quadrature_Gauss3D_Tetrahedron.hpp>    ####################


####################    <generated_from:lagrange_1D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Interpolation_Lagrange_1D_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule interpolation>
    class interpolation:  # Proxy class that introduces typings for the *submodule* interpolation
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Interpolation"""

        # <submodule lagrange>
        class lagrange:  # Proxy class that introduces typings for the *submodule* lagrange
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace Lagrange"""
            @staticmethod
            def lagrange_1_d_coefficients(
                interpolation_points_x: Eigen.VectorXd
                ) -> Eigen.VectorXd:
                pass
            @staticmethod
            def lagrange_1_d_values(
                interpolation_points_x: Eigen.VectorXd,
                lagrange_1_d_coefficients: Eigen.VectorXd,
                evaluation_points_x: Eigen.VectorXd
                ) -> Eigen.MatrixXd:
                pass
            @staticmethod
            def lagrange_1_d_derivative_values(
                interpolation_points_x: Eigen.VectorXd,
                lagrange_1_d_coefficients: Eigen.VectorXd,
                evaluation_points_x: Eigen.VectorXd
                ) -> Eigen.MatrixXd:
                pass


        # </submodule lagrange>

    # </submodule interpolation>

# </submodule polydim>
####################    </generated_from:lagrange_1D.hpp>    ####################


####################    <generated_from:VEM_Quadrature_2D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_Quadrature_2D_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule quadrature>
        class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace Quadrature"""
            class VEM_QuadratureData_2D:
                reference_segment_quadrature: Gedim.Quadrature.QuadratureData
                reference_edge_do_fs_quadrature: Gedim.Quadrature.QuadratureData
                reference_triangle_quadrature: Gedim.Quadrature.QuadratureData

                reference_segment_internal_points: Eigen.MatrixXd
                reference_segment_internal_weights: Eigen.VectorXd
                reference_segment_extrema_weights: Eigen.Vector2d

                reference_edge_do_fs_internal_points: Eigen.MatrixXd
                reference_edge_do_fs_internal_weights: Eigen.VectorXd
                reference_edge_do_fs_extrema_weights: Eigen.Vector2d
                def __init__(
                    self,
                    reference_segment_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_edge_do_fs_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_triangle_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_segment_internal_points: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_segment_internal_weights: Eigen.VectorXd = Eigen.VectorXd(),
                    reference_segment_extrema_weights: Eigen.Vector2d = Eigen.Vector2d(),
                    reference_edge_do_fs_internal_points: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_edge_do_fs_internal_weights: Eigen.VectorXd = Eigen.VectorXd(),
                    reference_edge_do_fs_extrema_weights: Eigen.Vector2d = Eigen.Vector2d()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_Quadrature_2D:
                """
                (final class)
                """
                class Edges_QuadratureData:
                    quadrature: Gedim.Quadrature.QuadratureData
                    weights_times_normal: List[Eigen.VectorXd]
                    def __init__(
                        self,
                        quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                        weights_times_normal: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                        ) -> None:
                        """Auto-generated default constructor with named params"""
                        pass

                def compute_pcc_2_d(self, order: int) -> VEM_QuadratureData_2D:
                    pass
                def compute_mcc_2_d(self, order: int) -> VEM_QuadratureData_2D:
                    pass
                def compute_mcc_edge_ortho_2_d(self, order: int) -> VEM_QuadratureData_2D:
                    pass
                def compute_df_pcc_2_d(self, order: int) -> VEM_QuadratureData_2D:
                    pass
                def compute_df_pcc_3_d(self, order: int) -> VEM_QuadratureData_2D:
                    pass

                def polygon_internal_quadrature(
                    self,
                    data: Gedim.Quadrature.QuadratureData,
                    polygon_triangulation_vertices: List[Eigen.Matrix3d]
                    ) -> Gedim.Quadrature.QuadratureData:
                    pass

                def polygon_edges_lobatto_quadrature(
                    self,
                    reference_segment_internal_points: Eigen.MatrixXd,
                    reference_segment_internal_weights: Eigen.VectorXd,
                    reference_segment_extrema_weights: Eigen.Vector2d,
                    polygon_vertices: Eigen.MatrixXd,
                    edge_lengths: Eigen.VectorXd,
                    edge_directions: List[bool],
                    edge_tangents: Eigen.MatrixXd,
                    edge_normals: Eigen.MatrixXd
                    ) -> VEM_Quadrature_2D.Edges_QuadratureData:
                    pass

                def polygon_edges_quadrature(
                    self,
                    data: Gedim.Quadrature.QuadratureData,
                    polygon_vertices: Eigen.MatrixXd,
                    edge_lengths: Eigen.VectorXd,
                    edge_directions: List[bool],
                    edge_tangents: Eigen.MatrixXd,
                    edge_normals: Eigen.MatrixXd
                    ) -> VEM_Quadrature_2D.Edges_QuadratureData:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule quadrature>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_Quadrature_2D.hpp>    ####################


####################    <generated_from:VEM_Quadrature_3D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_Quadrature_3D_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule quadrature>
        class quadrature:  # Proxy class that introduces typings for the *submodule* quadrature
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace Quadrature"""
            class VEM_QuadratureData_3D:
                """
                (final class)
                """
                reference_tetrahedron_quadrature: Gedim.Quadrature.QuadratureData
                quadrature_data_2_d: Polydim.VEM.Quadrature.VEM_QuadratureData_2D
                def __init__(
                    self,
                    reference_tetrahedron_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    quadrature_data_2_d: VEM.Quadrature.VEM_QuadratureData_2D = VEM.Quadrature.VEM_QuadratureData_2()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_Quadrature_3D:
                """
                (final class)
                """
                class Faces_QuadratureData_PCC:
                    quadrature: Gedim.Quadrature.QuadratureData
                    weights_times_normal: List[Eigen.VectorXd]
                    def __init__(
                        self,
                        quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                        weights_times_normal: List[Eigen.VectorXd] = List[Eigen.VectorXd]()
                        ) -> None:
                        """Auto-generated default constructor with named params"""
                        pass

                class Faces_QuadratureData_MCC:
                    quadrature: Gedim.Quadrature.QuadratureData
                    faces_quadrature: List[Gedim.Quadrature.QuadratureData]
                    def __init__(
                        self,
                        quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                        faces_quadrature: List[Gedim.Quadrature.QuadratureData] = List[Gedim.Quadrature.QuadratureData]()
                        ) -> None:
                        """Auto-generated default constructor with named params"""
                        pass

                def compute_pcc_3_d(self, order: int) -> VEM_QuadratureData_3D:
                    pass
                def compute_mcc_3_d(self, order: int) -> VEM_QuadratureData_3D:
                    pass
                def compute_df_pcc_3_d(self, order: int) -> VEM_QuadratureData_3D:
                    pass

                @overload
                def polyhedron_internal_quadrature(
                    self,
                    data: VEM_QuadratureData_3D,
                    geometry_utility: Gedim.GeometryUtilities,
                    polyhedron_tetrahedron_vertices: List[Eigen.MatrixXd]
                    ) -> Gedim.Quadrature.QuadratureData:
                    pass

                @overload
                def polyhedron_internal_quadrature(
                    self,
                    geometry_utility: Gedim.GeometryUtilities,
                    data: Gedim.Quadrature.QuadratureData,
                    polyhedron_tetrahedron_vertices: List[Eigen.MatrixXd]
                    ) -> Gedim.Quadrature.QuadratureData:
                    pass

                @overload
                def polyhedron_faces_quadrature(
                    self,
                    geometry_utility: Gedim.GeometryUtilities,
                    polyhedron_faces: List[Eigen.MatrixXi],
                    faces_rotation_matrix: List[Eigen.Matrix3d],
                    faces_translation: List[Eigen.Vector3d],
                    faces_normals: List[Eigen.Vector3d],
                    face_normal_directions: List[bool],
                    faces_quadrature_points: List[Eigen.MatrixXd],
                    faces_quadrature_weights: List[Eigen.VectorXd]
                    ) -> VEM_Quadrature_3D.Faces_QuadratureData_PCC:
                    pass

                def polyhedron_internal_edges_quadrature_points(
                    self,
                    reference_segment_internal_points: Eigen.MatrixXd,
                    polyhedron_vertices: Eigen.MatrixXd,
                    polyhedron_edges: Eigen.MatrixXi,
                    edge_directions: List[bool],
                    edge_tangents: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def polyhedron_faces_quadrature(
                    self,
                    data: VEM_QuadratureData_3D,
                    geometry_utility: Gedim.GeometryUtilities,
                    faces_triangulations2_d: List[List[Eigen.Matrix3d]],
                    faces_rotation_matrix: List[Eigen.Matrix3d],
                    faces_translation: List[Eigen.Vector3d]
                    ) -> VEM_Quadrature_3D.Faces_QuadratureData_MCC:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule quadrature>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_Quadrature_3D.hpp>    ####################


####################    <generated_from:Monomials_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Monomials_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule utilities>
    class utilities:  # Proxy class that introduces typings for the *submodule* utilities
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Utilities"""
        class Monomials_Data:
            polynomial_degree: int                     #/< Monomial space order
            dimension: int                             #/< The geometric dimension
            num_monomials: int                         #/< Number of monomials in the basis.
            exponents: List[Eigen.VectorXi]            #/< Table of exponents of each monomial.
            derivative_matrices: List[Eigen.MatrixXd]  #/< Matrices used to compute derivatives of monomials.
            laplacian: Eigen.MatrixXd                  #/< Matrix used to compute the laplacian of monomials.
            def __init__(
                self,
                exponents: List[Eigen.VectorXi] = List[Eigen.VectorXi](),
                derivative_matrices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                laplacian: Eigen.MatrixXd = Eigen.MatrixXd()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

    # </submodule utilities>

# </submodule polydim>
####################    </generated_from:Monomials_Data.hpp>    ####################


####################    <generated_from:GBasis_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __GBasis_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule utilities>
    class utilities:  # Proxy class that introduces typings for the *submodule* utilities
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Utilities"""
        class GBasis_Data:
            polynomial_degree: int
            dimension: int

            monomials_data: Polydim.Utilities.Monomials_Data

            nk: int
            nkm1: int
            nkp1: int
            nk_g_big_o_plus: int
            nk_g_nabla: int
            vector_decomposition: List[List[Eigen.MatrixXd]]

            matrix_exponents: Eigen.MatrixXi

            dim_first_basis: int
            map_exponents: List[List[List[int]]]
            save_first_group_vector_decomposition: List[int]
            map_first_group_vector_decomposition: List[int]
            def __init__(
                self,
                monomials_data: Utilities.Monomials_Data = Utilities.Monomials_Data(),
                vector_decomposition: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                matrix_exponents: Eigen.MatrixXi = Eigen.MatrixXi(),
                map_first_group_vector_decomposition: List[int] = List[int]()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

    # </submodule utilities>

# </submodule polydim>
####################    </generated_from:GBasis_Data.hpp>    ####################


####################    <generated_from:GBasis_2D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __GBasis_2D_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule utilities>
    class utilities:  # Proxy class that introduces typings for the *submodule* utilities
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Utilities"""
        class GBasis_2D:
            """
            (final class)
            """
            def compute(self, polynomial_degree: int) -> GBasis_Data:
                pass

            def vander_g_big_o_plus(
                self,
                data: GBasis_Data,
                vander: Eigen.MatrixXd
                ) -> List[Eigen.MatrixXd]:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule utilities>

# </submodule polydim>
####################    </generated_from:GBasis_2D.hpp>    ####################


####################    <generated_from:GBasis_3D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __GBasis_3D_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule utilities>
    class utilities:  # Proxy class that introduces typings for the *submodule* utilities
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Utilities"""
        class GBasis_3D:
            """
            (final class)
            """
            def compute(self, polynomial_degree: int) -> GBasis_Data:
                pass

            def vander_g_big_o_plus(
                self,
                data: GBasis_Data,
                vander: Eigen.MatrixXd
                ) -> List[Eigen.MatrixXd]:
                pass

            def vector_decomposition(self, data: GBasis_Data) -> List[List[Eigen.MatrixXd]]:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule utilities>

# </submodule polydim>
####################    </generated_from:GBasis_3D.hpp>    ####################


####################    <generated_from:Monomials_1D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Monomials_1D_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule utilities>
    class utilities:  # Proxy class that introduces typings for the *submodule* utilities
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Utilities"""
        class Monomials_1D:
            """
            (final class)
            """
            def compute(self, polynomial_degree: int) -> Monomials_Data:
                pass

            def exponents(self, data: Monomials_Data) -> Eigen.MatrixXi:
                pass

            def derivative_matrix(self, data: Monomials_Data, i: int) -> Eigen.MatrixXd:
                pass

            def d_x(self, data: Monomials_Data) -> Eigen.MatrixXd:
                pass

            def index(self, exponents: Eigen.VectorXi) -> int:
                pass
            def derivative_indices(self, data: Monomials_Data, index: int) -> List[int]:
                pass
            def second_derivative_indices(self, data: Monomials_Data, index: int) -> List[int]:
                pass

            def vander(
                self,
                data: Monomials_Data,
                points: Eigen.MatrixXd,
                centroid: Eigen.Vector3d,
                diam: float
                ) -> Eigen.MatrixXd:
                pass

            def vander_derivatives(
                self,
                data: Monomials_Data,
                vander: Eigen.MatrixXd,
                diam: float
                ) -> List[Eigen.MatrixXd]:
                pass

            def vander_laplacian(
                self,
                data: Monomials_Data,
                vander: Eigen.MatrixXd,
                diam: float
                ) -> Eigen.MatrixXd:
                pass

            def mgs_orthonormalize(
                self,
                weights: Eigen.VectorXd,
                vander: Eigen.MatrixXd,
                hmatrix: Eigen.MatrixXd,
                qmatrix_inv: Eigen.MatrixXd,
                qmatrix: Eigen.MatrixXd
                ) -> None:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule utilities>

# </submodule polydim>
####################    </generated_from:Monomials_1D.hpp>    ####################


####################    <generated_from:Monomials_2D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Monomials_2D_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule utilities>
    class utilities:  # Proxy class that introduces typings for the *submodule* utilities
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Utilities"""
        class Monomials_2D:
            """
            (final class)
            """
            def compute(self, polynomial_degree: int) -> Monomials_Data:
                pass

            def exponents(self, data: Monomials_Data) -> Eigen.MatrixXi:
                pass

            def derivative_matrix(self, data: Monomials_Data, i: int) -> Eigen.MatrixXd:
                pass

            def d_x(self, data: Monomials_Data) -> Eigen.MatrixXd:
                pass

            def d_y(self, data: Monomials_Data) -> Eigen.MatrixXd:
                pass

            def index(self, exponents: Eigen.VectorXi) -> int:
                pass

            def derivative_indices(self, data: Monomials_Data, index: int) -> List[int]:
                pass

            def second_derivative_indices(self, data: Monomials_Data, index: int) -> List[int]:
                pass

            def vander(
                self,
                data: Monomials_Data,
                points: Eigen.MatrixXd,
                centroid: Eigen.Vector3d,
                diam: float
                ) -> Eigen.MatrixXd:
                pass

            def vander_derivatives(
                self,
                data: Monomials_Data,
                vander: Eigen.MatrixXd,
                diam: float
                ) -> List[Eigen.MatrixXd]:
                pass

            def vander_laplacian(
                self,
                data: Monomials_Data,
                vander: Eigen.MatrixXd,
                diam: float
                ) -> Eigen.MatrixXd:
                pass

            def mgs_orthonormalize(
                self,
                weights: Eigen.VectorXd,
                vander: Eigen.MatrixXd,
                hmatrix: Eigen.MatrixXd,
                qmatrix_inv: Eigen.MatrixXd,
                qmatrix: Eigen.MatrixXd
                ) -> None:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule utilities>

# </submodule polydim>
####################    </generated_from:Monomials_2D.hpp>    ####################


####################    <generated_from:Monomials_3D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Monomials_3D_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule utilities>
    class utilities:  # Proxy class that introduces typings for the *submodule* utilities
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Utilities"""
        class Monomials_3D:
            """
            (final class)
            """
            def compute(self, polynomial_degree: int) -> Monomials_Data:
                pass

            def exponents(self, data: Monomials_Data) -> Eigen.MatrixXi:
                pass

            def derivative_matrix(self, data: Monomials_Data, i: int) -> Eigen.MatrixXd:
                pass

            def d_x(self, data: Monomials_Data) -> Eigen.MatrixXd:
                pass

            def d_y(self, data: Monomials_Data) -> Eigen.MatrixXd:
                pass

            def d_z(self, data: Monomials_Data) -> Eigen.MatrixXd:
                pass

            def index(self, exponents: Eigen.VectorXi) -> int:
                pass
            def derivative_indices(self, data: Monomials_Data, index: int) -> List[int]:
                pass
            def second_derivative_indices(self, data: Monomials_Data, index: int) -> List[int]:
                pass

            def vander(
                self,
                data: Monomials_Data,
                points: Eigen.MatrixXd,
                centroid: Eigen.Vector3d,
                diam: float
                ) -> Eigen.MatrixXd:
                pass
            def vander_derivatives(
                self,
                data: Monomials_Data,
                vander: Eigen.MatrixXd,
                diam: float
                ) -> List[Eigen.MatrixXd]:
                pass

            def vander_laplacian(
                self,
                data: Monomials_Data,
                vander: Eigen.MatrixXd,
                diam: float
                ) -> Eigen.MatrixXd:
                pass

            def mgs_orthonormalize(
                self,
                weights: Eigen.VectorXd,
                vander: Eigen.MatrixXd,
                hmatrix: Eigen.MatrixXd,
                qmatrix_inv: Eigen.MatrixXd,
                qmatrix: Eigen.MatrixXd
                ) -> None:
                pass
            def __init__(self) -> None:
                """Autogenerated default constructor"""
                pass

    # </submodule utilities>

# </submodule polydim>
####################    </generated_from:Monomials_3D.hpp>    ####################


####################    <generated_from:Inertia_Utilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __Inertia_Utilities_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule utilities>
    class utilities:  # Proxy class that introduces typings for the *submodule* utilities
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace Utilities"""

        class Inertia_Data:
            """
            (final class)
            """
            fmatrix: Eigen.Matrix3d
            fmatrix_inv: Eigen.Matrix3d
            translation: Eigen.Vector3d
            abs_det_fmatrix: float
            sign_det_q: float
            def __init__(
                self,
                fmatrix: Eigen.Matrix3d = Eigen.Matrix3d(),
                fmatrix_inv: Eigen.Matrix3d = Eigen.Matrix3d(),
                translation: Eigen.Vector3d = Eigen.Vector3d(),
                abs_det_fmatrix: float = float(),
                sign_det_q: float = float()
                ) -> None:
                """Auto-generated default constructor with named params"""
                pass

        class Inertia_Utilities:
            """
            (final class)
            """
            def inertia_mapping2_d(
                self,
                geometry_utilities: Gedim.GeometryUtilities,
                vertices: Eigen.MatrixXd,
                centroid: Eigen.Vector3d,
                diameter: float,
                triangulation_vertices: List[Eigen.Matrix3d],
                inertia_data: Inertia_Data
                ) -> None:
                pass

            def inertia_mapping3_d(
                self,
                geometry_utilities: Gedim.GeometryUtilities,
                vertices: Eigen.MatrixXd,
                centroid: Eigen.Vector3d,
                diameter: float,
                tetrahedrons_vertices: List[Eigen.MatrixXd],
                inertia_data: Inertia_Data
                ) -> None:
                pass
            def __init__(self) -> None:
                """Auto-generated default constructor"""
                pass


    # </submodule utilities>

# </submodule polydim>
####################    </generated_from:Inertia_Utilities.hpp>    ####################


####################    <generated_from:VEM_PCC_Utilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_Utilities_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class ProjectionTypes(enum.IntEnum):
                pi0km1 = enum.auto()     # (= 0)
                pi0k = enum.auto()       # (= 1)
                pi_nabla = enum.auto()   # (= 2)
                pi0km1_der = enum.auto() # (= 3)
                pi0klm1 = enum.auto()    # (= 4)

            class VEM_PCC_Utilities:
                """
                (final class)
                """
                def compute_edge_basis_coefficients(
                    self,
                    order: int,
                    edge_internal_points: Eigen.VectorXd
                    ) -> Eigen.VectorXd:
                    pass

                def compute_l2_projectors(
                    self,
                    measure: float,
                    order: int,
                    nkm1: int,
                    nk: int,
                    num_internal_basis_functions: int,
                    num_basis_functions: int,
                    hmatrix: Eigen.MatrixXd,
                    pi_nabla: Eigen.MatrixXd,
                    cmatrix: Eigen.MatrixXd,
                    pi0km1: Eigen.MatrixXd,
                    pi0k: Eigen.MatrixXd
                    ) -> None:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    reference_edge_do_fs_point: Eigen.RowVectorXd,
                    vertices: Eigen.MatrixXd,
                    edges: Eigen.MatrixXi,
                    edges_direction: List[bool],
                    edges_tangent: Eigen.MatrixXd,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_derivative_values(
                    self,
                    dimension: int,
                    projection_type: ProjectionTypes,
                    nkm1: int,
                    vander_internal: Eigen.MatrixXd,
                    vander_internal_derivatives: List[Eigen.MatrixXd],
                    pi_nabla: Eigen.MatrixXd,
                    pi0km1_der: List[Eigen.MatrixXd]
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_basis_functions_laplacian_values(
                    self,
                    dimension: int,
                    projection_type: ProjectionTypes,
                    nkm1: int,
                    vander_internal_derivatives: List[Eigen.MatrixXd],
                    pi0km1_der: List[Eigen.MatrixXd]
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values(
                    self,
                    projection_type: ProjectionTypes,
                    nkm1: int,
                    pi0km1: Eigen.MatrixXd,
                    pi0k: Eigen.MatrixXd,
                    vander_internal: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsValues>
                @overload
                def compute_polynomials_values(
                    self,
                    vander_internal: Eigen.MatrixXd,
                    monomial_type: Utilities.Monomials_2D
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    vander_internal: Eigen.MatrixXd,
                    monomial_type: Utilities.Monomials_3D
                    ) -> Eigen.MatrixXd:
                    pass
                #      </template specializations for function ComputePolynomialsValues>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsValues>
                @overload
                def compute_polynomials_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_2D,
                    centroid: Eigen.Vector3d,
                    diameter: float,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_3D,
                    centroid: Eigen.Vector3d,
                    diameter: float,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                #      </template specializations for function ComputePolynomialsValues>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsDerivativeValues>
                @overload
                def compute_polynomials_derivative_values(
                    self,
                    vander_internal_derivatives: List[Eigen.MatrixXd],
                    monomial_type: Utilities.Monomials_2D
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    vander_internal_derivatives: List[Eigen.MatrixXd],
                    monomial_type: Utilities.Monomials_3D
                    ) -> List[Eigen.MatrixXd]:
                    pass
                #      </template specializations for function ComputePolynomialsDerivativeValues>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsDerivativeValues>
                @overload
                def compute_polynomials_derivative_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_2D,
                    diameter: float,
                    vander: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_3D,
                    diameter: float,
                    vander: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass
                #      </template specializations for function ComputePolynomialsDerivativeValues>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsLaplacianValues>
                @overload
                def compute_polynomials_laplacian_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_2D,
                    diameter: float,
                    vander: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_laplacian_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_3D,
                    diameter: float,
                    vander: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                #      </template specializations for function ComputePolynomialsLaplacianValues>
                #  ------------------------------------------------------------------------

                def compute_values_on_edge(
                    self,
                    edge_internal_points: Eigen.RowVectorXd,
                    order: int,
                    edge_basis_coefficients: Eigen.VectorXd,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    projector: Eigen.MatrixXd,
                    coefficient: float,
                    dmatrix: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_d_recipe_stabilization_matrix(
                    self,
                    projector: Eigen.MatrixXd,
                    coercivity_matrix: Eigen.MatrixXd,
                    vector_coefficients: Eigen.VectorXd,
                    dmatrix: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_Utilities.hpp>    ####################


####################    <generated_from:VEM_PCC_2D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_2D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class VEM_PCC_2D_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_PCC_2D_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_2D_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_PCC_2D_LocalSpace_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_2D_LocalSpace_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class VEM_PCC_2D_Polygon_Geometry:
                """
                (final class)
                """
                tolerance1_d: float
                tolerance2_d: float

                vertices: Eigen.MatrixXd
                centroid: Eigen.Vector3d
                measure: float
                diameter: float
                triangulation_vertices: List[Eigen.Matrix3d]
                edges_length: Eigen.VectorXd
                edges_direction: List[bool]
                edges_tangent: Eigen.MatrixXd
                edges_normal: Eigen.MatrixXd
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_PCC_2D_LocalSpace_Data:
                """
                (final class)
                """
                dimension: int
                order: int
                num_vertex_basis_functions: int

                num_edge_basis_functions: int

                num_boundary_basis_functions: int

                num_internal_basis_functions: int
                num_basis_functions: int
                num_edge_dofs: int
                num_projector_basis_functions: int
                nkm1: int
                nkm2: int
                nklm1: int

                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: Polydim.VEM.Quadrature.VEM_Quadrature_2D.Edges_QuadratureData

                internal_quadrature_kl: Gedim.Quadrature.QuadratureData
                boundary_quadrature_kl: Polydim.VEM.Quadrature.VEM_Quadrature_2D.Edges_QuadratureData

                diameter: float
                measure: float
                centroid: Eigen.Vector3d

                vander_internal: Eigen.MatrixXd
                vander_internal_kl: Eigen.MatrixXd
                vander_internal_derivatives: List[Eigen.MatrixXd]

                vander_boundary: Eigen.MatrixXd
                vander_boundary_derivatives: List[Eigen.MatrixXd]

                pi_nabla: Eigen.MatrixXd
                pi0km1: Eigen.MatrixXd
                pi0k: Eigen.MatrixXd
                pi0klm1: Eigen.MatrixXd
                pi0km1_der: List[Eigen.MatrixXd]

                hmatrix: Eigen.MatrixXd

                h_klm1_matrix: Eigen.MatrixXd
                cmatrix: Eigen.MatrixXd
                bmatrix: Eigen.MatrixXd
                gmatrix: Eigen.MatrixXd
                dmatrix: Eigen.MatrixXd
                ematrix: List[Eigen.MatrixXd]

                qmatrix: Eigen.MatrixXd
                qmatrix_inv: Eigen.MatrixXd
                qmatrixkm1: Eigen.MatrixXd

                inertia_data: Polydim.Utilities.Inertia_Data
                inertia_polygon: Polydim.VEM.PCC.VEM_PCC_2D_Polygon_Geometry
                constant_stiff: float
                constant_mass: float
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_2D_LocalSpace_Data.hpp>    ####################


####################    <generated_from:VEM_PCC_3D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_3D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class VEM_PCC_3D_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_PCC_3D_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_3D_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_PCC_3D_LocalSpace_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_3D_LocalSpace_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class VEM_PCC_3D_Polyhedron_Geometry:
                """
                (final class)
                """
                tolerance1_d: float
                tolerance2_d: float
                tolerance3_d: float

                vertices: Eigen.MatrixXd
                edges: Eigen.MatrixXi
                faces: List[Eigen.MatrixXi]
                centroid: Eigen.Vector3d
                measure: float
                diameter: float
                tetrahedron_vertices: List[Eigen.MatrixXd]

                faces_rotation_matrix: List[Eigen.Matrix3d]
                faces_translation: List[Eigen.Vector3d]
                faces_normal: List[Eigen.Vector3d]
                faces_normal_direction: List[bool]

                edges_direction: List[bool]
                edges_tangent: Eigen.MatrixXd

                faces_2_d_geometry: List[Polydim.VEM.PCC.VEM_PCC_2D_Polygon_Geometry]
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_PCC_3D_LocalSpace_Data:
                """
                (final class)
                """
                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: Polydim.VEM.Quadrature.VEM_Quadrature_3D.Faces_QuadratureData_PCC

                faces_local_space: List[Polydim.VEM.PCC.VEM_PCC_2D_LocalSpace_Data]

                dimension: int
                order: int

                num_vertex_basis_functions: int
                num_edge_basis_functions: int
                num_face_basis_functions: int
                num_internal_basis_functions: int
                num_basis_functions: int
                num_edge_dofs: int
                num_face_dofs: int
                num_boundary_basis_functions: int
                num_projector_basis_functions: int

                nkm1: int
                nkm2: int

                vander_internal: Eigen.MatrixXd
                vander_internal_derivatives: List[Eigen.MatrixXd]

                diameter: float
                centroid: Eigen.Vector3d
                measure: float

                edge_basis_coefficients: Eigen.VectorXd
                edges_do_fs_coordinates: List[Eigen.MatrixXd]
                pi_nabla: Eigen.MatrixXd
                pi0km1: Eigen.MatrixXd
                pi0k: Eigen.MatrixXd

                pi0km1_der: List[Eigen.MatrixXd]
                stab_matrix: Eigen.MatrixXd
                stab_matrix_pi0k: Eigen.MatrixXd
                hmatrix: Eigen.MatrixXd
                cmatrix: Eigen.MatrixXd
                bmatrix: Eigen.MatrixXd
                gmatrix: Eigen.MatrixXd
                dmatrix: Eigen.MatrixXd
                ematrix: List[Eigen.MatrixXd]

                vander_boundary: Eigen.MatrixXd

                vander_edge_dofs: Eigen.MatrixXd
                scaled_hmatrix_on_boundary: Eigen.MatrixXd

                vander_face_projections: Eigen.MatrixXd
                face_scaled_moments_basis: List[Eigen.MatrixXd]
                face_projected_basis_functions_values: List[Eigen.MatrixXd]
                point_edge_dofs_coordinates: Eigen.MatrixXd

                vander_boundary_derivatives: List[Eigen.MatrixXd]

                qmatrix: Eigen.MatrixXd  # change of basis matrix: pV = mV*Q'
                qmatrix_inv: Eigen.MatrixXd
                qmatrixkm1: Eigen.MatrixXd

                inertia_data: Polydim.Utilities.Inertia_Data
                inertia_polyhedron: Polydim.VEM.PCC.VEM_PCC_3D_Polyhedron_Geometry
                constant_stiff: float
                constant_mass: float

                edge_internal_points: Eigen.RowVectorXd
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_3D_LocalSpace_Data.hpp>    ####################


####################    <generated_from:VEM_MCC_3D_LocalSpace_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_3D_LocalSpace_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            class VEM_MCC_3D_Polyhedron_Geometry:
                """
                (final class)
                """
                tolerance1_d: float
                tolerance2_d: float
                tolerance3_d: float

                vertices: Eigen.MatrixXd
                centroid: Eigen.Vector3d
                measure: float
                diameter: float
                tetrahedron_vertices: List[Eigen.MatrixXd]

                faces_rotation_matrix: List[Eigen.Matrix3d]
                faces_translation: List[Eigen.Vector3d]
                faces_normal: List[Eigen.Vector3d]
                faces_normal_direction: List[bool]
                faces_global_normal_direction: List[bool]
                faces_measure: List[float]
                faces_centroid2_d: List[Eigen.Vector3d]
                faces_diameter: List[float]
                faces_triangulation_vertices2_d: List[List[Eigen.Matrix3d]]
                def __init__(
                    self,
                    tolerance1_d: float = float(),
                    tolerance2_d: float = float(),
                    tolerance3_d: float = float(),
                    vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    measure: float = float(),
                    diameter: float = float(),
                    tetrahedron_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    faces_rotation_matrix: List[Eigen.Matrix3d] = List[Eigen.Matrix3d](),
                    faces_translation: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                    faces_normal: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                    faces_normal_direction: List[bool] = List[bool](),
                    faces_global_normal_direction: List[bool] = List[bool](),
                    faces_measure: List[float] = List[float](),
                    faces_centroid2_d: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                    faces_diameter: List[float] = List[float](),
                    faces_triangulation_vertices2_d: List[List[Eigen.Matrix3d]] = List[List[Eigen.Matrix3d]]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_MCC_3D_Velocity_LocalSpace_Data:
                """
                (final class)
                """
                order: int

                dimension: int

                num_boundary_basis_functions: int

                num_nabla_internal_basis_functions: int

                num_big_o_plus_internal_basis_functions: int
                num_internal_basis_functions: int
                num_basis_functions: int

                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: Polydim.VEM.Quadrature.VEM_Quadrature_3D.Faces_QuadratureData_MCC

                vander_internal: Eigen.MatrixXd
                vander_internal_kp1: Eigen.MatrixXd

                faces_vander_internal: List[Eigen.MatrixXd]

                edge_basis_coefficients: Eigen.VectorXd

                pi0k: Eigen.MatrixXd

                wmatrix: Eigen.MatrixXd

                hmatrix: Eigen.MatrixXd

                vander_boundary: Eigen.MatrixXd
                vander_boundary_kp1: Eigen.MatrixXd

                nk: int
                nk_nabla: int

                tk_nabla: Eigen.MatrixXd
                tk_big_o_plus: Eigen.MatrixXd
                gk_vander_internal: Eigen.MatrixXd
                gk_vander_boundary_times_normal: Eigen.MatrixXd

                qmatrix_kp1: Eigen.MatrixXd
                qmatrix_inv_kp1: Eigen.MatrixXd
                qmatrix_tk_nabla_inv: Eigen.MatrixXd
                qmatrix_tk_nabla: Eigen.MatrixXd

                diameter: float
                measure: float
                centroid: Eigen.Vector3d

                tk_nabla_dof: Eigen.MatrixXd

                bmatrix: Eigen.MatrixXd
                dmatrix: Eigen.MatrixXd
                gmatrix: Eigen.MatrixXd

                vmatrix: Eigen.MatrixXd

                vander_basis_function_values_on_face: List[Eigen.MatrixXd]
                def __init__(
                    self,
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    boundary_quadrature: VEM.Quadrature.VEM_Quadrature_3D.Faces_QuadratureData_MCC = VEM.Quadrature.VEM_Quadrature_3.Faces_QuadratureData_MCC(),
                    vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_internal_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    faces_vander_internal: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    edge_basis_coefficients: Eigen.VectorXd = Eigen.VectorXd(),
                    pi0k: Eigen.MatrixXd = Eigen.MatrixXd(),
                    wmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    hmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_boundary: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_boundary_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    tk_nabla: Eigen.MatrixXd = Eigen.MatrixXd(),
                    tk_big_o_plus: Eigen.MatrixXd = Eigen.MatrixXd(),
                    gk_vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    gk_vander_boundary_times_normal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix_inv_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix_tk_nabla_inv: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix_tk_nabla: Eigen.MatrixXd = Eigen.MatrixXd(),
                    diameter: float = float(),
                    measure: float = float(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    tk_nabla_dof: Eigen.MatrixXd = Eigen.MatrixXd(),
                    bmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    dmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    gmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_basis_function_values_on_face: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_MCC_3D_Pressure_LocalSpace_Data:
                """
                (final class)
                """
                order: int
                dimension: int

                nk: int
                nkm1: int

                num_basis_functions: int

                diameter: float
                centroid: Eigen.Vector3d

                internal_quadrature: Gedim.Quadrature.QuadratureData

                qmatrix: Eigen.MatrixXd
                vander_internal: Eigen.MatrixXd

                hmatrix: Eigen.MatrixXd
                def __init__(
                    self,
                    diameter: float = float(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    qmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    hmatrix: Eigen.MatrixXd = Eigen.MatrixXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass


        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_3D_LocalSpace_Data.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_EdgeOrtho_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_EdgeOrtho_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""
            class VEM_MCC_2D_EdgeOrtho_Pressure_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_MCC_2D_Pressure_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_MCC_2D_EdgeOrtho_Velocity_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_MCC_2D_Velocity_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_EdgeOrtho_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_PCC_2D_Creator.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_2D_Creator_HPP
#




# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class VEM_PCC_2D_LocalSpace_Types(enum.IntEnum):
                vem_pcc_2_d_local_space = enum.auto()         # (= 1)
                vem_pcc_2_d_inertia_local_space = enum.auto() # (= 2)
                vem_pcc_2_d_ortho_local_space = enum.auto()   # (= 3)

            @staticmethod
            def create_vem_pcc_2_d_reference_element(
                type: VEM_PCC_2D_LocalSpace_Types
                ) -> I_VEM_PCC_2D_ReferenceElement:
                pass

            @staticmethod
            def create_vem_pcc_2_d_local_space(
                type: VEM_PCC_2D_LocalSpace_Types
                ) -> I_VEM_PCC_2D_LocalSpace:
                pass


        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_2D_Creator.hpp>    ####################


####################    <generated_from:VEM_PCC_2D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_2D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class VEM_PCC_2D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    polygon: VEM_PCC_2D_Polygon_Geometry
                    ) -> VEM_PCC_2D_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute3_d_utilities(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    polygon: VEM_PCC_2D_Polygon_Geometry
                    ) -> VEM_PCC_2D_LocalSpace_Data:
                    pass

                def compute3_d_utilities_df_pcc(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    polygon: VEM_PCC_2D_Polygon_Geometry
                    ) -> VEM_PCC_2D_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_scaled_polynomials_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass
                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass
                def compute_polynomials_laplacian_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_values_on_edge(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_2D_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_PCC_2D_Inertia_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_2D_Inertia_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class VEM_PCC_2D_Inertia_LocalSpace:
                """/ \brief Primal Conforming Constant degree Virtual Element Methods 2D with improvements for high-order \cite
                / Teora2024.
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    polygon: VEM_PCC_2D_Polygon_Geometry
                    ) -> VEM_PCC_2D_LocalSpace_Data:
                    pass

                def compute3_d_utilities(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    polygon: VEM_PCC_2D_Polygon_Geometry
                    ) -> VEM_PCC_2D_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_scaled_polynomials_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_values_on_edge(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    param_0: VEM_PCC_2D_ReferenceElement_Data,
                    param_1: VEM_PCC_2D_LocalSpace_Data,
                    param_2: ProjectionTypes,
                    param_3: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def compute_polynomials_laplacian_values(
                    self,
                    param_0: VEM_PCC_2D_ReferenceElement_Data,
                    param_1: VEM_PCC_2D_LocalSpace_Data,
                    param_2: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_2D_Inertia_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_PCC_2D_Ortho_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_2D_Ortho_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class VEM_PCC_2D_Ortho_LocalSpace:
                """/ \brief Interface class for Primal Conforming Constant degree 2D Virtual Element Methods \cite Mascotto2018 \cite
                / Teora2024.
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    polygon: VEM_PCC_2D_Polygon_Geometry
                    ) -> VEM_PCC_2D_LocalSpace_Data:
                    pass

                def compute3_d_utilities(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    polygon: VEM_PCC_2D_Polygon_Geometry
                    ) -> VEM_PCC_2D_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_polynomials_dofs(
                    self,
                    polytope_measure: float,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> None:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_scaled_polynomials_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_values_on_edge(
                    self,
                    reference_element_data: VEM_PCC_2D_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    local_space: VEM_PCC_2D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass
                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    param_0: VEM_PCC_2D_ReferenceElement_Data,
                    param_1: VEM_PCC_2D_LocalSpace_Data,
                    param_2: ProjectionTypes,
                    param_3: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def compute_polynomials_laplacian_values(
                    self,
                    param_0: VEM_PCC_2D_ReferenceElement_Data,
                    param_1: VEM_PCC_2D_LocalSpace_Data,
                    param_2: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_2D_Ortho_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_PCC_3D_Creator.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_3D_Creator_HPP
#




# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class VEM_PCC_3D_LocalSpace_Types(enum.IntEnum):
                vem_pcc_3_d_local_space = enum.auto()         # (= 1)
                vem_pcc_3_d_inertia_local_space = enum.auto() # (= 2)
                vem_pcc_3_d_ortho_local_space = enum.auto()   # (= 3)

            @staticmethod
            def create_vem_pcc_3_d_reference_element_2_d(
                type: VEM_PCC_3D_LocalSpace_Types
                ) -> I_VEM_PCC_2D_ReferenceElement:
                pass

            @staticmethod
            def create_vem_pcc_3_d_reference_element_3_d(
                type: VEM_PCC_3D_LocalSpace_Types
                ) -> I_VEM_PCC_3D_ReferenceElement:
                pass

            @staticmethod
            def create_vem_pcc_3_d_local_space_2_d(
                type: VEM_PCC_3D_LocalSpace_Types
                ) -> I_VEM_PCC_2D_LocalSpace:
                pass

            @staticmethod
            def create_vem_pcc_3_d_local_space_3_d(
                type: VEM_PCC_3D_LocalSpace_Types
                ) -> I_VEM_PCC_3D_LocalSpace:
                pass


        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_3D_Creator.hpp>    ####################


####################    <generated_from:VEM_PCC_3D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_3D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class VEM_PCC_3D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data_2_d: VEM_PCC_2D_ReferenceElement_Data,
                    reference_element_data_3_d: VEM_PCC_3D_ReferenceElement_Data,
                    polyhedron: VEM_PCC_3D_Polyhedron_Geometry
                    ) -> VEM_PCC_3D_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_d_recipe_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    coercivity_matrix: Eigen.MatrixXd,
                    vector_coefficients: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_polynomials_laplacian_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_values_on_edge(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_3D_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_PCC_3D_Inertia_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_3D_Inertia_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class VEM_PCC_3D_Inertia_LocalSpace:
                """/ \brief Interface class for Primal Conforming Constant degree 3D Virtual Element Methods \cite Teora2024.
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data_2_d: VEM_PCC_2D_ReferenceElement_Data,
                    reference_element_data_3_d: VEM_PCC_3D_ReferenceElement_Data,
                    polyhedron: VEM_PCC_3D_Polyhedron_Geometry
                    ) -> VEM_PCC_3D_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_d_recipe_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    coercivity_matrix: Eigen.MatrixXd,
                    vector_coefficients: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    param_0: VEM_PCC_3D_LocalSpace_Data,
                    param_1: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    param_0: VEM_PCC_3D_ReferenceElement_Data,
                    param_1: VEM_PCC_3D_LocalSpace_Data,
                    param_2: ProjectionTypes,
                    param_3: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_polynomials_laplacian_values(
                    self,
                    param_0: VEM_PCC_3D_ReferenceElement_Data,
                    param_1: VEM_PCC_3D_LocalSpace_Data,
                    param_2: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_values_on_edge(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_3D_Inertia_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_PCC_3D_Ortho_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_PCC_3D_Ortho_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class VEM_PCC_3D_Ortho_LocalSpace:
                """/ \brief Interface class for Primal Conforming Constant degree 3D Virtual Element Methods \cite DassiMascotto2018
                / \cite Teora2024.
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data_2_d: VEM_PCC_2D_ReferenceElement_Data,
                    reference_element_data_3_d: VEM_PCC_3D_ReferenceElement_Data,
                    polyhedron: VEM_PCC_3D_Polyhedron_Geometry
                    ) -> VEM_PCC_3D_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_d_recipe_stabilization_matrix(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    coercivity_matrix: Eigen.MatrixXd,
                    vector_coefficients: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_values_on_edge(
                    self,
                    reference_element_data: VEM_PCC_3D_ReferenceElement_Data,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    param_0: VEM_PCC_3D_LocalSpace_Data,
                    param_1: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_laplacian_values(
                    self,
                    param_0: VEM_PCC_3D_ReferenceElement_Data,
                    param_1: VEM_PCC_3D_LocalSpace_Data,
                    param_2: ProjectionTypes,
                    param_3: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_polynomials_laplacian_values(
                    self,
                    param_0: VEM_PCC_3D_ReferenceElement_Data,
                    param_1: VEM_PCC_3D_LocalSpace_Data,
                    param_2: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    local_space: VEM_PCC_3D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_PCC_3D_Ortho_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_MCC_Utilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_Utilities_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""
            class ProjectionTypes(enum.IntEnum):
                pi0k = enum.auto() # (= 1)

            class VEM_MCC_Utilities:
                """
                (final class)
                """
                def compute_polynomial_basis_dofs(
                    self,
                    dimension: int,
                    polytope_measure: float,
                    order: int,
                    nk: int,
                    num_boundary_basis_functions: int,
                    num_nabla_internal_basis_functions: int,
                    num_big_o_plus_internal_basis_functions: int,
                    num_basis_functions: int,
                    gk_vander_boundary_times_normal: Eigen.MatrixXd,
                    gmatrix: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    projector: Eigen.MatrixXd,
                    coefficient: float,
                    d_matrix: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def monomial_trace_on_edges(
                    self,
                    polynomial_degree: int,
                    polygon_vertices: Eigen.MatrixXd,
                    polygon_diameter: float,
                    polygon_centroid: Eigen.Vector3d,
                    edge_directions: List[bool],
                    edge_tangents: Eigen.MatrixXd,
                    cmatrixkp1: List[Eigen.MatrixXd]
                    ) -> None:
                    pass

                def compute_basis_functions_values(
                    self,
                    dimension: int,
                    projector: Eigen.MatrixXd,
                    g_vander: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_Utilities.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_Creator.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_Creator_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            class VEM_MCC_2D_LocalSpace_Types(enum.IntEnum):
                vem_mcc_2_d_local_space = enum.auto()                  # (= 1)
                vem_mcc_2_d_partial_local_space = enum.auto()          # (= 2)
                vem_mcc_2_d_ortho_local_space = enum.auto()            # (= 3)
                vem_mcc_2_d_edge_ortho_local_space = enum.auto()       # (= 4)
                vem_mcc_2_d_ortho_edge_ortho_local_space = enum.auto() # (= 5)

            @staticmethod
            def create_vem_mcc_2_d_pressure_reference_element(
                type: VEM_MCC_2D_LocalSpace_Types
                ) -> I_VEM_MCC_2D_Pressure_ReferenceElement:
                pass

            @staticmethod
            def create_vem_mcc_2_d_velocity_reference_element(
                type: VEM_MCC_2D_LocalSpace_Types
                ) -> I_VEM_MCC_2D_Velocity_ReferenceElement:
                pass

            @staticmethod
            def create_vem_mcc_2_d_pressure_local_space(
                type: VEM_MCC_2D_LocalSpace_Types
                ) -> I_VEM_MCC_2D_Pressure_LocalSpace:
                pass

            @staticmethod
            def create_vem_mcc_2_d_velocity_local_space(
                type: VEM_MCC_2D_LocalSpace_Types
                ) -> I_VEM_MCC_2D_Velocity_LocalSpace:
                pass


        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_Creator.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""
            class VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_MCC_2D_Polygon_Geometry
                    ) -> VEM_MCC_2D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_LocalSpace_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_LocalSpace_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""
            class VEM_MCC_2D_Polygon_Geometry:
                """
                (final class)
                """
                tolerance1_d: float
                tolerance2_d: float

                vertices: Eigen.MatrixXd
                centroid: Eigen.Vector3d
                measure: float
                diameter: float
                triangulation_vertices: List[Eigen.Matrix3d]
                edges_length: Eigen.VectorXd
                edges_direction: List[bool]
                edges_tangent: Eigen.MatrixXd
                edges_normal: Eigen.MatrixXd
                def __init__(
                    self,
                    tolerance1_d: float = float(),
                    tolerance2_d: float = float(),
                    vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    measure: float = float(),
                    diameter: float = float(),
                    triangulation_vertices: List[Eigen.Matrix3d] = List[Eigen.Matrix3d](),
                    edges_length: Eigen.VectorXd = Eigen.VectorXd(),
                    edges_direction: List[bool] = List[bool](),
                    edges_tangent: Eigen.MatrixXd = Eigen.MatrixXd(),
                    edges_normal: Eigen.MatrixXd = Eigen.MatrixXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_MCC_2D_Velocity_LocalSpace_Data:
                """
                (final class)
                """
                order: int

                dimension: int

                num_boundary_basis_functions: int

                num_nabla_internal_basis_functions: int

                num_big_o_plus_internal_basis_functions: int
                num_internal_basis_functions: int
                num_basis_functions: int

                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: Polydim.VEM.Quadrature.VEM_Quadrature_2D.Edges_QuadratureData

                vander_internal: Eigen.MatrixXd
                vander_internal_kp1: Eigen.MatrixXd

                faces_vander_internal: List[Eigen.MatrixXd]

                edge_basis_coefficients: Eigen.VectorXd

                pi0k: Eigen.MatrixXd

                wmatrix: Eigen.MatrixXd

                diameter: float
                measure: float
                centroid: Eigen.Vector3d

                hmatrix: Eigen.MatrixXd

                vander_boundary: Eigen.MatrixXd
                vander_boundary_kp1: Eigen.MatrixXd

                nk: int
                nk_nabla: int

                tk_nabla: Eigen.MatrixXd
                tk_big_o_plus: Eigen.MatrixXd
                gk_vander_internal: Eigen.MatrixXd
                gk_vander_boundary_times_normal: Eigen.MatrixXd

                qmatrix_kp1: Eigen.MatrixXd
                qmatrix_inv_kp1: Eigen.MatrixXd
                qmatrix_tk_nabla_inv: Eigen.MatrixXd
                qmatrix_tk_nabla: Eigen.MatrixXd

                tk_nabla_dof: Eigen.MatrixXd

                bmatrix: Eigen.MatrixXd
                dmatrix: Eigen.MatrixXd
                gmatrix: Eigen.MatrixXd

                vmatrix: Eigen.MatrixXd

                vander_basis_function_values_on_face: List[Eigen.MatrixXd]
                def __init__(
                    self,
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    boundary_quadrature: VEM.Quadrature.VEM_Quadrature_2D.Edges_QuadratureData = VEM.Quadrature.VEM_Quadrature_2.Edges_QuadratureData(),
                    vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_internal_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    faces_vander_internal: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    edge_basis_coefficients: Eigen.VectorXd = Eigen.VectorXd(),
                    pi0k: Eigen.MatrixXd = Eigen.MatrixXd(),
                    wmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    diameter: float = float(),
                    measure: float = float(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    hmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_boundary: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_boundary_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    tk_nabla: Eigen.MatrixXd = Eigen.MatrixXd(),
                    tk_big_o_plus: Eigen.MatrixXd = Eigen.MatrixXd(),
                    gk_vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    gk_vander_boundary_times_normal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix_inv_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix_tk_nabla_inv: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix_tk_nabla: Eigen.MatrixXd = Eigen.MatrixXd(),
                    tk_nabla_dof: Eigen.MatrixXd = Eigen.MatrixXd(),
                    bmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    dmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    gmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_basis_function_values_on_face: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_MCC_2D_Pressure_LocalSpace_Data:
                """
                (final class)
                """
                order: int
                dimension: int

                nk: int
                nkm1: int

                num_basis_functions: int

                diameter: float
                centroid: Eigen.Vector3d

                internal_quadrature: Gedim.Quadrature.QuadratureData

                vander_internal: Eigen.MatrixXd
                qmatrix: Eigen.MatrixXd
                hmatrix: Eigen.MatrixXd
                def __init__(
                    self,
                    diameter: float = float(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    qmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    hmatrix: Eigen.MatrixXd = Eigen.MatrixXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass


        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_LocalSpace_Data.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            #/ \brief Interface class for the velocity space of 2D Mixed Conforming Constant degree Virtual Element Methods \cite
            #/ Teora2023.

            class VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_MCC_2D_Polygon_Geometry
                    ) -> VEM_MCC_2D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_Ortho_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_Ortho_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            #/ \brief Interface class for the velocity space of 2D Mixed Conforming Constant degree Virtual Element Methods \cite
            #/ Teora2024_mixed.

            class VEM_MCC_2D_Ortho_Velocity_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_MCC_2D_Polygon_Geometry
                    ) -> VEM_MCC_2D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_Ortho_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_Partial_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_Partial_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            #/ \brief Interface class for the velocity space of 2D Mixed Conforming Constant degree Virtual Element Methods \cite
            #/ Teora2024_mixed.

            class VEM_MCC_2D_Partial_Velocity_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_MCC_2D_Polygon_Geometry
                    ) -> VEM_MCC_2D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_Partial_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_Pressure_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_Presure_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            class VEM_MCC_2D_Pressure_LocalSpace:
                """
                (final class)
                """

                def create_local_space(
                    self,
                    reference_element_data: VEM_MCC_2D_Pressure_ReferenceElement_Data,
                    polygon: VEM_MCC_2D_Polygon_Geometry
                    ) -> VEM_MCC_2D_Pressure_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_MCC_2D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_MCC_2D_Pressure_ReferenceElement_Data,
                    local_space: VEM_MCC_2D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_MCC_2D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_MCC_2D_Pressure_ReferenceElement_Data,
                    local_space: VEM_MCC_2D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_Pressure_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            class VEM_MCC_2D_Pressure_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_MCC_2D_Pressure_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_MCC_2D_Velocity_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_MCC_2D_Velocity_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_MCC_2D_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_2D_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            class VEM_MCC_2D_Velocity_LocalSpace:
                """/ \brief Interface class for the velocity space of 2D Mixed Conforming Constant degree Virtual Element Methods \cite
                / secondMixed \cite DaVeiga2016.
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_MCC_2D_Polygon_Geometry
                    ) -> VEM_MCC_2D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_MCC_2D_Velocity_ReferenceElement_Data,
                    local_space: VEM_MCC_2D_Velocity_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_2D_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_MCC_3D_Creator.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_3D_Creator_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""
            class VEM_MCC_3D_LocalSpace_Types(enum.IntEnum):
                vem_mcc_3_d_local_space = enum.auto() # (= 1)

            @staticmethod
            def create_vem_mcc_3_d_pressure_reference_element(
                type: VEM_MCC_3D_LocalSpace_Types
                ) -> I_VEM_MCC_3D_Pressure_ReferenceElement:
                pass

            @staticmethod
            def create_vem_mcc_3_d_velocity_reference_element(
                type: VEM_MCC_3D_LocalSpace_Types
                ) -> I_VEM_MCC_3D_Velocity_ReferenceElement:
                pass

            @staticmethod
            def create_vem_mcc_3_d_pressure_local_space(
                type: VEM_MCC_3D_LocalSpace_Types
                ) -> I_VEM_MCC_3D_Pressure_LocalSpace:
                pass

            @staticmethod
            def create_vem_mcc_3_d_velocity_local_space(
                type: VEM_MCC_3D_LocalSpace_Types
                ) -> I_VEM_MCC_3D_Velocity_LocalSpace:
                pass


        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_3D_Creator.hpp>    ####################


####################    <generated_from:VEM_MCC_3D_Pressure_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_3D_Pressure_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            class VEM_MCC_3D_Pressure_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_MCC_3D_Pressure_ReferenceElement_Data,
                    polygon: VEM_MCC_3D_Polyhedron_Geometry
                    ) -> VEM_MCC_3D_Pressure_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_MCC_3D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_MCC_3D_Pressure_ReferenceElement_Data,
                    local_space: VEM_MCC_3D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_MCC_3D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_MCC_3D_Pressure_ReferenceElement_Data,
                    local_space: VEM_MCC_3D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_3D_Pressure_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_MCC_3D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_3D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""

            class VEM_MCC_3D_Pressure_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_MCC_3D_Pressure_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_MCC_3D_Velocity_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_MCC_3D_Velocity_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_3D_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_MCC_3D_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_MCC_3D_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule mcc>
        class mcc:  # Proxy class that introduces typings for the *submodule* mcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace MCC"""
            class VEM_MCC_3D_Velocity_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_MCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_MCC_3D_Polyhedron_Geometry
                    ) -> VEM_MCC_3D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_MCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values(
                    self,
                    local_space: VEM_MCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_MCC_3D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_MCC_3D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_MCC_3D_Velocity_ReferenceElement_Data,
                    local_space: VEM_MCC_3D_Velocity_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule mcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_MCC_3D_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_Utilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_Utilities_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class ProjectionTypes(enum.IntEnum):
                pi0km2 = enum.auto()     # (= 0)
                pi0k = enum.auto()       # (= 1)
                pi_nabla = enum.auto()   # (= 2)
                pi0km1_der = enum.auto() # (= 3)

            class VEM_DF_PCC_Utilities:
                """
                (final class)
                """
                def compute_edge_basis_coefficients(
                    self,
                    order: int,
                    edge_internal_points: Eigen.VectorXd
                    ) -> Eigen.VectorXd:
                    pass

                def compute_basis_functions_derivative_values(
                    self,
                    dimension: int,
                    projection_type: ProjectionTypes,
                    nkm1: int,
                    vander_internal: Eigen.MatrixXd,
                    vander_internal_derivatives: List[Eigen.MatrixXd],
                    pi_nabla: List[Eigen.MatrixXd],
                    pi0km1_der: List[Eigen.MatrixXd]
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    nkm1: int,
                    vander_internal: Eigen.MatrixXd,
                    vmatrix: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values(
                    self,
                    dimension: int,
                    projection_type: ProjectionTypes,
                    nkm2: int,
                    pi0km2: List[Eigen.MatrixXd],
                    pi0k: List[Eigen.MatrixXd],
                    vander_internal: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsValues>
                @overload
                def compute_polynomials_values(
                    self,
                    vander_internal: Eigen.MatrixXd,
                    monomials: Utilities.Monomials_2D
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    vander_internal: Eigen.MatrixXd,
                    monomials: Utilities.Monomials_3D
                    ) -> Eigen.MatrixXd:
                    pass
                #      </template specializations for function ComputePolynomialsValues>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsValues>
                @overload
                def compute_polynomials_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_2D,
                    centroid: Eigen.Vector3d,
                    diameter: float,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_3D,
                    centroid: Eigen.Vector3d,
                    diameter: float,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                #      </template specializations for function ComputePolynomialsValues>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsDerivativeValues>
                @overload
                def compute_polynomials_derivative_values(
                    self,
                    vander_internal_derivatives: List[Eigen.MatrixXd],
                    monomials: Utilities.Monomials_2D
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    vander_internal_derivatives: List[Eigen.MatrixXd],
                    monomials: Utilities.Monomials_3D
                    ) -> List[Eigen.MatrixXd]:
                    pass
                #      </template specializations for function ComputePolynomialsDerivativeValues>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsDerivativeValues>
                @overload
                def compute_polynomials_derivative_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_2D,
                    diameter: float,
                    vander: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_3D,
                    diameter: float,
                    vander: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass
                #      </template specializations for function ComputePolynomialsDerivativeValues>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function ComputePolynomialsLaplacianValues>
                @overload
                def compute_polynomials_laplacian_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_2D,
                    diameter: float,
                    vander: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_laplacian_values(
                    self,
                    data: Utilities.Monomials_Data,
                    monomials: Utilities.Monomials_3D,
                    diameter: float,
                    vander: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                #      </template specializations for function ComputePolynomialsLaplacianValues>
                #  ------------------------------------------------------------------------

                def compute_values_on_edge(
                    self,
                    edge_internal_points: Eigen.RowVectorXd,
                    order: int,
                    edge_basis_coefficients: Eigen.VectorXd,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    dimension: int,
                    projector: List[Eigen.MatrixXd],
                    coefficient: float,
                    dmatrix: List[Eigen.MatrixXd]
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_Utilities.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_2D_Creator.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_2D_Creator_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""
            class VEM_DF_PCC_2D_LocalSpace_Types(enum.IntEnum):
                vem_df_pcc_2_d_local_space = enum.auto()         # (= 1)
                vem_df_pcc_2_d_reduced_local_space = enum.auto() # (= 2)

            @staticmethod
            def create_vem_df_pcc_2_d_full_pressure_reference_element(
                type: VEM_DF_PCC_2D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_2D_Pressure_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_2_d_full_velocity_reference_element(
                type: VEM_DF_PCC_2D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_2D_Velocity_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_2_d_full_pressure_local_space(
                type: VEM_DF_PCC_2D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_2D_Pressure_LocalSpace:
                pass

            @staticmethod
            def create_vem_df_pcc_2_d_full_velocity_local_space(
                type: VEM_DF_PCC_2D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_2D_Velocity_LocalSpace:
                pass

            @staticmethod
            def create_vem_df_pcc_2_d_pressure_reference_element(
                type: VEM_DF_PCC_2D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_2D_Pressure_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_2_d_velocity_reference_element(
                type: VEM_DF_PCC_2D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_2D_Velocity_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_2_d_pressure_local_space(
                type: VEM_DF_PCC_2D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_2D_Pressure_LocalSpace:
                pass

            @staticmethod
            def create_vem_df_pcc_2_d_velocity_local_space(
                type: VEM_DF_PCC_2D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_2D_Velocity_LocalSpace:
                pass


        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_2D_Creator.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_2D_LocalSpace_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_2D_LocalSpace_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_2D_Polygon_Geometry:
                """
                (final class)
                """
                tolerance1_d: float
                tolerance2_d: float

                vertices: Eigen.MatrixXd
                centroid: Eigen.Vector3d
                measure: float
                diameter: float
                triangulation_vertices: List[Eigen.Matrix3d]
                edges_length: Eigen.VectorXd
                edges_direction: List[bool]
                edges_tangent: Eigen.MatrixXd
                edges_normal: Eigen.MatrixXd
                def __init__(
                    self,
                    tolerance1_d: float = float(),
                    tolerance2_d: float = float(),
                    vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    measure: float = float(),
                    diameter: float = float(),
                    triangulation_vertices: List[Eigen.Matrix3d] = List[Eigen.Matrix3d](),
                    edges_length: Eigen.VectorXd = Eigen.VectorXd(),
                    edges_direction: List[bool] = List[bool](),
                    edges_tangent: Eigen.MatrixXd = Eigen.MatrixXd(),
                    edges_normal: Eigen.MatrixXd = Eigen.MatrixXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_DF_PCC_2D_Velocity_LocalSpace_Data:
                """
                (final class)
                """
                order: int
                dimension: int

                n_kp1: int
                nk: int
                nkm1: int
                nkm2: int
                nkm3: int
                nkm4: int

                num_vertex_basis_functions: int
                num_edge_basis_functions: int

                num_boundary_basis_functions: int

                num_divergence_internal_basis_functions: int
                num_big_o_plus_internal_basis_functions: int

                num_internal_basis_functions: int

                num_basis_functions: int

                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: Polydim.VEM.Quadrature.VEM_Quadrature_2D.Edges_QuadratureData
                edges_do_fs: Polydim.VEM.Quadrature.VEM_Quadrature_2D.Edges_QuadratureData

                diameter: float
                measure: float
                centroid: Eigen.Vector3d

                vander_internal: Eigen.MatrixXd
                vander_internal_derivatives: List[Eigen.MatrixXd]

                vander_boundary: Eigen.MatrixXd
                vander_boundary_kp1: Eigen.MatrixXd
                vander_boundary_derivatives: List[Eigen.MatrixXd]
                vander_kp1_edge_projections: Eigen.MatrixXd

                vector_decomposition_matrices: List[List[Eigen.MatrixXd]]
                vander_g_big_o_plus: List[Eigen.MatrixXd]
                vander_g_big_o_pluskm2: List[Eigen.MatrixXd]

                hmatrix: Eigen.MatrixXd
                hmatrix_kp1: Eigen.MatrixXd

                reference_edge_internal_points: Eigen.VectorXd
                reference_edge_dof_internal_points: Eigen.VectorXd
                edge_basis_coefficients: Eigen.VectorXd

                pi_nabla: List[Eigen.MatrixXd]
                pi0km2: List[Eigen.MatrixXd]
                pi0k: List[Eigen.MatrixXd]
                pi0km1_der: List[Eigen.MatrixXd]

                wmatrix: Eigen.MatrixXd
                vmatrix: Eigen.MatrixXd
                bmatrix: List[Eigen.MatrixXd]
                dmatrix: List[Eigen.MatrixXd]
                gmatrix: Eigen.MatrixXd
                cmatrix: List[Eigen.MatrixXd]
                cmatrixkm2: List[Eigen.MatrixXd]
                ematrix: List[Eigen.MatrixXd]
                def __init__(
                    self,
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    boundary_quadrature: VEM.Quadrature.VEM_Quadrature_2D.Edges_QuadratureData = VEM.Quadrature.VEM_Quadrature_2.Edges_QuadratureData(),
                    edges_do_fs: VEM.Quadrature.VEM_Quadrature_2D.Edges_QuadratureData = VEM.Quadrature.VEM_Quadrature_2.Edges_QuadratureData(),
                    diameter: float = float(),
                    measure: float = float(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_internal_derivatives: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    vander_boundary: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_boundary_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_boundary_derivatives: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    vander_kp1_edge_projections: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vector_decomposition_matrices: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                    vander_g_big_o_plus: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    vander_g_big_o_pluskm2: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    hmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    hmatrix_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_edge_internal_points: Eigen.VectorXd = Eigen.VectorXd(),
                    reference_edge_dof_internal_points: Eigen.VectorXd = Eigen.VectorXd(),
                    edge_basis_coefficients: Eigen.VectorXd = Eigen.VectorXd(),
                    pi_nabla: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    pi0km2: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    pi0k: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    pi0km1_der: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    wmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    bmatrix: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    dmatrix: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    gmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    cmatrix: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    cmatrixkm2: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    ematrix: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_DF_PCC_2D_Pressure_LocalSpace_Data:
                """
                (final class)
                """
                order: int
                dimension: int

                nk: int
                nkm1: int

                num_basis_functions: int

                diameter: float
                centroid: Eigen.Vector3d

                internal_quadrature: Gedim.Quadrature.QuadratureData

                vander_internal: Eigen.MatrixXd

                hmatrix: Eigen.MatrixXd
                def __init__(
                    self,
                    diameter: float = float(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    hmatrix: Eigen.MatrixXd = Eigen.MatrixXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_2D_LocalSpace_Data.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_2D_Pressure_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_2D_Presure_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_2D_Pressure_LocalSpace:
                """
                (final class)
                """

                def create_local_space(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Pressure_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry
                    ) -> VEM_DF_PCC_2D_Pressure_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Pressure_ReferenceElement_Data,
                    local_space: VEM_DF_PCC_2D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Pressure_ReferenceElement_Data,
                    local_space: VEM_DF_PCC_2D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_2D_Pressure_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace:
                """
                (final class)
                """

                def create_local_space(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Pressure_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry
                    ) -> VEM_DF_PCC_2D_Pressure_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Pressure_ReferenceElement_Data,
                    local_space: VEM_DF_PCC_2D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Pressure_ReferenceElement_Data,
                    local_space: VEM_DF_PCC_2D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_2D_Reduced_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_2D_Reduced_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_2D_Reduced_Pressure_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_DF_PCC_2D_Pressure_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_DF_PCC_2D_Reduced_Velocity_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_DF_PCC_2D_Velocity_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_2D_Reduced_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace:
                """
                (final class)
                """

                def create_local_space(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry
                    ) -> VEM_DF_PCC_2D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_values_on_edge(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_polynomials_laplacian_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_2D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_2D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_2D_Pressure_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_DF_PCC_2D_Pressure_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_DF_PCC_2D_Velocity_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_DF_PCC_2D_Velocity_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_2D_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_2D_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_2D_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_2D_Velocity_LocalSpace:
                """
                (final class)
                """

                def create_local_space(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry
                    ) -> VEM_DF_PCC_2D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_values_on_edge(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_polynomials_laplacian_values(
                    self,
                    reference_element_data: VEM_DF_PCC_2D_Velocity_ReferenceElement_Data,
                    polygon: VEM_DF_PCC_2D_Polygon_Geometry,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_DF_PCC_2D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_2D_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_3D_Creator.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_3D_Creator_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""
            class VEM_DF_PCC_3D_LocalSpace_Types(enum.IntEnum):
                vem_df_pcc_3_d_local_space = enum.auto()         # (= 1)
                vem_df_pcc_3_d_reduced_local_space = enum.auto() # (= 2)

            @staticmethod
            def create_vem_df_pcc_3_d_velocity_reference_element_2_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> PCC.I_VEM_PCC_2D_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_3_d_full_pressure_reference_element_3_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_3D_Pressure_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_3_d_full_velocity_reference_element_3_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_3D_Velocity_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_3_d_full_pressure_local_space_3_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_3D_Pressure_LocalSpace:
                pass

            @staticmethod
            def create_vem_df_pcc_3_d_full_velocity_local_space_3_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_3D_Velocity_LocalSpace:
                pass

            @staticmethod
            def create_vem_df_pcc_3_d_pressure_reference_element_3_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_3D_Pressure_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_3_d_velocity_reference_element_3_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_3D_Velocity_ReferenceElement:
                pass

            @staticmethod
            def create_vem_df_pcc_3_d_pressure_local_space_3_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_3D_Pressure_LocalSpace:
                pass

            @staticmethod
            def create_vem_df_pcc_3_d_velocity_local_space_3_d(
                type: VEM_DF_PCC_3D_LocalSpace_Types
                ) -> I_VEM_DF_PCC_3D_Velocity_LocalSpace:
                pass


        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_3D_Creator.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_3D_LocalSpace_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_3D_LocalSpace_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""
            class VEM_DF_PCC_3D_Polyhedron_Geometry:
                """
                (final class)
                """
                tolerance1_d: float
                tolerance2_d: float
                tolerance3_d: float

                vertices: Eigen.MatrixXd
                edges: Eigen.MatrixXi
                faces: List[Eigen.MatrixXi]
                centroid: Eigen.Vector3d
                measure: float
                diameter: float
                tetrahedron_vertices: List[Eigen.MatrixXd]

                faces_rotation_matrix: List[Eigen.Matrix3d]
                faces_translation: List[Eigen.Vector3d]
                faces_normal: List[Eigen.Vector3d]
                faces_normal_direction: List[bool]
                faces_normal_global_direction: List[bool]
                faces_tangents: List[List[Eigen.Vector3d]]
                faces_tangents_global_direction: List[List[bool]]

                edges_direction: List[bool]
                edges_tangent: Eigen.MatrixXd
                def __init__(
                    self,
                    tolerance1_d: float = float(),
                    tolerance2_d: float = float(),
                    tolerance3_d: float = float(),
                    vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                    edges: Eigen.MatrixXi = Eigen.MatrixXi(),
                    faces: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    measure: float = float(),
                    diameter: float = float(),
                    tetrahedron_vertices: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    faces_rotation_matrix: List[Eigen.Matrix3d] = List[Eigen.Matrix3d](),
                    faces_translation: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                    faces_normal: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                    faces_normal_direction: List[bool] = List[bool](),
                    faces_normal_global_direction: List[bool] = List[bool](),
                    edges_direction: List[bool] = List[bool](),
                    edges_tangent: Eigen.MatrixXd = Eigen.MatrixXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_DF_PCC_3D_Velocity_LocalSpace_Data:
                """
                (final class)
                """
                order: int
                dimension: int

                n_kp1: int
                nk: int
                nkm1: int
                nkm2: int
                nkm3: int
                nkm4: int

                faces_local_space: List[Polydim.VEM.PCC.VEM_PCC_2D_LocalSpace_Data]

                num_vertex_basis_functions: int
                num_edge_basis_functions: int
                num_face_basis_functions: int
                num_normal_basis_functions: int
                num_tangents_basis_functions: int
                num_boundary_basis_functions: int
                num_divergence_internal_basis_functions: int
                num_big_o_plus_internal_basis_functions: int
                num_internal_basis_functions: int
                num_basis_functions: int

                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: Polydim.VEM.Quadrature.VEM_Quadrature_3D.Faces_QuadratureData_PCC
                boundary_quadrature_kl: Polydim.VEM.Quadrature.VEM_Quadrature_3D.Faces_QuadratureData_PCC

                diameter: float
                measure: float
                centroid: Eigen.Vector3d

                vander_internal: Eigen.MatrixXd
                vander_internal_derivatives: List[Eigen.MatrixXd]

                vander_boundary: Eigen.MatrixXd

                vander_boundary_kl: Eigen.MatrixXd

                vander_boundary_derivatives: List[Eigen.MatrixXd]

                vector_decomposition_matrices: List[List[Eigen.MatrixXd]]
                vander_g_big_o_plus: List[Eigen.MatrixXd]
                vander_g_big_o_pluskm2: List[Eigen.MatrixXd]

                hmatrix: Eigen.MatrixXd
                hmatrix_kp1: Eigen.MatrixXd

                vander_face_projections_km1: List[Eigen.MatrixXd]
                vander_edge_dofs: Eigen.MatrixXd
                vander_face_projections_kp1_times_normal: Eigen.MatrixXd
                face_scaled_moments_basis: List[Eigen.MatrixXd]
                scaled_hmatrix_on_boundary: List[Eigen.MatrixXd]

                pi_nabla: List[Eigen.MatrixXd]
                pi0km2: List[Eigen.MatrixXd]
                pi0k: List[Eigen.MatrixXd]
                pi0km1_der: List[Eigen.MatrixXd]

                wmatrix: Eigen.MatrixXd
                vmatrix: Eigen.MatrixXd
                bmatrix: List[Eigen.MatrixXd]
                dmatrix: List[Eigen.MatrixXd]
                gmatrix: Eigen.MatrixXd
                cmatrix: List[Eigen.MatrixXd]
                cmatrixkm2: List[Eigen.MatrixXd]
                ematrix: List[Eigen.MatrixXd]
                def __init__(
                    self,
                    faces_local_space: List[VEM.PCC.VEM_PCC_2D_LocalSpace_Data] = List[VEM.PCC.VEM_PCC_2D_LocalSpace_Data](),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    boundary_quadrature: VEM.Quadrature.VEM_Quadrature_3D.Faces_QuadratureData_PCC = VEM.Quadrature.VEM_Quadrature_3.Faces_QuadratureData_PCC(),
                    boundary_quadrature_kl: VEM.Quadrature.VEM_Quadrature_3D.Faces_QuadratureData_PCC = VEM.Quadrature.VEM_Quadrature_3.Faces_QuadratureData_PCC(),
                    diameter: float = float(),
                    measure: float = float(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_internal_derivatives: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    vander_boundary: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_boundary_kl: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_boundary_derivatives: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    vector_decomposition_matrices: List[List[Eigen.MatrixXd]] = List[List[Eigen.MatrixXd]](),
                    vander_g_big_o_plus: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    vander_g_big_o_pluskm2: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    hmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    hmatrix_kp1: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_face_projections_km1: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    vander_edge_dofs: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vander_face_projections_kp1_times_normal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    face_scaled_moments_basis: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    scaled_hmatrix_on_boundary: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    pi_nabla: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    pi0km2: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    pi0k: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    pi0km1_der: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    wmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    vmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    bmatrix: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    dmatrix: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    gmatrix: Eigen.MatrixXd = Eigen.MatrixXd(),
                    cmatrix: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    cmatrixkm2: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    ematrix: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class VEM_DF_PCC_3D_Pressure_LocalSpace_Data:
                """
                (final class)
                """
                order: int
                dimension: int

                nk: int
                nkm1: int

                num_basis_functions: int

                diameter: float
                centroid: Eigen.Vector3d

                internal_quadrature: Gedim.Quadrature.QuadratureData

                vander_internal: Eigen.MatrixXd

                hmatrix: Eigen.MatrixXd
                def __init__(
                    self,
                    diameter: float = float(),
                    centroid: Eigen.Vector3d = Eigen.Vector3d(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    vander_internal: Eigen.MatrixXd = Eigen.MatrixXd(),
                    hmatrix: Eigen.MatrixXd = Eigen.MatrixXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass


        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_3D_LocalSpace_Data.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_3D_Pressure_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_3D_Pressure_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_3D_Pressure_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Pressure_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry
                    ) -> VEM_DF_PCC_3D_Pressure_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Pressure_ReferenceElement_Data,
                    local_space: VEM_DF_PCC_3D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Pressure_ReferenceElement_Data,
                    local_space: VEM_DF_PCC_3D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_3D_Pressure_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace_HPP
#


# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data_3_d: VEM_DF_PCC_3D_Pressure_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry
                    ) -> VEM_DF_PCC_3D_Pressure_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Pressure_ReferenceElement_Data,
                    local_space: VEM_DF_PCC_3D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Pressure_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Pressure_ReferenceElement_Data,
                    local_space: VEM_DF_PCC_3D_Pressure_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_3D_Reduced_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_3D_Reduced_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_3D_Reduced_Pressure_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_DF_PCC_3D_Pressure_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_DF_PCC_3D_Reduced_Velocity_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_DF_PCC_3D_Velocity_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_3D_Reduced_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data_2_d: PCC.VEM_PCC_2D_ReferenceElement_Data,
                    reference_element_data_3_d: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polygonal_faces: List[PCC.VEM_PCC_2D_Polygon_Geometry],
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry
                    ) -> VEM_DF_PCC_3D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_polynomials_laplacian_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_3D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_3D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_3D_Pressure_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_DF_PCC_3D_Pressure_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class VEM_DF_PCC_3D_Velocity_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> VEM_DF_PCC_3D_Velocity_ReferenceElement_Data:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_3D_ReferenceElement.hpp>    ####################


####################    <generated_from:VEM_DF_PCC_3D_Velocity_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __VEM_DF_PCC_3D_Velocity_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule vem>
    class vem:  # Proxy class that introduces typings for the *submodule* vem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace VEM"""

        # <submodule df_pcc>
        class df_pcc:  # Proxy class that introduces typings for the *submodule* df_pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DF_PCC"""

            class VEM_DF_PCC_3D_Velocity_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data_2_d: PCC.VEM_PCC_2D_ReferenceElement_Data,
                    reference_element_data_3_d: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polygonal_faces: List[PCC.VEM_PCC_2D_Polygon_Geometry],
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry
                    ) -> VEM_DF_PCC_3D_Velocity_LocalSpace_Data:
                    pass

                def compute_dofi_dofi_stabilization_matrix(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data,
                    projection_type: ProjectionTypes,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_polynomials_derivative_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def compute_polynomials_laplacian_values(
                    self,
                    reference_element_data: VEM_DF_PCC_3D_Velocity_ReferenceElement_Data,
                    polyhedron: VEM_DF_PCC_3D_Polyhedron_Geometry,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_divergence_values(
                    self,
                    local_space: VEM_DF_PCC_3D_Velocity_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule df_pcc>

    # </submodule vem>

# </submodule polydim>
####################    </generated_from:VEM_DF_PCC_3D_Velocity_LocalSpace.hpp>    ####################


####################    <generated_from:FEM_PCC_1D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_PCC_1D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class FEM_PCC_1D_Segment_Geometry:
                """
                (final class)
                """
                tolerance1_d: float

                origin: Eigen.Vector3d
                tangent: Eigen.Vector3d
                length: float
                def __init__(
                    self,
                    tolerance1_d: float = float(),
                    origin: Eigen.Vector3d = Eigen.Vector3d(),
                    tangent: Eigen.Vector3d = Eigen.Vector3d(),
                    length: float = float()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_PCC_1D_LocalSpace_Data:
                """
                (final class)
                """
                class SegmentMapData:
                    origin: Eigen.Vector3d
                    tangent: Eigen.Vector3d
                    length: float
                    squared_length: float
                    def __init__(
                        self,
                        origin: Eigen.Vector3d = Eigen.Vector3d(),
                        tangent: Eigen.Vector3d = Eigen.Vector3d(),
                        length: float = float(),
                        squared_length: float = float()
                        ) -> None:
                        """Auto-generated default constructor with named params"""
                        pass

                map_data: Polydim.FEM.PCC.FEM_PCC_1D_LocalSpace_Data.SegmentMapData
                order: int
                number_of_basis_functions: int
                dofs: Eigen.MatrixXd
                dofs_mesh_order: List[int]
                dof0_ds_index: List[int]
                dof1_ds_index: List[int]
                internal_quadrature: Gedim.Quadrature.QuadratureData
                def __init__(
                    self,
                    map_data: FEM.PCC.FEM_PCC_1D_LocalSpace_Data.SegmentMapData = FEM.PCC.FEM_PCC_1D_LocalSpace_Data.SegmentMapData(),
                    dofs: Eigen.MatrixXd = Eigen.MatrixXd(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_PCC_1D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: FEM_PCC_1D_ReferenceElement_Data,
                    segment: FEM_PCC_1D_Segment_Geometry
                    ) -> FEM_PCC_1D_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_PCC_1D_ReferenceElement_Data,
                    local_space: FEM_PCC_1D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_PCC_1D_ReferenceElement_Data,
                    local_space: FEM_PCC_1D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_PCC_1D_ReferenceElement_Data,
                    local_space: FEM_PCC_1D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_PCC_1D_ReferenceElement_Data,
                    local_space: FEM_PCC_1D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def internal_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_PCC_1D_ReferenceElement_Data,
                    local_space: FEM_PCC_1D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_PCC_1D_LocalSpace.hpp>    ####################


####################    <generated_from:FEM_PCC_1D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_PCC_1D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class FEM_PCC_1D_Types(enum.IntEnum):
                equispaced = enum.auto()    # (= 0)
                gauss_lobatto = enum.auto() # (= 1)

            class FEM_PCC_1D_ReferenceElement_Data:
                """
                (final class)
                """
                dimension: int
                order: int
                num_dofs0_d: int
                num_dofs1_d: int

                num_basis_functions: int
                dof_positions: Eigen.MatrixXd
                interpolation_coefficients: Eigen.VectorXd

                reference_segment_quadrature: Gedim.Quadrature.QuadratureData

                reference_basis_function_values: Eigen.MatrixXd
                reference_basis_function_derivative_values: List[Eigen.MatrixXd]
                def __init__(
                    self,
                    dof_positions: Eigen.MatrixXd = Eigen.MatrixXd(),
                    interpolation_coefficients: Eigen.VectorXd = Eigen.VectorXd(),
                    reference_segment_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_basis_function_values: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_basis_function_derivative_values: List[Eigen.MatrixXd] = List[Eigen.MatrixXd]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_PCC_1D_ReferenceElement:
                """
                (final class)
                """
                def create(
                    self,
                    order: int,
                    type: FEM_PCC_1D_Types = FEM_PCC_1D_Types.equispaced
                    ) -> FEM_PCC_1D_ReferenceElement_Data:
                    pass
                def evaluate_lambda(self, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
                    """ ***************************************************************************"""
                    pass
                def evaluate_grad_lambda(self, points: Eigen.MatrixXd) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_functions(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_PCC_1D_ReferenceElement_Data
                    ) -> Eigen.MatrixXd:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_function_derivatives(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_PCC_1D_ReferenceElement_Data
                    ) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass
                # ***************************************************************************
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_PCC_1D_ReferenceElement.hpp>    ####################


####################    <generated_from:FEM_PCC_2D_LocalSpace_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_PCC_2D_LocalSpace_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class FEM_PCC_2D_Types(enum.IntEnum):
                triangle = enum.auto()      # (= 0)
                quadrilateral = enum.auto() # (= 1)

            class QuadrilateralType(enum.IntEnum):
                parallelogram = enum.auto() # (= 0)
                generic = enum.auto()       # (= 1)

            class FEM_PCC_2D_Polygon_Geometry:
                """
                (final class)
                """
                tolerance1_d: float
                tolerance2_d: float

                vertices: Eigen.MatrixXd
                edges_direction: List[bool]
                edges_tangent: Eigen.MatrixXd
                edges_length: Eigen.VectorXd
                def __init__(
                    self,
                    tolerance1_d: float = float(),
                    tolerance2_d: float = float(),
                    vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                    edges_direction: List[bool] = List[bool](),
                    edges_tangent: Eigen.MatrixXd = Eigen.MatrixXd(),
                    edges_length: Eigen.VectorXd = Eigen.VectorXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_Triangle_PCC_2D_LocalSpace_Data:
                """
                (final class)
                """
                map_data: Gedim.MapTriangle.MapTriangleData
                b_lap: Eigen.Matrix3d
                order: int
                number_of_basis_functions: int
                num_boundary_basis_functions: int
                num_internal_basis_functions: int
                dofs: Eigen.MatrixXd
                dofs_mesh_order: List[int]
                dof0_ds_index: List[int]
                dof1_ds_index: List[int]
                dof2_ds_index: List[int]
                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: List[Gedim.Quadrature.QuadratureData]
                def __init__(
                    self,
                    map_data: Gedim.MapTriangle.MapTriangleData = Gedim.MapTriangle.MapTriangleData(),
                    b_lap: Eigen.Matrix3d = Eigen.Matrix3d(),
                    dofs: Eigen.MatrixXd = Eigen.MatrixXd(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    boundary_quadrature: List[Gedim.Quadrature.QuadratureData] = List[Gedim.Quadrature.QuadratureData]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_Quadrilateral_PCC_2D_LocalSpace_Data:
                """
                (final class)
                """
                vertices: Eigen.MatrixXd
                map_data: Gedim.MapParallelogram.MapParallelogramData
                b_lap: Eigen.Matrix3d
                order: int
                number_of_basis_functions: int
                dofs: Eigen.MatrixXd
                dofs_mesh_order: List[int]
                dof0_ds_index: List[int]
                dof1_ds_index: List[int]
                dof2_ds_index: List[int]
                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: List[Gedim.Quadrature.QuadratureData]
                quadrilateral_type: Polydim.FEM.PCC.QuadrilateralType
                def __init__(
                    self,
                    vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                    map_data: Gedim.MapParallelogram.MapParallelogramData = Gedim.MapParallelogram.MapParallelogramData(),
                    b_lap: Eigen.Matrix3d = Eigen.Matrix3d(),
                    dofs: Eigen.MatrixXd = Eigen.MatrixXd(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    boundary_quadrature: List[Gedim.Quadrature.QuadratureData] = List[Gedim.Quadrature.QuadratureData](),
                    quadrilateral_type: FEM.PCC.QuadrilateralType = FEM.PCC.QuadrilateralType()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_PCC_2D_LocalSpace_Data:
                """
                (final class)
                """
                triangle_local_space_data: Polydim.FEM.PCC.FEM_Triangle_PCC_2D_LocalSpace_Data
                quadrilateral_local_space_data: Polydim.FEM.PCC.FEM_Quadrilateral_PCC_2D_LocalSpace_Data
                fem_type: Polydim.FEM.PCC.FEM_PCC_2D_Types

                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: List[Gedim.Quadrature.QuadratureData]
                number_of_basis_functions: int
                def __init__(
                    self,
                    triangle_local_space_data: FEM.PCC.FEM_Triangle_PCC_2D_LocalSpace_Data = FEM.PCC.FEM_Triangle_PCC_2D_LocalSpace_Data(),
                    quadrilateral_local_space_data: FEM.PCC.FEM_Quadrilateral_PCC_2D_LocalSpace_Data = FEM.PCC.FEM_Quadrilateral_PCC_2D_LocalSpace_Data(),
                    fem_type: FEM.PCC.FEM_PCC_2D_Types = FEM.PCC.FEM_PCC_2D_Types(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    boundary_quadrature: List[Gedim.Quadrature.QuadratureData] = List[Gedim.Quadrature.QuadratureData]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass


        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_PCC_2D_LocalSpace_Data.hpp>    ####################


####################    <generated_from:FEM_Quadrilateral_PCC_2D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Quadrilateral_PCC_2D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class FEM_Quadrilateral_PCC_2D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    polygon: FEM_PCC_2D_Polygon_Geometry
                    ) -> FEM_Quadrilateral_PCC_2D_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Quadrilateral_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_laplacian_values(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Quadrilateral_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Quadrilateral_PCC_2D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Quadrilateral_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Quadrilateral_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Quadrilateral_PCC_2D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def internal_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Quadrilateral_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_Quadrilateral_PCC_2D_LocalSpace.hpp>    ####################


####################    <generated_from:FEM_Quadrilateral_PCC_2D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Quadrilateral_PCC_2D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class FEM_Quadrilateral_PCC_2D_ReferenceElement_Data:
                """
                (final class)
                """
                dimension: int
                order: int
                num_dofs0_d: int
                num_dofs1_d: int
                num_dofs2_d: int

                num_basis_functions: int
                dof_positions: Eigen.MatrixXd
                dof_types: List[List[int]]

                edges_by_vertices: Dict[Tuple[int, int], Tuple[int, bool]]

                reference_triangle_quadrature: Gedim.Quadrature.QuadratureData
                reference_square_quadrature: Gedim.Quadrature.QuadratureData

                reference_basis_function_values: Eigen.MatrixXd
                reference_basis_function_derivative_values: List[Eigen.MatrixXd]
                reference_basis_function_second_derivative_values: List[Eigen.MatrixXd]

                boundary_reference_element_data: Polydim.FEM.PCC.FEM_PCC_1D_ReferenceElement_Data
                def __init__(
                    self,
                    dof_positions: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_triangle_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_square_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_basis_function_values: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_basis_function_derivative_values: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    boundary_reference_element_data: FEM.PCC.FEM_PCC_1D_ReferenceElement_Data = FEM.PCC.FEM_PCC_1D_ReferenceElement_Data()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_Quadrilateral_PCC_2D_ReferenceElement:
                """
                (final class)
                """

                vertices: Eigen.MatrixXd

                def __init__(self) -> None:
                    pass

                def create(self, order: int) -> FEM_Quadrilateral_PCC_2D_ReferenceElement_Data:
                    pass

                def evaluate_basis_functions(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data
                    ) -> Eigen.MatrixXd:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_function_derivatives(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data
                    ) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_function_second_derivatives(
                    self,
                    param_0: Eigen.MatrixXd,
                    param_1: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data
                    ) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_Quadrilateral_PCC_2D_ReferenceElement.hpp>    ####################


####################    <generated_from:FEM_Triangle_PCC_2D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Triangle_PCC_2D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class FEM_Triangle_PCC_2D_ReferenceElement_Data:
                """
                (final class)
                """
                dimension: int
                order: int
                num_dofs0_d: int
                num_dofs1_d: int
                num_dofs2_d: int

                num_basis_functions: int
                dof_positions: Eigen.MatrixXd
                dof_types: Eigen.MatrixXi

                reference_triangle_quadrature: Gedim.Quadrature.QuadratureData

                reference_basis_function_values: Eigen.MatrixXd
                reference_basis_function_derivative_values: List[Eigen.MatrixXd]
                reference_basis_function_second_derivative_values: List[Eigen.MatrixXd]

                boundary_reference_element_data: Polydim.FEM.PCC.FEM_PCC_1D_ReferenceElement_Data

                edge_internal_points: Eigen.RowVectorXd
                edge_basis_coefficients: Eigen.VectorXd
                def __init__(
                    self,
                    dof_positions: Eigen.MatrixXd = Eigen.MatrixXd(),
                    dof_types: Eigen.MatrixXi = Eigen.MatrixXi(),
                    reference_triangle_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_basis_function_values: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_basis_function_derivative_values: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    boundary_reference_element_data: FEM.PCC.FEM_PCC_1D_ReferenceElement_Data = FEM.PCC.FEM_PCC_1D_ReferenceElement_Data(),
                    edge_internal_points: Eigen.RowVectorXd = Eigen.RowVectorXd(),
                    edge_basis_coefficients: Eigen.VectorXd = Eigen.VectorXd()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_Triangle_PCC_2D_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> FEM_Triangle_PCC_2D_ReferenceElement_Data:
                    pass
                def evaluate_basis_functions(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data
                    ) -> Eigen.MatrixXd:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_function_derivatives(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data
                    ) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_function_second_derivatives(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data
                    ) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_Triangle_PCC_2D_ReferenceElement.hpp>    ####################


####################    <generated_from:FEM_Triangle_PCC_2D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Triangle_PCC_2D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class FEM_Triangle_PCC_2D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    polygon: FEM_PCC_2D_Polygon_Geometry
                    ) -> FEM_Triangle_PCC_2D_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Triangle_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Triangle_PCC_2D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def internal_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Triangle_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_laplacian_values(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Triangle_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Triangle_PCC_2D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Triangle_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_Triangle_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_Triangle_PCC_2D_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_Triangle_PCC_2D_LocalSpace.hpp>    ####################


####################    <generated_from:FEM_PCC_2D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_PCC_2D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class FEM_PCC_2D_ReferenceElement_Data:
                """
                (final class)
                """
                dimension: int
                order: int
                num_dofs0_d: int
                num_dofs1_d: int
                triangle_reference_element_data: Polydim.FEM.PCC.FEM_Triangle_PCC_2D_ReferenceElement_Data
                quadrilateral_reference_element_data: Polydim.FEM.PCC.FEM_Quadrilateral_PCC_2D_ReferenceElement_Data
                def __init__(
                    self,
                    triangle_reference_element_data: FEM.PCC.FEM_Triangle_PCC_2D_ReferenceElement_Data = FEM.PCC.FEM_Triangle_PCC_2D_ReferenceElement_Data(),
                    quadrilateral_reference_element_data: FEM.PCC.FEM_Quadrilateral_PCC_2D_ReferenceElement_Data = FEM.PCC.FEM_Quadrilateral_PCC_2D_ReferenceElement_Data()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_PCC_2D_ReferenceElement:
                """
                (final class)
                """

                def __init__(self) -> None:
                    pass

                def create(self, order: int) -> FEM_PCC_2D_ReferenceElement_Data:
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_PCC_2D_ReferenceElement.hpp>    ####################


####################    <generated_from:FEM_PCC_2D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_PCC_2D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class FEM_PCC_2D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    polygon: FEM_PCC_2D_Polygon_Geometry
                    ) -> FEM_PCC_2D_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_laplacian_values(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def internal_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_PCC_2D_ReferenceElement_Data,
                    local_space: FEM_PCC_2D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_PCC_2D_LocalSpace.hpp>    ####################


####################    <generated_from:FEM_Hexahedron_PCC_3D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Hexahedron_PCC_3D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class FEM_Hexahedron_PCC_3D_ReferenceElement_Data:
                """
                (final class)
                """
                dimension: int
                order: int
                num_dofs0_d: int
                num_dofs1_d: int
                num_dofs2_d: int
                num_dofs3_d: int

                edges_by_vertices: Dict[Tuple[int, int], Tuple[int, bool]]
                faces_by_edges: Dict[Tuple[int, int], int]

                num_basis_functions: int
                dof_positions: Eigen.MatrixXd
                dof_types: List[List[int]]

                reference_hexahedron_quadrature: Gedim.Quadrature.QuadratureData

                reference_basis_function_values: Eigen.MatrixXd
                reference_basis_function_derivative_values: List[Eigen.MatrixXd]

                edge_reference_element_data: Polydim.FEM.PCC.FEM_PCC_1D_ReferenceElement_Data
                boundary_reference_element_data: Polydim.FEM.PCC.FEM_Quadrilateral_PCC_2D_ReferenceElement_Data
                def __init__(
                    self,
                    dof_positions: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_hexahedron_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_basis_function_values: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_basis_function_derivative_values: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    edge_reference_element_data: FEM.PCC.FEM_PCC_1D_ReferenceElement_Data = FEM.PCC.FEM_PCC_1D_ReferenceElement_Data(),
                    boundary_reference_element_data: FEM.PCC.FEM_Quadrilateral_PCC_2D_ReferenceElement_Data = FEM.PCC.FEM_Quadrilateral_PCC_2D_ReferenceElement_Data()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_Hexahedron_PCC_3D_ReferenceElement:
                """
                (final class)
                """
                vertices: Eigen.MatrixXd

                def __init__(self) -> None:
                    pass


                def create(self, order: int) -> FEM_Hexahedron_PCC_3D_ReferenceElement_Data:
                    pass
                def evaluate_basis_functions(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data
                    ) -> Eigen.MatrixXd:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_function_derivatives(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data
                    ) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_function_second_derivatives(
                    self,
                    param_0: Eigen.MatrixXd,
                    param_1: FEM_Quadrilateral_PCC_2D_ReferenceElement_Data
                    ) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_Hexahedron_PCC_3D_ReferenceElement.hpp>    ####################


####################    <generated_from:FEM_Hexahedron_PCC_3D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Hexahedron_PCC_3D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class FEM_Hexahedron_PCC_3D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    polyhedron: FEM_PCC_3D_Polyhedron_Geometry
                    ) -> FEM_Hexahedron_PCC_3D_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Hexahedron_PCC_3D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Hexahedron_PCC_3D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Hexahedron_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Hexahedron_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values_on_face(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Hexahedron_PCC_3D_LocalSpace_Data,
                    face_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values_on_face(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Hexahedron_PCC_3D_LocalSpace_Data,
                    face_index: int,
                    points2_d: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Hexahedron_PCC_3D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def face_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Hexahedron_PCC_3D_LocalSpace_Data,
                    face_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_Hexahedron_PCC_3D_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_Hexahedron_PCC_3D_LocalSpace.hpp>    ####################


####################    <generated_from:FEM_Tetrahedron_PCC_3D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Tetrahedron_PCC_3D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class FEM_Tetrahedron_PCC_3D_ReferenceElement_Data:
                """
                (final class)
                """
                dimension: int
                order: int
                num_dofs0_d: int
                num_dofs1_d: int
                num_dofs2_d: int
                num_dofs3_d: int

                edges_by_vertices: Dict[Tuple[int, int], Tuple[int, bool]]
                faces_by_edge_vertex: Dict[Tuple[int, int], int]
                faces_by_edges: Dict[Tuple[int, int], Tuple[List[int], bool]]

                num_basis_functions: int
                dof_positions: Eigen.MatrixXd
                dof_types: List[List[int]]

                reference_tetrahedron_quadrature: Gedim.Quadrature.QuadratureData

                reference_basis_function_values: Eigen.MatrixXd
                reference_basis_function_derivative_values: List[Eigen.MatrixXd]

                edge_reference_element_data: Polydim.FEM.PCC.FEM_PCC_1D_ReferenceElement_Data
                boundary_reference_element_data: Polydim.FEM.PCC.FEM_Triangle_PCC_2D_ReferenceElement_Data
                def __init__(
                    self,
                    dof_positions: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_tetrahedron_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    reference_basis_function_values: Eigen.MatrixXd = Eigen.MatrixXd(),
                    reference_basis_function_derivative_values: List[Eigen.MatrixXd] = List[Eigen.MatrixXd](),
                    edge_reference_element_data: FEM.PCC.FEM_PCC_1D_ReferenceElement_Data = FEM.PCC.FEM_PCC_1D_ReferenceElement_Data(),
                    boundary_reference_element_data: FEM.PCC.FEM_Triangle_PCC_2D_ReferenceElement_Data = FEM.PCC.FEM_Triangle_PCC_2D_ReferenceElement_Data()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_Tetrahedron_PCC_3D_ReferenceElement:
                """
                (final class)
                """
                def create(self, order: int) -> FEM_Tetrahedron_PCC_3D_ReferenceElement_Data:
                    pass
                def evaluate_lambda(self, points: Eigen.MatrixXd) -> Eigen.MatrixXd:
                    """ ***************************************************************************"""
                    pass
                def evaluate_grad_lambda(self, points: Eigen.MatrixXd) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_functions(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data
                    ) -> Eigen.MatrixXd:
                    """ ***************************************************************************"""
                    pass
                def evaluate_basis_function_derivatives(
                    self,
                    points: Eigen.MatrixXd,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data
                    ) -> List[Eigen.MatrixXd]:
                    """ ***************************************************************************"""
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_Tetrahedron_PCC_3D_ReferenceElement.hpp>    ####################


####################    <generated_from:FEM_Tetrahedron_PCC_3D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Tetrahedron_PCC_3D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class FEM_Tetrahedron_PCC_3D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    polyhedron: FEM_PCC_3D_Polyhedron_Geometry
                    ) -> FEM_Tetrahedron_PCC_3D_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Tetrahedron_PCC_3D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Tetrahedron_PCC_3D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Tetrahedron_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Tetrahedron_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Tetrahedron_PCC_3D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def face_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Tetrahedron_PCC_3D_LocalSpace_Data,
                    face_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values_on_face(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Tetrahedron_PCC_3D_LocalSpace_Data,
                    face_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values_on_face(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_Tetrahedron_PCC_3D_LocalSpace_Data,
                    face_index: int,
                    points2_d: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_Tetrahedron_PCC_3D_ReferenceElement_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_Tetrahedron_PCC_3D_LocalSpace.hpp>    ####################


####################    <generated_from:FEM_PCC_3D_ReferenceElement.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_PCC_3D_ReferenceElement_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""
            class FEM_PCC_3D_ReferenceElement_Data:
                """
                (final class)
                """
                dimension: int
                order: int

                num_dofs0_d: int
                num_dofs1_d: int

                tetrahedron_reference_element_data: Polydim.FEM.PCC.FEM_Tetrahedron_PCC_3D_ReferenceElement_Data
                hexahedron_reference_element_data: Polydim.FEM.PCC.FEM_Hexahedron_PCC_3D_ReferenceElement_Data
                def __init__(
                    self,
                    tetrahedron_reference_element_data: FEM.PCC.FEM_Tetrahedron_PCC_3D_ReferenceElement_Data = FEM.PCC.FEM_Tetrahedron_PCC_3D_ReferenceElement_Data(),
                    hexahedron_reference_element_data: FEM.PCC.FEM_Hexahedron_PCC_3D_ReferenceElement_Data = FEM.PCC.FEM_Hexahedron_PCC_3D_ReferenceElement_Data()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_PCC_3D_ReferenceElement:
                """
                (final class)
                """
                def __init__(self) -> None:
                    pass


                def create(self, order: int) -> FEM_PCC_3D_ReferenceElement_Data:
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_PCC_3D_ReferenceElement.hpp>    ####################


####################    <generated_from:FEM_PCC_3D_LocalSpace_Data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_Hexahedron_PCC_3D_LocalSpace_Data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class FEM_PCC_3D_Types(enum.IntEnum):
                tetrahedron = enum.auto() # (= 0)
                hexahedron = enum.auto()  # (= 1)

            class HexahedronType(enum.IntEnum):
                parallelepiped = enum.auto() # (= 0)
                generic = enum.auto()        # (= 1)

            class FEM_PCC_3D_Polyhedron_Geometry:
                """
                (final class)
                """
                tolerance1_d: float
                tolerance2_d: float
                tolerance3_d: float

                vertices: Eigen.MatrixXd
                edges: Eigen.MatrixXi
                faces: List[Eigen.MatrixXi]
                edges_direction: List[bool]
                faces_direction: List[bool]
                faces_rotation_matrix: List[Eigen.Matrix3d]
                faces_translation: List[Eigen.Vector3d]

                faces_2_d_geometry: List[Polydim.FEM.PCC.FEM_PCC_2D_Polygon_Geometry]
                def __init__(
                    self,
                    tolerance1_d: float = float(),
                    tolerance2_d: float = float(),
                    tolerance3_d: float = float(),
                    vertices: Eigen.MatrixXd = Eigen.MatrixXd(),
                    edges: Eigen.MatrixXi = Eigen.MatrixXi(),
                    faces: List[Eigen.MatrixXi] = List[Eigen.MatrixXi](),
                    edges_direction: List[bool] = List[bool](),
                    faces_direction: List[bool] = List[bool](),
                    faces_rotation_matrix: List[Eigen.Matrix3d] = List[Eigen.Matrix3d](),
                    faces_translation: List[Eigen.Vector3d] = List[Eigen.Vector3d](),
                    faces_2_d_geometry: List[FEM.PCC.FEM_PCC_2D_Polygon_Geometry] = List[FEM.PCC.FEM_PCC_2D_Polygon_Geometry]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_Hexahedron_PCC_3D_LocalSpace_Data:
                """
                (final class)
                """
                map_data_parallelepiped: Gedim.MapParallelepiped.MapParallelepipedData
                map_data_hexahedron: Gedim.MapHexahedron.MapHexahedronData
                order: int
                number_of_basis_functions: int
                dofs: Eigen.MatrixXd
                polyhedron_to_reference_edge_index: List[int]
                polyhedron_to_reference_edge_direction: List[bool]
                polyhedron_to_reference_face_index: List[int]
                dofs_mesh_order: List[int]
                dof0_ds_index: List[int]
                dof1_ds_index: List[int]
                dof2_ds_index: List[int]
                dof3_ds_index: List[int]
                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_local_space_data: List[Polydim.FEM.PCC.FEM_Quadrilateral_PCC_2D_LocalSpace_Data]
                boundary_quadrature: List[Gedim.Quadrature.QuadratureData]
                hexahedron_type: Polydim.FEM.PCC.HexahedronType
                def __init__(
                    self,
                    map_data_parallelepiped: Gedim.MapParallelepiped.MapParallelepipedData = Gedim.MapParallelepiped.MapParallelepipedData(),
                    map_data_hexahedron: Gedim.MapHexahedron.MapHexahedronData = Gedim.MapHexahedron.MapHexahedronData(),
                    dofs: Eigen.MatrixXd = Eigen.MatrixXd(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    hexahedron_type: FEM.PCC.HexahedronType = FEM.PCC.HexahedronType()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_Tetrahedron_PCC_3D_LocalSpace_Data:
                """
                (final class)
                """
                map_data: Gedim.MapTetrahedron.MapTetrahedronData
                order: int
                number_of_basis_functions: int
                dofs: Eigen.MatrixXd
                polyhedron_to_reference_edge_index: List[int]
                polyhedron_to_reference_edge_direction: List[bool]
                polyhedron_to_reference_face_index: List[int]
                polyhedron_to_reference_face_direction: List[bool]
                polyhedron_to_reference_face_starting_index: List[int]
                dofs_mesh_order: List[int]
                dof0_ds_index: List[int]
                dof1_ds_index: List[int]
                dof2_ds_index: List[int]
                dof3_ds_index: List[int]
                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_local_space_data: List[Polydim.FEM.PCC.FEM_Triangle_PCC_2D_LocalSpace_Data]
                boundary_quadrature: List[Gedim.Quadrature.QuadratureData]
                def __init__(
                    self,
                    map_data: Gedim.MapTetrahedron.MapTetrahedronData = Gedim.MapTetrahedron.MapTetrahedronData(),
                    dofs: Eigen.MatrixXd = Eigen.MatrixXd(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass

            class FEM_PCC_3D_LocalSpace_Data:
                """
                (final class)
                """
                hexahedron_local_space_data: Polydim.FEM.PCC.FEM_Hexahedron_PCC_3D_LocalSpace_Data
                tetrahedron_local_space_data: Polydim.FEM.PCC.FEM_Tetrahedron_PCC_3D_LocalSpace_Data
                fem_type: Polydim.FEM.PCC.FEM_PCC_3D_Types

                internal_quadrature: Gedim.Quadrature.QuadratureData
                boundary_quadrature: List[Gedim.Quadrature.QuadratureData]
                number_of_basis_functions: int
                def __init__(
                    self,
                    hexahedron_local_space_data: FEM.PCC.FEM_Hexahedron_PCC_3D_LocalSpace_Data = FEM.PCC.FEM_Hexahedron_PCC_3D_LocalSpace_Data(),
                    tetrahedron_local_space_data: FEM.PCC.FEM_Tetrahedron_PCC_3D_LocalSpace_Data = FEM.PCC.FEM_Tetrahedron_PCC_3D_LocalSpace_Data(),
                    fem_type: FEM.PCC.FEM_PCC_3D_Types = FEM.PCC.FEM_PCC_3D_Types(),
                    internal_quadrature: Gedim.Quadrature.QuadratureData = Gedim.Quadrature.QuadratureData(),
                    boundary_quadrature: List[Gedim.Quadrature.QuadratureData] = List[Gedim.Quadrature.QuadratureData]()
                    ) -> None:
                    """Auto-generated default constructor with named params"""
                    pass


        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_PCC_3D_LocalSpace_Data.hpp>    ####################


####################    <generated_from:FEM_PCC_3D_LocalSpace.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __FEM_PCC_3D_LocalSpace_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule fem>
    class fem:  # Proxy class that introduces typings for the *submodule* fem
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace FEM"""

        # <submodule pcc>
        class pcc:  # Proxy class that introduces typings for the *submodule* pcc
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace PCC"""

            class FEM_PCC_3D_LocalSpace:
                """
                (final class)
                """
                def create_local_space(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    polyhedron: FEM_PCC_3D_Polyhedron_Geometry
                    ) -> FEM_PCC_3D_LocalSpace_Data:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_derivative_values(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data,
                    points: Eigen.MatrixXd
                    ) -> List[Eigen.MatrixXd]:
                    pass

                @overload
                def compute_basis_functions_values_on_face(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data,
                    face_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_basis_functions_values_on_face(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data,
                    face_index: int,
                    points2_d: Eigen.MatrixXd
                    ) -> Eigen.MatrixXd:
                    pass

                def face_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data,
                    face_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def edge_do_fs_coordinates(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data,
                    edge_local_index: int
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_basis_functions_values_on_edge(
                    self,
                    reference_element_data: FEM_PCC_3D_ReferenceElement_Data,
                    local_space: FEM_PCC_3D_LocalSpace_Data,
                    points_curvilinear_coordinates: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule pcc>

    # </submodule fem>

# </submodule polydim>
####################    </generated_from:FEM_PCC_3D_LocalSpace.hpp>    ####################


####################    <generated_from:PDE_Mesh_Utilities.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __PDETOOLS_MESH_PDE_Mesh_Utilities_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule pde_tools>
    class pde_tools:  # Proxy class that introduces typings for the *submodule* pde_tools
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace PDETools"""

        # <submodule mesh>
        class mesh:  # Proxy class that introduces typings for the *submodule* mesh
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace Mesh"""

            # <submodule pde_mesh_utilities>
            class pde_mesh_utilities:  # Proxy class that introduces typings for the *submodule* pde_mesh_utilities
                pass  # (This corresponds to a C++ namespace. All method are static!)
                """ namespace PDE_Mesh_Utilities"""
                class PDE_Domain_1D:
                    """
                    (final class)
                    """
                    vertices: Eigen.MatrixXd
                    length: float
                    def __init__(self) -> None:
                        """Autogenerated default constructor"""
                        pass

                class PDE_Domain_2D:
                    """
                    (final class)
                    """
                    class Domain_Shape_Types(enum.IntEnum):
                        parallelogram = enum.auto() # (= 0)
                        polygon = enum.auto()       # (= 1)
                        ellipse = enum.auto()       # (= 2)

                    vertices: Eigen.MatrixXd
                    area: float

                    # Ellipse type
                    radius_1: float
                    radius_2: float
                    center: Eigen.Vector3d
                    rotation_angle: Eigen.Vector3d

                    shape_type: Polydim.PDETools.Mesh.PDE_Mesh_Utilities.PDE_Domain_2D.Domain_Shape_Types
                    def __init__(self) -> None:
                        """Autogenerated default constructor"""
                        pass

                class PDE_Time_Domain_2D:
                    """
                    (final class)
                    """
                    time_domain: List[float]
                    spatial_domain: Polydim.PDETools.Mesh.PDE_Mesh_Utilities.PDE_Domain_2D
                    def __init__(
                        self,
                        spatial_domain: PDETools.Mesh.PDE_Mesh_Utilities.PDE_Domain_2D = PDETools.Mesh.PDE_Mesh_Utilities.PDE_Domain_2()
                        ) -> None:
                        """Auto-generated default constructor with named params"""
                        pass

                class PDE_Domain_3D:
                    """
                    (final class)
                    """
                    class Domain_Shape_Types(enum.IntEnum):
                        parallelepiped = enum.auto() # (= 0)
                        polygon = enum.auto()        # (= 1)

                    vertices: Eigen.MatrixXd
                    edges: Eigen.MatrixXi
                    faces: List[Eigen.MatrixXi]
                    volume: float
                    shape_type: Polydim.PDETools.Mesh.PDE_Mesh_Utilities.PDE_Domain_3D.Domain_Shape_Types
                    def __init__(self) -> None:
                        """Autogenerated default constructor"""
                        pass

                class MeshGenerator_Types_1D(enum.IntEnum):
                    equispaced = enum.auto()   # (= 0)  #/< equispaced mesh
                    minimal = enum.auto()      # (= 2)  #/< minimal mesh
                    csv_importer = enum.auto() # (= 1)  #/< imported csv mesh

                class MeshGenerator_Types_2D(enum.IntEnum):
                    triangular = enum.auto()       # (= 0)  #/< generated triangular mesh
                    minimal = enum.auto()          # (= 1)  #/< generated minimal mesh
                    polygonal = enum.auto()        # (= 2)  #/< generated voronoi polygonal mesh
                    off_importer = enum.auto()     # (= 3)  #/< imported off mesh
                    csv_importer = enum.auto()     # (= 4)  #/< imported csv mesh
                    squared = enum.auto()          # (= 5)  #/< squared mesh
                    random_distorted = enum.auto() # (= 6)

                class MeshGenerator_Types_3D(enum.IntEnum):
                    tetrahedral = enum.auto()  # (= 0)  #/< generated tetrahedral mesh
                    minimal = enum.auto()      # (= 1)  #/< generated minimal mesh
                    polyhedral = enum.auto()   # (= 2)  #/< generated voronoi polyhedral mesh
                    ovm_importer = enum.auto() # (= 3)  #/< imported ovm mesh
                    vtk_importer = enum.auto() # (= 4)  #/< imported vtk mesh
                    csv_importer = enum.auto() # (= 5)  #/< imported csv mesh
                    cubic = enum.auto()        # (= 6)  #/< cubic mesh

                @staticmethod
                def create_mesh_1_d(
                    geometry_utilities: Gedim.GeometryUtilities,
                    mesh_utilities: Gedim.MeshUtilities,
                    mesh_type: MeshGenerator_Types_1D,
                    pde_domain: PDE_Domain_1D,
                    max_relative_length: float,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> None:
                    pass

                @staticmethod
                def create_mesh_2_d(
                    geometry_utilities: Gedim.GeometryUtilities,
                    mesh_utilities: Gedim.MeshUtilities,
                    mesh_type: MeshGenerator_Types_2D,
                    pde_domain: PDE_Domain_2D,
                    max_relative_area: float,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> None:
                    pass

                @staticmethod
                def create_mesh_3_d(
                    geometry_utilities: Gedim.GeometryUtilities,
                    mesh_utilities: Gedim.MeshUtilities,
                    mesh_type: MeshGenerator_Types_3D,
                    pde_domain: PDE_Domain_3D,
                    max_relative_volume: float,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> None:
                    pass

                @staticmethod
                def import_mesh_1_d(
                    mesh_type: MeshGenerator_Types_1D,
                    file_path: str,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> None:
                    pass

                @staticmethod
                def import_mesh_2_d(
                    mesh_utilities: Gedim.MeshUtilities,
                    mesh_type: MeshGenerator_Types_2D,
                    file_path: str,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> None:
                    pass

                @staticmethod
                def import_mesh_3_d(
                    mesh_utilities: Gedim.MeshUtilities,
                    mesh_type: MeshGenerator_Types_3D,
                    file_path: str,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> None:
                    pass

                @staticmethod
                def compute_mesh_1_d_geometry_data(
                    geometry_utilities: Gedim.GeometryUtilities,
                    mesh_utilities: Gedim.MeshUtilities,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> Gedim.MeshUtilities.MeshGeometricData1D:
                    pass

                @staticmethod
                def compute_mesh_2_d_geometry_data(
                    geometry_utilities: Gedim.GeometryUtilities,
                    mesh_utilities: Gedim.MeshUtilities,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> Gedim.MeshUtilities.MeshGeometricData2D:
                    pass

                @staticmethod
                def compute_mesh_3_d_geometry_data(
                    geometry_utilities: Gedim.GeometryUtilities,
                    mesh: Gedim.MeshMatricesDAO
                    ) -> Gedim.MeshUtilities.MeshGeometricData3D:
                    pass

            # </submodule pde_mesh_utilities>

        # </submodule mesh>

    # </submodule pde_tools>

# </submodule polydim>
####################    </generated_from:PDE_Mesh_Utilities.hpp>    ####################


####################    <generated_from:EllipticEquation.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __PDETOOLS_EQUATION_EllipticEquation_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule pde_tools>
    class pde_tools:  # Proxy class that introduces typings for the *submodule* pde_tools
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace PDETools"""

        # <submodule equations>
        class equations:  # Proxy class that introduces typings for the *submodule* equations
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace Equations"""
            class EllipticEquation:
                """
                (final class)
                """
                @overload
                def compute_cell_diffusion_matrix(
                    self,
                    diffusion_term_values: Eigen.VectorXd,
                    basis_functions_derivative_values: List[Eigen.MatrixXd],
                    quadrature_weights: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_cell_diffusion_matrix(
                    self,
                    diffusion_term_values: List[Eigen.VectorXd],
                    basis_functions_derivative_values: List[Eigen.MatrixXd],
                    quadrature_weights: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_cell_reaction_matrix(
                    self,
                    reaction_term_values: Eigen.VectorXd,
                    basis_functions_values: Eigen.MatrixXd,
                    quadrature_weights: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                def compute_cell_advection_matrix(
                    self,
                    advection_term_values: List[Eigen.VectorXd],
                    basis_functions_values: Eigen.MatrixXd,
                    basis_functions_derivative_values: List[Eigen.MatrixXd],
                    quadrature_weights: Eigen.VectorXd
                    ) -> Eigen.MatrixXd:
                    pass

                @overload
                def compute_cell_forcing_term(
                    self,
                    forcing_term_values: Eigen.VectorXd,
                    basis_functions_values: Eigen.MatrixXd,
                    quadrature_weights: Eigen.VectorXd
                    ) -> Eigen.VectorXd:
                    pass

                @overload
                def compute_cell_forcing_term(
                    self,
                    forcing_term_values: List[Eigen.VectorXd],
                    basis_functions_values: List[Eigen.MatrixXd],
                    quadrature_weights: Eigen.VectorXd
                    ) -> Eigen.VectorXd:
                    pass
                def __init__(self) -> None:
                    """Auto-generated default constructor"""
                    pass

        # </submodule equations>

    # </submodule pde_tools>

# </submodule polydim>
####################    </generated_from:EllipticEquation.hpp>    ####################


####################    <generated_from:MeshMatricesDAO_mesh_connectivity_data.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __PDETOOLS_MESH_MeshMatricesDAO_mesh_connectivity_data_HPP
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule pde_tools>
    class pde_tools:  # Proxy class that introduces typings for the *submodule* pde_tools
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace PDETools"""

        # <submodule mesh>
        class mesh:  # Proxy class that introduces typings for the *submodule* mesh
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace Mesh"""
            class MeshMatricesDAO_mesh_connectivity_data:
                """
                (final class)
                """
                def __init__(self, mesh_data: Gedim.MeshMatricesDAO) -> None:
                    pass

                def dimension(self) -> int:
                    pass
                def cell0_ds_number(self) -> int:
                    pass
                def cell1_ds_number(self) -> int:
                    pass
                def cell2_ds_number(self) -> int:
                    pass
                def cell3_ds_number(self) -> int:
                    pass

                def cell0_d_marker(self, cell0_d_index: int) -> int:
                    pass
                def cell1_d_marker(self, cell1_d_index: int) -> int:
                    pass
                def cell2_d_marker(self, cell2_d_index: int) -> int:
                    pass
                def cell3_d_marker(self, cell3_d_index: int) -> int:
                    pass

                def cell1_d_vertices(self, cell1_d_index: int) -> List[int]:
                    pass

                def cell2_d_vertices(self, cell2_d_index: int) -> List[int]:
                    pass

                def cell2_d_edges(self, cell2_d_index: int) -> List[int]:
                    pass

                def cell3_d_vertices(self, cell3_d_index: int) -> List[int]:
                    pass

                def cell3_d_edges(self, cell3_d_index: int) -> List[int]:
                    pass

                def cell3_d_faces(self, cell3_d_index: int) -> List[int]:
                    pass

        # </submodule mesh>

    # </submodule pde_tools>

# </submodule polydim>
####################    </generated_from:MeshMatricesDAO_mesh_connectivity_data.hpp>    ####################


####################    <generated_from:DOFsManager.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __PDETOOLS_DOFS_DOFsManager_HPP
#





# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule pde_tools>
    class pde_tools:  # Proxy class that introduces typings for the *submodule* pde_tools
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace PDETools"""

        # <submodule do_fs>
        class do_fs:  # Proxy class that introduces typings for the *submodule* do_fs
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace DOFs"""


            class DOFsManager:
                class MeshDOFsInfo:
                    """
                    (final class)
                    """
                    class BoundaryInfo:
                        class BoundaryTypes(enum.IntEnum):
                            unknwon = enum.auto() # (= 0)
                            strong = enum.auto()  # (= 1)
                            weak = enum.auto()    # (= 2)
                            robin = enum.auto()   # (= 4)
                            none = enum.auto()    # (= 3)

                        type: Polydim.PDETools.DOFs.DOFsManager.MeshDOFsInfo.BoundaryInfo.BoundaryTypes
                        marker: int
                        def __init__(
                            self,
                            type: PDETools.DOFs.DOFsManager.MeshDOFsInfo.BoundaryInfo.BoundaryTypes = PDETools.DOFs.DOFsManager.MeshDOFsInfo.BoundaryInfo.BoundaryTypes()
                            ) -> None:
                            """Auto-generated default constructor with named params"""
                            pass

                    cells_num_do_fs: List[List[int]]
                    cells_boundary_info: List[List[Polydim.PDETools.DOFs.DOFsManager.MeshDOFsInfo.BoundaryInfo]]
                    def __init__(self) -> None:
                        """Auto-generated default constructor"""
                        pass


                class ConstantDOFsInfo:
                    """
                    (final class)
                    """
                    num_do_fs: List[int]
                    boundary_info: Dict[int, Polydim.PDETools.DOFs.DOFsManager.MeshDOFsInfo.BoundaryInfo]
                    def __init__(self) -> None:
                        """Auto-generated default constructor"""
                        pass

                class DOFsData:
                    """
                    (final class)
                    """
                    class DOF:
                        """
                        (final class)
                        """
                        class Types(enum.IntEnum):
                            unknwon = enum.auto() # (= 0)
                            strong = enum.auto()  # (= 1)
                            dof = enum.auto()     # (= 2)
                            robin = enum.auto()   # (= 3)

                        type: Polydim.PDETools.DOFs.DOFsManager.DOFsData.DOF.Types
                        global_index: int
                        def __init__(
                            self,
                            type: PDETools.DOFs.DOFsManager.DOFsData.DOF.Types = PDETools.DOFs.DOFsManager.DOFsData.DOF.Types()
                            ) -> None:
                            """Auto-generated default constructor with named params"""
                            pass

                    class GlobalCell_DOF:
                        dimension: int
                        cell_index: int
                        dof_index: int
                        def __init__(self) -> None:
                            """Auto-generated default constructor"""
                            pass

                    number_do_fs: int
                    number_internal_do_fs: int
                    number_boundary_do_fs: int
                    number_strongs: int
                    number_robin: int
                    cells_do_fs: List[List[List[Polydim.PDETools.DOFs.DOFsManager.DOFsData.DOF]]]
                    cells_global_do_fs: List[List[List[Polydim.PDETools.DOFs.DOFsManager.DOFsData.GlobalCell_DOF]]]
                    def __init__(self) -> None:
                        """Auto-generated default constructor"""
                        pass

                class CellsDOFsIndicesData:
                    """
                    (final class)
                    """
                    cells_do_fs_local_index: List[List[int]]
                    cells_strongs_local_index: List[List[int]]
                    cells_robin_local_index: List[List[int]]
                    cells_do_fs_global_index: List[List[int]]
                    cells_strongs_global_index: List[List[int]]
                    cells_robin_global_index: List[List[int]]
                    def __init__(self) -> None:
                        """Auto-generated default constructor"""
                        pass

                #  ------------------------------------------------------------------------
                #      <template specializations for function Create_Constant_DOFsInfo_0D>
                @overload
                def create_constant_do_fs_info_0_d(
                    self,
                    mesh: Mesh.MeshMatricesDAO_mesh_connectivity_data,
                    boundary_info: DOFsManager.ConstantDOFsInfo
                    ) -> DOFsManager.MeshDOFsInfo:
                    pass
                #      </template specializations for function Create_Constant_DOFsInfo_0D>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function Create_Constant_DOFsInfo_1D>
                @overload
                def create_constant_do_fs_info_1_d(
                    self,
                    mesh: Mesh.MeshMatricesDAO_mesh_connectivity_data,
                    boundary_info: DOFsManager.ConstantDOFsInfo
                    ) -> DOFsManager.MeshDOFsInfo:
                    pass
                #      </template specializations for function Create_Constant_DOFsInfo_1D>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function Create_Constant_DOFsInfo_2D>
                @overload
                def create_constant_do_fs_info_2_d(
                    self,
                    mesh: Mesh.MeshMatricesDAO_mesh_connectivity_data,
                    boundary_info: DOFsManager.ConstantDOFsInfo
                    ) -> DOFsManager.MeshDOFsInfo:
                    pass
                #      </template specializations for function Create_Constant_DOFsInfo_2D>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function Create_Constant_DOFsInfo_3D>
                @overload
                def create_constant_do_fs_info_3_d(
                    self,
                    mesh: Mesh.MeshMatricesDAO_mesh_connectivity_data,
                    boundary_info: DOFsManager.ConstantDOFsInfo
                    ) -> DOFsManager.MeshDOFsInfo:
                    pass
                #      </template specializations for function Create_Constant_DOFsInfo_3D>
                #  ------------------------------------------------------------------------

                def create_do_fs_0_d(
                    self,
                    mesh_do_fs_info: DOFsManager.MeshDOFsInfo
                    ) -> DOFsManager.DOFsData:
                    pass

                #  ------------------------------------------------------------------------
                #      <template specializations for function CreateDOFs_1D>
                @overload
                def create_do_fs_1_d(
                    self,
                    mesh_do_fs_info: DOFsManager.MeshDOFsInfo,
                    mesh: Mesh.MeshMatricesDAO_mesh_connectivity_data
                    ) -> DOFsManager.DOFsData:
                    pass
                #      </template specializations for function CreateDOFs_1D>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function CreateDOFs_2D>
                @overload
                def create_do_fs_2_d(
                    self,
                    mesh_do_fs_info: DOFsManager.MeshDOFsInfo,
                    mesh: Mesh.MeshMatricesDAO_mesh_connectivity_data
                    ) -> DOFsManager.DOFsData:
                    pass
                #      </template specializations for function CreateDOFs_2D>
                #  ------------------------------------------------------------------------

                #  ------------------------------------------------------------------------
                #      <template specializations for function CreateDOFs_3D>
                @overload
                def create_do_fs_3_d(
                    self,
                    mesh_do_fs_info: DOFsManager.MeshDOFsInfo,
                    mesh: Mesh.MeshMatricesDAO_mesh_connectivity_data
                    ) -> DOFsManager.DOFsData:
                    pass
                #      </template specializations for function CreateDOFs_3D>
                #  ------------------------------------------------------------------------

                def compute_cells_do_fs_indices(
                    self,
                    dofs: DOFsManager.DOFsData,
                    dim: int
                    ) -> DOFsManager.CellsDOFsIndicesData:
                    pass
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

        # </submodule do_fs>

    # </submodule pde_tools>

# </submodule polydim>
####################    </generated_from:DOFsManager.hpp>    ####################


####################    <generated_from:LocalSpace_PCC_2D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __LocalSpace_PCC_2D_H
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule pde_tools>
    class pde_tools:  # Proxy class that introduces typings for the *submodule* pde_tools
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace PDETools"""

        # <submodule local_space_pcc_2_d>
        class local_space_pcc_2_d:  # Proxy class that introduces typings for the *submodule* local_space_pcc_2_d
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace LocalSpace_PCC_2D"""
            class MethodTypes(enum.IntEnum):
                fem_pcc = enum.auto()         # (= 0)
                vem_pcc = enum.auto()         # (= 1)
                vem_pcc_inertia = enum.auto() # (= 2)
                vem_pcc_ortho = enum.auto()   # (= 3)

            class ReferenceElement_Data:
                """
                (final class)
                """
                method_type: Polydim.PDETools.LocalSpace_PCC_2D.MethodTypes
                order: int

                vem_reference_element: Polydim.VEM.PCC.I_VEM_PCC_2D_ReferenceElement
                vem_reference_element_data: Polydim.VEM.PCC.VEM_PCC_2D_ReferenceElement_Data
                vem_type: Polydim.VEM.PCC.VEM_PCC_2D_LocalSpace_Types
                vem_local_space: Polydim.VEM.PCC.I_VEM_PCC_2D_LocalSpace

                fem_reference_element: Polydim.FEM.PCC.FEM_PCC_2D_ReferenceElement
                fem_reference_element_data: Polydim.FEM.PCC.FEM_PCC_2D_ReferenceElement_Data
                fem_local_space: Polydim.FEM.PCC.FEM_PCC_2D_LocalSpace
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class LocalSpace_Data:
                """
                (final class)
                """
                vem_geometry: Polydim.VEM.PCC.VEM_PCC_2D_Polygon_Geometry
                vem_local_space_data: Polydim.VEM.PCC.VEM_PCC_2D_LocalSpace_Data

                fem_geometry: Polydim.FEM.PCC.FEM_PCC_2D_Polygon_Geometry
                fem_local_space_data: Polydim.FEM.PCC.FEM_PCC_2D_LocalSpace_Data
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class Performance_Data:
                """
                (final class)
                """
                class Cell2D_Performance:
                    """
                    (final class)
                    """
                    num_boundary_quadrature_points: int = 0
                    num_internal_quadrature_points: int = 0
                    analysis: Polydim.VEM.PCC.VEM_PCC_PerformanceAnalysis_Data
                    def __init__(self) -> None:
                        """Autogenerated default constructor"""
                        pass

                vem_performance_data: Polydim.PDETools.LocalSpace_PCC_2D.Performance_Data.Cell2D_Performance
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            @staticmethod
            def create_reference_element(
                method_type: MethodTypes,
                method_order: int
                ) -> ReferenceElement_Data:
                pass

            @staticmethod
            def set_mesh_do_fs_info(
                reference_element_data: ReferenceElement_Data,
                mesh: Gedim.MeshMatricesDAO,
                boundary_info: Dict[int, DOFs.DOFsManager.MeshDOFsInfo.BoundaryInfo]
                ) -> DOFs.DOFsManager.MeshDOFsInfo:
                pass

            @staticmethod
            def create_local_space(
                geometric_tolerance_1_d: float,
                geometric_tolerance_2_d: float,
                mesh_geometric_data: Gedim.MeshUtilities.MeshGeometricData2D,
                cell2_d_index: int,
                reference_element_data: ReferenceElement_Data
                ) -> LocalSpace_Data:
                pass

            @staticmethod
            def basis_functions_values(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.PCC.ProjectionTypes = VEM.PCC.ProjectionTypes.pi0km1
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def basis_functions_values_on_edge(
                edge_local_index: int,
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                points_curvilinear_coordinates: Eigen.MatrixXd
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def basis_functions_derivative_values(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.PCC.ProjectionTypes = VEM.PCC.ProjectionTypes.pi0km1_der
                ) -> List[Eigen.MatrixXd]:
                pass

            @staticmethod
            def basis_functions_laplacian_values(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.PCC.ProjectionTypes = VEM.PCC.ProjectionTypes.pi0km1_der
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def stabilization_matrix(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.PCC.ProjectionTypes = VEM.PCC.ProjectionTypes.pi_nabla
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def edge_dofs_coordinates(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                edge_local_index: int
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def internal_dofs_coordinates(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Gedim.Quadrature.QuadratureData:
                pass

            @staticmethod
            def internal_dofs(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                values_at_dofs: Eigen.VectorXd,
                internal_dofs_coordinates: Gedim.Quadrature.QuadratureData
                ) -> Eigen.VectorXd:
                pass

            @staticmethod
            def internal_quadrature(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Gedim.Quadrature.QuadratureData:
                pass

            @staticmethod
            def size(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> int:
                pass

            @staticmethod
            def compute_performance(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Performance_Data:
                pass

        # </submodule local_space_pcc_2_d>

    # </submodule pde_tools>

# </submodule polydim>
####################    </generated_from:LocalSpace_PCC_2D.hpp>    ####################


####################    <generated_from:LocalSpace_PCC_3D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __LocalSpace_PCC_3D_H
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule pde_tools>
    class pde_tools:  # Proxy class that introduces typings for the *submodule* pde_tools
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace PDETools"""

        # <submodule local_space_pcc_3_d>
        class local_space_pcc_3_d:  # Proxy class that introduces typings for the *submodule* local_space_pcc_3_d
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace LocalSpace_PCC_3D"""
            class MethodTypes(enum.IntEnum):
                fem_pcc = enum.auto()         # (= 0)
                vem_pcc = enum.auto()         # (= 1)
                vem_pcc_inertia = enum.auto() # (= 2)
                vem_pcc_ortho = enum.auto()   # (= 3)

            class ReferenceElement_Data:
                """
                (final class)
                """
                method_type: Polydim.PDETools.LocalSpace_PCC_3D.MethodTypes
                order: int

                vem_reference_element_2_d: Polydim.VEM.PCC.I_VEM_PCC_2D_ReferenceElement
                vem_reference_element_data_2_d: Polydim.VEM.PCC.VEM_PCC_2D_ReferenceElement_Data
                vem_reference_element_3_d: Polydim.VEM.PCC.I_VEM_PCC_3D_ReferenceElement
                vem_reference_element_data_3_d: Polydim.VEM.PCC.VEM_PCC_3D_ReferenceElement_Data
                vem_type: Polydim.VEM.PCC.VEM_PCC_3D_LocalSpace_Types
                vem_local_space: Polydim.VEM.PCC.I_VEM_PCC_3D_LocalSpace

                fem_reference_element_3_d: Polydim.FEM.PCC.FEM_PCC_3D_ReferenceElement
                fem_reference_element_data_3_d: Polydim.FEM.PCC.FEM_PCC_3D_ReferenceElement_Data
                fem_local_space: Polydim.FEM.PCC.FEM_PCC_3D_LocalSpace
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class LocalSpace_Data:
                """
                (final class)
                """
                vem_geometry: Polydim.VEM.PCC.VEM_PCC_3D_Polyhedron_Geometry
                vem_local_space_data: Polydim.VEM.PCC.VEM_PCC_3D_LocalSpace_Data

                fem_geometry: Polydim.FEM.PCC.FEM_PCC_3D_Polyhedron_Geometry
                fem_local_space_data: Polydim.FEM.PCC.FEM_PCC_3D_LocalSpace_Data
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class Performance_Data:
                """
                (final class)
                """
                class Cell3D_Performance:
                    """
                    (final class)
                    """
                    num_boundary_quadrature_points: int = 0
                    num_internal_quadrature_points: int = 0
                    analysis: Polydim.VEM.PCC.VEM_PCC_PerformanceAnalysis_Data
                    def __init__(self) -> None:
                        """Autogenerated default constructor"""
                        pass

                vem_performance_data: Polydim.PDETools.LocalSpace_PCC_3D.Performance_Data.Cell3D_Performance
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            @staticmethod
            def create_reference_element(
                method_type: MethodTypes,
                method_order: int
                ) -> ReferenceElement_Data:
                pass

            @staticmethod
            def set_mesh_do_fs_info(
                reference_element_data: ReferenceElement_Data,
                mesh: Gedim.MeshMatricesDAO,
                boundary_info: Dict[int, DOFs.DOFsManager.MeshDOFsInfo.BoundaryInfo]
                ) -> DOFs.DOFsManager.MeshDOFsInfo:
                pass

            @staticmethod
            def create_local_space(
                geometric_tolerance_1_d: float,
                geometric_tolerance_2_d: float,
                geometric_tolerance_3_d: float,
                mesh_geometric_data: Gedim.MeshUtilities.MeshGeometricData3D,
                cell3_d_index: int,
                reference_element_data: ReferenceElement_Data
                ) -> LocalSpace_Data:
                pass

            @staticmethod
            def basis_functions_values(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.PCC.ProjectionTypes = VEM.PCC.ProjectionTypes.pi0km1
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def basis_functions_values_on_face(
                face_local_index: int,
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                quadrature_points: Eigen.MatrixXd
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def basis_functions_derivative_values(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.PCC.ProjectionTypes = VEM.PCC.ProjectionTypes.pi0km1_der
                ) -> List[Eigen.MatrixXd]:
                pass

            @staticmethod
            def stabilization_matrix(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.PCC.ProjectionTypes = VEM.PCC.ProjectionTypes.pi_nabla
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def edge_dofs_coordinates(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                edge_local_index: int
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def face_dofs_coordinates(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                face_local_index: int,
                quadrature_offset: int
                ) -> Gedim.Quadrature.QuadratureData:
                pass

            @staticmethod
            def face_dofs(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                face_local_index: int,
                strong_values: Eigen.VectorXd,
                quadrature_offset: Gedim.Quadrature.QuadratureData
                ) -> Eigen.VectorXd:
                pass

            @staticmethod
            def face_quadrature(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                face_local_index: int,
                quadrature_offset: int
                ) -> Gedim.Quadrature.QuadratureData:
                pass

            @staticmethod
            def internal_quadrature(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Gedim.Quadrature.QuadratureData:
                pass

            @staticmethod
            def size(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> int:
                pass

            @staticmethod
            def compute_performance(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Performance_Data:
                pass

        # </submodule local_space_pcc_3_d>

    # </submodule pde_tools>

# </submodule polydim>
####################    </generated_from:LocalSpace_PCC_3D.hpp>    ####################


####################    <generated_from:LocalSpace_MCC_2D.hpp>    ####################
# _LICENSE_HEADER_
#
# Copyright (C) 2019 - 2025.
# Terms register on the GPL-3.0 license.
#
# This file can be redistributed and/or modified under the license terms.
#
# See top level LICENSE file for more details.
#
# This file can be used citing references in CITATION.cff file.

# #ifndef __LocalSpace_MCC_2D_H
#



# #endif
#

# <submodule polydim>
class polydim:  # Proxy class that introduces typings for the *submodule* polydim
    pass  # (This corresponds to a C++ namespace. All method are static!)
    """ namespace Polydim"""

    # <submodule pde_tools>
    class pde_tools:  # Proxy class that introduces typings for the *submodule* pde_tools
        pass  # (This corresponds to a C++ namespace. All method are static!)
        """ namespace PDETools"""

        # <submodule local_space_mcc_2_d>
        class local_space_mcc_2_d:  # Proxy class that introduces typings for the *submodule* local_space_mcc_2_d
            pass  # (This corresponds to a C++ namespace. All method are static!)
            """ namespace LocalSpace_MCC_2D"""
            class MethodTypes(enum.IntEnum):
                vem_mcc = enum.auto()                  # (= 1)
                vem_mcc_partial = enum.auto()          # (= 2)
                vem_mcc_ortho = enum.auto()            # (= 3)
                vem_mcc_edge_ortho = enum.auto()       # (= 4)
                vem_mcc_ortho_edge_ortho = enum.auto() # (= 5)

            class ReferenceElement_Data:
                """
                (final class)
                """
                method_type: Polydim.PDETools.LocalSpace_MCC_2D.MethodTypes
                order: int

                vem_reference_element_velocity: Polydim.VEM.MCC.I_VEM_MCC_2D_Velocity_ReferenceElement
                vem_reference_element_pressure: Polydim.VEM.MCC.I_VEM_MCC_2D_Pressure_ReferenceElement
                vem_reference_element_data_velocity: Polydim.VEM.MCC.VEM_MCC_2D_Velocity_ReferenceElement_Data
                vem_reference_element_data_pressure: Polydim.VEM.MCC.VEM_MCC_2D_Pressure_ReferenceElement_Data
                vem_type: Polydim.VEM.MCC.VEM_MCC_2D_LocalSpace_Types
                vem_local_space_velocity: VEM.MCC.I_VEM_MCC_2D_Velocity_LocalSpace
                vem_local_space_pressure: VEM.MCC.I_VEM_MCC_2D_Pressure_LocalSpace
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class LocalSpace_Data:
                """
                (final class)
                """
                vem_geometry: Polydim.VEM.MCC.VEM_MCC_2D_Polygon_Geometry
                vem_local_space_data_velocity: Polydim.VEM.MCC.VEM_MCC_2D_Velocity_LocalSpace_Data
                vem_local_space_data_pressure: Polydim.VEM.MCC.VEM_MCC_2D_Pressure_LocalSpace_Data
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            class Performance_Data:
                """
                (final class)
                """
                class Cell2D_Performance:
                    """
                    (final class)
                    """
                    num_boundary_quadrature_points: int = 0
                    num_internal_quadrature_points: int = 0
                    analysis: Polydim.VEM.MCC.VEM_MCC_PerformanceAnalysis_Data
                    def __init__(self) -> None:
                        """Autogenerated default constructor"""
                        pass

                vem_performance_data: Polydim.PDETools.LocalSpace_MCC_2D.Performance_Data.Cell2D_Performance
                def __init__(self) -> None:
                    """Autogenerated default constructor"""
                    pass

            @staticmethod
            def create_reference_element(
                method_type: MethodTypes,
                method_order: int
                ) -> ReferenceElement_Data:
                pass

            @staticmethod
            def reference_element_num_do_fs(
                reference_element_data: ReferenceElement_Data
                ) -> List[List[int]]:
                pass

            @staticmethod
            def create_local_space(
                geometric_tolerance_1_d: float,
                geometric_tolerance_2_d: float,
                mesh_geometric_data: Gedim.MeshUtilities.MeshGeometricData2D,
                cell2_d_index: int,
                reference_element_data: ReferenceElement_Data
                ) -> LocalSpace_Data:
                pass

            @staticmethod
            def velocity_basis_functions_values(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.MCC.ProjectionTypes = VEM.MCC.ProjectionTypes.pi0k
                ) -> List[Eigen.MatrixXd]:
                pass

            @staticmethod
            def pressure_basis_functions_values(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def velocity_basis_functions_divergence_values(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def stabilization_matrix(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                projection_type: VEM.MCC.ProjectionTypes = VEM.MCC.ProjectionTypes.pi0k
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def edge_dofs_coordinates(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                edge_local_index: int
                ) -> Gedim.Quadrature.QuadratureData:
                pass

            @staticmethod
            def edge_dofs(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                edge_local_index: int,
                edge_dofs_coordinates: Gedim.Quadrature.QuadratureData,
                strong_values: Eigen.VectorXd
                ) -> Eigen.VectorXd:
                pass

            @staticmethod
            def velocity_basis_functions_values_on_edges(
                edge_local_index: int,
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                edge_quadrature_points: Eigen.MatrixXd
                ) -> Eigen.MatrixXd:
                pass

            @staticmethod
            def edge_quadrature(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data,
                edge_local_index: int
                ) -> Gedim.Quadrature.QuadratureData:
                pass

            @staticmethod
            def internal_quadrature(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Gedim.Quadrature.QuadratureData:
                pass

            @staticmethod
            def velocity_size(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> int:
                pass

            @staticmethod
            def compute_performance(
                reference_element_data: ReferenceElement_Data,
                local_space_data: LocalSpace_Data
                ) -> Performance_Data:
                pass


        # </submodule local_space_mcc_2_d>

    # </submodule pde_tools>

# </submodule polydim>
####################    </generated_from:LocalSpace_MCC_2D.hpp>    ####################

# </litgen_stub> // Autogenerated code end! `
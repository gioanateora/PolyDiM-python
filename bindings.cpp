#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>
#include <pybind11/eigen.h>

#include "all_includes.hpp"

namespace py = pybind11;

void py_init_module_polydim(py::module &m);

PYBIND11_MODULE(pypolydim, m)
{
    m.doc() = "PolyDiM library for python";

    py_init_module_polydim(m);
}

void py_init_module_polydim(py::module &m)
{
    // You can add any code here

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:StringsUtilities.hpp>    ////////////////////
    // #ifndef __StringsUtilities_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassStringsUtilities =
            py::class_<Gedim::StringsUtilities>
                (pyNsGedim, "StringsUtilities", "")
            .def(py::init<>()) // implicit default constructor
            .def_static("split",
                py::overload_cast<const std::string &, const char &>(&Gedim::StringsUtilities::Split),
                py::arg("string_to_split"), py::arg("character") = ' ',
                "/ Divide a string by a character in a vector of strings\n/ @example stringToSplit=\"pippo_pe\" character='_' -> result=[\"pippo\", \"pe\"]")
            .def_static("split",
                py::overload_cast<const std::string &, const std::vector<char> &>(&Gedim::StringsUtilities::Split),
                py::arg("string_to_split"), py::arg("characters") = std::vector<char>(' '),
                "/ Divide a string by a set of characters in a vector of strings\n/ @example stringToSplit=\"pippo_pe:pu\" characters={'_',':'} -> result=[\"pippo\", \"pe\", \"pu\"]")
            .def_static("find_separator",
                &Gedim::StringsUtilities::FindSeparator,
                py::arg("string_to_search"), py::arg("key_one"), py::arg("key_two"),
                "/ Find inside a string a separator between two keys\n/ @example stringToSearch=\"id:value\" keyOne=\"id\" keyTwo=\"value\" -> separator=':'")
            .def_static("to_lower",
                &Gedim::StringsUtilities::ToLower,
                py::arg("input"),
                "/ Convert string to lower")
            .def_static("to_upper",
                &Gedim::StringsUtilities::ToUpper,
                py::arg("input"),
                "/ Convert string to upper")
            .def_static("parse_vector<unsigned_int>",
                &Gedim::StringsUtilities::Parse<std::vector<unsigned int>>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_vector<double>",
                &Gedim::StringsUtilities::Parse<std::vector<double>>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_set<unsigned_int>",
                &Gedim::StringsUtilities::Parse<std::set<unsigned int>>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_vector<int>",
                &Gedim::StringsUtilities::Parse<std::vector<int>>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_bool",
                &Gedim::StringsUtilities::Parse<bool>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_string",
                &Gedim::StringsUtilities::Parse<std::string>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_double",
                &Gedim::StringsUtilities::Parse<double>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_float",
                &Gedim::StringsUtilities::Parse<float>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_char",
                &Gedim::StringsUtilities::Parse<char>,
                py::arg("object_string"),
                "/ Parse a string to object")
            .def_static("parse_int",
                &Gedim::StringsUtilities::Parse<int>,
                py::arg("object_string"),
                "/ Parse a string to object")
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:StringsUtilities.hpp>    ////////////////////


    ////////////////////    <generated_from:GeometryUtilities.hpp>    ////////////////////
    // #ifndef __GEOMETRYUTILITIES_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassGeometryUtilitiesConfig =
            py::class_<Gedim::GeometryUtilitiesConfig>
                (pyNsGedim, "GeometryUtilitiesConfig", py::is_final(), "\n(final class)")
            .def(py::init<>([](
            double MinTolerance = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance(), double Tolerance1D = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance(), double Tolerance2D = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance(), double Tolerance3D = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance())
            {
                auto r_ctor_ = std::make_unique<Gedim::GeometryUtilitiesConfig>();
                r_ctor_->MinTolerance = MinTolerance;
                r_ctor_->Tolerance1D = Tolerance1D;
                r_ctor_->Tolerance2D = Tolerance2D;
                r_ctor_->Tolerance3D = Tolerance3D;
                return r_ctor_;
            })
            , py::arg("min_tolerance") = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance(), py::arg("tolerance1_d") = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance(), py::arg("tolerance2_d") = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance(), py::arg("tolerance3_d") = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance()
            )
            .def_static("default_min_tolerance",
                &Gedim::GeometryUtilitiesConfig::DefaultMinTolerance)
            .def_readwrite("min_tolerance", &Gedim::GeometryUtilitiesConfig::MinTolerance, "")
            .def_readwrite("tolerance1_d", &Gedim::GeometryUtilitiesConfig::Tolerance1D, "")
            .def_readwrite("tolerance2_d", &Gedim::GeometryUtilitiesConfig::Tolerance2D, "")
            .def_readwrite("tolerance3_d", &Gedim::GeometryUtilitiesConfig::Tolerance3D, "")
            ;


        auto pyNsGedim_ClassGeometryUtilities =
            py::class_<Gedim::GeometryUtilities>
                (pyNsGedim, "GeometryUtilities", py::is_final(), "/ \\brief The GeometryUtilities class intersects 3D segments\n(final class)");

        { // inner classes & enums of GeometryUtilities
            auto pyEnumCompareTypes =
                py::enum_<Gedim::GeometryUtilities::CompareTypes>(pyNsGedim_ClassGeometryUtilities, "CompareTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::CompareTypes::Unknown, "")
                    .value("first_before_second", Gedim::GeometryUtilities::CompareTypes::FirstBeforeSecond, "")
                    .value("coincident", Gedim::GeometryUtilities::CompareTypes::Coincident, "")
                    .value("second_before_first", Gedim::GeometryUtilities::CompareTypes::SecondBeforeFirst, "");
            auto pyEnumPolygonTypes =
                py::enum_<Gedim::GeometryUtilities::PolygonTypes>(pyNsGedim_ClassGeometryUtilities, "PolygonTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PolygonTypes::Unknown, "")
                    .value("triangle", Gedim::GeometryUtilities::PolygonTypes::Triangle, "")
                    .value("quadrilateral_convex", Gedim::GeometryUtilities::PolygonTypes::Quadrilateral_Convex, "")
                    .value("quadrilateral_concave", Gedim::GeometryUtilities::PolygonTypes::Quadrilateral_Concave, "")
                    .value("generic_convex", Gedim::GeometryUtilities::PolygonTypes::Generic_Convex, "")
                    .value("generic_concave", Gedim::GeometryUtilities::PolygonTypes::Generic_Concave, "");
            auto pyEnumPolygonOrientations =
                py::enum_<Gedim::GeometryUtilities::PolygonOrientations>(pyNsGedim_ClassGeometryUtilities, "PolygonOrientations", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PolygonOrientations::Unknown, "")
                    .value("clockwise", Gedim::GeometryUtilities::PolygonOrientations::Clockwise, "")
                    .value("counter_clockwise", Gedim::GeometryUtilities::PolygonOrientations::CounterClockwise, "");
            auto pyEnumPointSegmentPositionTypes =
                py::enum_<Gedim::GeometryUtilities::PointSegmentPositionTypes>(pyNsGedim_ClassGeometryUtilities, "PointSegmentPositionTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PointSegmentPositionTypes::Unknown, "")
                    .value("on_segment_line_before_origin", Gedim::GeometryUtilities::PointSegmentPositionTypes::OnSegmentLineBeforeOrigin, "")
                    .value("on_segment_origin", Gedim::GeometryUtilities::PointSegmentPositionTypes::OnSegmentOrigin, "")
                    .value("inside_segment", Gedim::GeometryUtilities::PointSegmentPositionTypes::InsideSegment, "")
                    .value("on_segment_end", Gedim::GeometryUtilities::PointSegmentPositionTypes::OnSegmentEnd, "")
                    .value("on_segment_line_after_end", Gedim::GeometryUtilities::PointSegmentPositionTypes::OnSegmentLineAfterEnd, "")
                    .value("left_the_segment", Gedim::GeometryUtilities::PointSegmentPositionTypes::LeftTheSegment, "")
                    .value("right_the_segment", Gedim::GeometryUtilities::PointSegmentPositionTypes::RightTheSegment, "");
            auto pyEnumPointPlanePositionTypes =
                py::enum_<Gedim::GeometryUtilities::PointPlanePositionTypes>(pyNsGedim_ClassGeometryUtilities, "PointPlanePositionTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PointPlanePositionTypes::Unknown, "")
                    .value("negative", Gedim::GeometryUtilities::PointPlanePositionTypes::Negative, "")
                    .value("on_plane", Gedim::GeometryUtilities::PointPlanePositionTypes::OnPlane, "")
                    .value("positive", Gedim::GeometryUtilities::PointPlanePositionTypes::Positive, "");
            auto pyEnumPolygonCirclePositionTypes =
                py::enum_<Gedim::GeometryUtilities::PolygonCirclePositionTypes>(pyNsGedim_ClassGeometryUtilities, "PolygonCirclePositionTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PolygonCirclePositionTypes::Unknown, "")
                    .value("polygon_outside_circle_no_intersection", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonOutsideCircleNoIntersection, "")
                    .value("polygon_outside_circle_one_intersection_on_vertex", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonOutsideCircleOneIntersectionOnVertex, "")
                    .value("polygon_outside_circle_one_intersection_tangent_on_edge", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonOutsideCircleOneIntersectionTangentOnEdge, "")
                    .value("circle_inside_polygon_no_intersection", Gedim::GeometryUtilities::PolygonCirclePositionTypes::CircleInsidePolygonNoIntersection, "")
                    .value("circle_inside_polygon_one_intersection_tangent_on_edge", Gedim::GeometryUtilities::PolygonCirclePositionTypes::CircleInsidePolygonOneIntersectionTangentOnEdge, "")
                    .value("polygon_inside_circle_no_intersection", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonInsideCircleNoIntersection, "")
                    .value("polygon_inside_circle_one_vertex_intersection", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonInsideCircleOneVertexIntersection, "")
                    .value("polygon_inside_circle_intersection_only_on_vertices", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonInsideCircleIntersectionOnlyOnVertices, "")
                    .value("circle_polygon_multiple_intersections", Gedim::GeometryUtilities::PolygonCirclePositionTypes::CirclePolygonMultipleIntersections, "");
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult =
                py::class_<Gedim::GeometryUtilities::IntersectionPolygonCircleResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionPolygonCircleResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionPolygonCircleResult
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult_ClassIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult, "Intersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of Intersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult_ClassIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types::Unknown, "")
                            .value("secant", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types::Secant, "")
                            .value("tangent", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types::Tangent, "");
                    auto pyEnumIndexTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult_ClassIntersection, "IndexTypes", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes::Unknown, "")
                            .value("vertex", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes::Vertex, "")
                            .value("edge", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes::Edge, "");
                } // end of inner classes & enums of Intersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult_ClassIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types Type = Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types::Unknown, Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes IndexType = Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes::Unknown, double CurvilinearCoordinate = double())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection>();
                        r_ctor_->Type = Type;
                        r_ctor_->IndexType = IndexType;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types::Unknown, py::arg("index_type") = Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes::Unknown, py::arg("curvilinear_coordinate") = double()
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Type, "")
                    .def_readwrite("index_type", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexType, "")
                    .def_readwrite("index", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Index, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::CurvilinearCoordinate, "/< Valid only in IndexType Edge")
                    ;
            } // end of inner classes & enums of IntersectionPolygonCircleResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult
                .def(py::init<>([](
                std::vector<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection> Intersections = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolygonCircleResult>();
                    r_ctor_->Intersections = Intersections;
                    return r_ctor_;
                })
                , py::arg("intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection>{}
                )
                .def_readwrite("intersections", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersections, "/< ordered")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassPolygonDivisionByAngleQuadrantResult =
                py::class_<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult>
                    (pyNsGedim_ClassGeometryUtilities, "PolygonDivisionByAngleQuadrantResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of PolygonDivisionByAngleQuadrantResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassPolygonDivisionByAngleQuadrantResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types::Unknown, "")
                        .value("external_origin", Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types::ExternalOrigin, "")
                        .value("internal", Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types::Internal, "")
                        .value("external_end", Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types::ExternalEnd, "");
            } // end of inner classes & enums of PolygonDivisionByAngleQuadrantResult

            pyNsGedim_ClassGeometryUtilities_ClassPolygonDivisionByAngleQuadrantResult
                .def(py::init<>([](
                Eigen::MatrixXd Points = Eigen::MatrixXd(), std::vector<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types> SubPolygonTypes = std::vector<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult>();
                    r_ctor_->Points = Points;
                    r_ctor_->SubPolygonTypes = SubPolygonTypes;
                    return r_ctor_;
                })
                , py::arg("points") = Eigen::MatrixXd(), py::arg("sub_polygon_types") = std::vector<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types>()
                )
                .def_readwrite("points", &Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Points, "/< Coordinates of generated points")
                .def_readwrite("sub_polygons", &Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::SubPolygons, "/< Subpolygon formed")
                .def_readwrite("sub_polygon_types", &Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::SubPolygonTypes, "/< SubPolygon")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassPolygonDivisionByCircleResult =
                py::class_<Gedim::GeometryUtilities::PolygonDivisionByCircleResult>
                    (pyNsGedim_ClassGeometryUtilities, "PolygonDivisionByCircleResult", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd Points = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::PolygonDivisionByCircleResult>();
                    r_ctor_->Points = Points;
                    return r_ctor_;
                })
                , py::arg("points") = Eigen::MatrixXd()
                )
                .def_readwrite("points", &Gedim::GeometryUtilities::PolygonDivisionByCircleResult::Points, "/< Coordinates of generated points")
                .def_readwrite("sub_triangles", &Gedim::GeometryUtilities::PolygonDivisionByCircleResult::SubTriangles, "/< Triangle formed with sub-polygons and circle Center")
                .def_readwrite("internal_triangles", &Gedim::GeometryUtilities::PolygonDivisionByCircleResult::InternalTriangles, "/< Triangle formed with circle Center and new points")
                .def_readwrite("sub_polygons", &Gedim::GeometryUtilities::PolygonDivisionByCircleResult::SubPolygons, "/< Subpolygon formed")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassCircleDivisionByPolygonResult =
                py::class_<Gedim::GeometryUtilities::CircleDivisionByPolygonResult>
                    (pyNsGedim_ClassGeometryUtilities, "CircleDivisionByPolygonResult", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd Points = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::CircleDivisionByPolygonResult>();
                    r_ctor_->Points = Points;
                    return r_ctor_;
                })
                , py::arg("points") = Eigen::MatrixXd()
                )
                .def_readwrite("points", &Gedim::GeometryUtilities::CircleDivisionByPolygonResult::Points, "/< Coordinates of generated points")
                .def_readwrite("sub_triangles", &Gedim::GeometryUtilities::CircleDivisionByPolygonResult::SubTriangles, "/< Triangle formed with sub-polygons and circle Center")
                .def_readwrite("internal_triangles", &Gedim::GeometryUtilities::CircleDivisionByPolygonResult::InternalTriangles, "/< Triangle formed with circle Center and new points")
                .def_readwrite("sub_polygons", &Gedim::GeometryUtilities::CircleDivisionByPolygonResult::SubPolygons, "/< Subpolygon formed")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput =
                py::class_<Gedim::GeometryUtilities::SplitPolygonInput>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolygonInput", py::is_final(), "\n(final class)");

            { // inner classes & enums of SplitPolygonInput
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassAlignedEdge =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput, "AlignedEdge", "")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("origin_vertex_index", &Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge::OriginVertexIndex, "")
                    .def_readwrite("end_vertex_index", &Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge::EndVertexIndex, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput, "SplitSegment", "");

                { // inner classes & enums of SplitSegment
                    auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment_ClassVertex =
                        py::class_<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex>
                            (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment, "Vertex", py::is_final(), "\n(final class)");

                    { // inner classes & enums of Vertex
                        auto pyEnumTypes =
                            py::enum_<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment_ClassVertex, "Types", py::arithmetic(), "")
                                .value("unknown", Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types::Unknown, "")
                                .value("vertex", Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types::Vertex, "")
                                .value("edge", Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types::Edge, "");
                    } // end of inner classes & enums of Vertex

                    pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment_ClassVertex
                        .def(py::init<>([](
                        Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types Type = Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types())
                        {
                            auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex>();
                            r_ctor_->Type = Type;
                            return r_ctor_;
                        })
                        , py::arg("type") = Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types()
                        )
                        .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Type, "")
                        .def_readwrite("index", &Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Index, "")
                        ;
                } // end of inner classes & enums of SplitSegment

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex Origin = Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex(), Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex End = Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment>();
                        r_ctor_->Origin = Origin;
                        r_ctor_->End = End;
                        return r_ctor_;
                    })
                    , py::arg("origin") = Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex(), py::arg("end") = Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex()
                    )
                    .def_readwrite("origin", &Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Origin, "")
                    .def_readwrite("end", &Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::End, "")
                    ;
            } // end of inner classes & enums of SplitPolygonInput

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput
                .def(py::init<>([](
                std::vector<Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge> AlignedEdges = std::vector<Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge>(), Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment Segment = Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonInput>();
                    r_ctor_->AlignedEdges = AlignedEdges;
                    r_ctor_->Segment = Segment;
                    return r_ctor_;
                })
                , py::arg("aligned_edges") = std::vector<Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge>(), py::arg("segment") = Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment()
                )
                .def_readwrite("number_polygon_vertices", &Gedim::GeometryUtilities::SplitPolygonInput::NumberPolygonVertices, "")
                .def_readwrite("aligned_edges", &Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdges, "")
                .def_readwrite("segment", &Gedim::GeometryUtilities::SplitPolygonInput::Segment, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult =
                py::class_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolygonWithSegmentResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of SplitPolygonWithSegmentResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::Unknown, "")
                        .value("no_action", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::NoAction, "")
                        .value("polygon_update", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::PolygonUpdate, "")
                        .value("polygon_creation", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::PolygonCreation, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewVertex =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult, "NewVertex", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewVertex
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewVertex, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types::Unknown, "")
                            .value("segment_origin", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types::SegmentOrigin, "")
                            .value("segment_end", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types::SegmentEnd, "");
                } // end of inner classes & enums of NewVertex

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewVertex
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types Type = Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Type, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewEdge =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult, "NewEdge", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewEdge
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewEdge, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types::Unknown, "")
                            .value("edge_new", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types::EdgeNew, "")
                            .value("edge_update", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types::EdgeUpdate, "");
                } // end of inner classes & enums of NewEdge

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewEdge
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types Type = Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Type, "")
                    .def_readwrite("old_edge_id", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::OldEdgeId, "")
                    .def_readwrite("origin_id", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::OriginId, "")
                    .def_readwrite("end_id", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::EndId, "")
                    .def_readwrite("cell2_d_neighbours", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Cell2DNeighbours, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewPolygon =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygon>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult, "NewPolygon", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygon::Vertices, "")
                    .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygon::Edges, "")
                    ;
            } // end of inner classes & enums of SplitPolygonWithSegmentResult

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types Type = Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::Unknown, std::list<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex> NewVertices = {}, std::list<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge> NewEdges = {}, std::vector<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygon> NewPolygons = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->NewVertices = NewVertices;
                    r_ctor_->NewEdges = NewEdges;
                    r_ctor_->NewPolygons = NewPolygons;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::Unknown, py::arg("new_vertices") = std::list<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex>{}, py::arg("new_edges") = std::list<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge>{}, py::arg("new_polygons") = std::vector<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygon>{}
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Type, "")
                .def_readwrite("new_vertices", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertices, "")
                .def_readwrite("new_edges", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdges, "")
                .def_readwrite("new_polygons", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygons, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult =
                py::class_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolygonWithCircleResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of SplitPolygonWithCircleResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::Unknown, "")
                        .value("no_action", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::NoAction, "")
                        .value("polygon_update", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::PolygonUpdate, "")
                        .value("polygon_creation", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::PolygonCreation, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewVertex =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult, "NewVertex", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewVertex
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewVertex, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::Unknown, "")
                            .value("polygon_vertex", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::PolygonVertex, "")
                            .value("circle_intersection", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::CircleIntersection, "")
                            .value("both", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::Both, "");
                } // end of inner classes & enums of NewVertex

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewVertex
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types Type = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Type, "")
                    .def_readwrite("polygon_index", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::PolygonIndex, "/< Index in polygon vertices")
                    .def_readwrite("intersection_index", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::IntersectionIndex, "/< Index in circle intersections")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewEdge =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult, "NewEdge", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewEdge
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewEdge, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types::Unknown, "")
                            .value("segment", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types::Segment, "")
                            .value("arc", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types::Arc, "");
                    auto pyEnumArcTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewEdge, "ArcTypes", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes::Unknown, "")
                            .value("inside_polygon", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes::InsidePolygon, "")
                            .value("outside_polygon", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes::OutsidePolygon, "");
                } // end of inner classes & enums of NewEdge

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewEdge
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types Type = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types::Unknown, Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes ArcType = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge>();
                        r_ctor_->Type = Type;
                        r_ctor_->ArcType = ArcType;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types::Unknown, py::arg("arc_type") = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Type, "")
                    .def_readwrite("arc_type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcType, "/< Valid only if")
                    .def_readwrite("vertex_indices", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::VertexIndices, "/< Index of vertices in NewVertices")
                    .def_readwrite("polygon_index", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::PolygonIndex, "/< Index of Edge in polygon intersections")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewPolygon =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult, "NewPolygon", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewPolygon
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewPolygon, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::Unknown, "")
                            .value("inside_only_circle", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::InsideOnlyCircle, "")
                            .value("inside_only_polygon", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::InsideOnlyPolygon, "")
                            .value("inside_circle_and_polygon", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::InsideCircleAndPolygon, "");
                } // end of inner classes & enums of NewPolygon

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewPolygon
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types Type = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Type, "")
                    .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Vertices, "")
                    .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Edges, "")
                    ;
            } // end of inner classes & enums of SplitPolygonWithCircleResult

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types Type = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::Unknown, std::vector<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex> NewVertices = {}, std::vector<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge> NewEdges = {}, std::vector<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon> NewPolygons = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithCircleResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->NewVertices = NewVertices;
                    r_ctor_->NewEdges = NewEdges;
                    r_ctor_->NewPolygons = NewPolygons;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::Unknown, py::arg("new_vertices") = std::vector<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex>{}, py::arg("new_edges") = std::vector<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge>{}, py::arg("new_polygons") = std::vector<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon>{}
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Type, "")
                .def_readwrite("polygon_vertices_new_vertices_position", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::PolygonVerticesNewVerticesPosition, "")
                .def_readwrite("circle_intersections_new_vertices_position", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::CircleIntersectionsNewVerticesPosition, "")
                .def_readwrite("new_vertices", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertices, "")
                .def_readwrite("new_edges", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdges, "")
                .def_readwrite("new_polygons", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygons, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult =
                py::class_<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionSegmentSegmentResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionSegmentSegmentResult
                auto pyEnumIntersectionLineTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult, "IntersectionLineTypes", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::Unknown, "")
                        .value("on_different_planes", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::OnDifferentPlanes, "")
                        .value("co_planar_parallel", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::CoPlanarParallel, "")
                        .value("co_planar_intersecting", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::CoPlanarIntersecting, "");
                auto pyEnumIntersectionSegmentTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult, "IntersectionSegmentTypes", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::Unknown, "")
                        .value("no_intersection", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::NoIntersection, "")
                        .value("single_intersection", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::SingleIntersection, "")
                        .value("multiple_intersections", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::MultipleIntersections, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult_ClassIntersectionPosition =
                    py::class_<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult, "IntersectionPosition", "")
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::PointSegmentPositionTypes Type = Gedim::GeometryUtilities::PointSegmentPositionTypes::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition>();
                        r_ctor_->Type = Type;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::PointSegmentPositionTypes::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition::Type, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition::CurvilinearCoordinate, "")
                    ;
            } // end of inner classes & enums of IntersectionSegmentSegmentResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes IntersectionLinesType = Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::Unknown, Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes IntersectionSegmentsType = Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::Unknown, std::vector<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition> FirstSegmentIntersections = std::vector<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition>(), std::vector<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition> SecondSegmentIntersections = std::vector<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult>();
                    r_ctor_->IntersectionLinesType = IntersectionLinesType;
                    r_ctor_->IntersectionSegmentsType = IntersectionSegmentsType;
                    r_ctor_->FirstSegmentIntersections = FirstSegmentIntersections;
                    r_ctor_->SecondSegmentIntersections = SecondSegmentIntersections;
                    return r_ctor_;
                })
                , py::arg("intersection_lines_type") = Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::Unknown, py::arg("intersection_segments_type") = Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::Unknown, py::arg("first_segment_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition>(), py::arg("second_segment_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition>()
                )
                .def_readwrite("intersection_lines_type", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLinesType, "")
                .def_readwrite("intersection_segments_type", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentsType, "")
                .def_readwrite("second_intersection_relation", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::SecondIntersectionRelation, "/ \\brief relation between first and second intersection.\n/ Values are the indeces of the SecondSegmentIntersections vector respect the FirstSegmentIntersections vector\n/ \\example in MultipleIntersection case, if SecondIntersectionRelation[0] = 1,\n/ then the second intersection point SecondSegmentIntersections[1] is equal to FirstSegmentIntersections[0]\n/ point")
                .def_readwrite("first_segment_intersections", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::FirstSegmentIntersections, "/ \\brief intersections of the first segment,\n/ \note if multiple intersections are found, than the origin and the end coordinate are stored")
                .def_readwrite("second_segment_intersections", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::SecondSegmentIntersections, "/ intersections of the second segment")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult =
                py::class_<Gedim::GeometryUtilities::IntersectionSegmentCircleResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionSegmentCircleResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionSegmentCircleResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::Unknown, "")
                        .value("no_intersection", Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::NoIntersection, "")
                        .value("tangent_intersection", Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::TangentIntersection, "")
                        .value("two_intersections", Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::TwoIntersections, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult_ClassIntersectionPosition =
                    py::class_<Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult, "IntersectionPosition", "")
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::PointSegmentPositionTypes Type = Gedim::GeometryUtilities::PointSegmentPositionTypes::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition>();
                        r_ctor_->Type = Type;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::PointSegmentPositionTypes::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition::Type, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition::CurvilinearCoordinate, "")
                    ;
            } // end of inner classes & enums of IntersectionSegmentCircleResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types Type = Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::Unknown, std::vector<Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition> SegmentIntersections = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentCircleResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->SegmentIntersections = SegmentIntersections;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::Unknown, py::arg("segment_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition>{}
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Type, "")
                .def_readwrite("segment_intersections", &Gedim::GeometryUtilities::IntersectionSegmentCircleResult::SegmentIntersections, "/ \\brief intersections of the segment,")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult =
                py::class_<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionSegmentPlaneResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionSegmentPlaneResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::Unknown, "")
                        .value("single_intersection", Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::SingleIntersection, "")
                        .value("no_intersection", Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::NoIntersection, "")
                        .value("multiple_intersections", Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::MultipleIntersections, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult_ClassIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult, "Intersection", "")
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::PointSegmentPositionTypes Type = Gedim::GeometryUtilities::PointSegmentPositionTypes::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection>();
                        r_ctor_->Type = Type;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::PointSegmentPositionTypes::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection::Type, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection::CurvilinearCoordinate, "")
                    ;
            } // end of inner classes & enums of IntersectionSegmentPlaneResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types Type = Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::Unknown, Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection SingleIntersection = Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->SingleIntersection = SingleIntersection;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::Unknown, py::arg("single_intersection") = Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection()
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Type, "/< The intersection type")
                .def_readwrite("single_intersection", &Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::SingleIntersection, "/< The single")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult =
                py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionPolyhedronLineResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionPolyhedronLineResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::Unknown, "")
                        .value("none", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::None, "/< No intersection found")
                        .value("one_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::OneIntersection, "/< One intersection found")
                        .value("two_intersections", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::TwoIntersections, "/< Two intersection found")
                        .value("multiple_intersections", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::MultipleIntersections, "/< Multiple intersection found");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronFaceIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "PolyhedronFaceIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of PolyhedronFaceIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronFaceIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of PolyhedronFaceIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronFaceIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types Type = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Type, "")
                    .def_readwrite("line_intersection_index", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::LineIntersectionIndex, "/< Index of line intersection collection")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronEdgeIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "PolyhedronEdgeIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of PolyhedronEdgeIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronEdgeIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of PolyhedronEdgeIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronEdgeIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types Type = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Type, "")
                    .def_readwrite("line_intersection_index", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::LineIntersectionIndex, "/< Index of line intersection collection")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronVertexIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "PolyhedronVertexIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of PolyhedronVertexIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronVertexIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of PolyhedronVertexIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronVertexIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types Type = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Type, "")
                    .def_readwrite("line_intersection_index", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::LineIntersectionIndex, "/< Index of line intersection collection")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassLineIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "LineIntersection", "");

                { // inner classes & enums of LineIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassLineIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::Unknown, "")
                            .value("on_vertex", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::OnVertex, "/< On polyhedron vertex")
                            .value("on_edge", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::OnEdge, "/< On polyhedron edge")
                            .value("on_face", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::OnFace, "/< On polyhedron face")
                            .value("inside", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::Inside, "/< Inside polyhedron");
                } // end of inner classes & enums of LineIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassLineIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types PolyhedronType = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection>();
                        r_ctor_->PolyhedronType = PolyhedronType;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("polyhedron_type") = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("polyhedron_type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::PolyhedronType, "/< Type")
                    .def_readwrite("polyhedron_index", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::PolyhedronIndex, "/<  Index of the intersecting element of the Polyhedron (face, edge or")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::CurvilinearCoordinate, "/< Curvilinear coordinate in the line")
                    ;
            } // end of inner classes & enums of IntersectionPolyhedronLineResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types Type = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::Unknown, std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection> LineIntersections = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection>(), std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection> PolyhedronVertexIntersections = {}, std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection> PolyhedronEdgeIntersections = {}, std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection> PolyhedronFaceIntersections = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->LineIntersections = LineIntersections;
                    r_ctor_->PolyhedronVertexIntersections = PolyhedronVertexIntersections;
                    r_ctor_->PolyhedronEdgeIntersections = PolyhedronEdgeIntersections;
                    r_ctor_->PolyhedronFaceIntersections = PolyhedronFaceIntersections;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::Unknown, py::arg("line_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection>(), py::arg("polyhedron_vertex_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection>{}, py::arg("polyhedron_edge_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection>{}, py::arg("polyhedron_face_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection>{}
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Type, "")
                .def_readwrite("line_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersections, "/< The line intersections")
                .def_readwrite("polyhedron_vertex_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersections, "/< Polyhedron Vertex")
                .def_readwrite("polyhedron_edge_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersections, "/< Polyhedron Edge intersections,")
                .def_readwrite("polyhedron_face_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersections, "/< Polyhedron Face intersections,")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult =
                py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionPolyhedronsSegmentResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionPolyhedronsSegmentResult
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult_ClassIntersectionPoint =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionPoint>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult, "IntersectionPoint", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("cell3_d_indices", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionPoint::Cell3DIndices, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult_ClassIntersectionSegment =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult, "IntersectionSegment", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    std::vector<double> Points = {})
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment>();
                        r_ctor_->Points = Points;
                        return r_ctor_;
                    })
                    , py::arg("points") = std::vector<double>{}
                    )
                    .def_readwrite("points", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment::Points, "")
                    .def_readwrite("cell3_d_indices", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment::Cell3DIndices, "")
                    ;
            } // end of inner classes & enums of IntersectionPolyhedronsSegmentResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult
                .def(py::init<>([](
                std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment> Segments = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult>();
                    r_ctor_->Segments = Segments;
                    return r_ctor_;
                })
                , py::arg("segments") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment>()
                )
                .def_readwrite("points", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::Points, "")
                .def_readwrite("segments", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::Segments, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult =
                py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionPolyhedronPlaneResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionPolyhedronPlaneResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::Unknown, "")
                        .value("none", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::None, "/< No intersection found")
                        .value("on_vertex", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::OnVertex, "/< On polyhedron vertex")
                        .value("on_edge", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::OnEdge, "/< On polyhedron edge")
                        .value("on_face", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::OnFace, "/< On polyhedron face")
                        .value("new_polygon", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::NewPolygon, "/< New polygon intersection");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassFaceIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "FaceIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of FaceIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassFaceIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of FaceIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassFaceIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types Type = Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Type, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassEdgeIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "EdgeIntersection", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionSegmentPlaneResult Intersection = Gedim::GeometryUtilities::IntersectionSegmentPlaneResult())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersection>();
                        r_ctor_->Intersection = Intersection;
                        return r_ctor_;
                    })
                    , py::arg("intersection") = Gedim::GeometryUtilities::IntersectionSegmentPlaneResult()
                    )
                    .def_readwrite("intersection", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersection::Intersection, "/< Intersection between edge and")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassVertexIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "VertexIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of VertexIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassVertexIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of VertexIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassVertexIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types Type = Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Type, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "Intersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of Intersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types::Unknown, "")
                            .value("vertex", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types::Vertex, "")
                            .value("edge", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types::Edge, "");
                } // end of inner classes & enums of Intersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types Type = Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Type, "")
                    .def_readwrite("edge_id", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::EdgeId, "/<  Edge index of the Polyhedron")
                    .def_readwrite("vertex_id", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::VertexId, "/<  Vertex index of the Polyhedron, available only if Type is Types::Vertex")
                    ;
            } // end of inner classes & enums of IntersectionPolyhedronPlaneResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types Type = Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::Unknown, std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection> VertexIntersections = {}, std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersection> EdgeIntersections = {}, std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection> FaceIntersections = {}, std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection> Intersections = {}, Eigen::MatrixXd IntersectionCoordinates = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->VertexIntersections = VertexIntersections;
                    r_ctor_->EdgeIntersections = EdgeIntersections;
                    r_ctor_->FaceIntersections = FaceIntersections;
                    r_ctor_->Intersections = Intersections;
                    r_ctor_->IntersectionCoordinates = IntersectionCoordinates;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::Unknown, py::arg("vertex_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection>{}, py::arg("edge_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersection>{}, py::arg("face_intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection>{}, py::arg("intersections") = std::vector<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection>{}, py::arg("intersection_coordinates") = Eigen::MatrixXd()
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Type, "/< The intersection type")
                .def_readwrite("intersection_id", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::IntersectionId, "/< The geometry id of the intersection, available only with Types::OnVertex,")
                .def_readwrite("vertex_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersections, "/< Vertex intersections")
                .def_readwrite("edge_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersections, "/< Edge intersections")
                .def_readwrite("face_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersections, "/< Face intersections")
                .def_readwrite("intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersections, "/< The resulting intersections")
                .def_readwrite("intersection_coordinates", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::IntersectionCoordinates, "/< The resulting intersection coordinates")
                ;
            auto pyEnumPointCirclePositionResult =
                py::enum_<Gedim::GeometryUtilities::PointCirclePositionResult>(pyNsGedim_ClassGeometryUtilities, "PointCirclePositionResult", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PointCirclePositionResult::Unknown, "")
                    .value("outside", Gedim::GeometryUtilities::PointCirclePositionResult::Outside, "")
                    .value("on_border", Gedim::GeometryUtilities::PointCirclePositionResult::OnBorder, "")
                    .value("inside", Gedim::GeometryUtilities::PointCirclePositionResult::Inside, "");
            auto pyNsGedim_ClassGeometryUtilities_ClassPointPolygonPositionResult =
                py::class_<Gedim::GeometryUtilities::PointPolygonPositionResult>
                    (pyNsGedim_ClassGeometryUtilities, "PointPolygonPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of PointPolygonPositionResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::PointPolygonPositionResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassPointPolygonPositionResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::Unknown, "")
                        .value("outside", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::Outside, "")
                        .value("border_edge", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::BorderEdge, "")
                        .value("border_vertex", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::BorderVertex, "")
                        .value("inside", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::Inside, "");
            } // end of inner classes & enums of PointPolygonPositionResult

            pyNsGedim_ClassGeometryUtilities_ClassPointPolygonPositionResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::PointPolygonPositionResult::Types Type = Gedim::GeometryUtilities::PointPolygonPositionResult::Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::PointPolygonPositionResult>();
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::PointPolygonPositionResult::Types::Unknown
                )
                .def_readwrite("border_index", &Gedim::GeometryUtilities::PointPolygonPositionResult::BorderIndex, "/< index of vertex/edge of border")
                .def_readwrite("type", &Gedim::GeometryUtilities::PointPolygonPositionResult::Type, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult =
                py::class_<Gedim::GeometryUtilities::LinePolygonPositionResult>
                    (pyNsGedim_ClassGeometryUtilities, "LinePolygonPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of LinePolygonPositionResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::LinePolygonPositionResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::LinePolygonPositionResult::Types::Unknown, "")
                        .value("outside", Gedim::GeometryUtilities::LinePolygonPositionResult::Types::Outside, "")
                        .value("intersecting", Gedim::GeometryUtilities::LinePolygonPositionResult::Types::Intersecting, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult_ClassEdgeIntersection =
                    py::class_<Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult, "EdgeIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of EdgeIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult_ClassEdgeIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::Unknown, "")
                            .value("on_edge_origin", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::OnEdgeOrigin, "")
                            .value("inside_edge", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::InsideEdge, "")
                            .value("on_edge_end", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::OnEdgeEnd, "")
                            .value("parallel", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::Parallel, "");
                } // end of inner classes & enums of EdgeIntersection

                pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult_ClassEdgeIntersection
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types Type = Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection>();
                        r_ctor_->Type = Type;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Type, "")
                    .def_readwrite("index", &Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Index, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::CurvilinearCoordinate, "")
                    ;
            } // end of inner classes & enums of LinePolygonPositionResult

            pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult
                .def(py::init<>([](
                std::vector<Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection> EdgeIntersections = {}, Gedim::GeometryUtilities::LinePolygonPositionResult::Types Type = Gedim::GeometryUtilities::LinePolygonPositionResult::Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::LinePolygonPositionResult>();
                    r_ctor_->EdgeIntersections = EdgeIntersections;
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("edge_intersections") = std::vector<Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection>{}, py::arg("type") = Gedim::GeometryUtilities::LinePolygonPositionResult::Types::Unknown
                )
                .def_readwrite("edge_intersections", &Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersections, "")
                .def_readwrite("type", &Gedim::GeometryUtilities::LinePolygonPositionResult::Type, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassPointPolyhedronPositionResult =
                py::class_<Gedim::GeometryUtilities::PointPolyhedronPositionResult>
                    (pyNsGedim_ClassGeometryUtilities, "PointPolyhedronPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of PointPolyhedronPositionResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassPointPolyhedronPositionResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::Unknown, "")
                        .value("outside", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::Outside, "")
                        .value("border_face", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::BorderFace, "")
                        .value("border_edge", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::BorderEdge, "")
                        .value("border_vertex", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::BorderVertex, "")
                        .value("inside", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::Inside, "");
            } // end of inner classes & enums of PointPolyhedronPositionResult

            pyNsGedim_ClassGeometryUtilities_ClassPointPolyhedronPositionResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types Type = Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::PointPolyhedronPositionResult>();
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::Unknown
                )
                .def_readwrite("border_index", &Gedim::GeometryUtilities::PointPolyhedronPositionResult::BorderIndex, "/< index of vertex/edge/face of border")
                .def_readwrite("internal_indices", &Gedim::GeometryUtilities::PointPolyhedronPositionResult::Internal_indices, "/< list of index of internal cell (usually tetrahedrons)")
                .def_readwrite("type", &Gedim::GeometryUtilities::PointPolyhedronPositionResult::Type, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSegmentPolyhedronPositionResult =
                py::class_<Gedim::GeometryUtilities::SegmentPolyhedronPositionResult>
                    (pyNsGedim_ClassGeometryUtilities, "SegmentPolyhedronPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of SegmentPolyhedronPositionResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSegmentPolyhedronPositionResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::Unknown, "")
                        .value("outside", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::Outside, "")
                        .value("border_face", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::BorderFace, "")
                        .value("border_edge", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::BorderEdge, "")
                        .value("inside", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::Inside, "");
            } // end of inner classes & enums of SegmentPolyhedronPositionResult

            pyNsGedim_ClassGeometryUtilities_ClassSegmentPolyhedronPositionResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types Type = Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SegmentPolyhedronPositionResult>();
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::Unknown
                )
                .def_readwrite("border_index", &Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::BorderIndex, "/< index of edge/face of border")
                .def_readwrite("type", &Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Type, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassPolyhedron =
                py::class_<Gedim::GeometryUtilities::Polyhedron>
                    (pyNsGedim_ClassGeometryUtilities, "Polyhedron", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::MatrixXi Edges = Eigen::MatrixXi(), std::vector<Eigen::MatrixXi> Faces = std::vector<Eigen::MatrixXi>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::Polyhedron>();
                    r_ctor_->Vertices = Vertices;
                    r_ctor_->Edges = Edges;
                    r_ctor_->Faces = Faces;
                    return r_ctor_;
                })
                , py::arg("vertices") = Eigen::MatrixXd(), py::arg("edges") = Eigen::MatrixXi(), py::arg("faces") = std::vector<Eigen::MatrixXi>()
                )
                .def_readwrite("vertices", &Gedim::GeometryUtilities::Polyhedron::Vertices, "/< vertices, size 3 x numVertices")
                .def_readwrite("edges", &Gedim::GeometryUtilities::Polyhedron::Edges, "/< edges, size 2 x numEdges")
                .def_readwrite("faces", &Gedim::GeometryUtilities::Polyhedron::Faces, "/< faces vertices and edges, size numFaces x 2 x numFaceVertices")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithPlaneResult =
                py::class_<Gedim::GeometryUtilities::SplitPolygonWithPlaneResult>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolygonWithPlaneResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of SplitPolygonWithPlaneResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithPlaneResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Unknown, "")
                        .value("split", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Split, "")
                        .value("positive", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Positive, "")
                        .value("negative", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Negative, "")
                        .value("on_plane", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::OnPlane, "");
            } // end of inner classes & enums of SplitPolygonWithPlaneResult

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithPlaneResult
                .def(py::init<>([](
                std::vector<Eigen::Vector3d> NewVertices = std::vector<Eigen::Vector3d>(), Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types Type = Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithPlaneResult>();
                    r_ctor_->NewVertices = NewVertices;
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("new_vertices") = std::vector<Eigen::Vector3d>(), py::arg("type") = Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Unknown
                )
                .def_readwrite("positive_vertices", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::PositiveVertices, "/ vertices indices of the positive sub-polygon")
                .def_readwrite("negative_vertices", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::NegativeVertices, "/ vertices indices of the negative sub-polygon")
                .def_readwrite("points_on_plane", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::PointsOnPlane, "/ vertices indices of the points on plane")
                .def_readwrite("new_vertices", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::NewVertices, "/ new vertices coordinates")
                .def_readwrite("new_vertices_edge_index", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::NewVerticesEdgeIndex, "/ new vertices edge indices")
                .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Type, "/ type of split")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult =
                py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolyhedronWithPlaneResult", "");

            { // inner classes & enums of SplitPolyhedronWithPlaneResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types::Unknown, "")
                        .value("split", Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types::Split, "")
                        .value("none", Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types::None, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult_ClassNewVertices =
                    py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "NewVertices", "")
                    .def(py::init<>([](
                    Eigen::MatrixXd Vertices = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices>();
                        r_ctor_->Vertices = Vertices;
                        return r_ctor_;
                    })
                    , py::arg("vertices") = Eigen::MatrixXd()
                    )
                    .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices::Vertices, "/< all vertices contained in the new polyhedra")
                    .def_readwrite("new_vertices_original_edge", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices::NewVerticesOriginalEdge, "/< For each new vertex the index of the original edge")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult_ClassNewEdges =
                    py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "NewEdges", "")
                    .def(py::init<>([](
                    Eigen::MatrixXi Edges = Eigen::MatrixXi(), std::vector<int> NewEdgesOriginalEdges = std::vector<int>(), std::vector<int> NewEdgesOriginalFace = std::vector<int>())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges>();
                        r_ctor_->Edges = Edges;
                        r_ctor_->NewEdgesOriginalEdges = NewEdgesOriginalEdges;
                        r_ctor_->NewEdgesOriginalFace = NewEdgesOriginalFace;
                        return r_ctor_;
                    })
                    , py::arg("edges") = Eigen::MatrixXi(), py::arg("new_edges_original_edges") = std::vector<int>(), py::arg("new_edges_original_face") = std::vector<int>()
                    )
                    .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges::Edges, "/< all edges contained in the new polyhedra")
                    .def_readwrite("new_edges_original_edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges::NewEdgesOriginalEdges, "/< indices of original edges for new edges, -1 means no original")
                    .def_readwrite("new_edges_original_face", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges::NewEdgesOriginalFace, "/< For each new vertex the index of the original edge to which is")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult_ClassNewFaces =
                    py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "NewFaces", "")
                    .def(py::init<>([](
                    std::vector<Eigen::MatrixXi> Faces = std::vector<Eigen::MatrixXi>(), std::vector<int> NewFacesOriginalFaces = std::vector<int>())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces>();
                        r_ctor_->Faces = Faces;
                        r_ctor_->NewFacesOriginalFaces = NewFacesOriginalFaces;
                        return r_ctor_;
                    })
                    , py::arg("faces") = std::vector<Eigen::MatrixXi>(), py::arg("new_faces_original_faces") = std::vector<int>()
                    )
                    .def_readwrite("faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces::Faces, "")
                    .def_readwrite("new_faces_original_faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces::NewFacesOriginalFaces, "/< indices of original faces for new faces, -1 means no original")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult_ClassNewPolyhedron =
                    py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "NewPolyhedron", "")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron::Vertices, "")
                    .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron::Edges, "")
                    .def_readwrite("faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron::Faces, "")
                    ;
            } // end of inner classes & enums of SplitPolyhedronWithPlaneResult

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult
                .def(py::init<>([](
                Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices Vertices = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices(), Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges Edges = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges(), Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces Faces = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces(), Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron PositivePolyhedron = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron(), Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron NegativePolyhedron = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron(), Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types Type = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult>();
                    r_ctor_->Vertices = Vertices;
                    r_ctor_->Edges = Edges;
                    r_ctor_->Faces = Faces;
                    r_ctor_->PositivePolyhedron = PositivePolyhedron;
                    r_ctor_->NegativePolyhedron = NegativePolyhedron;
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("vertices") = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices(), py::arg("edges") = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges(), py::arg("faces") = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces(), py::arg("positive_polyhedron") = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron(), py::arg("negative_polyhedron") = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron(), py::arg("type") = Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types::Unknown
                )
                .def_readwrite("original_edges_new_edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::OriginalEdgesNewEdges, "")
                .def_readwrite("original_faces_new_faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::OriginalFacesNewFaces, "")
                .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Vertices, "")
                .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Edges, "")
                .def_readwrite("faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Faces, "")
                .def_readwrite("positive_polyhedron", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::PositivePolyhedron, "")
                .def_readwrite("negative_polyhedron", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NegativePolyhedron, "")
                .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Type, "/ type of split")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassAlignedPolyhedronEdgesResult =
                py::class_<Gedim::GeometryUtilities::AlignedPolyhedronEdgesResult>
                    (pyNsGedim_ClassGeometryUtilities, "AlignedPolyhedronEdgesResult", "")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("aligned_edges_vertices", &Gedim::GeometryUtilities::AlignedPolyhedronEdgesResult::AlignedEdgesVertices, "")
                .def_readwrite("aligned_edges_edges", &Gedim::GeometryUtilities::AlignedPolyhedronEdgesResult::AlignedEdgesEdges, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassMergePolyhedronsInput =
                py::class_<Gedim::GeometryUtilities::MergePolyhedronsInput>
                    (pyNsGedim_ClassGeometryUtilities, "MergePolyhedronsInput", "");

            { // inner classes & enums of MergePolyhedronsInput
                auto pyEnumMergeTypes =
                    py::enum_<Gedim::GeometryUtilities::MergePolyhedronsInput::MergeTypes>(pyNsGedim_ClassGeometryUtilities_ClassMergePolyhedronsInput, "MergeTypes", py::arithmetic(), "")
                        .value("none", Gedim::GeometryUtilities::MergePolyhedronsInput::MergeTypes::None, "")
                        .value("common", Gedim::GeometryUtilities::MergePolyhedronsInput::MergeTypes::Common, "")
                        .value("remove", Gedim::GeometryUtilities::MergePolyhedronsInput::MergeTypes::Remove, "");
            } // end of inner classes & enums of MergePolyhedronsInput

            pyNsGedim_ClassGeometryUtilities_ClassMergePolyhedronsInput
                .def(py::init<>()) // implicit default constructor
                .def_readonly_static("none", &Gedim::GeometryUtilities::MergePolyhedronsInput::none, "")
                .def_readwrite("vertices_type", &Gedim::GeometryUtilities::MergePolyhedronsInput::Vertices_Type, "")
                .def_readwrite("edges_type", &Gedim::GeometryUtilities::MergePolyhedronsInput::Edges_Type, "")
                .def_readwrite("faces_type", &Gedim::GeometryUtilities::MergePolyhedronsInput::Faces_Type, "")
                .def_readwrite("common_vertices", &Gedim::GeometryUtilities::MergePolyhedronsInput::Common_vertices, "")
                .def_readwrite("common_edges", &Gedim::GeometryUtilities::MergePolyhedronsInput::Common_edges, "")
                .def_readwrite("common_faces", &Gedim::GeometryUtilities::MergePolyhedronsInput::Common_faces, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassMergePolyhedronsResult =
                py::class_<Gedim::GeometryUtilities::MergePolyhedronsResult>
                    (pyNsGedim_ClassGeometryUtilities, "MergePolyhedronsResult", "")
                .def(py::init<>([](
                Gedim::GeometryUtilities::Polyhedron MergedPolyhedron = Gedim::GeometryUtilities::Polyhedron())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::MergePolyhedronsResult>();
                    r_ctor_->MergedPolyhedron = MergedPolyhedron;
                    return r_ctor_;
                })
                , py::arg("merged_polyhedron") = Gedim::GeometryUtilities::Polyhedron()
                )
                .def_readonly_static("none", &Gedim::GeometryUtilities::MergePolyhedronsResult::none, "")
                .def_readwrite("original_to_merged_vertices", &Gedim::GeometryUtilities::MergePolyhedronsResult::OriginalToMergedVertices, "")
                .def_readwrite("original_to_merged_edges", &Gedim::GeometryUtilities::MergePolyhedronsResult::OriginalToMergedEdges, "")
                .def_readwrite("original_to_merged_faces", &Gedim::GeometryUtilities::MergePolyhedronsResult::OriginalToMergedFaces, "")
                .def_readwrite("merged_to_original_vertices", &Gedim::GeometryUtilities::MergePolyhedronsResult::MergedToOriginalVertices, "")
                .def_readwrite("merged_to_original_edges", &Gedim::GeometryUtilities::MergePolyhedronsResult::MergedToOriginalEdges, "")
                .def_readwrite("merged_to_original_faces", &Gedim::GeometryUtilities::MergePolyhedronsResult::MergedToOriginalFaces, "")
                .def_readwrite("merged_polyhedron", &Gedim::GeometryUtilities::MergePolyhedronsResult::MergedPolyhedron, "")
                ;
        } // end of inner classes & enums of GeometryUtilities

        pyNsGedim_ClassGeometryUtilities
            .def(py::init<const Gedim::GeometryUtilitiesConfig &>(),
                py::arg("configuration"))
            .def("tolerance1_d",
                &Gedim::GeometryUtilities::Tolerance1D, "/ \\return tolerance used for segment length")
            .def("tolerance1_d_squared",
                &Gedim::GeometryUtilities::Tolerance1DSquared, "/ \\return tolerance used for squared segment length")
            .def("tolerance2_d",
                &Gedim::GeometryUtilities::Tolerance2D, "/ \\return tolerance used for polygon area")
            .def("tolerance3_d",
                &Gedim::GeometryUtilities::Tolerance3D, "/ \\return tolerance used for polyhedron volume")
            .def("relative_difference",
                &Gedim::GeometryUtilities::RelativeDifference,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\param first the first value\n/ \\param second the second value\n/ \\return the relative difference between the two values according the first")
            .def("compare_values",
                &Gedim::GeometryUtilities::CompareValues,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\brief Compare two values according to tolerance\n/ \\param first the first value\n/ \\param second the second value\n/ \\return the result\n/ \note the interval [-tolerance, tolerance] is considered 0.0")
            .def("are_values_equal",
                &Gedim::GeometryUtilities::AreValuesEqual,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\brief Check if two values are equal according to tolerance\n/ \\param first the first value\n/ \\param second the second value\n/ \\return the result")
            .def("is_value_greater",
                &Gedim::GeometryUtilities::IsValueGreater,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\param first the first value\n/ \\param second the second value\n/ \\return True if first is greater than second")
            .def("is_value_greater_or_equal",
                &Gedim::GeometryUtilities::IsValueGreaterOrEqual,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\param first the first value\n/ \\param second the second value\n/ \\return True if first is greater or equal than second")
            .def("is_value_lower",
                &Gedim::GeometryUtilities::IsValueLower, py::arg("first"), py::arg("second"), py::arg("tolerance"))
            .def("is_value_lower_or_equal",
                &Gedim::GeometryUtilities::IsValueLowerOrEqual, py::arg("first"), py::arg("second"), py::arg("tolerance"))
            .def("is_value_positive",
                &Gedim::GeometryUtilities::IsValuePositive,
                py::arg("value"), py::arg("tolerance"),
                "/ \\param value the value\n/ \\return True if value is positive")
            .def("is_value_negative",
                &Gedim::GeometryUtilities::IsValueNegative,
                py::arg("value"), py::arg("tolerance"),
                "/ \\param value the value\n/ \\return True if value is negative")
            .def("is_value_zero",
                &Gedim::GeometryUtilities::IsValueZero,
                py::arg("value"), py::arg("tolerance"),
                "/ \\param value the value\n/ \\return True if value is zero")
            .def("fibonacci_sphere",
                &Gedim::GeometryUtilities::fibonacci_sphere, py::arg("num_points"))
            .def("generate_uniform_random_points_in_sphere",
                &Gedim::GeometryUtilities::generate_uniform_random_points_in_sphere, py::arg("num_points"), py::arg("radius") = 1.0)
            .def("equispace_coordinates",
                py::overload_cast<const double &, const bool &>(&Gedim::GeometryUtilities::EquispaceCoordinates, py::const_),
                py::arg("step"), py::arg("insert_extremes"),
                "/ \\param step the distance between each coordinate\n/ \\param insertExtremes if True keeps the extremes\n/ \\return the equispace coordinates between [0.0, 1.0], size 1 x numCoordinates")
            .def("equispace_coordinates",
                py::overload_cast<const unsigned int &, const double &, const double &, const bool &>(&Gedim::GeometryUtilities::EquispaceCoordinates, py::const_),
                py::arg("size"), py::arg("origin"), py::arg("end"), py::arg("insert_extremes"),
                "/ \\param size the number of resulting coordinates\n/ \\param origin the starting curvilinear coordinate\n/ \\param end the ending curvilinear coordinate\n/ \\param insertExtremes if True keeps the extremes\n/ \\return equispaced curvilinear coordinates in the interval [origin, end]\n/ \note if size < 2 then size will be considered as 2")
            .def("random_coordinates",
                &Gedim::GeometryUtilities::RandomCoordinates,
                py::arg("size"), py::arg("insert_extremes"), py::arg("min_distance"), py::arg("seed") = time(nullptr),
                "/ \\param size the number of resulting coordinates\n/ \\param origin the starting curvilinear coordinate\n/ \\param end the ending curvilinear coordinate\n/ \\param insertExtremes if True keeps the extremes\n/ \\return random curvilinear coordinates in the interval [0.0, 1.0], size 1 x numCoordinates\n/ \note if size < 2 then size will be considered as 2")
            .def("polar_angle",
                &Gedim::GeometryUtilities::PolarAngle,
                py::arg("v_prev"), py::arg("v"), py::arg("v_next"), py::arg("norm_v_prev_v"), py::arg("norm_v_next_v"),
                "/ \\param v_prev the previous point\n/ \\param v the middle point\n/ \\param v_next the next point\n/ \\return the polar angle between the three points, computed as the cross product (v_next-v) x (v_prev-v)\n/ \note positive is convex (counter-clockwise), negative is concave (clockwise), zero is collinear")
            .def("point_distance",
                &Gedim::GeometryUtilities::PointDistance,
                py::arg("first_point"), py::arg("second_point"),
                "/ \\brief compute the Point distance\n/ \\param firstPoint the first point\n/ \\param secondPoint the second point\n/ \\return the distance")
            .def("point_distances",
                &Gedim::GeometryUtilities::PointDistances,
                py::arg("points"), py::arg("point"),
                "/ \\brief compute the distance between a point and a list of points\n/ \\param points the point collection, size 3 x numPoints\n/ \\param point the point\n/ \\return the collection of distances, size 1 x numPoints")
            .def("points_distance",
                &Gedim::GeometryUtilities::PointsDistance,
                py::arg("points"),
                "/ \\param points the point collection, size 3 x numPoints\n/ \\return the distances between the points collected in matrix, size numPoints x numPoints.")
            .def("points_bounding_box",
                &Gedim::GeometryUtilities::PointsBoundingBox,
                py::arg("points"),
                "/ \\param points the point collection, size 3 x numPoints\n/ \\return the extreme bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints")
            .def("is_point_in_bounding_box",
                &Gedim::GeometryUtilities::IsPointInBoundingBox,
                py::arg("point"), py::arg("bouding_box"),
                "/ \\param point the point\n/ \\param boudingBox the bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints\n/ \\return False if the point is outside the bounding box, True otherwise (border or inside)")
            .def("bounding_boxes_intersects",
                &Gedim::GeometryUtilities::BoundingBoxesIntersects, py::arg("bouding_box_1"), py::arg("bouding_box_2"))
            .def("points_max_distance",
                &Gedim::GeometryUtilities::PointsMaxDistance,
                py::arg("points"),
                "/ \\param points the point collection, size 3 x numPoints\n/ \\return the maximum distance between the points.")
            .def("is_point_zero",
                &Gedim::GeometryUtilities::IsPointZero, py::arg("point"))
            .def("points_are_coincident",
                &Gedim::GeometryUtilities::PointsAreCoincident,
                py::arg("first_point"), py::arg("second_point"),
                "/ \\param firstPoint the first point\n/ \\param secondPoint the second point\n/ \\return True if the points are coincident")
            .def("find_point_in_points",
                &Gedim::GeometryUtilities::FindPointInPoints,
                py::arg("points"), py::arg("point"),
                "/ \\brief Find a point in point list\n/ \\param points the point list, size 3 x numPoints\n/ \\param point the point to find\n/ \\return the collection of point found")
            .def("point_line_distance",
                &Gedim::GeometryUtilities::PointLineDistance,
                py::arg("point"), py::arg("line_origin"), py::arg("normal_to_line"),
                "/ \\brief Compute the distance between a point and a line\n/ \\param point a point P\n/ \\param lineOrigin the line origin O\n/ \\param normalToLine a normal vector n to the line, in the same plane of P and the line\n/ \\return the distance d\n/ \note The distance is computed as d = n^T * (P - O) / ||n||")
            .def("point_is2_d",
                &Gedim::GeometryUtilities::PointIs2D,
                py::arg("point"),
                "/ \\param point the point\n/ \\return True if the point is 2D (z == 0)")
            .def("points_are2_d",
                &Gedim::GeometryUtilities::PointsAre2D,
                py::arg("points"),
                "/ \\param points the points to test, size 3 x numPoints\n/ \\return True if the points are 2D (z == 0)")
            .def("point_curvilinear_coordinate",
                &Gedim::GeometryUtilities::PointCurvilinearCoordinate,
                py::arg("point"), py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief compute the Point Curvilinear Coordinate of segment\n/ \\param point the point\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the curvilinear coordinate computed")
            .def("point_line_curvilinear_coordinate",
                &Gedim::GeometryUtilities::PointLineCurvilinearCoordinate,
                py::arg("point"), py::arg("line_origin"), py::arg("line_tangent"), py::arg("line_tangent_squared_length"),
                "/ \\brief compute the Point Curvilinear Coordinate of line\n/ \\param point the point\n/ \\param lineOrigin the line origin\n/ \\param lineTangent the line tangent\n/ \\param lineTangentSquaredLength the line tangent length squared\n/ \\return the curvilinear coordinate computed")
            .def("is_point_on_line",
                &Gedim::GeometryUtilities::IsPointOnLine,
                py::arg("point"), py::arg("line_origin"), py::arg("line_tangent"), py::arg("line_tangent_squared_length"),
                "/ \\param point the point\n/ \\param lineOrigin the line origin\n/ \\param lineTangent the line tangent\n/ \\param lineTangentSquaredLength the line tangent length squared\n/ \\return True if the point belongs on line")
            .def("point_segment_position",
                py::overload_cast<const Eigen::Vector3d &, const Eigen::Vector3d &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::PointSegmentPosition, py::const_),
                py::arg("point"), py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Compute point position respect to a segment\n/ \\param point the point\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return result the point position\n/ \\warning left and right point positions work only in xy plane")
            .def("point_segment_position",
                py::overload_cast<const double &>(&Gedim::GeometryUtilities::PointSegmentPosition, py::const_),
                py::arg("curvilinear_coordinate"),
                "/ \\brief Compute point position on a segment line given the curvilinear Coordinate\n/ \\param curvilinearCoordinate the curvilinear coordinate, segment is between 0.0 and 1.0\n/ \\param result the point position on the line")
            .def("point_segment_projection",
                &Gedim::GeometryUtilities::PointSegmentProjection,
                py::arg("point"), py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Project point on a segment line\n/ \\param point the point\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the projected point curvilinear coordinate")
            .def("point_plane_distance",
                py::overload_cast<const Eigen::Vector3d &, const std::array<Eigen::Vector3d, 3> &>(&Gedim::GeometryUtilities::PointPlaneDistance, py::const_),
                py::arg("point"), py::arg("plane_points"),
                "/ \\brief Compute point position respect to a plane formed by 3 points\n/ \\param planePoints the 3 plane points\n/ \\param point the point\n/ \\return the signed point distance, 0.0 on plane, positive above, negative bottom")
            .def("point_plane_distance",
                py::overload_cast<const Eigen::Vector3d &, const Eigen::Vector3d &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::PointPlaneDistance, py::const_),
                py::arg("point"), py::arg("plane_normal"), py::arg("plane_origin"),
                "/ \\brief Compute point position respect to a plane normal\n/ \\param planeNormal the plane normal\n/ \\param planeOrigin the plane origin\n/ \\param point the point\n/ \\return the signed point distance, 0.0 on plane, positive above, negative bottom")
            .def("point_plane_position",
                &Gedim::GeometryUtilities::PointPlanePosition,
                py::arg("point_plane_distance"),
                "/ \\brief Compute point position respect to a plane\n/ \\param pointPlaneDistance the point plane distance\n/ \\return result the point position")
            .def("is_point_on_plane",
                py::overload_cast<const double &>(&Gedim::GeometryUtilities::IsPointOnPlane, py::const_),
                py::arg("point_plane_distance"),
                "/ \\param pointPlaneDistance the point plane distance\n/ \\return True if point is on the plane")
            .def("is_point_on_plane",
                py::overload_cast<const Eigen::Vector3d &, const Eigen::Vector3d &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::IsPointOnPlane, py::const_),
                py::arg("point"), py::arg("plane_normal"), py::arg("plane_origin"),
                "/ \\param point the point\n/ \\param planeNormal the plane normal\n/ \\param planeOrigin the plane origin\n/ \\return True if point is on the plane")
            .def("segment_length",
                &Gedim::GeometryUtilities::SegmentLength,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment length")
            .def("segment_tangent",
                &Gedim::GeometryUtilities::SegmentTangent,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment tangent")
            .def("segment_normal",
                &Gedim::GeometryUtilities::SegmentNormal,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment normal normalized, rotation of the normalized tangent (x,y,0) with 90 clockwise (y, -x,0)\n/ \note the segment shall be 2D")
            .def("segment_slope",
                &Gedim::GeometryUtilities::SegmentSlope,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Compute the segment slope m of line y = m * x + q\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment slope\n/ \note the segment shall be 2D")
            .def("segment_intercept",
                &Gedim::GeometryUtilities::SegmentIntercept,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Compute the segment intercept q of line y = m * x + q\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment intercept\n/ \note the segment shall be 2D")
            .def("make_concatenation",
                &Gedim::GeometryUtilities::MakeConcatenation, py::arg("segments"), py::arg("starting_vertex"))
            .def("check_no_spheres_intersection",
                &Gedim::GeometryUtilities::CheckNoSpheresIntersection,
                py::arg("first_sphere_center"), py::arg("second_sphere_center"), py::arg("first_sphere_diameter"), py::arg("second_sphere_diameter"),
                "/ \\brief Check if two spheres do not intersect\n/ \\param firstSphereCenter the first sphere center\n/ \\param secondSphereCenter the second sphere center\n/ \\param firstSphereDiameter the first sphere diameter\n/ \\param secondSphereDiameter the second sphere diameter\n/ \\return True if the two segments do not intersect\n/ \note if the function returns True it does not mean that the two segments intersects")
            .def("check_triangles_intersection",
                &Gedim::GeometryUtilities::CheckTrianglesIntersection,
                py::arg("triangle_one"), py::arg("triangle_two"), py::arg("admit_boundary") = true,
                "/ \note works only for 2D triangles\n/ \\see https://rosettacode.org/wiki/Determine_if_two_triangles_overlap#C++")
            .def("are_line_coplanar",
                &Gedim::GeometryUtilities::AreLineCoplanar,
                py::arg("first_line_origin"), py::arg("first_line_tangent"), py::arg("second_line_origin"), py::arg("second_line_tangent"),
                "/ \\param firstLineOrigin first line origin\n/ \\param firstLineTangent first line tangent\n/ \\param secondLineOrigin second line origin\n/ \\param secondLineTangent second line tangent\n/ \\return line coplanarity")
            .def("is_polygon_coplanar",
                &Gedim::GeometryUtilities::IsPolygonCoplanar,
                py::arg("plane_normal"), py::arg("plane_origin"), py::arg("polygon_vertices"), py::arg("polygon_unaligned_vertices"),
                "/ \\brief verify if the polygon is in the coplana to a plane")
            .def("intersection_segment_segment",
                &Gedim::GeometryUtilities::IntersectionSegmentSegment,
                py::arg("first_segment_origin"), py::arg("first_segment_end"), py::arg("second_segment_origin"), py::arg("second_segment_end"),
                "/ \\brief Compute the intersection between the two segments\n/ \\param firstSegmentOrigin first segment origin\n/ \\param firstSegmentEnd first segment end\n/ \\param secondSegmentOrigin second segment origin\n/ \\param secondSegmentEnd second segment end\n/ \\return the resulting intersection\n/ \note no check is performed")
            .def("intersections_between_segments",
                &Gedim::GeometryUtilities::IntersectionsBetweenSegments,
                py::arg("segments_vertices"), py::arg("segments_tangent"), py::arg("segments_barycenter"), py::arg("segments_length"),
                "/ \\brief Compute the intersection between a collection of segments\n/ \\param segmentsVertices the segments vertices\n/ \\param segmentsTangent the segments tangent\n/ \\param segmentsBarycenter the segments barycenter\n/ \\param segmentsLength the segments length\n/ \\return for each segment the list of intersections curvilinear coordinate")
            .def("intersection_segment_circle",
                &Gedim::GeometryUtilities::IntersectionSegmentCircle,
                py::arg("segment_origin"), py::arg("segment_end"), py::arg("circle_center"), py::arg("circle_radius"),
                "/ \\brief Compute the intersection between the a segment and a circle\n/ \\param segmentOrigin first segment origin\n/ \\param segmentEnd first segment end\n/ \\param circleCenter circle center\n/ \\param circleRadius circle radius\n/ \\return the resulting intersection\n/ \note tested only in 2D")
            .def("intersection_segment_plane",
                &Gedim::GeometryUtilities::IntersectionSegmentPlane,
                py::arg("segment_origin"), py::arg("segment_end"), py::arg("plane_normal"), py::arg("plane_origin"),
                "/ \\brief Intersection between a Segment, represented by origin and end and a plane\n/ represented by the normal and a point\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segement end\n/ \\param planeNormal the plane normal normalized\n/ \\param planeOrigin a plane point\n/ \\return the resulting intersection")
            .def("intersection_polyhedron_plane",
                &Gedim::GeometryUtilities::IntersectionPolyhedronPlane,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("plane_normal"), py::arg("plane_origin"), py::arg("plane_rotation_matrix"), py::arg("plane_translation"),
                "/ \\brief Intersection between a Polyhedron and a Plane\n/ \\param polyhedronVertices the polyhedron vertices, size 3 x numVertices\n/ \\param polyhedronEdges the polyhedron edges, size 2 x numEdges\n/ \\param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices\n/ \\param planeNormal the plane normal normalized\n/ \\param planeOrigin the plane origin\n/ \\param planeRotationMatrix the plane rotation from 3D to 2D\n/ \\param planeTranslation the plane translation vector\n/ \\return the intersection result\n/ \note works only with convex polyhedra")
            .def("split_polyhedron_with_plane",
                &Gedim::GeometryUtilities::SplitPolyhedronWithPlane, py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_edge_tangents"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"), py::arg("plane_normal"), py::arg("plane_origin"), py::arg("plane_rotation_matrix"), py::arg("plane_translation"))
            .def("split_polyhedron_with_plane_result_to_polyhedra",
                &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResultToPolyhedra, py::arg("result"))
            .def("intersection_polyhedron_line",
                &Gedim::GeometryUtilities::IntersectionPolyhedronLine,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("line_tangent"), py::arg("line_origin"),
                "/ \\brief Intersection between a Polyhedron and a line\n/ \\param polyhedronVertices the polyhedron vertices, size 3 x numVertices\n/ \\param polyhedronEdges the polyhedron edges, size 2 x numEdges\n/ \\param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices\n/ \\param lineTangent the line tangent\n/ \\param lineOrigin the line origin\n/ \\return the intersection result\n/ \\warning NOT TESTED PROPERLY")
            .def("intersection_polyhedron_segment",
                &Gedim::GeometryUtilities::IntersectionPolyhedronSegment,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("segment_origin"), py::arg("segment_end"), py::arg("segment_tangent"), py::arg("polyhedron_line_intersections"),
                "/ \\brief Intersection between a Polyhedron and a segment\n/ \\param polyhedronVertices the polyhedron vertices, size 3 x numVertices\n/ \\param polyhedronEdges the polyhedron edges, size 2 x numEdges\n/ \\param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\param segmentTangent the segment tangent\n/ \\param polyhedronLineIntersections the intersection between the polyhedron and the line of the segment\n/ \\return the intersection result\n/ /// \\warning NOT TESTED PROPERLY")
            .def("intersection_polyhedrons_segment",
                &Gedim::GeometryUtilities::IntersectionPolyhedronsSegment,
                py::arg("polyhedrons"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("segment_origin"), py::arg("segment_end"), py::arg("segment_tangent"),
                "/ \\brief Intersection between a collectio of Polyhedrons and a segment\n/ \\param polyhedrons the polyhedron collection\n/ \\param polyhedronFaceNormals polyhedron face normals\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\param segmentTangent the segment tangent\n/ \\return the intersection result\n/ \\warning NOT TESTED PROPERLY")
            .def("point_polygon_position",
                &Gedim::GeometryUtilities::PointPolygonPosition,
                py::arg("point"), py::arg("polygon_vertices"),
                "/ \\brief Check if point is inside a polygon\n/ \\param point the point\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting position\n/ \\warning works only in 2D with convex polygons")
            .def("point_polygon_position_ray_casting",
                &Gedim::GeometryUtilities::PointPolygonPosition_RayCasting, py::arg("point"), py::arg("polygon_vertices"))
            .def("is_point_inside_polygon",
                &Gedim::GeometryUtilities::IsPointInsidePolygon,
                py::arg("point"), py::arg("polygon_vertices"),
                "/ \\param point the point\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return False if it is outside, True the other cases\n/ \\warning works only in 2D with convex polygons")
            .def("is_point_inside_polygon_ray_casting",
                &Gedim::GeometryUtilities::IsPointInsidePolygon_RayCasting,
                py::arg("point"), py::arg("polygon_vertices"),
                "/ \\brief IsPointInsidePolygon using RayCasting algorithm\n/ (see https://en.wikipedia.org/wiki/Point_in_polygon)\n/ \\param point the point\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return False if it is outside, True the other cases")
            .def("line_polygon_position",
                &Gedim::GeometryUtilities::LinePolygonPosition, py::arg("line_tangent"), py::arg("line_origin"), py::arg("polygon_vertices"))
            .def("point_polyhedron_position",
                py::overload_cast<const Eigen::Vector3d &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<bool> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &>(&Gedim::GeometryUtilities::PointPolyhedronPosition, py::const_),
                py::arg("point"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_rotated_vertices"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"),
                "/ \\brief Check if point is inside a polyhedron\n/ \\param point the point\n/ \\param polyhedronFaces the polyhedron faces, size numPolyhedronFaces\n/ \\param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces\n/ \\param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces\n/ \\param polyhedronFaceNormals the polyhedron face normals\n/ \\param polyhedronFaceNormalDirections the polyhedron face normal directions\n/ \\param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D\n/ \\param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D\n/ \\return the point position respect the polyhedron\n/ \note works only for convex polyhedrons")
            .def("point_polyhedron_position",
                py::overload_cast<const Eigen::Vector3d &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<bool> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &, const std::vector<Eigen::MatrixXd> &>(&Gedim::GeometryUtilities::PointPolyhedronPosition, py::const_),
                py::arg("point"), py::arg("polyhedron_faces"), py::arg("polyhedron_faces_3_d_vertices"), py::arg("polyhedron_faces_2_d_vertices"), py::arg("polyhedron_faces_normals"), py::arg("polyhedron_faces_normal_direction"), py::arg("polyhedron_faces_translation"), py::arg("polyhedron_faces_rotation_matrix"), py::arg("polyhedron_tetrahedrons"),
                "/ \\brief Check if point is inside a polyhedron\n/ \\param point the point\n/ \\param polyhedronFaces the polyhedron faces, size numPolyhedronFaces\n/ \\param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces\n/ \\param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces\n/ \\param polyhedronFaceNormals the polyhedron face normals\n/ \\param polyhedronFaceNormalDirections the polyhedron face normal directions\n/ \\param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D\n/ \\param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D\n/ \\return the point position respect the polyhedron\n/ \note works for concave and convex polyhedrons")
            .def("is_point_inside_tetrahedron",
                &Gedim::GeometryUtilities::IsPointInsideTetrahedron, py::arg("tetrahedron"), py::arg("point"))
            .def("point_circle_position",
                &Gedim::GeometryUtilities::PointCirclePosition,
                py::arg("point"), py::arg("circle_center"), py::arg("circle_radius"),
                "/ \\brief Check if point is inside a circle\n/ \\param point the point\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\param result the resulting position\n/ \note tested only in 2D")
            .def("point_circle_positions",
                &Gedim::GeometryUtilities::PointCirclePositions,
                py::arg("points"), py::arg("circle_center"), py::arg("circle_radius"),
                "/ \\brief Check if points are inside a circle\n/ \\param points the matrix of points (size 3 x numVertices)\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\param result the resulting positions\n/ \note tested only in 2D")
            .def("polygon_circle_position",
                &Gedim::GeometryUtilities::PolygonCirclePosition,
                py::arg("polygon_vertices"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("vertex_positions"), py::arg("polygon_circle_intersections"),
                "/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\param vertexPositions the polygon vertices positions respect the circle\n/ \\param polygonCircleIntersections the polygon center intersections\n/ \\return the Polygon Circle reciprocal position\n/ \note tested only in 2D")
            .def("intersection_polygon_circle",
                &Gedim::GeometryUtilities::IntersectionPolygonCircle,
                py::arg("polygon_vertices"), py::arg("circle_center"), py::arg("circle_radius"),
                "/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\return the Polygon Circle reciprocal intersections\n/ \note tested only in 2D")
            .def("polygon_triangulation_by_first_vertex",
                &Gedim::GeometryUtilities::PolygonTriangulationByFirstVertex,
                py::arg("polygon_vertices"),
                "/ \\brief Convex Polygon simple Triangulation from the first vertex\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\return the sub-division triangulation, size 1 x 3 * numTriangles\n/ \note works only for convex polygon")
            .def("polygon_triangulation_by_ear_clipping",
                &Gedim::GeometryUtilities::PolygonTriangulationByEarClipping,
                py::arg("polygon_vertices"),
                "/ \\brief Concave Polygon Triangulation with ear clipping algorithm\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\return the sub-division triangulation, size 1 x 3 * numTriangles")
            .def("polygon_triangulation_by_internal_point",
                &Gedim::GeometryUtilities::PolygonTriangulationByInternalPoint,
                py::arg("polygon_vertices"), py::arg("internal_point"),
                "/ \\brief Convex Polygon simple Triangulation from an internal point\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param point internal polygon point\n/ \\return the sub-division triangulation, size 1 x 3 * numPolygonVertices,\n/ \note the internal point index is numPolygonVertices")
            .def("polygon_outside_circle_division_by_angle_quadrant",
                &Gedim::GeometryUtilities::PolygonOutsideCircleDivisionByAngleQuadrant,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("curved_edge_index"),
                "/ \\brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param circleCenter the circle center from which the curved edge derives\n/ \\param circleRadius the radius of the circle from which the curved edge derives\n/ \\param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices\n/ \\return the sub-division polygons result")
            .def("polygon_inside_circle_division_by_angle_quadrant",
                &Gedim::GeometryUtilities::PolygonInsideCircleDivisionByAngleQuadrant,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("curved_edge_index"),
                "/ \\brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param circleCenter the circle center from which the curved edge derives\n/ \\param circleRadius the radius of the circle from which the curved edge derives\n/ \\param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices\n/ \\return the sub-division polygons result")
            .def("polygon_division_by_circle",
                &Gedim::GeometryUtilities::PolygonDivisionByCircle,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("curved_edge_index"),
                "/ \\brief Convex Polygon sub division from a circle which intersects a polygon in a curved edge\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param circleCenter the circle center from which the curved edge derives\n/ \\param circleRadius the radius of the circle from which the curved edge derives\n/ \\param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices\n/ \\return the sub-division polygons result\n/ \note the polygon should be inside the angle quadrant formed by the curved edge\n/ \note otherwise use PolygonDivisionByAngleQuadrant function to split the polygon")
            .def("circle_division_by_polygon",
                &Gedim::GeometryUtilities::CircleDivisionByPolygon,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("curved_edge_index"),
                "/ \\brief Circle division from Convex Polygon sub division which intersects a polygon in a curved edge\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param circleCenter the circle center from which the curved edge derives\n/ \\param circleRadius the radius of the circle from which the curved edge derives\n/ \\param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices\n/ \\return the sub-division circle result\n/ \note the polygon should be inside the angle quadrant formed by the curved edge")
            .def("polygon_area",
                &Gedim::GeometryUtilities::PolygonArea,
                py::arg("polygon_vertices"),
                "/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\return the polygon area\n/ \note the polygon shall be 2D")
            .def("polygon_area3_d",
                &Gedim::GeometryUtilities::PolygonArea3D,
                py::arg("polygon_vertices"),
                "/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\return the polygon area")
            .def("polygon_mass",
                &Gedim::GeometryUtilities::PolygonMass,
                py::arg("polygon_centroid"), py::arg("polygon_triangulation_points"),
                "/ \\param polygonCentroid the centroid\n/ \\param polygonTriangulationPoints the internal polygon sub-triangulation\n/ \\return the polygon mass matrix")
            .def("polygon_inertia",
                &Gedim::GeometryUtilities::PolygonInertia,
                py::arg("polygon_centroid"), py::arg("polygon_triangulation_points"),
                "/ \\param polygonCentroid the centroid\n/ \\param polygonTriangulationPoints the internal polygon sub-triangulation\n/ \\return the polygon intertia tensor")
            .def("split_polygon_with_segment",
                &Gedim::GeometryUtilities::SplitPolygonWithSegment,
                py::arg("input"),
                "/ \\brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a segment contained inside\n/ \\param input the input data\n/ \\param result the resulting split\n/ \note only indices are threated in this function, no space points")
            .def("split_polygon_with_circle",
                &Gedim::GeometryUtilities::SplitPolygonWithCircle,
                py::arg("polygon_vertices"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("vertex_positions"), py::arg("polygon_circle_intersections"), py::arg("polygon_circle_position"),
                "/ \\brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a cirle\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\param vertexPositions the polygon vertices positions respect the circle\n/ \\param polygonCircleIntersections the polygon center intersections\n/ \\param polygonCirclePosition the polygon position respect the circle\n/ \note tested only in 2D\n/ \\return the split result\n/ \note only indices are threated in this function, no space points")
            .def("split_polygon_with_circle_build_sub_polygon",
                &Gedim::GeometryUtilities::SplitPolygonWithCircleBuildSubPolygon,
                py::arg("split_result"), py::arg("sub_polygon_index"), py::arg("polygon_vertices"), py::arg("polygon_circle_intersections"),
                "/ \\brief Build the subpolygon coordinates from split result\n/ \\param splitResult the split result\n/ \\param subPolygonIndex the subpolygon index, from 0 to SplitPolygonWithCircleResult::NewPolygons.size()\n/ \\param polygonVertices the original polygon vertices\n/ \\param polygonCircleIntersections the polygon circle intersection\n/ \\return the resulting subpolygon coordinates")
            .def("split_polygon_with_plane",
                &Gedim::GeometryUtilities::SplitPolygonWithPlane,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("plane_normal"), py::arg("plane_origin"), py::arg("polygon_translation"), py::arg("polygon_rotation_matrix"),
                "/ \\brief Split 3 Polygon With Plane\n/ \\param polygonVertices the 3D polygon vertices\n/ \\param polygonEdgeTangents the 3D polygon edge tangents\n/ \\param planeNormal the plane normal\n/ \\param planeOrigin the plane origin\n/ \\param polygonTranslation the polygon translation vector for rotation\n/ \\param polygonRotationMatrix the polygon rotation matrix from 2D to 3D\n/ \\return the splitted polygons")
            .def("polygon_normal",
                &Gedim::GeometryUtilities::PolygonNormal,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon tridimensional normalized Normal\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting normalized normal")
            .def("polygon_tangents",
                &Gedim::GeometryUtilities::PolygonTangents, py::arg("polygon_vertices"), py::arg("polygon_normal"))
            .def("polygon_edges_centroid",
                &Gedim::GeometryUtilities::PolygonEdgesCentroid,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon edges centroid\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting edges centroid, size 3 x numVertices")
            .def("polygon_edge_lengths",
                &Gedim::GeometryUtilities::PolygonEdgeLengths,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon edge lengths\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting edge lengths, size 1 x numVertices")
            .def("polygon_edge_tangents",
                &Gedim::GeometryUtilities::PolygonEdgeTangents,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon edge tangents\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting edge tangents, size 3 x numVertices")
            .def("polygon_edge_normals",
                &Gedim::GeometryUtilities::PolygonEdgeNormals,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon edge normals outgoing the polygon\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting edge normals outgoing the polygon, size 3 x numVertices")
            .def("simplex_barycenter",
                &Gedim::GeometryUtilities::SimplexBarycenter,
                py::arg("vertices"),
                "/ \\brief Compute the simplex barycenter as a mean of all vertices\n/ \\param vertices the matrix of vertices of the simplex (size 3 x numVertices)")
            .def("simplex_measure",
                &Gedim::GeometryUtilities::SimplexMeasure, py::arg("vertices"))
            .def("segment_barycenter",
                &Gedim::GeometryUtilities::SegmentBarycenter,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Compute the segment barycenter as a mean of all vertices\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end")
            .def("polygon_barycenter",
                &Gedim::GeometryUtilities::PolygonBarycenter,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon barycenter as a mean of all vertices\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)")
            .def("polyhedron_barycenter",
                &Gedim::GeometryUtilities::PolyhedronBarycenter,
                py::arg("polyhedron_vertices"),
                "/ \\brief Compute the polyhedron barycenter as a mean of all vertices\n/ \\param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)")
            .def("polygon_centroid",
                py::overload_cast<const Eigen::MatrixXd &, const double &>(&Gedim::GeometryUtilities::PolygonCentroid, py::const_),
                py::arg("polygon_vertices"), py::arg("polygon_area"),
                "/ \\brief Compute the Polygon centroid as described in https://en.wikipedia.org/wiki/Centroid\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\param polygonArea the area of the polygon\n/ \note the polygon shall be 2D")
            .def("polygon_centroid",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::VectorXd &, const double &>(&Gedim::GeometryUtilities::PolygonCentroid, py::const_),
                py::arg("sub_polygon_centroids"), py::arg("sub_polygon_areas"), py::arg("polygon_area"),
                "/ \\brief Compute the Polygon centroid using polygon sub-division\n/ \\param subPolygonCentroids the centroid of each subPolygon (size 3 x numSubPolygons)\n/ \\param subPolygonAreas the areas of each subPolygon, size 1 x numSubPolygons\n/ \\param polygonArea the total area of the polygon")
            .def("polygon_area_by_boundary_integral",
                &Gedim::GeometryUtilities::PolygonAreaByBoundaryIntegral,
                py::arg("polygon_vertices"), py::arg("edge_lengths"), py::arg("edge_tangents"), py::arg("edge_normals"), py::arg("reference_quadrature_points") = (Eigen::MatrixXd(3, 1) << 0.5, 0.0, 0.0).finished(), py::arg("reference_quadrature_weights") = Eigen::VectorXd::Ones(1),
                "/ \\brief Polygon Area By Integral on edges\n/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param edgeLengths the edge lengths, size numEdges\n/ \\param edgeTangents the edge tangents, size 3 x numEdges\n/ \\param edgeNormals the edge outgoint normals, size 3 x numEdges\n/ \\param referenceQuadraturePoints quadrature points on reference segment [0,1]\n/ \\param referenceQuadratureWeights quadrature weights on reference segment [0,1]\n/ \\return the polygon area\n/ \note the area is computed as integral_edges x dot n_x with gauss formula on edges of order 1")
            .def("polygon_area_by_internal_integral",
                &Gedim::GeometryUtilities::PolygonAreaByInternalIntegral,
                py::arg("polygon_triangulation_points"), py::arg("reference_quadrature_weights") = Eigen::VectorXd::Constant(1, 0.5),
                "/ \\brief Polygon Area By Internal Integral\n/ \\param polygonTriangulationPoints the internal polygon sub-triangulation\n/ \\param referenceQuadratureWeights the reference triangle quadrature weights [0,1]x[0,1]\n/ \\return the area computed as integral on sub-triangles")
            .def("polygon_centroid_by_integral",
                &Gedim::GeometryUtilities::PolygonCentroidByIntegral,
                py::arg("polygon_vertices"), py::arg("edge_lengths"), py::arg("edge_tangents"), py::arg("edge_normals"), py::arg("polygon_area"),
                "/ \\brief Polygon Area By Integral on edges\n/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param edgeLengths the edge lengths, size numEdges\n/ \\param edgeTangents the edge tangents, size 3 x numEdges\n/ \\param edgeNormals the edge outgoint normals, size 3 x numEdges\n/ \\param polygonArea the polygon area\n/ \\return the polygon centroid\n/ \note the area is computed as integral_edges (x^2, y^2) dot n with gauss formula on edges of order 2")
            .def("polygon_centroid_edges_distance",
                &Gedim::GeometryUtilities::PolygonCentroidEdgesDistance,
                py::arg("polygon_vertices"), py::arg("polygon_centroid"), py::arg("polygon_edge_normals"),
                "/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param polygonCentroid the polygon centroid\n/ \\param polygonEdgeNormals the polygon edge normals outgoing the polygon, size 3 x numEdges\n/ \\return the distance between the centroid and all the polygon edges, size 1 x numEdges")
            .def("polygon_centroid_vertices_distance",
                &Gedim::GeometryUtilities::PolygonCentroidVerticesDistance,
                py::arg("polygon_vertices"), py::arg("polygon_centroid"),
                "/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param polygonCentroid the polygon centroid\n/ \\return the distance between the centroid and all the polygon vertices, size 1 x numEdges")
            .def("polygon_in_radius",
                &Gedim::GeometryUtilities::PolygonInRadius,
                py::arg("polygon_centroid_edges_distance"),
                "/ \\param polygonCentroidEdgesDistance the polygon centroid edges distance, size 1 x numEdges\n/ \\return the polygon in radius, as the minimum distance between the polygon centroid and the edges")
            .def("polygon_aspect_ratio",
                &Gedim::GeometryUtilities::PolygonAspectRatio,
                py::arg("polygon_diameter"), py::arg("polygon_in_radius"),
                "/ \\param polygonDiameter the polygon diameter\n/ \\param polygonInRadius the polygon in radius\n/ \\return the polygon aspect ratio, defined as the ratio bewteen the in and out diameter")
            .def("polygon_diameter",
                &Gedim::GeometryUtilities::PolygonDiameter,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon diameter defined as the maximum distance between the vertices\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)")
            .def("polygon_translation",
                &Gedim::GeometryUtilities::PolygonTranslation,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the translation vector of a tridimensional Polygon\n/ \\param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)\n/ \\return the resulting translation vector t which corresponds to the first vertex of the polygon\n/ \note to rotate some point P from 2D to 3D use Q * P + t\n/ \note to rotate some point P from 3D to 2D use Q^T * (P - t)")
            .def("polygon_rotation_matrix",
                &Gedim::GeometryUtilities::PolygonRotationMatrix,
                py::arg("polygon_vertices"), py::arg("polygon_normal"), py::arg("polygon_translation"),
                "/ \\brief Compute the rotation matrix and translation vector of a tridimensional Polygon\n/ \\param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)\n/ \\param polygonNormal the normalized normal of the plane which contains the polygon\n/ \\param polygonTranslation the translation vector t\n/ \\return the resulting rotation matrix Q which rotates 2D points to 3D points\n/ \note to rotate some point P from 2D to 3D use Q * P + t\n/ \note to rotate some point P from 3D to 2D use Q^T * (P - t)")
            .def("polygon_is_convex",
                &Gedim::GeometryUtilities::PolygonIsConvex,
                py::arg("polygon_vertices"), py::arg("convex_hull"),
                "/ \\brief Check if Polygon is Convex\n/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param convexHull the convex hull vertices counterclockwise\n/ \\return True if polygon is convex, False otherwise\n/ \note works only in 2D-plane")
            .def("polygon_type",
                &Gedim::GeometryUtilities::PolygonType,
                py::arg("num_polygon_vertices"), py::arg("is_polygon_convex"),
                "/ \\param numPolygonVertices the number of polygon vertices\n/ \\param isPolygonConvex True if the polygon is convex\n/ \\return the polygon type")
            .def("polygon_orientation",
                &Gedim::GeometryUtilities::PolygonOrientation,
                py::arg("convex_hull"),
                "/ \\param convexHull the polygon convex hull vertices indices counterclockwise\n/ \\return the polygon 2D orientation\n/ \note works only in 2D-plane")
            .def("change_polygon_orientation",
                &Gedim::GeometryUtilities::ChangePolygonOrientation,
                py::arg("num_polygon_vertices"),
                "/ \\param numPolygonVertices the number of polygon vertices\n/ \\return the new polygon vertices indices oriented in the opposite direction")
            .def("plane_rotation_matrix",
                &Gedim::GeometryUtilities::PlaneRotationMatrix,
                py::arg("plane_normal"),
                "/ \\brief Compute the rotation matrix of a plane from 2D to 3D\n/ \\param planeNormal the normalized normal of the plane\n/ \\return the resulting rotation matrix Q which rotates 2D points to 3D points\n/ \note to rotate some point P from 2D to 3D use Q * P + t\n/ \note to rotate some point P from 3D to 2D use Q^T * (P - t)")
            .def("plane_translation",
                &Gedim::GeometryUtilities::PlaneTranslation,
                py::arg("plane_origin"),
                "/ \\brief Compute the translation vector of a plane from 2D to 3D\n/ \\param planeNormal the normalized normal of the plane\n/ \\param planeOrigin the 3D plane origin\n/ \\return the resulting translation vector t which translates 2D points to 3D points\n/ \note to rotate some point P from 2D to 3D use Q * P + t\n/ \note to rotate some point P from 3D to 2D use Q^T * (P - t)")
            .def("plane_reflection_matrix",
                &Gedim::GeometryUtilities::PlaneReflectionMatrix, py::arg("plane_normal"))
            .def("plane_reflection_translation",
                &Gedim::GeometryUtilities::PlaneReflectionTranslation, py::arg("plane_normal"), py::arg("plane_origin"))
            .def("rotate_points",
                &Gedim::GeometryUtilities::RotatePoints,
                py::arg("points"), py::arg("rotation_matrix"), py::arg("translation") = Eigen::Vector3d::Zero(),
                "/ \\brief Rotate Points P using rotation matrix Q and translation t: Q * P + t\n/ \\param points the points (size 3 x numPoints)\n/ \\param rotationMatrix the rotation matrix, size 3x3\n/ \\param translation the translation vector, size 1x3\n/ \\param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t")
            .def("rotate_points_from2_d_to3_d",
                &Gedim::GeometryUtilities::RotatePointsFrom2DTo3D,
                py::arg("points"), py::arg("rotation_matrix"), py::arg("translation") = Eigen::Vector3d::Zero(),
                "/ \\brief Rotate Points P From 2D To 3D using rotation matrix Q and translation t: Q * P + t\n/ \\param points the points (size 3 x numPoints)\n/ \\param rotationMatrix the rotation matrix from 2D to 3D\n/ \\param translation the translation vector\n/ \\param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t")
            .def("rotate_points_from3_d_to2_d",
                &Gedim::GeometryUtilities::RotatePointsFrom3DTo2D,
                py::arg("points"), py::arg("rotation_matrix"), py::arg("translation") = Eigen::Vector3d::Zero(),
                "/ \\brief Rotate Points P From 3D To 2D using rotation matrix Q and translation t: Q * (P - t)\n/ \\param points the points (size 3 x numPoints)\n/ \\param rotationMatrix the rotation matrix from 3D to 2D\n/ \\param translation the translation vector\n/ \\param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * (P - t)")
            .def("convex_hull",
                &Gedim::GeometryUtilities::ConvexHull,
                py::arg("points"), py::arg("include_collinear") = true,
                "/ \\brief Compute the Convex Hull of 2D points\n/ \\param points the points, size 3 x numPoints\n/ \\param includeCollinear include the collinear points, default True\n/ \\return the convex hull indices counterclockwise, size numConvexHullPoints, numConvexHullPoints <= numPoints\n/ \note works in 2D, use the Graham_scan algorithm https://en.wikipedia.org/wiki/Graham_scan")
            .def("points_are_aligned",
                &Gedim::GeometryUtilities::PointsAreAligned,
                py::arg("segment_origin"), py::arg("segment_end"), py::arg("points"),
                "/ \\brief Check if a set of points are aligned to a line identified by a segment\n/ \\param segmentOrigin segment origin of the line\n/ \\param segmentEnd segment end of the line\n/ \\param points the points, size 3 x numPoints\n/ \\return True if the i-th point is aligned, size 1 x numPoints")
            .def("points_are_on_line",
                &Gedim::GeometryUtilities::PointsAreOnLine,
                py::arg("points"), py::arg("line_origin"), py::arg("line_tangent"),
                "/ \\brief Check if a set of points are on a line\n/ \\param points the points, size 3 x numPoints\n/ \\param lineTangent the line tangent\n/ \\param lineOrigin the line origin\n/ \\return True if the i-th point is aligned, size 1 x numPoints")
            .def("point_is_aligned",
                &Gedim::GeometryUtilities::PointIsAligned,
                py::arg("segment_origin"), py::arg("segment_end"), py::arg("point"),
                "/ \\brief Check if a point is aligned to a line identified by a segment\n/ \\param segmentOrigin segment origin of the line\n/ \\param segmentEnd segment end of the line\n/ \\param point the point\n/ \\return True if the point is aligned")
            .def("point_is_on_line",
                &Gedim::GeometryUtilities::PointIsOnLine,
                py::arg("point"), py::arg("line_origin"), py::arg("line_tangent"),
                "/ \\brief Check if a point is on a line\n/ \\param point the point\n/ \\param lineTangent the line tangent\n/ \\param lineOrigin the line origin\n/ \\return True if the point is aligned")
            .def("unaligned_points",
                &Gedim::GeometryUtilities::UnalignedPoints,
                py::arg("points"), py::arg("num_desired_unaligned_points") = 0,
                "/ \\brief Extract the circumscribed unaligned points (minimum 2) in a set of points\n/ \\param points the points, size 3 x numPoints\n/ \\param numDesiredUnalignedPoints the number of desired unaligned points, if 0 all the points are computed\n/ \\return the unaligned points indices counterclockwise, size numUnalignedPoints, 2 <= numUnalignedPoints <=\n/ numPoints")
            .def("unaligned_polyhedron_points",
                &Gedim::GeometryUtilities::UnalignedPolyhedronPoints,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"), py::arg("polyhedron_faces_translation"), py::arg("polyhedron_faces_rotation_matrix"), py::arg("polyhedron_unaliged_faces"), py::arg("polyhedron_faces_unaligned_vertices"),
                "/ \\brief Extract the circumscribed unaligned points (minimum 4) in a polyhedron\n/ \\return the unaligned points, size numUnalignedPoints, 4 <= numUnalignedPoints <= numPoints\n/ \\warning works only for convex polyhedron")
            .def("aligned_polyhedron_edges",
                &Gedim::GeometryUtilities::AlignedPolyhedronEdges, py::arg("polyhedron_vertices"), py::arg("vertices_adjacency"), py::arg("edges_adjacency"), py::arg("adjacency_vertices_map"), py::arg("polyhedron_edge_tangents"), py::arg("polyhedron_edge_squared_lenghts"))
            .def("extract_points",
                &Gedim::GeometryUtilities::ExtractPoints,
                py::arg("points"), py::arg("filter"),
                "/ \\param points the points, size 3 x numPoints\n/ \\param filter indices counterclockwise, size numFilterPoints, numFilterPoints <= numPoints\n/ \\return the points coordinates filtered, size 3 x numFilterPoints")
            .def("extract_triangulation_points",
                &Gedim::GeometryUtilities::ExtractTriangulationPoints,
                py::arg("points"), py::arg("points_triangulation"),
                "/ \\param points the points, size 3 x numPoints\n/ \\param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles\n/ \\return the triangles coordinates, size 1 x numTriangles")
            .def("extract_triangulation_points_by_internal_point",
                &Gedim::GeometryUtilities::ExtractTriangulationPointsByInternalPoint,
                py::arg("points"), py::arg("internal_point"), py::arg("points_triangulation"),
                "/ \\param points the points, size 3 x numPoints\n/ \\param externalPoint the external point coordinates\n/ \\param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles\n/ \\return the triangles coordinates, size 1 x numTriangles")
            .def("create_ellipse",
                &Gedim::GeometryUtilities::CreateEllipse,
                py::arg("axis_major_length"), py::arg("axis_minor_length"), py::arg("resolution"),
                "/ \\brief Create 2D Ellipse approximation with 2D polygon\n/ \\param axisMajorLength the ellipse axis major length\n/ \\param axisMinorLength the ellipse axis minor length\n/ \\param resolution the number of points on each ellipse quadrant\n/ \\return the polygon which approximate the ellipse\n/ \note the ellipse is centered in the origin and parallel to xy-axis")
            .def("create_triangle",
                &Gedim::GeometryUtilities::CreateTriangle,
                py::arg("p1"), py::arg("p2"), py::arg("p3"),
                "/ \\brief Create a triangle with points")
            .def("create_parallelogram",
                &Gedim::GeometryUtilities::CreateParallelogram,
                py::arg("origin"), py::arg("length_vector"), py::arg("width_vector"),
                "/ \\brief Create a parallelogram with origin and dimension\n/ \\param origin the origin\n/ \\param lengthVector the length vector\n/ \\param widthVector the width vector")
            .def("create_rectangle",
                &Gedim::GeometryUtilities::CreateRectangle,
                py::arg("origin"), py::arg("base"), py::arg("height"),
                "/ \\brief Create a rectangle with origin and dimensions parallel to axis\n/ \\param origin the origin\n/ \\param base the base length\n/ \\param height the height length")
            .def("create_square",
                &Gedim::GeometryUtilities::CreateSquare,
                py::arg("origin"), py::arg("edge_length"),
                "/ \\brief Create a square with origin and dimensions parallel to axis\n/ \\param origin the origin\n/ \\param edgeLength the edge length")
            .def("create_tetrahedron_with_origin",
                &Gedim::GeometryUtilities::CreateTetrahedronWithOrigin,
                py::arg("origin"), py::arg("length_vector"), py::arg("height_vector"), py::arg("width_vector"),
                "/ \\brief Create a Tetrahedron with origin and dimension\n/ \\param origin the origin\n/ \\param lengthVector the length vector\n/ \\param heightVector the heigth vector\n/ \\param widthVector the width vector\n/ \\return the tetrahedron created")
            .def("create_tetrahedron_with_vertices",
                &Gedim::GeometryUtilities::CreateTetrahedronWithVertices,
                py::arg("v1"), py::arg("v2"), py::arg("v3"), py::arg("v4"),
                "/ \\brief Create a Tetrahedron with the four vertices\n/ \\param v1 the first vertex\n/ \\param v2 the second vertex\n/ \\param v3 the third vertex\n/ \\param v4 the fourth vertex\n/ \\return the tetrahedron created")
            .def("create_parallelepiped_with_origin",
                &Gedim::GeometryUtilities::CreateParallelepipedWithOrigin,
                py::arg("origin"), py::arg("length_vector"), py::arg("height_vector"), py::arg("width_vector"),
                "/ \\brief Create a Parallelepiped with origin and dimension\n/ \\param origin the origin\n/ \\param lengthVector the length vector\n/ \\param heightVector the heigth vector\n/ \\param widthVector the width vector\n/ \\return the parallelepiped created")
            .def("create_polyhedron_with_extrusion",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::CreatePolyhedronWithExtrusion, py::const_),
                py::arg("polygon_vertices"), py::arg("height_vector"),
                "/ \\brief Create Polyhedron With Extrusion\n/ \\param polygon the 2D polygon vertices\n/ \\param heightVector  the height vector\n/ \\return the polyhedron created")
            .def("create_polyhedron_with_extrusion",
                py::overload_cast<const Eigen::MatrixXd &, const std::vector<Eigen::Vector3d> &>(&Gedim::GeometryUtilities::CreatePolyhedronWithExtrusion, py::const_),
                py::arg("polygon_vertices"), py::arg("height_vectors"),
                "/ \\brief Create Polyhedron With Extrusion\n/ \\param polygon the 2D polygon vertices, size 3 x numPolygonVertices\n/ \\param heightVectors the height vector to be used for each polygon vertex, size numPolygonVertices\n/ \\return the polyhedron created")
            .def("create_cube_with_origin",
                &Gedim::GeometryUtilities::CreateCubeWithOrigin,
                py::arg("origin"), py::arg("edge_length"),
                "/ \\brief Create a Cube with origin aligned to axis\n/ \\param origin the origin\n/ \\param edgeLength the edge length\n/ \\return the cube created")
            .def("polyhedron_volume_by_boundary_integral",
                &Gedim::GeometryUtilities::PolyhedronVolumeByBoundaryIntegral,
                py::arg("polyhedron_face_rotated_triangulation_points"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"), py::arg("reference_quadrature_points") = (Eigen::MatrixXd(3, 1) << 1.0 / 3.0, 1.0 / 3.0, 0.0).finished(), py::arg("reference_quadrature_weights") = Eigen::VectorXd::Constant(1, 0.5),
                "/ \\brief Compute the Polyhedron Volume\n/ \\param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces\n/ x numTrianglesPerFace \\param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \\param\n/ polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \\param\n/ polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \\param\n/ polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \\param referenceQuadraturePoints\n/ the reference tetrahedron quadrature points [0,1]x[0,1]x[0,1] \\param referenceQuadratureWeights the reference\n/ tetrahedron quadrature weights [0,1]x[0,1]x[0,1] \\return the polyhedron volume \note use the divergence theorem,\n/ with F = 1/3 (x, y, z), see https://en.wikipedia.org/wiki/Divergence_theorem")
            .def("polyhedron_volume_by_internal_integral",
                &Gedim::GeometryUtilities::PolyhedronVolumeByInternalIntegral,
                py::arg("polyhedron_tetrahedron_vertices"), py::arg("reference_quadrature_weights") = Eigen::VectorXd::Constant(1, 1.0 / 6.0),
                "/ \\brief Polyhedron Volume By Internal Integral\n/ \\param polyhedronTetrahedronVertices the internal polyhedron sub-tetrahedra\n/ \\param referenceQuadratureWeights the reference tetrahedron quadrature weights [0,1]x[0,1]x[0,1]\n/ \\return the area computed as integral on sub-tetrahedra")
            .def("polyhedron_centroid",
                &Gedim::GeometryUtilities::PolyhedronCentroid,
                py::arg("polyhedron_face_rotated_triangulation_points"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"), py::arg("polyhedron_volume"),
                "/ \\brief Compute the Polyhedron centroid\n/ \\param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces\n/ x numTrianglesPerFace \\param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \\param\n/ polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \\param\n/ polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \\param\n/ polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \\param polyhedronVolume the\n/ polyhedron volume \\return the polyhedron centroid \note use the divergence theorem, with F_x = 1/2 (x^2, 0, 0),\n/ F_y = 1/2 (0, y^2, 0), F_z = 1/2 (0, 0, z^2), see https://en.wikipedia.org/wiki/Divergence_theorem")
            .def("polyhedron_diameter",
                &Gedim::GeometryUtilities::PolyhedronDiameter,
                py::arg("polyhedron_vertices"),
                "/ \\brief Compute the Polyhedron diameter defined as the maximum distance between the vertices\n/ \\param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)")
            .def("polyhedron_edges_centroid",
                &Gedim::GeometryUtilities::PolyhedronEdgesCentroid,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"),
                "/ \\brief Compute Polyhedron Edges Centroid\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\return for each edge the centroid, size 3xnumEdges")
            .def("polyhedron_edges_length",
                &Gedim::GeometryUtilities::PolyhedronEdgesLength,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"),
                "/ \\brief Compute Polyhedron Edges Lenght\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\return for each edge the length, size 1xnumEdges")
            .def("polyhedron_edge_tangents",
                &Gedim::GeometryUtilities::PolyhedronEdgeTangents,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"),
                "/ \\brief Compute Polyhedron Edges Tangent\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\return for each edge the tangent, size 3xnumEdges")
            .def("polyhedron_face_vertices",
                &Gedim::GeometryUtilities::PolyhedronFaceVertices,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"),
                "/ \\brief Compute Polyhedron Faces Vertices\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\return for each face the vertices, size 1xnumFaces")
            .def("polyhedron_face_edge_directions",
                &Gedim::GeometryUtilities::PolyhedronFaceEdgeDirections,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"),
                "/ \\brief Compute Polyhedron Faces Edge Direction\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\return for each face the edge direction compare to polyhedron edge directions, size 1xnumFaces")
            .def("polyhedron_face_edge_tangents",
                &Gedim::GeometryUtilities::PolyhedronFaceEdgeTangents,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_edge_directions"), py::arg("polyhedron_edge_tangents"),
                "/ \\brief Compute Polyhedron Faces Edge Tangents\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param polyhedronEdgeTangents for each polyhedron edge the tangent, size 3xnumEdges\n/ \\return for each face the edge tangents, size 1xnumFaces")
            .def("polyhedron_face_rotation_matrices",
                &Gedim::GeometryUtilities::PolyhedronFaceRotationMatrices,
                py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_translations"),
                "/ \\brief Compute Polyhedron Faces Rotation matrix\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each polyhedron face the rotation matrix from 2D to 3D")
            .def("polyhedron_face_translations",
                &Gedim::GeometryUtilities::PolyhedronFaceTranslations,
                py::arg("polyhedron_face_vertices"),
                "/ \\brief Compute Polyhedron Faces translation vectors\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each polyhedron face the translation vector")
            .def("polyhedron_face_rotated_vertices",
                &Gedim::GeometryUtilities::PolyhedronFaceRotatedVertices,
                py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"),
                "/ \\brief Compute Polyhedron Faces Rotated Vertices 2D\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronFaceTranslations the polyhedron face translations from 2D to 3D\n/ \\param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D\n/ \\return for each face the 2D vertices, size 1xnumFaces")
            .def("polyhedron_faces_unaligned_vertices",
                &Gedim::GeometryUtilities::PolyhedronFacesUnalignedVertices,
                py::arg("polyhedron_faces_rotated_vertices"),
                "/ \\brief Compute Polyhedron Faces Unaligned Vertices Indices\n/ \\param polyhedronFacesRotatedVertices the polyhedron faces 2D vertices\n/ \\return for each face the unaligned vertices indices, size 1 x numFaces")
            .def("polyhedron_face_normals",
                &Gedim::GeometryUtilities::PolyhedronFaceNormals,
                py::arg("polyhedron_face_vertices"),
                "/ \\brief Compute Polyhedron Faces Normals\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each polyhedron face the normal")
            .def("polyhedron_face_tangents",
                &Gedim::GeometryUtilities::PolyhedronFaceTangents, py::arg("polyhedron_faces_vertices"), py::arg("polyhedron_faces_normal"), py::arg("polyhedron_faces_normal_direction"))
            .def("polyhedron_face_barycenter",
                &Gedim::GeometryUtilities::PolyhedronFaceBarycenter,
                py::arg("polyhedron_face_vertices"),
                "/ \\brief Compute Polyhedron Faces barycenters\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each polyhedron face the barycenter")
            .def("polyhedron_mass",
                &Gedim::GeometryUtilities::PolyhedronMass, py::arg("polyhedron_centroid"), py::arg("polyhedron_tetrahedron_points"))
            .def("polyhedron_inertia",
                &Gedim::GeometryUtilities::PolyhedronInertia, py::arg("polyhedron_centroid"), py::arg("polyhedron_tetrahedra_points"))
            .def("polyhedron_centroid_faces_distance",
                &Gedim::GeometryUtilities::PolyhedronCentroidFacesDistance, py::arg("polyhedron_centroid"), py::arg("polyhedron_faces_normal"), py::arg("polyhedron_face_vertices"))
            .def("polyhedron_in_radius",
                &Gedim::GeometryUtilities::PolyhedronInRadius, py::arg("polyhedron_centroid_faces_distance"))
            .def("polyhedron_is_convex",
                &Gedim::GeometryUtilities::PolyhedronIsConvex,
                py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_rotated_vertices"), py::arg("polyhedron_face_internal_points"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("polyhedron_internal_point"),
                "/ \\brief Check if Polyhedron is Convex\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\param polyhedronFaceInternalPoints the polyhedron face internal points\n/ \\param polyhedronFaceNormals the normal of each face\n/ \\param polyhedronFaceNormalDirections the normal outgoing direction\n/ \\param pointInsidePolyhedron a point inside polyhedron\n/ \\return True if polyhedron is convex, False otherwise\n/ \\warning still not working")
            .def("polyhedron_face_normal_directions",
                py::overload_cast<const std::vector<Eigen::MatrixXd> &, const Eigen::Vector3d &, const std::vector<Eigen::Vector3d> &>(&Gedim::GeometryUtilities::PolyhedronFaceNormalDirections, py::const_),
                py::arg("polyhedron_face_vertices"), py::arg("point_inside_polyhedron"), py::arg("polyhedron_face_normals"),
                "/ \\brief Compute Polyhedron Face Normal Directions\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\param pointInsidePolyhedron a point inside polyhedron\n/ \\param polyhedronFaceNormals the normal of each face\n/ \\return True if the face has normal outgoing\n/ \\warning works only for convex polyhedrons")
            .def("polyhedron_face_normal_directions",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::MatrixXi &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &>(&Gedim::GeometryUtilities::PolyhedronFaceNormalDirections, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_internal_points"), py::arg("polyhedron_face_rotated_vertices"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"),
                "/ \\brief Compute Polyhedron Face Normal Directions for generic polyhedron (slower)\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\param pointInsidePolyhedron a point inside polyhedron\n/ \\param polyhedronFaceNormals the normal of each face\n/ \\return True if the face has normal outgoing\n/ \\warning NOT WORKING in all cases")
            .def("polyhedron_face_triangulations",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulations,
                py::arg("polyhedron_faces"), py::arg("local_face_triangulations"),
                "/ \\brief Polyhedron Face Triangulations of each face\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param localFaceTriangulations the local faces triangulations indices, size 1xnumFaces x (3xnumTriangles)\n/ \\return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)")
            .def("polyhedron_face_triangulations_by_first_vertex",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulationsByFirstVertex,
                py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"),
                "/ \\brief Polyhedron Face Triangulations by first vertex of each face\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)")
            .def("polyhedron_face_triangulations_by_ear_clipping",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulationsByEarClipping,
                py::arg("num_polyhedron_faces"), py::arg("polyhedron_faces2_d_vertices"),
                "/ \\brief Polyhedron Face Triangulations by ear clipping of each face\n/ \\param numPolyhedronFaces the number of polyhedron faces\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)")
            .def("polyhedron_face_extract_triangulation_points",
                &Gedim::GeometryUtilities::PolyhedronFaceExtractTriangulationPoints, py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_triangulations"))
            .def("polyhedron_face_triangulation_points_by_internal_point",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulationPointsByInternalPoint, py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_internal_points"), py::arg("polyhedron_face_triangulations"))
            .def("polyhedron_face_triangulations_by_internal_point",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulationsByInternalPoint,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_internal_points"),
                "/ \\brief Polyhedron Face Triangulations by internal point of each face\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\param polyhedronFaceInternalPoints the polyhedron face internal points\n/ \\return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)\n/ \note the internal point index is polyhedronVertices.size()")
            .def("polyhedron_tetrahedrons_by_face_triangulations",
                py::overload_cast<const Eigen::MatrixXd &, const std::vector<Eigen::MatrixXi> &, const std::vector<std::vector<unsigned int>> &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::PolyhedronTetrahedronsByFaceTriangulations, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_triangulations"), py::arg("polyhedron_internal_point"),
                "/ \\brief Polyhedron Tetrahedrons By Face Triangulations\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param faceTriangulations the triangulation on face vertices\n/ \\param polyhedronInternalPoint a polyhedron internal point\n/ \\return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)\n/ \note the polyhedron internal point index is polyhedronVertices.size() + f")
            .def("polyhedron_tetrahedrons_by_face_triangulations",
                py::overload_cast<const Eigen::MatrixXd &, const std::vector<Eigen::MatrixXi> &, const std::vector<std::vector<unsigned int>> &, const std::vector<Eigen::Vector3d> &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::PolyhedronTetrahedronsByFaceTriangulations, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_triangulations"), py::arg("polyhedron_face_internal_points"), py::arg("polyhedron_internal_point"),
                "/ \\brief Polyhedron Tetrahedrons By Face Triangulations with face internal points\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param faceTriangulations the triangulation on face vertices by internal points\n/ \\param polyhedronFaceInternalPoints the polyhedron face internal points\n/ \\param polyhedronInternalPoint a polyhedron internal point\n/ \\return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)\n/ \note the polyhedron face internal points are polyhedronVertices.size() + f\n/ \note the polyhedron internal point index is polyhedronVertices.size() + polyhedronFaceInternalPoints.size()")
            .def("extract_tetrahedron_points",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::Vector3d &, const std::vector<unsigned int> &>(&Gedim::GeometryUtilities::ExtractTetrahedronPoints, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_internal_point"), py::arg("point_tetrahedrons"),
                "/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronInternalPoint a polyhedron internal point\n/ \\param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra\n/ \\return the tetrahedrons coordinates, size 1 x numTetra")
            .def("extract_tetrahedron_points",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::Vector3d &, const std::vector<Eigen::Vector3d> &, const std::vector<unsigned int> &>(&Gedim::GeometryUtilities::ExtractTetrahedronPoints, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_internal_point"), py::arg("polyhedron_face_internal_points"), py::arg("point_tetrahedrons"),
                "/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronInternalPoint a polyhedron internal point\n/ \\param polyhedronFaceInternalPoints the polyhedron face internal points\n/ \\param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra\n/ \\return the tetrahedrons coordinates, size 1 x numTetra")
            .def("polyhedron_coordinate_system",
                &Gedim::GeometryUtilities::PolyhedronCoordinateSystem,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"),
                "/ \\brief Get Polyhedron Coordinate System\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\return the four vertices indices forming a coordinate system for the polyhedron, size 1x4")
            .def("export_polyhedron_to_vtu",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::MatrixXi &, const std::vector<Eigen::MatrixXi> &, const std::string &>(&Gedim::GeometryUtilities::ExportPolyhedronToVTU, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("export_folder"),
                "/ \\brief Export Polyhedron To VTU\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param exportFolder the folder in which to export")
            .def("export_polyhedron_to_vtu",
                py::overload_cast<const Gedim::GeometryUtilities::Polyhedron &, const std::string &>(&Gedim::GeometryUtilities::ExportPolyhedronToVTU, py::const_), py::arg("polyhedron"), py::arg("export_folder"))
            .def("export_polyhedron_to_vtu",
                py::overload_cast<const unsigned int &, const Eigen::MatrixXd &, const Eigen::MatrixXi &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::MatrixXd> &, const double &, const Eigen::Vector3d &, const std::vector<Eigen::MatrixXd> &, const std::vector<double> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &, const std::vector<std::vector<Eigen::Matrix3d>> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<bool> &, const std::string &>(&Gedim::GeometryUtilities::ExportPolyhedronToVTU, py::const_),
                py::arg("index"), py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_tetra"), py::arg("polyhedron_volume"), py::arg("polyhedron_centroid"), py::arg("polyhedron_faces3_d_vertices"), py::arg("polyhedron_faces_area"), py::arg("polyhedron_faces2_d_centroid"), py::arg("polyhedron_faces_translation"), py::arg("polyhedron_faces_rotation_matrix"), py::arg("polyhedron_faces3_d_triangles"), py::arg("polyhedron_faces3_d_internal_point"), py::arg("polyhedron_faces3_d_normal"), py::arg("polyhedron_faces3_d_normal_direction"), py::arg("export_folder"),
                "/ \\brief Export Polyhedron To VTU\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param exportFolder the folder in which to export")
            .def("export_polygon_to_vtu",
                &Gedim::GeometryUtilities::ExportPolygonToVTU, py::arg("index"), py::arg("polygon"), py::arg("polygon_triangles"), py::arg("polygon_volume"), py::arg("polygon_centroid"), py::arg("polygon_edges_centroid"), py::arg("polygon_edges_normal"), py::arg("polygon_edges_normal_direction"), py::arg("export_folder"))
            .def("merge_polyhedron_by_face",
                &Gedim::GeometryUtilities::MergePolyhedronByFace, py::arg("polyhedrons"), py::arg("polyhedrons_common_face_index"), py::arg("remove_common_face"))
            .def("merge_polyhedrons",
                &Gedim::GeometryUtilities::MergePolyhedrons, py::arg("polyhedrons"), py::arg("merge_information") = Gedim::GeometryUtilities::MergePolyhedronsInput{})
            .def("facets_to_polyhedron",
                &Gedim::GeometryUtilities::FacetsToPolyhedron, py::arg("points"), py::arg("facets"))
            .def("polyhedron_to_facets",
                &Gedim::GeometryUtilities::PolyhedronToFacets, py::arg("polyhedron"))
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:GeometryUtilities.hpp>    ////////////////////


    ////////////////////    <generated_from:MapParallelepiped.hpp>    ////////////////////
    // #ifndef __MapParallelepiped_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMapParallelepiped =
            py::class_<Gedim::MapParallelepiped>
                (pyNsGedim, "MapParallelepiped", "");

        { // inner classes & enums of MapParallelepiped
            auto pyNsGedim_ClassMapParallelepiped_ClassMapParallelepipedData =
                py::class_<Gedim::MapParallelepiped::MapParallelepipedData>
                    (pyNsGedim_ClassMapParallelepiped, "MapParallelepipedData", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::Matrix3d Q = Eigen::Matrix3d(), Eigen::Vector3d b = Eigen::Vector3d(), Eigen::Matrix3d QInv = Eigen::Matrix3d(), double DetQ = double(), double DetQInv = double())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MapParallelepiped::MapParallelepipedData>();
                    r_ctor_->Q = Q;
                    r_ctor_->b = b;
                    r_ctor_->QInv = QInv;
                    r_ctor_->DetQ = DetQ;
                    r_ctor_->DetQInv = DetQInv;
                    return r_ctor_;
                })
                , py::arg("q") = Eigen::Matrix3d(), py::arg("b") = Eigen::Vector3d(), py::arg("q_inv") = Eigen::Matrix3d(), py::arg("det_q") = double(), py::arg("det_q_inv") = double()
                )
                .def_readwrite("q", &Gedim::MapParallelepiped::MapParallelepipedData::Q, "")
                .def_readwrite("b", &Gedim::MapParallelepiped::MapParallelepipedData::b, "")
                .def_readwrite("q_inv", &Gedim::MapParallelepiped::MapParallelepipedData::QInv, "")
                .def_readwrite("det_q", &Gedim::MapParallelepiped::MapParallelepipedData::DetQ, "")
                .def_readwrite("det_q_inv", &Gedim::MapParallelepiped::MapParallelepipedData::DetQInv, "")
                ;
        } // end of inner classes & enums of MapParallelepiped

        pyNsGedim_ClassMapParallelepiped
            .def_readwrite("reference_vertices", &Gedim::MapParallelepiped::ReferenceVertices, "")
            .def(py::init<const Gedim::GeometryUtilities &>(),
                py::arg("geometry_utilities"))
            .def_static("q",
                &Gedim::MapParallelepiped::Q,
                py::arg("first_vertex"), py::arg("second_vertex"), py::arg("third_vertex"), py::arg("fourth_vertex"),
                "/ Matrix Q for linear map x = Q * x_r + b from reference Hexahedron [0,1]x[0,1]x[0,1] to Hexahedron with x points\n/ vertices the Hexahedron to map vertices, size 3 x 4\n/ return the resulting value, size 3 x 3")
            .def_static("b",
                &Gedim::MapParallelepiped::b,
                py::arg("first_vertex"),
                "/ Matrix Q for linear map x = Q * x_r + b from reference Hexahedron [0,1]x[0,1]x[0,1] to Hexahedron with x points\n/ vertices the Hexahedron to map vertices, size 3 x 4\n/ return the resulting value, size 3 x 3")
            .def("compute",
                &Gedim::MapParallelepiped::Compute,
                py::arg("vertices"), py::arg("coordinate_system"),
                "/ Map from the hexahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b\n/ \\param vertices the hexahedron to map vertices, size 3 x 4\n/ \\param edges the hexahedron edges\n/ \\return the map data")
            .def_static("f",
                &Gedim::MapParallelepiped::F,
                py::arg("map_data"), py::arg("x"),
                "/ Map from the Hexahedron reference element [0,1]x[0,1]x[0,1] to the polygon x = F(x_r) = Q * x_r + b\n/ \\param mapData the map data computed\n/ \\param x points in reference Hexahedron, size 3 x numPoints\n/ \\return the mapped points, size 3 x numPoints")
            .def_static("f_inv",
                &Gedim::MapParallelepiped::FInv, py::arg("map_data"), py::arg("x"))
            .def_static("j",
                &Gedim::MapParallelepiped::J,
                py::arg("map_data"), py::arg("x"),
                "/ Compute the jacobian matrix of the transformation F\n/ \\param mapData the map data computed\n/ \\param x points in reference Hexahedron, size 3 x numPoints\n/ \\return the Q matrix for each points, size 2 x (2 * numPoints)")
            .def_static("det_j",
                &Gedim::MapParallelepiped::DetJ,
                py::arg("map_data"), py::arg("x"),
                "/ Compute the determinant of the jacobian matrix of the trasformation\n/ \\param mapData the map data computed\n/ \\param x points in reference Hexahedron, size 3 x numPoints\n/ \\return the determinant of Jacobian matrix for each points, size 1 x numPoints")
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MapParallelepiped.hpp>    ////////////////////


    ////////////////////    <generated_from:MapHexahedron.hpp>    ////////////////////
    // #ifndef __MapHexahedron_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMapHexahedron =
            py::class_<Gedim::MapHexahedron>
                (pyNsGedim, "MapHexahedron", "");

        { // inner classes & enums of MapHexahedron
            auto pyNsGedim_ClassMapHexahedron_ClassMapHexahedronData =
                py::class_<Gedim::MapHexahedron::MapHexahedronData>
                    (pyNsGedim_ClassMapHexahedron, "MapHexahedronData", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd ReferenceVertices = Eigen::MatrixXd(), Eigen::MatrixXd A = Eigen::MatrixXd(), Eigen::MatrixXd Coefficients = Eigen::MatrixXd(), Eigen::MatrixXd Vertices = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MapHexahedron::MapHexahedronData>();
                    r_ctor_->ReferenceVertices = ReferenceVertices;
                    r_ctor_->A = A;
                    r_ctor_->Coefficients = Coefficients;
                    r_ctor_->Vertices = Vertices;
                    return r_ctor_;
                })
                , py::arg("reference_vertices") = Eigen::MatrixXd(), py::arg("a") = Eigen::MatrixXd(), py::arg("coefficients") = Eigen::MatrixXd(), py::arg("vertices") = Eigen::MatrixXd()
                )
                .def_readwrite("reference_vertices", &Gedim::MapHexahedron::MapHexahedronData::ReferenceVertices, "")
                .def_readwrite("a", &Gedim::MapHexahedron::MapHexahedronData::A, "")
                .def_readwrite("coefficients", &Gedim::MapHexahedron::MapHexahedronData::Coefficients, "")
                .def_readwrite("vertices", &Gedim::MapHexahedron::MapHexahedronData::Vertices, "")
                .def_readwrite("vertex_order", &Gedim::MapHexahedron::MapHexahedronData::VertexOrder, "")
                ;
        } // end of inner classes & enums of MapHexahedron

        pyNsGedim_ClassMapHexahedron
            .def(py::init<>())
            .def_static("compute",
                &Gedim::MapHexahedron::Compute, py::arg("vertices"), py::arg("faces"))
            .def_static("f",
                &Gedim::MapHexahedron::F, py::arg("map_data"), py::arg("reference_points"))
            .def_static("f_inv",
                &Gedim::MapHexahedron::FInv, py::arg("map_data"), py::arg("points"))
            .def_static("j",
                &Gedim::MapHexahedron::J, py::arg("map_data"), py::arg("reference_points"))
            .def_static("j_inv",
                &Gedim::MapHexahedron::JInv, py::arg("map_data"), py::arg("reference_points"))
            .def_static("det_j",
                &Gedim::MapHexahedron::DetJ, py::arg("map_data"), py::arg("reference_points"))
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MapHexahedron.hpp>    ////////////////////


    ////////////////////    <generated_from:MapTriangle.hpp>    ////////////////////
    // #ifndef __MapTriangle_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMapTriangle =
            py::class_<Gedim::MapTriangle>
                (pyNsGedim, "MapTriangle", "");

        { // inner classes & enums of MapTriangle
            auto pyNsGedim_ClassMapTriangle_ClassMapTriangleData =
                py::class_<Gedim::MapTriangle::MapTriangleData>
                    (pyNsGedim_ClassMapTriangle, "MapTriangleData", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::Matrix3d B = Eigen::Matrix3d(), Eigen::Matrix3d BInv = Eigen::Matrix3d(), Eigen::Vector3d b = Eigen::Vector3d(), double DetB = double(), double DetBInv = double())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MapTriangle::MapTriangleData>();
                    r_ctor_->B = B;
                    r_ctor_->BInv = BInv;
                    r_ctor_->b = b;
                    r_ctor_->DetB = DetB;
                    r_ctor_->DetBInv = DetBInv;
                    return r_ctor_;
                })
                , py::arg("b") = Eigen::Matrix3d(), py::arg("b_inv") = Eigen::Matrix3d(), py::arg("b") = Eigen::Vector3d(), py::arg("det_b") = double(), py::arg("det_b_inv") = double()
                )
                .def_readwrite("b", &Gedim::MapTriangle::MapTriangleData::B, "")
                .def_readwrite("b_inv", &Gedim::MapTriangle::MapTriangleData::BInv, "")
                .def_readwrite("b", &Gedim::MapTriangle::MapTriangleData::b, "")
                .def_readwrite("det_b", &Gedim::MapTriangle::MapTriangleData::DetB, "")
                .def_readwrite("det_b_inv", &Gedim::MapTriangle::MapTriangleData::DetBInv, "")
                ;
        } // end of inner classes & enums of MapTriangle

        pyNsGedim_ClassMapTriangle
            .def(py::init<>())
            .def("compute",
                &Gedim::MapTriangle::Compute,
                py::arg("vertices"),
                "/ Map from the triangle reference element [0,1]x[0,1]/2 to the polygon x = F(x_r) = B * x_r + b\n/ \\param vertices the triangle 2D to map vertices, size 3 x 3\n/ \\return the map data")
            .def_static("f",
                &Gedim::MapTriangle::F,
                py::arg("map_data"), py::arg("x"),
                "/ Map from the triangle reference element [0,1]x[0,1] to the polygon x = F(x_r) = B * x_r + b\n/ \\param mapData the map data\n/ \\param x points in reference triangle, size 3 x numPoints\n/ \\return the mapped polygon points, size 3 x numPoints")
            .def_static("f_inv",
                &Gedim::MapTriangle::FInv,
                py::arg("map_data"), py::arg("x"),
                "/ Map from the polygon x to the triangle reference element [0,1]x[0,1] x_r = F^-1(x_r) = B^-1 * (x - b)\n/ \\param mapData the map data\n/ \\param x points in polygon, size 3 x numPoints\n/ \\return the mapped reference points, size 3 x numPoints")
            .def_static("j",
                &Gedim::MapTriangle::J,
                py::arg("map_data"), py::arg("x"),
                "/ Compute the jacobian matrix of the transformation F\n/ \\param mapData the map data\n/ \\param x points in reference triangle, size 3 x numPoints\n/ \\return the B matrix for each points, size 3 x (3 * numPoints)")
            .def_static("det_j",
                py::overload_cast<const Gedim::MapTriangle::MapTriangleData &, const Eigen::MatrixXd &>(&Gedim::MapTriangle::DetJ),
                py::arg("map_data"), py::arg("x"),
                "/ Compute the determinant of the jacobian matrix of the trasformation\n/ \\param mapData the map data\n/ \\param x points in reference triangle, size 3 x numPoints\n/ \\return the determinant of Jacobian matrix for each points, size 1 x numPoints")
            .def_static("det_j",
                py::overload_cast<const Gedim::MapTriangle::MapTriangleData &>(&Gedim::MapTriangle::DetJ),
                py::arg("map_data"),
                "/ Compute the determinant of the jacobian matrix of the trasformation\n/ \\param mapData the map data\n/ \\param x points in reference triangle, size 3 x numPoints\n/ \\return the determinant of Jacobian matrix")
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MapTriangle.hpp>    ////////////////////


    ////////////////////    <generated_from:MapParallelogram.hpp>    ////////////////////
    // #ifndef __MapParallelogram_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMapParallelogram =
            py::class_<Gedim::MapParallelogram>
                (pyNsGedim, "MapParallelogram", "");

        { // inner classes & enums of MapParallelogram
            auto pyNsGedim_ClassMapParallelogram_ClassMapParallelogramData =
                py::class_<Gedim::MapParallelogram::MapParallelogramData>
                    (pyNsGedim_ClassMapParallelogram, "MapParallelogramData", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::Matrix3d B = Eigen::Matrix3d(), Eigen::Matrix3d BInv = Eigen::Matrix3d(), Eigen::Vector3d b = Eigen::Vector3d(), double DetB = double(), double DetBInv = double())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MapParallelogram::MapParallelogramData>();
                    r_ctor_->B = B;
                    r_ctor_->BInv = BInv;
                    r_ctor_->b = b;
                    r_ctor_->DetB = DetB;
                    r_ctor_->DetBInv = DetBInv;
                    return r_ctor_;
                })
                , py::arg("b") = Eigen::Matrix3d(), py::arg("b_inv") = Eigen::Matrix3d(), py::arg("b") = Eigen::Vector3d(), py::arg("det_b") = double(), py::arg("det_b_inv") = double()
                )
                .def_readwrite("b", &Gedim::MapParallelogram::MapParallelogramData::B, "")
                .def_readwrite("b_inv", &Gedim::MapParallelogram::MapParallelogramData::BInv, "")
                .def_readwrite("b", &Gedim::MapParallelogram::MapParallelogramData::b, "")
                .def_readwrite("det_b", &Gedim::MapParallelogram::MapParallelogramData::DetB, "")
                .def_readwrite("det_b_inv", &Gedim::MapParallelogram::MapParallelogramData::DetBInv, "")
                ;
        } // end of inner classes & enums of MapParallelogram

        pyNsGedim_ClassMapParallelogram
            .def_readwrite("reference_vertices", &Gedim::MapParallelogram::ReferenceVertices, "")
            .def(py::init<>())
            .def("compute",
                &Gedim::MapParallelogram::Compute, py::arg("vertices"))
            .def_static("f",
                &Gedim::MapParallelogram::F, py::arg("map_data"), py::arg("x"))
            .def_static("f_inv",
                &Gedim::MapParallelogram::FInv, py::arg("map_data"), py::arg("x"))
            .def_static("j",
                &Gedim::MapParallelogram::J,
                py::arg("map_data"), py::arg("x"),
                "/ Compute the jacobian matrix of the transformation F\n/ \\param mapData the map data\n/ \\param x points in reference triangle, size 3 x numPoints\n/ \\return the B matrix for each points, size 3 x (3 * numPoints)")
            .def_static("det_j",
                py::overload_cast<const Gedim::MapParallelogram::MapParallelogramData &, const Eigen::MatrixXd &>(&Gedim::MapParallelogram::DetJ), py::arg("map_data"), py::arg("x"))
            .def_static("det_j",
                py::overload_cast<const Gedim::MapParallelogram::MapParallelogramData &>(&Gedim::MapParallelogram::DetJ), py::arg("map_data"))
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MapParallelogram.hpp>    ////////////////////


    ////////////////////    <generated_from:MapTetrahedron.hpp>    ////////////////////
    // #ifndef __MapTetrahedron_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMapTetrahedron =
            py::class_<Gedim::MapTetrahedron>
                (pyNsGedim, "MapTetrahedron", "");

        { // inner classes & enums of MapTetrahedron
            auto pyNsGedim_ClassMapTetrahedron_ClassMapTetrahedronData =
                py::class_<Gedim::MapTetrahedron::MapTetrahedronData>
                    (pyNsGedim_ClassMapTetrahedron, "MapTetrahedronData", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::Matrix3d Q = Eigen::Matrix3d(), Eigen::Vector3d b = Eigen::Vector3d(), Eigen::Matrix3d QInv = Eigen::Matrix3d(), double DetQ = double(), double DetQInv = double())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MapTetrahedron::MapTetrahedronData>();
                    r_ctor_->Q = Q;
                    r_ctor_->b = b;
                    r_ctor_->QInv = QInv;
                    r_ctor_->DetQ = DetQ;
                    r_ctor_->DetQInv = DetQInv;
                    return r_ctor_;
                })
                , py::arg("q") = Eigen::Matrix3d(), py::arg("b") = Eigen::Vector3d(), py::arg("q_inv") = Eigen::Matrix3d(), py::arg("det_q") = double(), py::arg("det_q_inv") = double()
                )
                .def_readwrite("q", &Gedim::MapTetrahedron::MapTetrahedronData::Q, "")
                .def_readwrite("b", &Gedim::MapTetrahedron::MapTetrahedronData::b, "")
                .def_readwrite("q_inv", &Gedim::MapTetrahedron::MapTetrahedronData::QInv, "")
                .def_readwrite("det_q", &Gedim::MapTetrahedron::MapTetrahedronData::DetQ, "")
                .def_readwrite("det_q_inv", &Gedim::MapTetrahedron::MapTetrahedronData::DetQInv, "")
                ;
        } // end of inner classes & enums of MapTetrahedron

        pyNsGedim_ClassMapTetrahedron
            .def(py::init<const Gedim::GeometryUtilities &>(),
                py::arg("geometry_utilities"))
            .def_static("q",
                &Gedim::MapTetrahedron::Q,
                py::arg("first_vertex"), py::arg("second_vertex"), py::arg("third_vertex"), py::arg("fourth_vertex"),
                "/ Matrix Q for linear map x = Q * x_r + b from reference tetrahedron [0,1]x[0,1]x[0,1]/2 to tetrahedron with x\n/ points vertices the tetrahedron to map vertices, size 3 x 4 return the resulting value, size 3 x 3")
            .def_static("b",
                &Gedim::MapTetrahedron::b,
                py::arg("first_vertex"),
                "/ Matrix Q for linear map x = Q * x_r + b from reference tetrahedron [0,1]x[0,1]x[0,1]/2 to tetrahedron with x\n/ points vertices the tetrahedron to map vertices, size 3 x 4 return the resulting value, size 3 x 3")
            .def("compute",
                &Gedim::MapTetrahedron::Compute,
                py::arg("vertices"),
                "/ Map from the tetrahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b\n/ \\param vertices the tetrahedron to map vertices, size 3 x 4\n/ \\return the map data")
            .def_static("f",
                &Gedim::MapTetrahedron::F,
                py::arg("map_data"), py::arg("x"),
                "/ Map from the tetrahedron reference element [0,1]x[0,1]x[0,1]/2 to the polygon x = F(x_r) = Q * x_r + b\n/ \\param mapData the map data computed\n/ \\param x points in reference tetrahedron, size 3 x numPoints\n/ \\return the mapped points, size 3 x numPoints")
            .def_static("f_inv",
                &Gedim::MapTetrahedron::FInv, py::arg("map_data"), py::arg("x"))
            .def_static("j",
                &Gedim::MapTetrahedron::J,
                py::arg("map_data"), py::arg("x"),
                "/ Compute the jacobian matrix of the transformation F\n/ \\param mapData the map data computed\n/ \\param x points in reference tetrahedron, size 3 x numPoints\n/ \\return the Q matrix for each points, size 2 x (2 * numPoints)")
            .def_static("det_j",
                py::overload_cast<const Gedim::MapTetrahedron::MapTetrahedronData &, const Eigen::MatrixXd &>(&Gedim::MapTetrahedron::DetJ),
                py::arg("map_data"), py::arg("x"),
                "/ Compute the determinant of the jacobian matrix of the trasformation\n/ \\param mapData the map data computed\n/ \\param x points in reference tetrahedron, size 3 x numPoints\n/ \\return the determinant of Jacobian matrix for each points, size 1 x numPoints")
            .def_static("det_j",
                py::overload_cast<const Gedim::MapTetrahedron::MapTetrahedronData &>(&Gedim::MapTetrahedron::DetJ),
                py::arg("map_data"),
                "/ Compute the determinant of the jacobian matrix of the trasformation\n/ \\param mapData the map data computed\n/ \\return the determinant of Jacobian matrix")
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MapTetrahedron.hpp>    ////////////////////


    ////////////////////    <generated_from:MapQuadrilateral.hpp>    ////////////////////
    // #ifndef __MapQuadrilateral_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMapQuadrilateral =
            py::class_<Gedim::MapQuadrilateral>
                (pyNsGedim, "MapQuadrilateral", "")
            .def_readwrite("reference_points", &Gedim::MapQuadrilateral::ReferencePoints, "")
            .def(py::init<>())
            .def("f",
                &Gedim::MapQuadrilateral::F, py::arg("vertices"), py::arg("reference_points"))
            .def("f_inv",
                &Gedim::MapQuadrilateral::FInv, py::arg("vertices"), py::arg("points"))
            .def("j",
                &Gedim::MapQuadrilateral::J, py::arg("vertices"), py::arg("reference_points"))
            .def("j_inv",
                &Gedim::MapQuadrilateral::JInv, py::arg("vertices"), py::arg("reference_points"))
            .def("det_j",
                &Gedim::MapQuadrilateral::DetJ, py::arg("vertices"), py::arg("reference_points"))
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MapQuadrilateral.hpp>    ////////////////////


    ////////////////////    <generated_from:MeshDAOExporterToCsv.hpp>    ////////////////////
    // #ifndef __MeshDAOExporterToCsv_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMeshDAOExporterToCsv =
            py::class_<Gedim::MeshDAOExporterToCsv>
                (pyNsGedim, "MeshDAOExporterToCsv", py::is_final(), "/ \\brief MeshDAOExporterToCsv\n/ \\copyright See top level LICENSE file for details.\n(final class)")
            .def(py::init<const Gedim::MeshFromCsvUtilities &>(),
                py::arg("utilities"))
            .def("export",
                &Gedim::MeshDAOExporterToCsv::Export,
                py::arg("configuration"), py::arg("mesh"),
                "/ \\brief Export the mesh in all parts\n/ \\param configuration the configuration for export\n/ \\param mesh the mesh to be exported")
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MeshDAOExporterToCsv.hpp>    ////////////////////


    ////////////////////    <generated_from:MeshDAOImporterFromCsv.hpp>    ////////////////////
    // #ifndef __MeshDAOImporterFromCsv_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMeshDAOImporterFromCsv =
            py::class_<Gedim::MeshDAOImporterFromCsv>
                (pyNsGedim, "MeshDAOImporterFromCsv", py::is_final(), "/ \\brief MeshDAOImporterFromCsv\n/ \note each file could be EmptyFileReader if not necessary\n/ \\copyright See top level LICENSE file for details\n(final class)")
            .def(py::init<const Gedim::MeshFromCsvUtilities &>(),
                py::arg("utilities"))
            .def("import_",
                &Gedim::MeshDAOImporterFromCsv::Import, py::arg("configuration"), py::arg("mesh"))
            .def("import_mesh2_d",
                &Gedim::MeshDAOImporterFromCsv::ImportMesh2D, py::arg("configuration"), py::arg("mesh"))
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MeshDAOImporterFromCsv.hpp>    ////////////////////


    ////////////////////    <generated_from:MeshFromCsvUtilities.hpp>    ////////////////////
    // #ifndef __MeshImporterFromCsvUtilities_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMeshFromCsvUtilities =
            py::class_<Gedim::MeshFromCsvUtilities>
                (pyNsGedim, "MeshFromCsvUtilities", py::is_final(), "/ \\brief MeshImporterFromCsvUtilities\n/ \note each file could be EmptyFileReader if not necessary\n/ \\copyright See top level LICENSE file for details\n(final class)");

        { // inner classes & enums of MeshFromCsvUtilities
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassConfiguration =
                py::class_<Gedim::MeshFromCsvUtilities::Configuration>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Configuration", "")
                .def(py::init<>([](
                std::string Folder = "./", std::string FileCell0DsName = "Cell0Ds", std::string FileCell1DsName = "Cell1Ds", std::string FileCell2DsName = "Cell2Ds", std::string FileCell3DsName = "Cell3Ds", std::string FileCell0DNeighboursName = "Cell0DNeighbours", std::string FileCell1DNeighboursName = "Cell1DNeighbours", std::string FileCell2DNeighboursName = "Cell2DNeighbours", std::string FileCell0DPropertiesName = "Cell0DProperties", std::string FileCell1DPropertiesName = "Cell1DProperties", std::string FileCell2DPropertiesName = "Cell2DProperties", std::string FileCell3DPropertiesName = "Cell3DProperties", std::string FileCell2DSubDivisionsName = "Cell2DSubDivisions", std::string FileCell0DUpdatedCellsName = "Cell0DUpdatedCells", std::string FileCell1DUpdatedCellsName = "Cell1DUpdatedCells", std::string FileCell2DUpdatedCellsName = "Cell2DUpdatedCells", std::string FileCell3DUpdatedCellsName = "Cell3DUpdatedCells", char Separator = ';', std::string FileExtension = "csv")
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshFromCsvUtilities::Configuration>();
                    r_ctor_->Folder = Folder;
                    r_ctor_->FileCell0DsName = FileCell0DsName;
                    r_ctor_->FileCell1DsName = FileCell1DsName;
                    r_ctor_->FileCell2DsName = FileCell2DsName;
                    r_ctor_->FileCell3DsName = FileCell3DsName;
                    r_ctor_->FileCell0DNeighboursName = FileCell0DNeighboursName;
                    r_ctor_->FileCell1DNeighboursName = FileCell1DNeighboursName;
                    r_ctor_->FileCell2DNeighboursName = FileCell2DNeighboursName;
                    r_ctor_->FileCell0DPropertiesName = FileCell0DPropertiesName;
                    r_ctor_->FileCell1DPropertiesName = FileCell1DPropertiesName;
                    r_ctor_->FileCell2DPropertiesName = FileCell2DPropertiesName;
                    r_ctor_->FileCell3DPropertiesName = FileCell3DPropertiesName;
                    r_ctor_->FileCell2DSubDivisionsName = FileCell2DSubDivisionsName;
                    r_ctor_->FileCell0DUpdatedCellsName = FileCell0DUpdatedCellsName;
                    r_ctor_->FileCell1DUpdatedCellsName = FileCell1DUpdatedCellsName;
                    r_ctor_->FileCell2DUpdatedCellsName = FileCell2DUpdatedCellsName;
                    r_ctor_->FileCell3DUpdatedCellsName = FileCell3DUpdatedCellsName;
                    r_ctor_->Separator = Separator;
                    r_ctor_->FileExtension = FileExtension;
                    return r_ctor_;
                })
                , py::arg("folder") = "./", py::arg("file_cell0_ds_name") = "Cell0Ds", py::arg("file_cell1_ds_name") = "Cell1Ds", py::arg("file_cell2_ds_name") = "Cell2Ds", py::arg("file_cell3_ds_name") = "Cell3Ds", py::arg("file_cell0_d_neighbours_name") = "Cell0DNeighbours", py::arg("file_cell1_d_neighbours_name") = "Cell1DNeighbours", py::arg("file_cell2_d_neighbours_name") = "Cell2DNeighbours", py::arg("file_cell0_d_properties_name") = "Cell0DProperties", py::arg("file_cell1_d_properties_name") = "Cell1DProperties", py::arg("file_cell2_d_properties_name") = "Cell2DProperties", py::arg("file_cell3_d_properties_name") = "Cell3DProperties", py::arg("file_cell2_d_sub_divisions_name") = "Cell2DSubDivisions", py::arg("file_cell0_d_updated_cells_name") = "Cell0DUpdatedCells", py::arg("file_cell1_d_updated_cells_name") = "Cell1DUpdatedCells", py::arg("file_cell2_d_updated_cells_name") = "Cell2DUpdatedCells", py::arg("file_cell3_d_updated_cells_name") = "Cell3DUpdatedCells", py::arg("separator") = ';', py::arg("file_extension") = "csv"
                )
                .def_readwrite("folder", &Gedim::MeshFromCsvUtilities::Configuration::Folder, "")
                .def_readwrite("file_cell0_ds_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell0DsName, "")
                .def_readwrite("file_cell1_ds_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell1DsName, "")
                .def_readwrite("file_cell2_ds_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell2DsName, "")
                .def_readwrite("file_cell3_ds_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell3DsName, "")
                .def_readwrite("file_cell0_d_neighbours_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell0DNeighboursName, "")
                .def_readwrite("file_cell1_d_neighbours_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell1DNeighboursName, "")
                .def_readwrite("file_cell2_d_neighbours_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell2DNeighboursName, "")
                .def_readwrite("file_cell0_d_properties_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell0DPropertiesName, "")
                .def_readwrite("file_cell1_d_properties_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell1DPropertiesName, "")
                .def_readwrite("file_cell2_d_properties_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell2DPropertiesName, "")
                .def_readwrite("file_cell3_d_properties_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell3DPropertiesName, "")
                .def_readwrite("file_cell2_d_sub_divisions_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell2DSubDivisionsName, "")
                .def_readwrite("file_cell0_d_updated_cells_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell0DUpdatedCellsName, "")
                .def_readwrite("file_cell1_d_updated_cells_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell1DUpdatedCellsName, "")
                .def_readwrite("file_cell2_d_updated_cells_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell2DUpdatedCellsName, "")
                .def_readwrite("file_cell3_d_updated_cells_name", &Gedim::MeshFromCsvUtilities::Configuration::FileCell3DUpdatedCellsName, "")
                .def_readwrite("separator", &Gedim::MeshFromCsvUtilities::Configuration::Separator, "")
                .def_readwrite("file_extension", &Gedim::MeshFromCsvUtilities::Configuration::FileExtension, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCellDoubleProperty =
                py::class_<Gedim::MeshFromCsvUtilities::CellDoubleProperty>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "CellDoubleProperty", "");

            { // inner classes & enums of CellDoubleProperty
                auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCellDoubleProperty_ClassValue =
                    py::class_<Gedim::MeshFromCsvUtilities::CellDoubleProperty::Value>
                        (pyNsGedim_ClassMeshFromCsvUtilities_ClassCellDoubleProperty, "Value", "")
                    .def(py::init<>([](
                    std::vector<double> Values = std::vector<double>())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::MeshFromCsvUtilities::CellDoubleProperty::Value>();
                        r_ctor_->Values = Values;
                        return r_ctor_;
                    })
                    , py::arg("values") = std::vector<double>()
                    )
                    .def_readwrite("cell_id", &Gedim::MeshFromCsvUtilities::CellDoubleProperty::Value::CellId, "")
                    .def_readwrite("values", &Gedim::MeshFromCsvUtilities::CellDoubleProperty::Value::Values, "")
                    ;
            } // end of inner classes & enums of CellDoubleProperty

            pyNsGedim_ClassMeshFromCsvUtilities_ClassCellDoubleProperty
                .def(py::init<>([](
                std::string Id = std::string(), std::string FilePath = std::string(), std::vector<Gedim::MeshFromCsvUtilities::CellDoubleProperty::Value> Values = std::vector<Gedim::MeshFromCsvUtilities::CellDoubleProperty::Value>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshFromCsvUtilities::CellDoubleProperty>();
                    r_ctor_->Id = Id;
                    r_ctor_->FilePath = FilePath;
                    r_ctor_->Values = Values;
                    return r_ctor_;
                })
                , py::arg("id") = std::string(), py::arg("file_path") = std::string(), py::arg("values") = std::vector<Gedim::MeshFromCsvUtilities::CellDoubleProperty::Value>()
                )
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::CellDoubleProperty::Id, "")
                .def_readwrite("file_path", &Gedim::MeshFromCsvUtilities::CellDoubleProperty::FilePath, "")
                .def_readwrite("values", &Gedim::MeshFromCsvUtilities::CellDoubleProperty::Values, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCell0D =
                py::class_<Gedim::MeshFromCsvUtilities::Cell0D>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Cell0D", "")
                .def(py::init<>([](
                double X = double(), double Y = double(), double Z = double(), bool Active = bool())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshFromCsvUtilities::Cell0D>();
                    r_ctor_->X = X;
                    r_ctor_->Y = Y;
                    r_ctor_->Z = Z;
                    r_ctor_->Active = Active;
                    return r_ctor_;
                })
                , py::arg("x") = double(), py::arg("y") = double(), py::arg("z") = double(), py::arg("active") = bool()
                )
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::Cell0D::Id, "")
                .def_readwrite("x", &Gedim::MeshFromCsvUtilities::Cell0D::X, "")
                .def_readwrite("y", &Gedim::MeshFromCsvUtilities::Cell0D::Y, "")
                .def_readwrite("z", &Gedim::MeshFromCsvUtilities::Cell0D::Z, "")
                .def_readwrite("marker", &Gedim::MeshFromCsvUtilities::Cell0D::Marker, "")
                .def_readwrite("active", &Gedim::MeshFromCsvUtilities::Cell0D::Active, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCell0DNeighbours =
                py::class_<Gedim::MeshFromCsvUtilities::Cell0DNeighbours>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Cell0DNeighbours", "")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::Cell0DNeighbours::Id, "")
                .def_readwrite("cell1_d_neighbours", &Gedim::MeshFromCsvUtilities::Cell0DNeighbours::Cell1DNeighbours, "")
                .def_readwrite("cell2_d_neighbours", &Gedim::MeshFromCsvUtilities::Cell0DNeighbours::Cell2DNeighbours, "")
                .def_readwrite("cell3_d_neighbours", &Gedim::MeshFromCsvUtilities::Cell0DNeighbours::Cell3DNeighbours, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCellUpdatedCells =
                py::class_<Gedim::MeshFromCsvUtilities::CellUpdatedCells>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "CellUpdatedCells", "")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::CellUpdatedCells::Id, "")
                .def_readwrite("updated_cells", &Gedim::MeshFromCsvUtilities::CellUpdatedCells::UpdatedCells, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCell1D =
                py::class_<Gedim::MeshFromCsvUtilities::Cell1D>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Cell1D", "")
                .def(py::init<>([](
                bool Active = bool())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshFromCsvUtilities::Cell1D>();
                    r_ctor_->Active = Active;
                    return r_ctor_;
                })
                , py::arg("active") = bool()
                )
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::Cell1D::Id, "")
                .def_readwrite("origin", &Gedim::MeshFromCsvUtilities::Cell1D::Origin, "")
                .def_readwrite("end", &Gedim::MeshFromCsvUtilities::Cell1D::End, "")
                .def_readwrite("marker", &Gedim::MeshFromCsvUtilities::Cell1D::Marker, "")
                .def_readwrite("active", &Gedim::MeshFromCsvUtilities::Cell1D::Active, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCell1DNeighbours =
                py::class_<Gedim::MeshFromCsvUtilities::Cell1DNeighbours>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Cell1DNeighbours", "")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::Cell1DNeighbours::Id, "")
                .def_readwrite("cell2_d_neighbours", &Gedim::MeshFromCsvUtilities::Cell1DNeighbours::Cell2DNeighbours, "")
                .def_readwrite("cell3_d_neighbours", &Gedim::MeshFromCsvUtilities::Cell1DNeighbours::Cell3DNeighbours, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCell2D =
                py::class_<Gedim::MeshFromCsvUtilities::Cell2D>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Cell2D", "")
                .def(py::init<>([](
                bool Active = bool())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshFromCsvUtilities::Cell2D>();
                    r_ctor_->Active = Active;
                    return r_ctor_;
                })
                , py::arg("active") = bool()
                )
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::Cell2D::Id, "")
                .def_readwrite("vertices", &Gedim::MeshFromCsvUtilities::Cell2D::Vertices, "")
                .def_readwrite("edges", &Gedim::MeshFromCsvUtilities::Cell2D::Edges, "")
                .def_readwrite("marker", &Gedim::MeshFromCsvUtilities::Cell2D::Marker, "")
                .def_readwrite("active", &Gedim::MeshFromCsvUtilities::Cell2D::Active, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCell2DNeighbours =
                py::class_<Gedim::MeshFromCsvUtilities::Cell2DNeighbours>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Cell2DNeighbours", "")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::Cell2DNeighbours::Id, "")
                .def_readwrite("cell3_d_neighbours", &Gedim::MeshFromCsvUtilities::Cell2DNeighbours::Cell3DNeighbours, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCell2DSubDivision =
                py::class_<Gedim::MeshFromCsvUtilities::Cell2DSubDivision>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Cell2DSubDivision", "")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::Cell2DSubDivision::Id, "")
                .def_readwrite("sub_division", &Gedim::MeshFromCsvUtilities::Cell2DSubDivision::SubDivision, "")
                ;
            auto pyNsGedim_ClassMeshFromCsvUtilities_ClassCell3D =
                py::class_<Gedim::MeshFromCsvUtilities::Cell3D>
                    (pyNsGedim_ClassMeshFromCsvUtilities, "Cell3D", "")
                .def(py::init<>([](
                bool Active = bool())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshFromCsvUtilities::Cell3D>();
                    r_ctor_->Active = Active;
                    return r_ctor_;
                })
                , py::arg("active") = bool()
                )
                .def_readwrite("id", &Gedim::MeshFromCsvUtilities::Cell3D::Id, "")
                .def_readwrite("vertices", &Gedim::MeshFromCsvUtilities::Cell3D::Vertices, "")
                .def_readwrite("edges", &Gedim::MeshFromCsvUtilities::Cell3D::Edges, "")
                .def_readwrite("faces", &Gedim::MeshFromCsvUtilities::Cell3D::Faces, "")
                .def_readwrite("marker", &Gedim::MeshFromCsvUtilities::Cell3D::Marker, "")
                .def_readwrite("active", &Gedim::MeshFromCsvUtilities::Cell3D::Active, "")
                ;
        } // end of inner classes & enums of MeshFromCsvUtilities

        pyNsGedim_ClassMeshFromCsvUtilities
            .def(py::init<>())
            .def("convert_mesh2_d",
                &Gedim::MeshFromCsvUtilities::ConvertMesh2D,
                py::arg("cell0_ds"), py::arg("cell1_ds"), py::arg("cell2_ds"), py::arg("mesh"),
                "/ \\brief Convert a 2D Mesh\n/ \\param cell0Ds the container of cell0Ds\n/ \\param cell1Ds the container of cell1Ds\n/ \\param cell2Ds the container of cell2Ds\n/ \\param mesh the resulting mesh")
            .def("convert_cell0_ds",
                &Gedim::MeshFromCsvUtilities::ConvertCell0Ds,
                py::arg("cell0_ds"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell0Ds to mesh\n/ \\param cell0Ds the container of cell0Ds\n/ \\param mesh the mesh")
            .def("convert_cell1_ds",
                &Gedim::MeshFromCsvUtilities::ConvertCell1Ds,
                py::arg("cell1_ds"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell1Ds to mesh\n/ \\param cell1Ds the container of cell1Ds\n/ \\param mesh the mesh")
            .def("convert_cell2_ds",
                &Gedim::MeshFromCsvUtilities::ConvertCell2Ds,
                py::arg("cell2_ds"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell2Ds to mesh\n/ \\param cell2Ds the container of cell2Ds\n/ \\param mesh the mesh")
            .def("convert_cell3_ds",
                &Gedim::MeshFromCsvUtilities::ConvertCell3Ds,
                py::arg("cell3_ds"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell3Ds to mesh\n/ \\param cell3Ds the container of cell3Ds\n/ \\param mesh the mesh")
            .def("convert_cell0_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ConvertCell0DNeighbours,
                py::arg("cell0_d_neighbours"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell0D neighbours to mesh\n/ \\param cell0DNeighbours the container of cell0D neighbours\n/ \\param mesh the mesh")
            .def("convert_cell1_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ConvertCell1DNeighbours,
                py::arg("cell1_d_neighbours"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell1D neighbours to mesh\n/ \\param cell1DNeighbours the container of cell1D neighbours\n/ \\param mesh the mesh")
            .def("convert_cell2_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ConvertCell2DNeighbours,
                py::arg("cell2_d_neighbours"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell2D neighbours to mesh\n/ \\param cell2DNeighbours the container of cell2D neighbours\n/ \\param mesh the mesh")
            .def("convert_cell2_d_sub_divisions",
                &Gedim::MeshFromCsvUtilities::ConvertCell2DSubDivisions,
                py::arg("cell2_d_sub_divisions"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell2D subdivision to mesh\n/ \\param cell2DSubDivisions the container of cell2D neighbours\n/ \\param mesh the mesh")
            .def("convert_cell0_d_double_properties",
                &Gedim::MeshFromCsvUtilities::ConvertCell0DDoubleProperties,
                py::arg("cell0_d_double_properties"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell0D double properties to mesh\n/ \\param cell0DDoubleProperties the container of cell0D double properties\n/ \\param mesh the mesh")
            .def("convert_cell1_d_double_properties",
                &Gedim::MeshFromCsvUtilities::ConvertCell1DDoubleProperties,
                py::arg("cell1_d_double_properties"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell1D double properties to mesh\n/ \\param cell1DDoubleProperties the container of cell1D double properties\n/ \\param mesh the mesh")
            .def("convert_cell2_d_double_properties",
                &Gedim::MeshFromCsvUtilities::ConvertCell2DDoubleProperties,
                py::arg("cell2_d_double_properties"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell2D double properties to mesh\n/ \\param cell2DDoubleProperties the container of cell2D double properties\n/ \\param mesh the mesh")
            .def("convert_cell3_d_double_properties",
                &Gedim::MeshFromCsvUtilities::ConvertCell3DDoubleProperties,
                py::arg("cell3_d_double_properties"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell3D double properties to mesh\n/ \\param cell3DDoubleProperties the container of cell3D double properties\n/ \\param mesh the mesh")
            .def("convert_cell0_d_updated_cells",
                &Gedim::MeshFromCsvUtilities::ConvertCell0DUpdatedCells,
                py::arg("cell0_d_updated_cells"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell0D updated cells to mesh\n/ \\param cell0DUpdatedCells the container of cell0D updated cells\n/ \\param mesh the mesh")
            .def("convert_cell1_d_updated_cells",
                &Gedim::MeshFromCsvUtilities::ConvertCell1DUpdatedCells,
                py::arg("cell1_d_updated_cells"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell1D updated cells to mesh\n/ \\param cell1DUpdatedCells the container of cell1D updated cells\n/ \\param mesh the mesh")
            .def("convert_cell2_d_updated_cells",
                &Gedim::MeshFromCsvUtilities::ConvertCell2DUpdatedCells,
                py::arg("cell2_d_updated_cells"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell2D updated cells to mesh\n/ \\param cell2DUpdatedCells the container of cell2D updated cells\n/ \\param mesh the mesh")
            .def("convert_cell3_d_updated_cells",
                &Gedim::MeshFromCsvUtilities::ConvertCell3DUpdatedCells,
                py::arg("cell3_d_updated_cells"), py::arg("mesh"),
                "/ \\brief Convert the imported Cell3D updated cells to mesh\n/ \\param cell3DUpdatedCells the container of cell3D updated cells\n/ \\param mesh the mesh")
            .def("import_cell0_ds",
                &Gedim::MeshFromCsvUtilities::ImportCell0Ds,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import Cell0Ds; format: Id, Marker, Active, X, Y, Z\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator\n/ \\param mesh the mesh to be Imported")
            .def("import_cell1_ds",
                &Gedim::MeshFromCsvUtilities::ImportCell1Ds,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import Cell1Ds; format: Id, Marker, Active, Origin, End\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator")
            .def("import_cell2_ds",
                &Gedim::MeshFromCsvUtilities::ImportCell2Ds,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import Cell2Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator")
            .def("import_cell3_ds",
                &Gedim::MeshFromCsvUtilities::ImportCell3Ds,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import Cell3Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges, NumFaces, Faces\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator")
            .def("import_cell0_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ImportCell0DNeighbours,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import Cell0DNeighbours; format: Id, Num1DNeighbours, 1DNeighbours, Num2DNeighbours, 2DNeighbours,\n/ Num3DNeighbours, 3DNeighbours \\param csvFileReader the file reader \\param separator the file separator")
            .def("import_cell1_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ImportCell1DNeighbours,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import Cell1DNeighbours; format: Id, Num2DNeighbours, 2DNeighbours, Num3DNeighbours, 3DNeighbours\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator")
            .def("import_cell2_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ImportCell2DNeighbours,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import Cell2DNeighbours; format: Id, Num3DNeighbours, 3DNeighbours\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator")
            .def("import_cell2_d_sub_division",
                &Gedim::MeshFromCsvUtilities::ImportCell2DSubDivision,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import Cell2DSubDivision; format: Id, NumSubDivision, SubDivisions\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator")
            .def("import_cell_double_properties",
                &Gedim::MeshFromCsvUtilities::ImportCellDoubleProperties,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import CellProperties; format: Id, FilePath\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator")
            .def("import_cell_updated_cells",
                &Gedim::MeshFromCsvUtilities::ImportCellUpdatedCells,
                py::arg("csv_file_reader"), py::arg("separator"),
                "/ \\brief Import CellUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells\n/ \\param csvFileReader the file reader\n/ \\param separator the file separator")
            .def("export_cell0_ds",
                &Gedim::MeshFromCsvUtilities::ExportCell0Ds,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell0Ds; format: Id, Marker, Active, X, Y, Z\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell1_ds",
                &Gedim::MeshFromCsvUtilities::ExportCell1Ds,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell1Ds; format: Id, Marker, Active, Origin, End\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell2_ds",
                &Gedim::MeshFromCsvUtilities::ExportCell2Ds,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell2Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell3_ds",
                &Gedim::MeshFromCsvUtilities::ExportCell3Ds,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell3Ds; format: Id, Marker, Active, NumVertices, Vertices, NumEdges, Edges, NumFaces, Faces\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell0_d_properties",
                &Gedim::MeshFromCsvUtilities::ExportCell0DProperties,
                py::arg("export_folder"), py::arg("property_file_name"), py::arg("property_file_extension"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell0DProperties; format: Id, FilePath\n/ \\param exportFolder the folder where to export the files\n/ \\param propertyFileName the name of property file\n/ \\param propertyFileExtension the extension of the files\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell0_d_property",
                &Gedim::MeshFromCsvUtilities::ExportCell0DProperty,
                py::arg("property_index"), py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell0DProperty identified by index; format: Id, PropertySize, PropertyValues\n/ \\param propertyIndex the property index\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell1_d_properties",
                &Gedim::MeshFromCsvUtilities::ExportCell1DProperties,
                py::arg("export_folder"), py::arg("property_file_name"), py::arg("property_file_extension"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell1DProperties; format: Id, FilePath\n/ \\param exportFolder the folder where to export the files\n/ \\param propertyFileName the name of property file\n/ \\param propertyFileExtension the extension of the files\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell1_d_property",
                &Gedim::MeshFromCsvUtilities::ExportCell1DProperty,
                py::arg("property_index"), py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell1DProperty identified by index; format: Id, PropertySize, PropertyValues\n/ \\param propertyIndex the property index\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell2_d_properties",
                &Gedim::MeshFromCsvUtilities::ExportCell2DProperties,
                py::arg("export_folder"), py::arg("property_file_name"), py::arg("property_file_extension"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell2DProperties; format: Id, FilePath\n/ \\param exportFolder the folder where to export the files\n/ \\param propertyFileName the name of property file\n/ \\param propertyFileExtension the extension of the files\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell2_d_property",
                &Gedim::MeshFromCsvUtilities::ExportCell2DProperty,
                py::arg("property_index"), py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell2DProperty identified by index; format: Id, PropertySize, PropertyValues\n/ \\param propertyIndex the property index\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell3_d_properties",
                &Gedim::MeshFromCsvUtilities::ExportCell3DProperties,
                py::arg("export_folder"), py::arg("property_file_name"), py::arg("property_file_extension"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell3DProperties; format: Id, FilePath\n/ \\param exportFolder the folder where to export the files\n/ \\param propertyFileName the name of property file\n/ \\param propertyFileExtension the extension of the files\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell3_d_property",
                &Gedim::MeshFromCsvUtilities::ExportCell3DProperty,
                py::arg("property_index"), py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell3DProperty identified by index; format: Id, PropertySize, PropertyValues\n/ \\param propertyIndex the property index\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell0_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ExportCell0DNeighbours,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell0DNeighbours; format: Id, Num1DNeighbours, 1DNeighbours, Num2DNeighbours, 2DNeighbours,\n/ Num3DNeighbours, 3DNeighbours \\param filePath the path of the file \\param separator the file separator \\param\n/ mesh the mesh to be exported")
            .def("export_cell1_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ExportCell1DNeighbours,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell1DNeighbours; format: Id, Num2DNeighbours, 2DNeighbours, Num3DNeighbours, 3DNeighbours\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell2_d_neighbours",
                &Gedim::MeshFromCsvUtilities::ExportCell2DNeighbours,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell2DNeighbours; format: Id, Num3DNeighbours, 3DNeighbours\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell2_d_sub_divisions",
                &Gedim::MeshFromCsvUtilities::ExportCell2DSubDivisions,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell2DSubDivisions; format: Id, NumSubDivision, SubDivisions\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell0_d_updated_cells",
                &Gedim::MeshFromCsvUtilities::ExportCell0DUpdatedCells,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell0DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell1_d_updated_cells",
                &Gedim::MeshFromCsvUtilities::ExportCell1DUpdatedCells,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell1DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell2_d_updated_cells",
                &Gedim::MeshFromCsvUtilities::ExportCell2DUpdatedCells,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell2DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            .def("export_cell3_d_updated_cells",
                &Gedim::MeshFromCsvUtilities::ExportCell3DUpdatedCells,
                py::arg("file_path"), py::arg("separator"), py::arg("mesh"),
                "/ \\brief Export Cell3DUpdatedCells; format: Id, NumUpdatedCells, UpdatedCells\n/ \\param filePath the path of the file\n/ \\param separator the file separator\n/ \\param mesh the mesh to be exported")
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MeshFromCsvUtilities.hpp>    ////////////////////


    ////////////////////    <generated_from:MeshMatrices.hpp>    ////////////////////
    // #ifndef __MeshMatrices_H
    //
    // #endif
    //

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMeshMatrices =
            py::class_<Gedim::MeshMatrices>
                (pyNsGedim, "MeshMatrices", py::is_final(), "\n(final class)")
            .def(py::init<>([](
            std::vector<double> Cell0DCoordinates = {}, std::vector<bool> ActiveCell0D = {}, std::vector<std::string> Cell0DDoublePropertyIds = {}, std::vector<std::vector<double>> Cell0DDoublePropertyValues = {}, std::vector<bool> ActiveCell1D = {}, std::vector<std::string> Cell1DDoublePropertyIds = {}, std::vector<std::vector<double>> Cell1DDoublePropertyValues = {}, std::vector<bool> ActiveCell2D = {}, std::vector<std::string> Cell2DDoublePropertyIds = {}, std::vector<std::vector<double>> Cell2DDoublePropertyValues = {}, std::vector<bool> ActiveCell3D = {}, std::vector<std::string> Cell3DDoublePropertyIds = {}, std::vector<std::vector<double>> Cell3DDoublePropertyValues = {})
            {
                auto r_ctor_ = std::make_unique<Gedim::MeshMatrices>();
                r_ctor_->Cell0DCoordinates = Cell0DCoordinates;
                r_ctor_->ActiveCell0D = ActiveCell0D;
                r_ctor_->Cell0DDoublePropertyIds = Cell0DDoublePropertyIds;
                r_ctor_->Cell0DDoublePropertyValues = Cell0DDoublePropertyValues;
                r_ctor_->ActiveCell1D = ActiveCell1D;
                r_ctor_->Cell1DDoublePropertyIds = Cell1DDoublePropertyIds;
                r_ctor_->Cell1DDoublePropertyValues = Cell1DDoublePropertyValues;
                r_ctor_->ActiveCell2D = ActiveCell2D;
                r_ctor_->Cell2DDoublePropertyIds = Cell2DDoublePropertyIds;
                r_ctor_->Cell2DDoublePropertyValues = Cell2DDoublePropertyValues;
                r_ctor_->ActiveCell3D = ActiveCell3D;
                r_ctor_->Cell3DDoublePropertyIds = Cell3DDoublePropertyIds;
                r_ctor_->Cell3DDoublePropertyValues = Cell3DDoublePropertyValues;
                return r_ctor_;
            })
            , py::arg("cell0_d_coordinates") = std::vector<double>{}, py::arg("active_cell0_d") = std::vector<bool>{}, py::arg("cell0_d_double_property_ids") = std::vector<std::string>{}, py::arg("cell0_d_double_property_values") = std::vector<std::vector<double>>{}, py::arg("active_cell1_d") = std::vector<bool>{}, py::arg("cell1_d_double_property_ids") = std::vector<std::string>{}, py::arg("cell1_d_double_property_values") = std::vector<std::vector<double>>{}, py::arg("active_cell2_d") = std::vector<bool>{}, py::arg("cell2_d_double_property_ids") = std::vector<std::string>{}, py::arg("cell2_d_double_property_values") = std::vector<std::vector<double>>{}, py::arg("active_cell3_d") = std::vector<bool>{}, py::arg("cell3_d_double_property_ids") = std::vector<std::string>{}, py::arg("cell3_d_double_property_values") = std::vector<std::vector<double>>{}
            )
            .def_readwrite("dimension", &Gedim::MeshMatrices::Dimension, "/< Geometric dimension")
            .def_readwrite("number_cell0_d", &Gedim::MeshMatrices::NumberCell0D, "/< number of Cell0D")
            .def_readwrite("cell0_d_coordinates", &Gedim::MeshMatrices::Cell0DCoordinates, "/< Cell0D coordinates, size 3 x NumberCell0D (x,y,z)")
            .def_readwrite("cell0_d_markers", &Gedim::MeshMatrices::Cell0DMarkers, "/< Cell0D markers, size 1 x NumberCell0D (marker)")
            .def_readwrite("number_cell0_d_neighbour_cell1_d", &Gedim::MeshMatrices::NumberCell0DNeighbourCell1D, "/< Cell0D neighbour Cell1D indices per cell, size  1")
            .def_readwrite("cell0_d_neighbour_cell1_ds", &Gedim::MeshMatrices::Cell0DNeighbourCell1Ds, "/< Cell0D neighbour Cell1D indices, size 1 x")
            .def_readwrite("number_cell0_d_neighbour_cell2_d", &Gedim::MeshMatrices::NumberCell0DNeighbourCell2D, "/< Cell0D neighbour Cell2D indices per cell, size  1")
            .def_readwrite("cell0_d_neighbour_cell2_ds", &Gedim::MeshMatrices::Cell0DNeighbourCell2Ds, "/< Cell0D neighbour Cell2D indices, size 1 x")
            .def_readwrite("number_cell0_d_neighbour_cell3_d", &Gedim::MeshMatrices::NumberCell0DNeighbourCell3D, "/< Cell0D neighbour Cell2D indices per cell, size  1")
            .def_readwrite("cell0_d_neighbour_cell3_ds", &Gedim::MeshMatrices::Cell0DNeighbourCell3Ds, "/< Cell0D neighbour Cell3D indices, size 1 x")
            .def_readwrite("active_cell0_d", &Gedim::MeshMatrices::ActiveCell0D, "/< active Cell0D")
            .def_readwrite("updated_cell0_ds", &Gedim::MeshMatrices::UpdatedCell0Ds, "/< for each cell0D the")
            .def_readwrite("cell0_d_double_property_ids", &Gedim::MeshMatrices::Cell0DDoublePropertyIds, "/< Cell0D double property id - double property index")
            .def_readwrite("cell0_d_double_property_indices", &Gedim::MeshMatrices::Cell0DDoublePropertyIndices, "/< Cell0D double property id -")
            .def_readwrite("cell0_d_double_property_sizes", &Gedim::MeshMatrices::Cell0DDoublePropertySizes, "/< Cell0D double property sizes")
            .def_readwrite("cell0_d_double_property_values", &Gedim::MeshMatrices::Cell0DDoublePropertyValues, "/< Cell0D double property values")
            .def_readwrite("number_cell1_d", &Gedim::MeshMatrices::NumberCell1D, "/< number of Cell1D")
            .def_readwrite("cell1_d_vertices", &Gedim::MeshMatrices::Cell1DVertices, "/< Cell1D vertices indices, size 2 x NumberCell1D (fromId,toId)")
            .def_readwrite("number_cell1_d_neighbour_cell2_d", &Gedim::MeshMatrices::NumberCell1DNeighbourCell2D, "/< Cell1D neighbour Cell2D indices per cell, size  1")
            .def_readwrite("number_cell1_d_neighbour_cell3_d", &Gedim::MeshMatrices::NumberCell1DNeighbourCell3D, "/< Cell1D neighbour Cell3D indices per cell, size  1")
            .def_readwrite("cell1_d_neighbour_cell2_ds", &Gedim::MeshMatrices::Cell1DNeighbourCell2Ds, "/< Cell1D neighbour Cell2D indices, size 1 x")
            .def_readwrite("cell1_d_neighbour_cell3_ds", &Gedim::MeshMatrices::Cell1DNeighbourCell3Ds, "/< Cell1D neighbour Cell3D indices, size 1 x")
            .def_readwrite("cell1_d_markers", &Gedim::MeshMatrices::Cell1DMarkers, "/< Cell1D propertoes, size 1 x NumberCell1D (marker)")
            .def_readwrite("active_cell1_d", &Gedim::MeshMatrices::ActiveCell1D, "/< active Cell1D")
            .def_readwrite("cell1_d_original_cell1_ds", &Gedim::MeshMatrices::Cell1DOriginalCell1Ds, "/< for each cell1D the index of original cell1D,")
            .def_readwrite("updated_cell1_ds", &Gedim::MeshMatrices::UpdatedCell1Ds, "/< for each cell1D the")
            .def_readwrite("cell1_d_double_property_ids", &Gedim::MeshMatrices::Cell1DDoublePropertyIds, "/< Cell1D double property id - double property index")
            .def_readwrite("cell1_d_double_property_indices", &Gedim::MeshMatrices::Cell1DDoublePropertyIndices, "/< Cell1D double property id -")
            .def_readwrite("cell1_d_double_property_sizes", &Gedim::MeshMatrices::Cell1DDoublePropertySizes, "/< Cell1D double property sizes")
            .def_readwrite("cell1_d_double_property_values", &Gedim::MeshMatrices::Cell1DDoublePropertyValues, "/< Cell1D double property values")
            .def_readwrite("number_cell2_d", &Gedim::MeshMatrices::NumberCell2D, "/< number of Cell2D")
            .def_readwrite("number_cell2_d_vertices", &Gedim::MeshMatrices::NumberCell2DVertices, "/< number of Vertices per Cell2D, size 1 x NumberCell2D + 1")
            .def_readwrite("number_cell2_d_edges", &Gedim::MeshMatrices::NumberCell2DEdges, "/< number of Edges per Cell2D, size 1 x NumberCell2D + 1")
            .def_readwrite("cell2_d_vertices", &Gedim::MeshMatrices::Cell2DVertices, "/< Cell2D Vertices indices, size 1 x")
            .def_readwrite("cell2_d_edges", &Gedim::MeshMatrices::Cell2DEdges, "/< Cell2D Cell1D indices, size 1 x NumberCell2DEdges[NumberCell2D]")
            .def_readwrite("number_cell2_d_neighbour_cell3_d", &Gedim::MeshMatrices::NumberCell2DNeighbourCell3D, "/< Cell2D neighbour Cell3D indices per cell, size  1")
            .def_readwrite("cell2_d_neighbour_cell3_ds", &Gedim::MeshMatrices::Cell2DNeighbourCell3Ds, "/< Cell2D neighbour Cell3D indices, size 1 x")
            .def_readwrite("cell2_d_markers", &Gedim::MeshMatrices::Cell2DMarkers, "/< Cell2D markers, size 1 x NumberCell2D (marker)")
            .def_readwrite("active_cell2_d", &Gedim::MeshMatrices::ActiveCell2D, "/< active Cell2D")
            .def_readwrite("number_cell2_d_subdivision", &Gedim::MeshMatrices::NumberCell2DSubdivision, "/< number of sub-division per Cell2D, size 1 x")
            .def_readwrite("cell2_d_subdivision", &Gedim::MeshMatrices::Cell2DSubdivision, "/< Sub-division of Cell2Ds, used for Concave polygons, size 1 x")
            .def_readwrite("cell2_d_original_cell2_ds", &Gedim::MeshMatrices::Cell2DOriginalCell2Ds, "/< for each cell2D the index of original cell2D,")
            .def_readwrite("updated_cell2_ds", &Gedim::MeshMatrices::UpdatedCell2Ds, "/< for each cell2D the")
            .def_readwrite("cell2_d_double_property_ids", &Gedim::MeshMatrices::Cell2DDoublePropertyIds, "/< Cell2D double property id - double property index")
            .def_readwrite("cell2_d_double_property_indices", &Gedim::MeshMatrices::Cell2DDoublePropertyIndices, "/< Cell2D double property id -")
            .def_readwrite("cell2_d_double_property_sizes", &Gedim::MeshMatrices::Cell2DDoublePropertySizes, "/< Cell2D double property sizes")
            .def_readwrite("cell2_d_double_property_values", &Gedim::MeshMatrices::Cell2DDoublePropertyValues, "/< Cell2D double property values")
            .def_readwrite("number_cell3_d", &Gedim::MeshMatrices::NumberCell3D, "/< number of Cell3D")
            .def_readwrite("number_cell3_d_vertices", &Gedim::MeshMatrices::NumberCell3DVertices, "/< number of Vertices per Cell3D, size 1 x NumberCell3D + 1")
            .def_readwrite("number_cell3_d_edges", &Gedim::MeshMatrices::NumberCell3DEdges, "/< number of Edges per Cell3D, size 1 x NumberCell3D + 1")
            .def_readwrite("number_cell3_d_faces", &Gedim::MeshMatrices::NumberCell3DFaces, "/< number of Faces per Cell3D, size 1 x NumberCell3D + 1")
            .def_readwrite("cell3_d_vertices", &Gedim::MeshMatrices::Cell3DVertices, "/< Cell3D Cell0D indices, size 1 x")
            .def_readwrite("cell3_d_edges", &Gedim::MeshMatrices::Cell3DEdges, "/< Cell3D Cell1D indices, size 1 x NumberCell3DEdges[NumberCell3D]")
            .def_readwrite("cell3_d_faces", &Gedim::MeshMatrices::Cell3DFaces, "/< Cell3D Cell2D indices, size 1 x NumberCell3DFaces[NumberCell3D]")
            .def_readwrite("cell3_d_markers", &Gedim::MeshMatrices::Cell3DMarkers, "/< Cell3D markers, size 1 x NumberCell3D (marker)")
            .def_readwrite("active_cell3_d", &Gedim::MeshMatrices::ActiveCell3D, "/< active Cell3D")
            .def_readwrite("cell3_d_original_cell3_ds", &Gedim::MeshMatrices::Cell3DOriginalCell3Ds, "/< for each cell3D the index of original cell3D,")
            .def_readwrite("updated_cell3_ds", &Gedim::MeshMatrices::UpdatedCell3Ds, "/< for each cell3D the")
            .def_readwrite("cell3_d_double_property_ids", &Gedim::MeshMatrices::Cell3DDoublePropertyIds, "/< Cell3D double property id - double property index")
            .def_readwrite("cell3_d_double_property_indices", &Gedim::MeshMatrices::Cell3DDoublePropertyIndices, "/< Cell3D double property id -")
            .def_readwrite("cell3_d_double_property_sizes", &Gedim::MeshMatrices::Cell3DDoublePropertySizes, "/< Cell3D double property sizes")
            .def_readwrite("cell3_d_double_property_values", &Gedim::MeshMatrices::Cell3DDoublePropertyValues, "/< Cell3D double property values")
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MeshMatrices.hpp>    ////////////////////


    ////////////////////    <generated_from:MeshMatricesDAO.hpp>    ////////////////////
    // #ifndef __MeshMatricesWrapper_H
    //
    // #endif
    //

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMeshMatricesDAO =
            py::class_<Gedim::MeshMatricesDAO>
                (pyNsGedim, "MeshMatricesDAO", py::is_final(), "\n(final class)")
            .def(py::init<Gedim::MeshMatrices &>(),
                py::arg("mesh"))
            .def("initialize_dimension",
                &Gedim::MeshMatricesDAO::InitializeDimension, py::arg("dimension"))
            .def("dimension",
                &Gedim::MeshMatricesDAO::Dimension)
            .def("cell0_ds_initialize",
                &Gedim::MeshMatricesDAO::Cell0DsInitialize, py::arg("number_cell0_ds"))
            .def("cell0_d_append",
                &Gedim::MeshMatricesDAO::Cell0DAppend, py::arg("number_cell0_ds"))
            .def("cell0_d_remove",
                &Gedim::MeshMatricesDAO::Cell0DRemove, py::arg("cell0_d_index"))
            .def("cell0_d_insert_coordinates",
                &Gedim::MeshMatricesDAO::Cell0DInsertCoordinates, py::arg("cell0_d_index"), py::arg("coordinates"))
            .def("cell0_ds_insert_coordinates",
                &Gedim::MeshMatricesDAO::Cell0DsInsertCoordinates, py::arg("coordinates"))
            .def("cell0_d_set_marker",
                &Gedim::MeshMatricesDAO::Cell0DSetMarker, py::arg("cell0_d_index"), py::arg("marker"))
            .def("cell0_d_set_state",
                &Gedim::MeshMatricesDAO::Cell0DSetState, py::arg("cell0_d_index"), py::arg("state"))
            .def("cell0_d_total_number",
                &Gedim::MeshMatricesDAO::Cell0DTotalNumber)
            .def("cell0_d_coordinate_x",
                &Gedim::MeshMatricesDAO::Cell0DCoordinateX, py::arg("cell0_d_index"))
            .def("cell0_d_coordinate_y",
                &Gedim::MeshMatricesDAO::Cell0DCoordinateY, py::arg("cell0_d_index"))
            .def("cell0_d_coordinate_z",
                &Gedim::MeshMatricesDAO::Cell0DCoordinateZ, py::arg("cell0_d_index"))
            .def("cell0_d_coordinates",
                &Gedim::MeshMatricesDAO::Cell0DCoordinates, py::arg("cell0_d_index"))
            .def("cell0_ds_coordinates",
                [](Gedim::MeshMatricesDAO & self) { return self.Cell0DsCoordinates(); })
            .def("cell0_ds_coordinates",
                py::overload_cast<const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell0DsCoordinates, py::const_), py::arg("cell0_ds"))
            .def("cell0_d_marker",
                &Gedim::MeshMatricesDAO::Cell0DMarker, py::arg("cell0_d_index"))
            .def("cell0_ds_marker",
                &Gedim::MeshMatricesDAO::Cell0DsMarker)
            .def("cell0_d_is_active",
                &Gedim::MeshMatricesDAO::Cell0DIsActive, py::arg("cell0_d_index"))
            .def("cell0_d_has_updated_cell0_ds",
                &Gedim::MeshMatricesDAO::Cell0DHasUpdatedCell0Ds, py::arg("cell0_d_index"))
            .def("cell0_d_number_updated_cell0_ds",
                &Gedim::MeshMatricesDAO::Cell0DNumberUpdatedCell0Ds, py::arg("cell0_d_index"))
            .def("cell0_d_has_updated_cell0_d",
                &Gedim::MeshMatricesDAO::Cell0DHasUpdatedCell0D, py::arg("cell0_d_index"), py::arg("updated_cell0_d_idex"))
            .def("cell0_d_insert_updated_cell0_d",
                &Gedim::MeshMatricesDAO::Cell0DInsertUpdatedCell0D, py::arg("cell0_d_index"), py::arg("updated_cell0_d_idex"))
            .def("cell0_d_updated_cell0_ds",
                &Gedim::MeshMatricesDAO::Cell0DUpdatedCell0Ds, py::arg("cell0_d_index"), py::arg("updated_cell0_d_ids"))
            .def("cell0_ds_neighbour_cell1_ds",
                &Gedim::MeshMatricesDAO::Cell0DsNeighbourCell1Ds)
            .def("cell0_ds_initialize_neighbour_cell1_ds",
                &Gedim::MeshMatricesDAO::Cell0DsInitializeNeighbourCell1Ds, py::arg("number_neighbour_cell1_ds"))
            .def("cell0_d_initialize_neighbour_cell1_ds",
                py::overload_cast<const unsigned int &, const unsigned int &>(&Gedim::MeshMatricesDAO::Cell0DInitializeNeighbourCell1Ds), py::arg("cell0_d_index"), py::arg("number_neighbour_cell1_ds"))
            .def("cell0_d_initialize_neighbour_cell1_ds",
                py::overload_cast<const unsigned int &, const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell0DInitializeNeighbourCell1Ds), py::arg("cell0_d_index"), py::arg("neighbour_cell1_ds"))
            .def("cell0_d_insert_neighbour_cell1_d",
                &Gedim::MeshMatricesDAO::Cell0DInsertNeighbourCell1D, py::arg("cell0_d_index"), py::arg("neighbour_index"), py::arg("neigbour_cell1_d_index"))
            .def("cell0_d_number_neighbour_cell1_d",
                &Gedim::MeshMatricesDAO::Cell0DNumberNeighbourCell1D, py::arg("cell0_d_index"))
            .def("cell0_d_neighbour_cell1_d",
                &Gedim::MeshMatricesDAO::Cell0DNeighbourCell1D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_d_neighbour_cell1_ds",
                &Gedim::MeshMatricesDAO::Cell0DNeighbourCell1Ds, py::arg("cell0_d_index"))
            .def("cell0_d_has_neighbour_cell1_d",
                &Gedim::MeshMatricesDAO::Cell0DHasNeighbourCell1D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_d_reset_neighbour_cell1_d",
                &Gedim::MeshMatricesDAO::Cell0DResetNeighbourCell1D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_ds_neighbour_cell2_ds",
                &Gedim::MeshMatricesDAO::Cell0DsNeighbourCell2Ds)
            .def("cell0_ds_initialize_neighbour_cell2_ds",
                &Gedim::MeshMatricesDAO::Cell0DsInitializeNeighbourCell2Ds, py::arg("number_neighbour_cell2_ds"))
            .def("cell0_d_initialize_neighbour_cell2_ds",
                py::overload_cast<const unsigned int &, const unsigned int &>(&Gedim::MeshMatricesDAO::Cell0DInitializeNeighbourCell2Ds), py::arg("cell0_d_index"), py::arg("number_neighbour_cell2_ds"))
            .def("cell0_d_initialize_neighbour_cell2_ds",
                py::overload_cast<const unsigned int &, const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell0DInitializeNeighbourCell2Ds), py::arg("cell0_d_index"), py::arg("neighbour_cell2_ds"))
            .def("cell0_d_insert_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell0DInsertNeighbourCell2D, py::arg("cell0_d_index"), py::arg("neighbour_index"), py::arg("neigbour_cell2_d_index"))
            .def("cell0_d_number_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell0DNumberNeighbourCell2D, py::arg("cell0_d_index"))
            .def("cell0_d_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell0DNeighbourCell2D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_d_neighbour_cell2_ds",
                &Gedim::MeshMatricesDAO::Cell0DNeighbourCell2Ds, py::arg("cell0_d_index"))
            .def("cell0_d_has_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell0DHasNeighbourCell2D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_d_reset_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell0DResetNeighbourCell2D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_ds_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell0DsNeighbourCell3Ds)
            .def("cell0_ds_initialize_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell0DsInitializeNeighbourCell3Ds, py::arg("number_neighbour_cell3_ds"))
            .def("cell0_d_initialize_neighbour_cell3_ds",
                py::overload_cast<const unsigned int &, const unsigned int &>(&Gedim::MeshMatricesDAO::Cell0DInitializeNeighbourCell3Ds), py::arg("cell0_d_index"), py::arg("number_neighbour_cell3_ds"))
            .def("cell0_d_initialize_neighbour_cell3_ds",
                py::overload_cast<const unsigned int &, const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell0DInitializeNeighbourCell3Ds), py::arg("cell0_d_index"), py::arg("neighbour_cell3_ds"))
            .def("cell0_d_insert_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell0DInsertNeighbourCell3D, py::arg("cell0_d_index"), py::arg("neighbour_index"), py::arg("neigbour_cell3_d_index"))
            .def("cell0_d_number_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell0DNumberNeighbourCell3D, py::arg("cell0_d_index"))
            .def("cell0_d_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell0DNeighbourCell3D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_d_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell0DNeighbourCell3Ds, py::arg("cell0_d_index"))
            .def("cell0_d_has_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell0DHasNeighbourCell3D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_d_reset_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell0DResetNeighbourCell3D, py::arg("cell0_d_index"), py::arg("neighbour_index"))
            .def("cell0_d_initialize_double_properties",
                &Gedim::MeshMatricesDAO::Cell0DInitializeDoubleProperties, py::arg("number_double_properties"))
            .def("cell0_d_add_double_property",
                &Gedim::MeshMatricesDAO::Cell0DAddDoubleProperty, py::arg("property_id"))
            .def("cell0_ds_initialize_double_property_values",
                &Gedim::MeshMatricesDAO::Cell0DsInitializeDoublePropertyValues, py::arg("property_index"), py::arg("property_sizes"))
            .def("cell0_d_initialize_double_property_values",
                &Gedim::MeshMatricesDAO::Cell0DInitializeDoublePropertyValues, py::arg("cell0_d_index"), py::arg("property_index"), py::arg("property_size"))
            .def("cell0_d_insert_double_property_value",
                &Gedim::MeshMatricesDAO::Cell0DInsertDoublePropertyValue, py::arg("cell0_d_index"), py::arg("property_index"), py::arg("property_value_index"), py::arg("property_value"))
            .def("cell0_d_number_double_properties",
                &Gedim::MeshMatricesDAO::Cell0DNumberDoubleProperties)
            .def("cell0_d_double_property_id",
                &Gedim::MeshMatricesDAO::Cell0DDoublePropertyId, py::arg("property_index"))
            .def("cell0_d_double_property_exists",
                &Gedim::MeshMatricesDAO::Cell0DDoublePropertyExists, py::arg("property_id"))
            .def("cell0_d_double_property_index",
                &Gedim::MeshMatricesDAO::Cell0DDoublePropertyIndex, py::arg("property_id"))
            .def("cell0_d_double_property_size",
                &Gedim::MeshMatricesDAO::Cell0DDoublePropertySize, py::arg("cell0_d_index"), py::arg("property_index"))
            .def("cell0_d_double_property_value",
                &Gedim::MeshMatricesDAO::Cell0DDoublePropertyValue, py::arg("cell0_d_index"), py::arg("property_index"), py::arg("property_value_index"))
            .def("cell1_ds_initialize",
                &Gedim::MeshMatricesDAO::Cell1DsInitialize, py::arg("number_cell1_ds"))
            .def("cell1_d_append",
                &Gedim::MeshMatricesDAO::Cell1DAppend, py::arg("number_cell1_ds"))
            .def("cell1_d_remove",
                &Gedim::MeshMatricesDAO::Cell1DRemove, py::arg("cell1_d_index"))
            .def("cell1_d_insert_extremes",
                &Gedim::MeshMatricesDAO::Cell1DInsertExtremes, py::arg("cell1_d_index"), py::arg("origin_cell0_d_index"), py::arg("end_cell0_d_index"))
            .def("cell1_ds_insert_extremes",
                &Gedim::MeshMatricesDAO::Cell1DsInsertExtremes, py::arg("cell1_d_extremes"))
            .def("cell1_ds_extremes",
                [](Gedim::MeshMatricesDAO & self) { return self.Cell1DsExtremes(); })
            .def("cell1_ds_extremes",
                py::overload_cast<const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell1DsExtremes, py::const_), py::arg("cell1_ds"))
            .def("cell1_d_extremes",
                &Gedim::MeshMatricesDAO::Cell1DExtremes,
                py::arg("cell1_d_index"),
                "/ \\return the extrems as Eigen MatrixXi of cell1D, size 2\n/ \\param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()")
            .def("cell1_d_by_extremes",
                &Gedim::MeshMatricesDAO::Cell1DByExtremes, py::arg("origin_cell0_d_index"), py::arg("end_cell0_d_index"))
            .def("cell1_d_set_marker",
                &Gedim::MeshMatricesDAO::Cell1DSetMarker, py::arg("cell1_d_index"), py::arg("marker"))
            .def("cell1_d_set_state",
                &Gedim::MeshMatricesDAO::Cell1DSetState, py::arg("cell1_d_index"), py::arg("state"))
            .def("cell1_ds_neighbour_cell2_ds",
                &Gedim::MeshMatricesDAO::Cell1DsNeighbourCell2Ds)
            .def("cell1_ds_initialize_neighbour_cell2_ds",
                py::overload_cast<const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell1DsInitializeNeighbourCell2Ds), py::arg("number_neighbour_cell2_ds"))
            .def("cell1_ds_initialize_neighbour_cell2_ds",
                py::overload_cast<const unsigned int &>(&Gedim::MeshMatricesDAO::Cell1DsInitializeNeighbourCell2Ds), py::arg("number_neighbour_cell2_ds"))
            .def("cell1_d_initialize_neighbour_cell2_ds",
                py::overload_cast<const unsigned int &, const unsigned int &>(&Gedim::MeshMatricesDAO::Cell1DInitializeNeighbourCell2Ds), py::arg("cell1_d_index"), py::arg("number_neighbour_cell2_ds"))
            .def("cell1_d_initialize_neighbour_cell2_ds",
                py::overload_cast<const unsigned int &, const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell1DInitializeNeighbourCell2Ds), py::arg("cell1_d_index"), py::arg("neighbour_cell2_ds"))
            .def("cell1_d_insert_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell1DInsertNeighbourCell2D, py::arg("cell1_d_index"), py::arg("neighbour_index"), py::arg("neigbour_cell2_d_index"))
            .def("cell1_d_total_number",
                &Gedim::MeshMatricesDAO::Cell1DTotalNumber)
            .def("cell1_d_vertex",
                &Gedim::MeshMatricesDAO::Cell1DVertex, py::arg("cell1_d_index"), py::arg("vertex_index"))
            .def("cell1_d_origin",
                &Gedim::MeshMatricesDAO::Cell1DOrigin, py::arg("cell1_d_index"))
            .def("cell1_d_end",
                &Gedim::MeshMatricesDAO::Cell1DEnd, py::arg("cell1_d_index"))
            .def("cell1_d_find_extreme",
                &Gedim::MeshMatricesDAO::Cell1DFindExtreme, py::arg("cell1_d_index"), py::arg("cell0_d_index"))
            .def("cell1_d_coordinates",
                &Gedim::MeshMatricesDAO::Cell1DCoordinates, py::arg("cell1_d_index"))
            .def("cell1_d_origin_coordinates",
                &Gedim::MeshMatricesDAO::Cell1DOriginCoordinates, py::arg("cell1_d_index"))
            .def("cell1_d_end_coordinates",
                &Gedim::MeshMatricesDAO::Cell1DEndCoordinates, py::arg("cell1_d_index"))
            .def("cell1_d_number_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell1DNumberNeighbourCell2D, py::arg("cell1_d_index"))
            .def("cell1_d_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell1DNeighbourCell2D, py::arg("cell1_d_index"), py::arg("neighbour_index"))
            .def("cell1_d_neighbour_cell2_ds",
                &Gedim::MeshMatricesDAO::Cell1DNeighbourCell2Ds, py::arg("cell1_d_index"))
            .def("cell1_d_has_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell1DHasNeighbourCell2D, py::arg("cell1_d_index"), py::arg("neighbour_index"))
            .def("cell1_d_reset_neighbour_cell2_d",
                &Gedim::MeshMatricesDAO::Cell1DResetNeighbourCell2D, py::arg("cell1_d_index"), py::arg("neighbour_index"))
            .def("cell1_d_marker",
                &Gedim::MeshMatricesDAO::Cell1DMarker, py::arg("cell1_d_index"))
            .def("cell1_ds_marker",
                &Gedim::MeshMatricesDAO::Cell1DsMarker)
            .def("cell1_d_is_active",
                &Gedim::MeshMatricesDAO::Cell1DIsActive, py::arg("cell1_d_index"))
            .def("cell1_d_has_original_cell1_d",
                &Gedim::MeshMatricesDAO::Cell1DHasOriginalCell1D, py::arg("updated_cell1_d_index"))
            .def("cell1_d_original_cell1_d",
                &Gedim::MeshMatricesDAO::Cell1DOriginalCell1D, py::arg("updated_cell1_d_index"))
            .def("cell1_d_has_updated_cell1_ds",
                &Gedim::MeshMatricesDAO::Cell1DHasUpdatedCell1Ds, py::arg("cell1_d_index"))
            .def("cell1_d_number_updated_cell1_ds",
                &Gedim::MeshMatricesDAO::Cell1DNumberUpdatedCell1Ds, py::arg("cell1_d_index"))
            .def("cell1_d_has_updated_cell1_d",
                &Gedim::MeshMatricesDAO::Cell1DHasUpdatedCell1D, py::arg("cell1_d_index"), py::arg("updated_cell1_d_idex"))
            .def("cell1_d_insert_updated_cell1_d",
                &Gedim::MeshMatricesDAO::Cell1DInsertUpdatedCell1D, py::arg("cell1_d_index"), py::arg("updated_cell1_d_idex"))
            .def("cell1_d_updated_cell1_ds",
                &Gedim::MeshMatricesDAO::Cell1DUpdatedCell1Ds, py::arg("cell1_d_index"), py::arg("updated_cell1_d_ids"))
            .def("cell1_d_initialize_double_properties",
                &Gedim::MeshMatricesDAO::Cell1DInitializeDoubleProperties, py::arg("number_double_properties"))
            .def("cell1_ds_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell1DsNeighbourCell3Ds)
            .def("cell1_ds_initialize_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell1DsInitializeNeighbourCell3Ds, py::arg("number_neighbour_cell3_ds"))
            .def("cell1_d_initialize_neighbour_cell3_ds",
                py::overload_cast<const unsigned int &, const unsigned int &>(&Gedim::MeshMatricesDAO::Cell1DInitializeNeighbourCell3Ds), py::arg("cell1_d_index"), py::arg("number_neighbour_cell3_ds"))
            .def("cell1_d_initialize_neighbour_cell3_ds",
                py::overload_cast<const unsigned int &, const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell1DInitializeNeighbourCell3Ds), py::arg("cell1_d_index"), py::arg("neighbour_cell3_ds"))
            .def("cell1_d_insert_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell1DInsertNeighbourCell3D, py::arg("cell1_d_index"), py::arg("neighbour_index"), py::arg("neigbour_cell3_d_index"))
            .def("cell1_d_number_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell1DNumberNeighbourCell3D, py::arg("cell1_d_index"))
            .def("cell1_d_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell1DNeighbourCell3D, py::arg("cell1_d_index"), py::arg("neighbour_index"))
            .def("cell1_d_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell1DNeighbourCell3Ds, py::arg("cell1_d_index"))
            .def("cell1_d_has_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell1DHasNeighbourCell3D, py::arg("cell1_d_index"), py::arg("neighbour_index"))
            .def("cell1_d_reset_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell1DResetNeighbourCell3D, py::arg("cell1_d_index"), py::arg("neighbour_index"))
            .def("cell1_d_add_double_property",
                &Gedim::MeshMatricesDAO::Cell1DAddDoubleProperty, py::arg("property_id"))
            .def("cell1_ds_initialize_double_property_values",
                &Gedim::MeshMatricesDAO::Cell1DsInitializeDoublePropertyValues, py::arg("property_index"), py::arg("property_sizes"))
            .def("cell1_d_initialize_double_property_values",
                &Gedim::MeshMatricesDAO::Cell1DInitializeDoublePropertyValues, py::arg("cell1_d_index"), py::arg("property_index"), py::arg("property_size"))
            .def("cell1_d_insert_double_property_value",
                &Gedim::MeshMatricesDAO::Cell1DInsertDoublePropertyValue, py::arg("cell1_d_index"), py::arg("property_index"), py::arg("property_value_index"), py::arg("property_value"))
            .def("cell1_d_number_double_properties",
                &Gedim::MeshMatricesDAO::Cell1DNumberDoubleProperties)
            .def("cell1_d_double_property_id",
                &Gedim::MeshMatricesDAO::Cell1DDoublePropertyId, py::arg("property_index"))
            .def("cell1_d_double_property_exists",
                &Gedim::MeshMatricesDAO::Cell1DDoublePropertyExists, py::arg("property_id"))
            .def("cell1_d_double_property_index",
                &Gedim::MeshMatricesDAO::Cell1DDoublePropertyIndex, py::arg("property_id"))
            .def("cell1_d_double_property_size",
                &Gedim::MeshMatricesDAO::Cell1DDoublePropertySize, py::arg("cell1_d_index"), py::arg("property_index"))
            .def("cell1_d_double_property_value",
                &Gedim::MeshMatricesDAO::Cell1DDoublePropertyValue, py::arg("cell1_d_index"), py::arg("property_index"), py::arg("property_value_index"))
            .def("cell2_ds_initialize",
                &Gedim::MeshMatricesDAO::Cell2DsInitialize, py::arg("number_cell2_ds"))
            .def("cell2_d_append",
                &Gedim::MeshMatricesDAO::Cell2DAppend, py::arg("number_cell2_ds"))
            .def("cell2_d_remove",
                &Gedim::MeshMatricesDAO::Cell2DRemove, py::arg("cell2_d_index"))
            .def("cell2_d_set_marker",
                &Gedim::MeshMatricesDAO::Cell2DSetMarker, py::arg("cell2_d_index"), py::arg("marker"))
            .def("cell2_d_set_state",
                &Gedim::MeshMatricesDAO::Cell2DSetState, py::arg("cell2_d_index"), py::arg("state"))
            .def("cell2_ds_initialize_vertices",
                py::overload_cast<const unsigned int &>(&Gedim::MeshMatricesDAO::Cell2DsInitializeVertices), py::arg("number_cell2_d_vertices"))
            .def("cell2_ds_initialize_vertices",
                py::overload_cast<const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell2DsInitializeVertices), py::arg("number_cell2_ds_vertices"))
            .def("cell2_d_initialize_vertices",
                &Gedim::MeshMatricesDAO::Cell2DInitializeVertices, py::arg("cell2_d_index"), py::arg("number_cell2_d_vertices"))
            .def("cell2_ds_initialize_edges",
                py::overload_cast<const unsigned int &>(&Gedim::MeshMatricesDAO::Cell2DsInitializeEdges), py::arg("number_cell2_d_edges"))
            .def("cell2_ds_initialize_edges",
                py::overload_cast<const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell2DsInitializeEdges), py::arg("number_cell2_ds_edges"))
            .def("cell2_d_initialize_edges",
                &Gedim::MeshMatricesDAO::Cell2DInitializeEdges, py::arg("cell2_d_index"), py::arg("number_cell2_d_edges"))
            .def("cell2_d_insert_vertices",
                &Gedim::MeshMatricesDAO::Cell2DInsertVertices, py::arg("cell2_d_index"), py::arg("vertices_cell0_d_indices"))
            .def("cell2_d_insert_vertex",
                &Gedim::MeshMatricesDAO::Cell2DInsertVertex, py::arg("cell2_d_index"), py::arg("vertex_index"), py::arg("vertex_cell0_d_index"))
            .def("cell2_d_insert_edges",
                &Gedim::MeshMatricesDAO::Cell2DInsertEdges, py::arg("cell2_d_index"), py::arg("edges_cell1_d_indices"))
            .def("cell2_d_insert_edge",
                &Gedim::MeshMatricesDAO::Cell2DInsertEdge, py::arg("cell2_d_index"), py::arg("edge_index"), py::arg("edge_cell1_d_index"))
            .def("cell2_d_add_vertices",
                &Gedim::MeshMatricesDAO::Cell2DAddVertices, py::arg("cell2_d_index"), py::arg("vertices_cell0_d_indices"))
            .def("cell2_d_add_edges",
                &Gedim::MeshMatricesDAO::Cell2DAddEdges, py::arg("cell2_d_index"), py::arg("edges_cell1_d_indices"))
            .def("cell2_d_add_vertices_and_edges",
                &Gedim::MeshMatricesDAO::Cell2DAddVerticesAndEdges, py::arg("cell2_d_index"), py::arg("vertices_and_edges_indices"))
            .def("cell2_d_total_number",
                &Gedim::MeshMatricesDAO::Cell2DTotalNumber)
            .def("cell2_d_number_vertices",
                &Gedim::MeshMatricesDAO::Cell2DNumberVertices, py::arg("cell2_d_index"))
            .def("cell2_d_number_edges",
                &Gedim::MeshMatricesDAO::Cell2DNumberEdges, py::arg("cell2_d_index"))
            .def("cell2_d_vertices",
                &Gedim::MeshMatricesDAO::Cell2DVertices, py::arg("cell2_d_index"))
            .def("cell2_ds_vertices",
                &Gedim::MeshMatricesDAO::Cell2DsVertices)
            .def("cell2_ds_extremes",
                &Gedim::MeshMatricesDAO::Cell2DsExtremes)
            .def("cell2_d_vertex",
                &Gedim::MeshMatricesDAO::Cell2DVertex, py::arg("cell2_d_index"), py::arg("vertex_index"))
            .def("cell2_d_vertex_coordinates",
                &Gedim::MeshMatricesDAO::Cell2DVertexCoordinates, py::arg("cell2_d_index"), py::arg("vertex_index"))
            .def("cell2_d_vertices_coordinates",
                &Gedim::MeshMatricesDAO::Cell2DVerticesCoordinates, py::arg("cell2_d_index"))
            .def("cell2_d_find_vertex",
                &Gedim::MeshMatricesDAO::Cell2DFindVertex, py::arg("cell2_d_index"), py::arg("cell0_d_index"))
            .def("cell2_d_edges",
                &Gedim::MeshMatricesDAO::Cell2DEdges, py::arg("cell2_d_index"))
            .def("cell2_d_edge",
                &Gedim::MeshMatricesDAO::Cell2DEdge, py::arg("cell2_d_index"), py::arg("edge_index"))
            .def("cell2_d_find_edge",
                &Gedim::MeshMatricesDAO::Cell2DFindEdge, py::arg("cell2_d_index"), py::arg("cell1_d_index"))
            .def("cell2_d_find_edge_by_extremes",
                &Gedim::MeshMatricesDAO::Cell2DFindEdgeByExtremes, py::arg("cell2_d_index"), py::arg("origin_cell0_d_index"), py::arg("end_cell0_d_index"))
            .def("cell2_d_marker",
                &Gedim::MeshMatricesDAO::Cell2DMarker, py::arg("cell2_d_index"))
            .def("cell2_ds_marker",
                &Gedim::MeshMatricesDAO::Cell2DsMarker)
            .def("cell2_d_is_active",
                &Gedim::MeshMatricesDAO::Cell2DIsActive, py::arg("cell2_d_index"))
            .def("cell2_d_has_updated_cell2_ds",
                &Gedim::MeshMatricesDAO::Cell2DHasUpdatedCell2Ds, py::arg("cell2_d_index"))
            .def("cell2_d_number_updated_cell2_ds",
                &Gedim::MeshMatricesDAO::Cell2DNumberUpdatedCell2Ds, py::arg("cell2_d_index"))
            .def("cell2_d_has_updated_cell2_d",
                &Gedim::MeshMatricesDAO::Cell2DHasUpdatedCell2D, py::arg("cell2_d_index"), py::arg("updated_cell2_d_index"))
            .def("cell2_d_insert_updated_cell2_d",
                &Gedim::MeshMatricesDAO::Cell2DInsertUpdatedCell2D, py::arg("cell2_d_index"), py::arg("updated_cell2_d_idex"))
            .def("cell2_d_has_original_cell2_d",
                &Gedim::MeshMatricesDAO::Cell2DHasOriginalCell2D, py::arg("updated_cell2_d_index"))
            .def("cell2_d_original_cell2_d",
                &Gedim::MeshMatricesDAO::Cell2DOriginalCell2D, py::arg("updated_cell2_d_index"))
            .def("cell2_d_updated_cell2_ds",
                &Gedim::MeshMatricesDAO::Cell2DUpdatedCell2Ds, py::arg("cell2_d_index"), py::arg("updated_cell2_d_ids"))
            .def("cell2_ds_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell2DsNeighbourCell3Ds)
            .def("cell2_ds_initialize_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell2DsInitializeNeighbourCell3Ds, py::arg("number_neighbour_cell3_ds"))
            .def("cell2_d_initialize_neighbour_cell3_ds",
                py::overload_cast<const unsigned int &, const unsigned int &>(&Gedim::MeshMatricesDAO::Cell2DInitializeNeighbourCell3Ds), py::arg("cell2_d_index"), py::arg("number_neighbour_cell3_ds"))
            .def("cell2_d_initialize_neighbour_cell3_ds",
                py::overload_cast<const unsigned int &, const std::vector<unsigned int> &>(&Gedim::MeshMatricesDAO::Cell2DInitializeNeighbourCell3Ds), py::arg("cell2_d_index"), py::arg("neighbour_cell3_ds"))
            .def("cell2_d_insert_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell2DInsertNeighbourCell3D, py::arg("cell2_d_index"), py::arg("neighbour_index"), py::arg("neigbour_cell3_d_index"))
            .def("cell2_d_number_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell2DNumberNeighbourCell3D, py::arg("cell2_d_index"))
            .def("cell2_d_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell2DNeighbourCell3D, py::arg("cell2_d_index"), py::arg("neighbour_index"))
            .def("cell2_d_neighbour_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell2DNeighbourCell3Ds, py::arg("cell2_d_index"))
            .def("cell2_d_has_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell2DHasNeighbourCell3D, py::arg("cell2_d_index"), py::arg("neighbour_index"))
            .def("cell2_d_reset_neighbour_cell3_d",
                &Gedim::MeshMatricesDAO::Cell2DResetNeighbourCell3D, py::arg("cell2_d_index"), py::arg("neighbour_index"))
            .def("cell2_d_initialize_double_properties",
                &Gedim::MeshMatricesDAO::Cell2DInitializeDoubleProperties, py::arg("number_double_properties"))
            .def("cell2_d_add_double_property",
                &Gedim::MeshMatricesDAO::Cell2DAddDoubleProperty, py::arg("property_id"))
            .def("cell2_ds_initialize_double_property_values",
                &Gedim::MeshMatricesDAO::Cell2DsInitializeDoublePropertyValues, py::arg("property_index"), py::arg("property_sizes"))
            .def("cell2_d_initialize_double_property_values",
                &Gedim::MeshMatricesDAO::Cell2DInitializeDoublePropertyValues, py::arg("cell2_d_index"), py::arg("property_index"), py::arg("property_size"))
            .def("cell2_d_insert_double_property_value",
                &Gedim::MeshMatricesDAO::Cell2DInsertDoublePropertyValue, py::arg("cell2_d_index"), py::arg("property_index"), py::arg("property_value_index"), py::arg("property_value"))
            .def("cell2_d_number_double_properties",
                &Gedim::MeshMatricesDAO::Cell2DNumberDoubleProperties)
            .def("cell2_d_double_property_id",
                &Gedim::MeshMatricesDAO::Cell2DDoublePropertyId, py::arg("property_index"))
            .def("cell2_d_double_property_exists",
                &Gedim::MeshMatricesDAO::Cell2DDoublePropertyExists, py::arg("property_id"))
            .def("cell2_d_double_property_index",
                &Gedim::MeshMatricesDAO::Cell2DDoublePropertyIndex, py::arg("property_id"))
            .def("cell2_d_double_property_size",
                &Gedim::MeshMatricesDAO::Cell2DDoublePropertySize, py::arg("cell2_d_index"), py::arg("property_index"))
            .def("cell2_d_double_property_value",
                &Gedim::MeshMatricesDAO::Cell2DDoublePropertyValue, py::arg("cell2_d_index"), py::arg("property_index"), py::arg("property_value_index"))
            .def("cell2_ds_initialize_sub_division",
                &Gedim::MeshMatricesDAO::Cell2DsInitializeSubDivision, py::arg("number_sub_divisions"))
            .def("cell2_d_initialize_sub_division",
                &Gedim::MeshMatricesDAO::Cell2DInitializeSubDivision, py::arg("cell2_d_index"), py::arg("number_sub_division"))
            .def("cell2_d_insert_sub_division",
                &Gedim::MeshMatricesDAO::Cell2DInsertSubDivision, py::arg("cell2_d_index"), py::arg("sub_division_index"), py::arg("cell0_d_index"))
            .def("cell2_d_number_sub_division",
                &Gedim::MeshMatricesDAO::Cell2DNumberSubDivision, py::arg("cell2_d_index"))
            .def("cell2_d_sub_division_cell0_d",
                &Gedim::MeshMatricesDAO::Cell2DSubDivisionCell0D, py::arg("cell2_d_index"), py::arg("sub_division_index"))
            .def("cell3_ds_initialize",
                &Gedim::MeshMatricesDAO::Cell3DsInitialize, py::arg("number_cell3_ds"))
            .def("cell3_d_append",
                &Gedim::MeshMatricesDAO::Cell3DAppend, py::arg("number_cell3_ds"))
            .def("cell3_d_remove",
                &Gedim::MeshMatricesDAO::Cell3DRemove, py::arg("cell3_d_index"))
            .def("cell3_d_set_marker",
                &Gedim::MeshMatricesDAO::Cell3DSetMarker, py::arg("cell3_d_index"), py::arg("marker"))
            .def("cell3_d_set_state",
                &Gedim::MeshMatricesDAO::Cell3DSetState, py::arg("cell3_d_index"), py::arg("state"))
            .def("cell3_ds_initialize_vertices",
                &Gedim::MeshMatricesDAO::Cell3DsInitializeVertices, py::arg("number_cell3_ds_vertices"))
            .def("cell3_ds_initialize_edges",
                &Gedim::MeshMatricesDAO::Cell3DsInitializeEdges, py::arg("number_cell3_ds_edges"))
            .def("cell3_ds_initialize_faces",
                &Gedim::MeshMatricesDAO::Cell3DsInitializeFaces, py::arg("number_cell3_ds_faces"))
            .def("cell3_d_initialize_vertices",
                &Gedim::MeshMatricesDAO::Cell3DInitializeVertices, py::arg("cell3_d_index"), py::arg("number_cell3_d_vertices"))
            .def("cell3_d_initialize_edges",
                &Gedim::MeshMatricesDAO::Cell3DInitializeEdges, py::arg("cell3_d_index"), py::arg("number_cell3_d_edges"))
            .def("cell3_d_initialize_faces",
                &Gedim::MeshMatricesDAO::Cell3DInitializeFaces, py::arg("cell3_d_index"), py::arg("number_cell3_d_faces"))
            .def("cell3_d_insert_vertex",
                &Gedim::MeshMatricesDAO::Cell3DInsertVertex, py::arg("cell3_d_index"), py::arg("vertex_index"), py::arg("vertex_cell0_d_index"))
            .def("cell3_d_insert_edge",
                &Gedim::MeshMatricesDAO::Cell3DInsertEdge, py::arg("cell3_d_index"), py::arg("edge_index"), py::arg("edge_cell1_d_index"))
            .def("cell3_d_insert_face",
                &Gedim::MeshMatricesDAO::Cell3DInsertFace, py::arg("cell3_d_index"), py::arg("face_index"), py::arg("face_cell2_d_index"))
            .def("cell3_d_add_vertices",
                &Gedim::MeshMatricesDAO::Cell3DAddVertices, py::arg("cell3_d_index"), py::arg("vertices_cell0_d_indices"))
            .def("cell3_d_add_edges",
                &Gedim::MeshMatricesDAO::Cell3DAddEdges, py::arg("cell3_d_index"), py::arg("edges_cell1_d_indices"))
            .def("cell3_d_add_faces",
                &Gedim::MeshMatricesDAO::Cell3DAddFaces, py::arg("cell3_d_index"), py::arg("faces_cell2_d_indices"))
            .def("cell3_d_find_vertex",
                &Gedim::MeshMatricesDAO::Cell3DFindVertex, py::arg("cell3_d_index"), py::arg("cell0_d_index"))
            .def("cell3_d_find_edge",
                &Gedim::MeshMatricesDAO::Cell3DFindEdge, py::arg("cell3_d_index"), py::arg("cell1_d_index"))
            .def("cell3_d_find_face",
                &Gedim::MeshMatricesDAO::Cell3DFindFace, py::arg("cell3_d_index"), py::arg("cell2_d_index"))
            .def("cell3_d_find_edge_by_extremes",
                &Gedim::MeshMatricesDAO::Cell3DFindEdgeByExtremes, py::arg("cell3_d_index"), py::arg("origin_cell0_d_index"), py::arg("end_cell0_d_index"))
            .def("cell3_d_total_number",
                &Gedim::MeshMatricesDAO::Cell3DTotalNumber)
            .def("cell3_d_number_vertices",
                &Gedim::MeshMatricesDAO::Cell3DNumberVertices, py::arg("cell3_d_index"))
            .def("cell3_d_number_edges",
                &Gedim::MeshMatricesDAO::Cell3DNumberEdges, py::arg("cell3_d_index"))
            .def("cell3_d_number_faces",
                &Gedim::MeshMatricesDAO::Cell3DNumberFaces, py::arg("cell3_d_index"))
            .def("cell3_d_vertices",
                &Gedim::MeshMatricesDAO::Cell3DVertices, py::arg("cell3_d_index"))
            .def("cell3_d_vertex",
                &Gedim::MeshMatricesDAO::Cell3DVertex, py::arg("cell3_d_index"), py::arg("vertex_index"))
            .def("cell3_d_vertex_coordinates",
                &Gedim::MeshMatricesDAO::Cell3DVertexCoordinates, py::arg("cell3_d_index"), py::arg("vertex_index"))
            .def("cell3_d_vertices_coordinates",
                &Gedim::MeshMatricesDAO::Cell3DVerticesCoordinates, py::arg("cell3_d_index"))
            .def("cell3_d_edges",
                &Gedim::MeshMatricesDAO::Cell3DEdges, py::arg("cell3_d_index"))
            .def("cell3_d_edge",
                &Gedim::MeshMatricesDAO::Cell3DEdge, py::arg("cell3_d_index"), py::arg("edge_index"))
            .def("cell3_d_faces",
                &Gedim::MeshMatricesDAO::Cell3DFaces, py::arg("cell3_d_index"))
            .def("cell3_d_face",
                &Gedim::MeshMatricesDAO::Cell3DFace, py::arg("cell3_d_index"), py::arg("face_index"))
            .def("cell3_ds_faces_vertices",
                &Gedim::MeshMatricesDAO::Cell3DsFacesVertices)
            .def("cell3_ds_vertices",
                &Gedim::MeshMatricesDAO::Cell3DsVertices)
            .def("cell3_ds_edges",
                &Gedim::MeshMatricesDAO::Cell3DsEdges)
            .def("cell3_ds_faces",
                &Gedim::MeshMatricesDAO::Cell3DsFaces)
            .def("cell3_d_marker",
                &Gedim::MeshMatricesDAO::Cell3DMarker, py::arg("cell3_d_index"))
            .def("cell3_ds_marker",
                &Gedim::MeshMatricesDAO::Cell3DsMarker)
            .def("cell3_d_is_active",
                &Gedim::MeshMatricesDAO::Cell3DIsActive, py::arg("cell3_d_index"))
            .def("cell3_d_has_updated_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell3DHasUpdatedCell3Ds, py::arg("cell3_d_index"))
            .def("cell3_d_number_updated_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell3DNumberUpdatedCell3Ds, py::arg("cell3_d_index"))
            .def("cell3_d_has_updated_cell3_d",
                &Gedim::MeshMatricesDAO::Cell3DHasUpdatedCell3D, py::arg("cell3_d_index"), py::arg("updated_cell3_d_idex"))
            .def("cell3_d_insert_updated_cell3_d",
                &Gedim::MeshMatricesDAO::Cell3DInsertUpdatedCell3D, py::arg("cell3_d_index"), py::arg("updated_cell3_d_idex"))
            .def("cell3_d_updated_cell3_ds",
                &Gedim::MeshMatricesDAO::Cell3DUpdatedCell3Ds, py::arg("cell3_d_index"), py::arg("updated_cell3_d_ids"))
            .def("cell3_d_has_original_cell3_d",
                &Gedim::MeshMatricesDAO::Cell3DHasOriginalCell3D, py::arg("updated_cell3_d_index"))
            .def("cell3_d_original_cell3_d",
                &Gedim::MeshMatricesDAO::Cell3DOriginalCell3D, py::arg("updated_cell3_d_index"))
            .def("cell3_d_initialize_double_properties",
                &Gedim::MeshMatricesDAO::Cell3DInitializeDoubleProperties, py::arg("number_double_properties"))
            .def("cell3_d_add_double_property",
                &Gedim::MeshMatricesDAO::Cell3DAddDoubleProperty, py::arg("property_id"))
            .def("cell3_ds_initialize_double_property_values",
                &Gedim::MeshMatricesDAO::Cell3DsInitializeDoublePropertyValues, py::arg("property_index"), py::arg("property_sizes"))
            .def("cell3_d_initialize_double_property_values",
                &Gedim::MeshMatricesDAO::Cell3DInitializeDoublePropertyValues, py::arg("cell3_d_index"), py::arg("property_index"), py::arg("property_size"))
            .def("cell3_d_insert_double_property_value",
                &Gedim::MeshMatricesDAO::Cell3DInsertDoublePropertyValue, py::arg("cell3_d_index"), py::arg("property_index"), py::arg("property_value_index"), py::arg("property_value"))
            .def("cell3_d_number_double_properties",
                &Gedim::MeshMatricesDAO::Cell3DNumberDoubleProperties)
            .def("cell3_d_double_property_id",
                &Gedim::MeshMatricesDAO::Cell3DDoublePropertyId, py::arg("property_index"))
            .def("cell3_d_double_property_exists",
                &Gedim::MeshMatricesDAO::Cell3DDoublePropertyExists, py::arg("property_id"))
            .def("cell3_d_double_property_index",
                &Gedim::MeshMatricesDAO::Cell3DDoublePropertyIndex, py::arg("property_id"))
            .def("cell3_d_double_property_size",
                &Gedim::MeshMatricesDAO::Cell3DDoublePropertySize, py::arg("cell3_d_index"), py::arg("property_index"))
            .def("cell3_d_double_property_value",
                &Gedim::MeshMatricesDAO::Cell3DDoublePropertyValue, py::arg("cell3_d_index"), py::arg("property_index"), py::arg("property_value_index"))
            .def("compress",
                &Gedim::MeshMatricesDAO::Compress)
            .def("to_string",
                &Gedim::MeshMatricesDAO::ToString)
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MeshMatricesDAO.hpp>    ////////////////////


    ////////////////////    <generated_from:MeshUtilities.hpp>    ////////////////////
    // #ifndef __MeshUtilities_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassMeshUtilities =
            py::class_<Gedim::MeshUtilities>
                (pyNsGedim, "MeshUtilities", py::is_final(), "/ \\brief MeshUtilities\n/ \\copyright See top level LICENSE file for details.\n(final class)");

        { // inner classes & enums of MeshUtilities
            auto pyNsGedim_ClassMeshUtilities_ClassCheckMesh2DConfiguration =
                py::class_<Gedim::MeshUtilities::CheckMesh2DConfiguration>
                    (pyNsGedim_ClassMeshUtilities, "CheckMesh2DConfiguration", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                bool Cell0D_CheckCoordinates2D = true, bool Cell0D_CheckDuplications = true, bool Cell1D_CheckDuplications = true, bool Cell1D_CheckNeighbours = true, bool Cell1D_CheckMeasure = true, bool Cell2D_CheckEdges = true, bool Cell2D_CheckDuplications = true, bool Cell2D_CheckConvexity = true, bool Cell2D_CheckMeasure = true)
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::CheckMesh2DConfiguration>();
                    r_ctor_->Cell0D_CheckCoordinates2D = Cell0D_CheckCoordinates2D;
                    r_ctor_->Cell0D_CheckDuplications = Cell0D_CheckDuplications;
                    r_ctor_->Cell1D_CheckDuplications = Cell1D_CheckDuplications;
                    r_ctor_->Cell1D_CheckNeighbours = Cell1D_CheckNeighbours;
                    r_ctor_->Cell1D_CheckMeasure = Cell1D_CheckMeasure;
                    r_ctor_->Cell2D_CheckEdges = Cell2D_CheckEdges;
                    r_ctor_->Cell2D_CheckDuplications = Cell2D_CheckDuplications;
                    r_ctor_->Cell2D_CheckConvexity = Cell2D_CheckConvexity;
                    r_ctor_->Cell2D_CheckMeasure = Cell2D_CheckMeasure;
                    return r_ctor_;
                })
                , py::arg("cell0_d_check_coordinates2_d") = true, py::arg("cell0_d_check_duplications") = true, py::arg("cell1_d_check_duplications") = true, py::arg("cell1_d_check_neighbours") = true, py::arg("cell1_d_check_measure") = true, py::arg("cell2_d_check_edges") = true, py::arg("cell2_d_check_duplications") = true, py::arg("cell2_d_check_convexity") = true, py::arg("cell2_d_check_measure") = true
                )
                .def_readwrite("cell0_d_check_coordinates2_d", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell0D_CheckCoordinates2D, "")
                .def_readwrite("cell0_d_check_duplications", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell0D_CheckDuplications, "")
                .def_readwrite("cell1_d_check_duplications", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell1D_CheckDuplications, "")
                .def_readwrite("cell1_d_check_neighbours", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell1D_CheckNeighbours, "")
                .def_readwrite("cell1_d_check_measure", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell1D_CheckMeasure, "")
                .def_readwrite("cell2_d_check_edges", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell2D_CheckEdges, "")
                .def_readwrite("cell2_d_check_duplications", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell2D_CheckDuplications, "")
                .def_readwrite("cell2_d_check_convexity", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell2D_CheckConvexity, "")
                .def_readwrite("cell2_d_check_measure", &Gedim::MeshUtilities::CheckMesh2DConfiguration::Cell2D_CheckMeasure, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassCheckMesh3DConfiguration =
                py::class_<Gedim::MeshUtilities::CheckMesh3DConfiguration>
                    (pyNsGedim_ClassMeshUtilities, "CheckMesh3DConfiguration", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                bool Cell0D_CheckDuplications = true, bool Cell1D_CheckDuplications = true, bool Cell1D_CheckMeasure = true, bool Cell2D_CheckEdges = true, bool Cell2D_CheckDuplications = true, bool Cell2D_CheckConvexity = true, bool Cell2D_CheckMeasure = true, bool Cell3D_CheckDuplications = true, bool Cell3D_CheckEdges = true, bool Cell3D_CheckEdgesAreActive = true, bool Cell3D_CheckConvexity = true, bool Cell3D_CheckMeasure = true)
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::CheckMesh3DConfiguration>();
                    r_ctor_->Cell0D_CheckDuplications = Cell0D_CheckDuplications;
                    r_ctor_->Cell1D_CheckDuplications = Cell1D_CheckDuplications;
                    r_ctor_->Cell1D_CheckMeasure = Cell1D_CheckMeasure;
                    r_ctor_->Cell2D_CheckEdges = Cell2D_CheckEdges;
                    r_ctor_->Cell2D_CheckDuplications = Cell2D_CheckDuplications;
                    r_ctor_->Cell2D_CheckConvexity = Cell2D_CheckConvexity;
                    r_ctor_->Cell2D_CheckMeasure = Cell2D_CheckMeasure;
                    r_ctor_->Cell3D_CheckDuplications = Cell3D_CheckDuplications;
                    r_ctor_->Cell3D_CheckEdges = Cell3D_CheckEdges;
                    r_ctor_->Cell3D_CheckEdgesAreActive = Cell3D_CheckEdgesAreActive;
                    r_ctor_->Cell3D_CheckConvexity = Cell3D_CheckConvexity;
                    r_ctor_->Cell3D_CheckMeasure = Cell3D_CheckMeasure;
                    return r_ctor_;
                })
                , py::arg("cell0_d_check_duplications") = true, py::arg("cell1_d_check_duplications") = true, py::arg("cell1_d_check_measure") = true, py::arg("cell2_d_check_edges") = true, py::arg("cell2_d_check_duplications") = true, py::arg("cell2_d_check_convexity") = true, py::arg("cell2_d_check_measure") = true, py::arg("cell3_d_check_duplications") = true, py::arg("cell3_d_check_edges") = true, py::arg("cell3_d_check_edges_are_active") = true, py::arg("cell3_d_check_convexity") = true, py::arg("cell3_d_check_measure") = true
                )
                .def_readwrite("cell0_d_check_duplications", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell0D_CheckDuplications, "")
                .def_readwrite("cell1_d_check_duplications", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell1D_CheckDuplications, "")
                .def_readwrite("cell1_d_check_measure", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell1D_CheckMeasure, "")
                .def_readwrite("cell2_d_check_edges", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell2D_CheckEdges, "")
                .def_readwrite("cell2_d_check_duplications", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell2D_CheckDuplications, "")
                .def_readwrite("cell2_d_check_convexity", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell2D_CheckConvexity, "")
                .def_readwrite("cell2_d_check_measure", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell2D_CheckMeasure, "")
                .def_readwrite("cell3_d_check_duplications", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell3D_CheckDuplications, "")
                .def_readwrite("cell3_d_check_edges", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell3D_CheckEdges, "")
                .def_readwrite("cell3_d_check_edges_are_active", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell3D_CheckEdgesAreActive, "")
                .def_readwrite("cell3_d_check_convexity", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell3D_CheckConvexity, "")
                .def_readwrite("cell3_d_check_measure", &Gedim::MeshUtilities::CheckMesh3DConfiguration::Cell3D_CheckMeasure, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassCheckMeshGeometricData2DConfiguration =
                py::class_<Gedim::MeshUtilities::CheckMeshGeometricData2DConfiguration>
                    (pyNsGedim_ClassMeshUtilities, "CheckMeshGeometricData2DConfiguration", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                bool Cell1D_CheckMeasure = true, bool Cell1D_CheckNormals = true, bool Cell2D_CheckMeasure = true, bool Cell2D_CheckTriangles = true)
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::CheckMeshGeometricData2DConfiguration>();
                    r_ctor_->Cell1D_CheckMeasure = Cell1D_CheckMeasure;
                    r_ctor_->Cell1D_CheckNormals = Cell1D_CheckNormals;
                    r_ctor_->Cell2D_CheckMeasure = Cell2D_CheckMeasure;
                    r_ctor_->Cell2D_CheckTriangles = Cell2D_CheckTriangles;
                    return r_ctor_;
                })
                , py::arg("cell1_d_check_measure") = true, py::arg("cell1_d_check_normals") = true, py::arg("cell2_d_check_measure") = true, py::arg("cell2_d_check_triangles") = true
                )
                .def_readwrite("cell1_d_check_measure", &Gedim::MeshUtilities::CheckMeshGeometricData2DConfiguration::Cell1D_CheckMeasure, "")
                .def_readwrite("cell1_d_check_normals", &Gedim::MeshUtilities::CheckMeshGeometricData2DConfiguration::Cell1D_CheckNormals, "")
                .def_readwrite("cell2_d_check_measure", &Gedim::MeshUtilities::CheckMeshGeometricData2DConfiguration::Cell2D_CheckMeasure, "")
                .def_readwrite("cell2_d_check_triangles", &Gedim::MeshUtilities::CheckMeshGeometricData2DConfiguration::Cell2D_CheckTriangles, "")
                .def_readwrite("cell1_d_quadrature_order", &Gedim::MeshUtilities::CheckMeshGeometricData2DConfiguration::Cell1D_QuadratureOrder, "")
                .def_readwrite("cell2_d_quadrature_order", &Gedim::MeshUtilities::CheckMeshGeometricData2DConfiguration::Cell2D_QuadratureOrder, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassCheckMeshGeometricData3DConfiguration =
                py::class_<Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration>
                    (pyNsGedim_ClassMeshUtilities, "CheckMeshGeometricData3DConfiguration", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                bool Cell1D_CheckMeasure = true, bool Cell1D_CheckNormals = true, bool Cell2D_CheckMeasure = true, bool Cell2D_CheckTriangles = true, bool Cell2D_CheckNormals = true, bool Cell3D_CheckMeasure = true, bool Cell3D_CheckTetrahedra = true)
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration>();
                    r_ctor_->Cell1D_CheckMeasure = Cell1D_CheckMeasure;
                    r_ctor_->Cell1D_CheckNormals = Cell1D_CheckNormals;
                    r_ctor_->Cell2D_CheckMeasure = Cell2D_CheckMeasure;
                    r_ctor_->Cell2D_CheckTriangles = Cell2D_CheckTriangles;
                    r_ctor_->Cell2D_CheckNormals = Cell2D_CheckNormals;
                    r_ctor_->Cell3D_CheckMeasure = Cell3D_CheckMeasure;
                    r_ctor_->Cell3D_CheckTetrahedra = Cell3D_CheckTetrahedra;
                    return r_ctor_;
                })
                , py::arg("cell1_d_check_measure") = true, py::arg("cell1_d_check_normals") = true, py::arg("cell2_d_check_measure") = true, py::arg("cell2_d_check_triangles") = true, py::arg("cell2_d_check_normals") = true, py::arg("cell3_d_check_measure") = true, py::arg("cell3_d_check_tetrahedra") = true
                )
                .def_readwrite("cell1_d_check_measure", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell1D_CheckMeasure, "")
                .def_readwrite("cell1_d_check_normals", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell1D_CheckNormals, "")
                .def_readwrite("cell2_d_check_measure", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell2D_CheckMeasure, "")
                .def_readwrite("cell2_d_check_triangles", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell2D_CheckTriangles, "")
                .def_readwrite("cell2_d_check_normals", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell2D_CheckNormals, "")
                .def_readwrite("cell3_d_check_measure", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell3D_CheckMeasure, "")
                .def_readwrite("cell3_d_check_tetrahedra", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell3D_CheckTetrahedra, "")
                .def_readwrite("cell1_d_quadrature_order", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell1D_QuadratureOrder, "")
                .def_readwrite("cell2_d_quadrature_order", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell2D_QuadratureOrder, "")
                .def_readwrite("cell3_d_quadrature_order", &Gedim::MeshUtilities::CheckMeshGeometricData3DConfiguration::Cell3D_QuadratureOrder, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassExtractActiveMeshData =
                py::class_<Gedim::MeshUtilities::ExtractActiveMeshData>
                    (pyNsGedim_ClassMeshUtilities, "ExtractActiveMeshData", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("old_cell0_d_to_new_cell0_d", &Gedim::MeshUtilities::ExtractActiveMeshData::OldCell0DToNewCell0D, "/< each pair is {old Cell0D index, new")
                .def_readwrite("old_cell1_d_to_new_cell1_d", &Gedim::MeshUtilities::ExtractActiveMeshData::OldCell1DToNewCell1D, "/< each pair is {old Cell1D index, new")
                .def_readwrite("old_cell2_d_to_new_cell2_d", &Gedim::MeshUtilities::ExtractActiveMeshData::OldCell2DToNewCell2D, "/< each pair is {old Cell2D index, new")
                .def_readwrite("old_cell3_d_to_new_cell3_d", &Gedim::MeshUtilities::ExtractActiveMeshData::OldCell3DToNewCell3D, "/< each pair is {old Cell3D index, new")
                .def_readwrite("new_cell0_d_to_old_cell0_d", &Gedim::MeshUtilities::ExtractActiveMeshData::NewCell0DToOldCell0D, "/< each pair is {new Cell0D index, old")
                .def_readwrite("new_cell1_d_to_old_cell1_d", &Gedim::MeshUtilities::ExtractActiveMeshData::NewCell1DToOldCell1D, "/< each pair is {new Cell1D index, old")
                .def_readwrite("new_cell2_d_to_old_cell2_d", &Gedim::MeshUtilities::ExtractActiveMeshData::NewCell2DToOldCell2D, "/< each pair is {new Cell2D index, old")
                .def_readwrite("new_cell3_d_to_old_cell3_d", &Gedim::MeshUtilities::ExtractActiveMeshData::NewCell3DToOldCell3D, "/< each pair is {new Cell3D index, old")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassFilterMeshData =
                py::class_<Gedim::MeshUtilities::FilterMeshData>
                    (pyNsGedim_ClassMeshUtilities, "FilterMeshData", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("cell0_ds", &Gedim::MeshUtilities::FilterMeshData::Cell0Ds, "")
                .def_readwrite("cell1_ds", &Gedim::MeshUtilities::FilterMeshData::Cell1Ds, "")
                .def_readwrite("cell2_ds", &Gedim::MeshUtilities::FilterMeshData::Cell2Ds, "")
                .def_readwrite("cell3_ds", &Gedim::MeshUtilities::FilterMeshData::Cell3Ds, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassExtractMeshData =
                py::class_<Gedim::MeshUtilities::ExtractMeshData>
                    (pyNsGedim_ClassMeshUtilities, "ExtractMeshData", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("old_cell0_d_to_new_cell0_d", &Gedim::MeshUtilities::ExtractMeshData::OldCell0DToNewCell0D, "/< each element is [old Cell0D index] = new Cell0D index")
                .def_readwrite("old_cell1_d_to_new_cell1_d", &Gedim::MeshUtilities::ExtractMeshData::OldCell1DToNewCell1D, "/< each element is [old Cell1D index] = new Cell1D index")
                .def_readwrite("old_cell2_d_to_new_cell2_d", &Gedim::MeshUtilities::ExtractMeshData::OldCell2DToNewCell2D, "/< each element is [old Cell2D index] = new Cell2D index")
                .def_readwrite("old_cell3_d_to_new_cell3_d", &Gedim::MeshUtilities::ExtractMeshData::OldCell3DToNewCell3D, "/< each element is [old Cell3D index] = new Cell3D index")
                .def_readwrite("new_cell0_d_to_old_cell0_d", &Gedim::MeshUtilities::ExtractMeshData::NewCell0DToOldCell0D, "/< each element is [new Cell0D index] = old Cell0D index")
                .def_readwrite("new_cell1_d_to_old_cell1_d", &Gedim::MeshUtilities::ExtractMeshData::NewCell1DToOldCell1D, "/< each element is [new Cell1D index] = old Cell1D index")
                .def_readwrite("new_cell2_d_to_old_cell2_d", &Gedim::MeshUtilities::ExtractMeshData::NewCell2DToOldCell2D, "/< each element is [new Cell2D index] = old Cell2D index")
                .def_readwrite("new_cell3_d_to_old_cell3_d", &Gedim::MeshUtilities::ExtractMeshData::NewCell3DToOldCell3D, "/< each element is [new Cell3D index] = old Cell3D index")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassComputeMesh2DCell1DsResult =
                py::class_<Gedim::MeshUtilities::ComputeMesh2DCell1DsResult>
                    (pyNsGedim_ClassMeshUtilities, "ComputeMesh2DCell1DsResult", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXi Cell1Ds = Eigen::MatrixXi(), std::vector<Eigen::MatrixXi> Cell2Ds = std::vector<Eigen::MatrixXi>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::ComputeMesh2DCell1DsResult>();
                    r_ctor_->Cell1Ds = Cell1Ds;
                    r_ctor_->Cell2Ds = Cell2Ds;
                    return r_ctor_;
                })
                , py::arg("cell1_ds") = Eigen::MatrixXi(), py::arg("cell2_ds") = std::vector<Eigen::MatrixXi>()
                )
                .def_readwrite("cell1_ds", &Gedim::MeshUtilities::ComputeMesh2DCell1DsResult::Cell1Ds, "/ Cell1Ds vertices, size 2 x Cell1DTotalNumber()")
                .def_readwrite("cell2_ds", &Gedim::MeshUtilities::ComputeMesh2DCell1DsResult::Cell2Ds, "/< Cell2Ds vertices and edges, size")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassComputeMesh3DAlignedCell1DsResult =
                py::class_<Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult>
                    (pyNsGedim_ClassMeshUtilities, "ComputeMesh3DAlignedCell1DsResult", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXi AlignedCell1Ds = Eigen::MatrixXi(), std::vector<Eigen::MatrixXi> Cell0DsAlignedCell1DsIndex = std::vector<Eigen::MatrixXi>(), std::vector<Eigen::MatrixXi> Cell1DsAlignedCell1DsIndex = std::vector<Eigen::MatrixXi>(), std::vector<Eigen::MatrixXi> Cell3DsAlignedCell1DsIndex = std::vector<Eigen::MatrixXi>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult>();
                    r_ctor_->AlignedCell1Ds = AlignedCell1Ds;
                    r_ctor_->Cell0DsAlignedCell1DsIndex = Cell0DsAlignedCell1DsIndex;
                    r_ctor_->Cell1DsAlignedCell1DsIndex = Cell1DsAlignedCell1DsIndex;
                    r_ctor_->Cell3DsAlignedCell1DsIndex = Cell3DsAlignedCell1DsIndex;
                    return r_ctor_;
                })
                , py::arg("aligned_cell1_ds") = Eigen::MatrixXi(), py::arg("cell0_ds_aligned_cell1_ds_index") = std::vector<Eigen::MatrixXi>(), py::arg("cell1_ds_aligned_cell1_ds_index") = std::vector<Eigen::MatrixXi>(), py::arg("cell3_ds_aligned_cell1_ds_index") = std::vector<Eigen::MatrixXi>()
                )
                .def_readwrite("aligned_cell1_ds", &Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult::AlignedCell1Ds, "")
                .def_readwrite("cell0_ds_aligned_cell1_ds_index", &Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult::Cell0DsAlignedCell1DsIndex, "")
                .def_readwrite("cell1_ds_aligned_cell1_ds_index", &Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult::Cell1DsAlignedCell1DsIndex, "")
                .def_readwrite("cell3_ds_aligned_cell1_ds_index", &Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult::Cell3DsAlignedCell1DsIndex, "")
                .def_readwrite("aligned_cell1_ds_sub_cell0_ds", &Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult::AlignedCell1Ds_SubCell0Ds, "")
                .def_readwrite("aligned_cell1_ds_sub_cell1_ds", &Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult::AlignedCell1Ds_SubCell1Ds, "")
                .def_readwrite("aligned_cell1_ds_cell3_ds", &Gedim::MeshUtilities::ComputeMesh3DAlignedCell1DsResult::AlignedCell1Ds_Cell3Ds, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassMeshGeometricData1D =
                py::class_<Gedim::MeshUtilities::MeshGeometricData1D>
                    (pyNsGedim_ClassMeshUtilities, "MeshGeometricData1D", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                std::vector<Eigen::MatrixXd> Cell1DsBoundingBox = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Cell1DsVertices = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::Vector3d> Cell1DsTangents = std::vector<Eigen::Vector3d>(), std::vector<double> Cell1DsLengths = std::vector<double>(), std::vector<double> Cell1DsSquaredLengths = std::vector<double>(), std::vector<Eigen::Vector3d> Cell1DsCentroids = std::vector<Eigen::Vector3d>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::MeshGeometricData1D>();
                    r_ctor_->Cell1DsBoundingBox = Cell1DsBoundingBox;
                    r_ctor_->Cell1DsVertices = Cell1DsVertices;
                    r_ctor_->Cell1DsTangents = Cell1DsTangents;
                    r_ctor_->Cell1DsLengths = Cell1DsLengths;
                    r_ctor_->Cell1DsSquaredLengths = Cell1DsSquaredLengths;
                    r_ctor_->Cell1DsCentroids = Cell1DsCentroids;
                    return r_ctor_;
                })
                , py::arg("cell1_ds_bounding_box") = std::vector<Eigen::MatrixXd>(), py::arg("cell1_ds_vertices") = std::vector<Eigen::MatrixXd>(), py::arg("cell1_ds_tangents") = std::vector<Eigen::Vector3d>(), py::arg("cell1_ds_lengths") = std::vector<double>(), py::arg("cell1_ds_squared_lengths") = std::vector<double>(), py::arg("cell1_ds_centroids") = std::vector<Eigen::Vector3d>()
                )
                .def_readwrite("cell1_ds_bounding_box", &Gedim::MeshUtilities::MeshGeometricData1D::Cell1DsBoundingBox, "")
                .def_readwrite("cell1_ds_vertices", &Gedim::MeshUtilities::MeshGeometricData1D::Cell1DsVertices, "/< cell1D vertices coordinates")
                .def_readwrite("cell1_ds_tangents", &Gedim::MeshUtilities::MeshGeometricData1D::Cell1DsTangents, "/< cell1D tangents")
                .def_readwrite("cell1_ds_lengths", &Gedim::MeshUtilities::MeshGeometricData1D::Cell1DsLengths, "/< cell1D lengths")
                .def_readwrite("cell1_ds_squared_lengths", &Gedim::MeshUtilities::MeshGeometricData1D::Cell1DsSquaredLengths, "/< cell1D squared lengths")
                .def_readwrite("cell1_ds_centroids", &Gedim::MeshUtilities::MeshGeometricData1D::Cell1DsCentroids, "/< cell1D centroids")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassMeshGeometricData2D =
                py::class_<Gedim::MeshUtilities::MeshGeometricData2D>
                    (pyNsGedim_ClassMeshUtilities, "MeshGeometricData2D", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                std::vector<Eigen::MatrixXd> Cell2DsBoundingBox = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Cell2DsVertices = std::vector<Eigen::MatrixXd>(), std::vector<std::vector<Eigen::Matrix3d>> Cell2DsTriangulations = std::vector<std::vector<Eigen::Matrix3d>>(), std::vector<double> Cell2DsAreas = std::vector<double>(), std::vector<Eigen::Vector3d> Cell2DsCentroids = std::vector<Eigen::Vector3d>(), std::vector<double> Cell2DsDiameters = std::vector<double>(), std::vector<std::vector<bool>> Cell2DsEdgeDirections = std::vector<std::vector<bool>>(), std::vector<Eigen::MatrixXd> Cell2DsEdgesCentroid = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::VectorXd> Cell2DsEdgeLengths = std::vector<Eigen::VectorXd>(), std::vector<Eigen::MatrixXd> Cell2DsEdgeTangents = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Cell2DsEdgeNormals = std::vector<Eigen::MatrixXd>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::MeshGeometricData2D>();
                    r_ctor_->Cell2DsBoundingBox = Cell2DsBoundingBox;
                    r_ctor_->Cell2DsVertices = Cell2DsVertices;
                    r_ctor_->Cell2DsTriangulations = Cell2DsTriangulations;
                    r_ctor_->Cell2DsAreas = Cell2DsAreas;
                    r_ctor_->Cell2DsCentroids = Cell2DsCentroids;
                    r_ctor_->Cell2DsDiameters = Cell2DsDiameters;
                    r_ctor_->Cell2DsEdgeDirections = Cell2DsEdgeDirections;
                    r_ctor_->Cell2DsEdgesCentroid = Cell2DsEdgesCentroid;
                    r_ctor_->Cell2DsEdgeLengths = Cell2DsEdgeLengths;
                    r_ctor_->Cell2DsEdgeTangents = Cell2DsEdgeTangents;
                    r_ctor_->Cell2DsEdgeNormals = Cell2DsEdgeNormals;
                    return r_ctor_;
                })
                , py::arg("cell2_ds_bounding_box") = std::vector<Eigen::MatrixXd>(), py::arg("cell2_ds_vertices") = std::vector<Eigen::MatrixXd>(), py::arg("cell2_ds_triangulations") = std::vector<std::vector<Eigen::Matrix3d>>(), py::arg("cell2_ds_areas") = std::vector<double>(), py::arg("cell2_ds_centroids") = std::vector<Eigen::Vector3d>(), py::arg("cell2_ds_diameters") = std::vector<double>(), py::arg("cell2_ds_edge_directions") = std::vector<std::vector<bool>>(), py::arg("cell2_ds_edges_centroid") = std::vector<Eigen::MatrixXd>(), py::arg("cell2_ds_edge_lengths") = std::vector<Eigen::VectorXd>(), py::arg("cell2_ds_edge_tangents") = std::vector<Eigen::MatrixXd>(), py::arg("cell2_ds_edge_normals") = std::vector<Eigen::MatrixXd>()
                )
                .def_readwrite("cell2_ds_bounding_box", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsBoundingBox, "")
                .def_readwrite("cell2_ds_vertices", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsVertices, "/< cell2D vertices coordinates")
                .def_readwrite("cell2_ds_triangulations", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsTriangulations, "/< cell2D triangulations")
                .def_readwrite("cell2_ds_areas", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsAreas, "/< cell2D areas")
                .def_readwrite("cell2_ds_centroids", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsCentroids, "/< cell2D centroids")
                .def_readwrite("cell2_ds_diameters", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsDiameters, "/< cell2D diameters")
                .def_readwrite("cell2_ds_edge_directions", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsEdgeDirections, "/< cell2D edge directions")
                .def_readwrite("cell2_ds_edges_centroid", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsEdgesCentroid, "/< cell2D edge centroid")
                .def_readwrite("cell2_ds_edge_lengths", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsEdgeLengths, "/< cell2D edge lengths")
                .def_readwrite("cell2_ds_edge_tangents", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsEdgeTangents, "/< cell2D edge tangents")
                .def_readwrite("cell2_ds_edge_normals", &Gedim::MeshUtilities::MeshGeometricData2D::Cell2DsEdgeNormals, "/< cell2D edge normals")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassMeshGeometricData3D =
                py::class_<Gedim::MeshUtilities::MeshGeometricData3D>
                    (pyNsGedim_ClassMeshUtilities, "MeshGeometricData3D", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                std::vector<Eigen::MatrixXd> Cell3DsVertices = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXi> Cell3DsEdges = std::vector<Eigen::MatrixXi>(), std::vector<std::vector<Eigen::MatrixXi>> Cell3DsFaces = std::vector<std::vector<Eigen::MatrixXi>>(), std::vector<Eigen::MatrixXd> Cell3DsBoundingBox = std::vector<Eigen::MatrixXd>(), std::vector<double> Cell3DsVolumes = std::vector<double>(), std::vector<double> Cell3DsDiameters = std::vector<double>(), std::vector<Eigen::Vector3d> Cell3DsCentroids = std::vector<Eigen::Vector3d>(), std::vector<Eigen::MatrixXd> Cell3DsEdgesCentroid = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::VectorXd> Cell3DsEdgeLengths = std::vector<Eigen::VectorXd>(), std::vector<Eigen::MatrixXd> Cell3DsEdgeTangents = std::vector<Eigen::MatrixXd>(), std::vector<std::vector<bool>> Cell3DsEdgeDirections = std::vector<std::vector<bool>>(), std::vector<std::vector<Eigen::MatrixXd>> Cell3DsTetrahedronPoints = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<std::vector<Eigen::Vector3d>> Cell3DsFacesTranslations = std::vector<std::vector<Eigen::Vector3d>>(), std::vector<std::vector<Eigen::Matrix3d>> Cell3DsFacesRotationMatrices = std::vector<std::vector<Eigen::Matrix3d>>(), std::vector<std::vector<Eigen::Vector3d>> Cell3DsFacesNormals = std::vector<std::vector<Eigen::Vector3d>>(), std::vector<std::vector<bool>> Cell3DsFacesNormalDirections = std::vector<std::vector<bool>>(), std::vector<std::vector<bool>> Cell3DsFacesNormalGlobalDirection = std::vector<std::vector<bool>>(), std::vector<std::vector<std::vector<bool>>> Cell3DsFacesEdgeDirections = std::vector<std::vector<std::vector<bool>>>(), std::vector<std::vector<Eigen::MatrixXd>> Cell3DsFaces3DVertices = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<std::vector<Eigen::MatrixXd>> Cell3DsFaces2DVertices = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<std::vector<std::vector<Eigen::Matrix3d>>> Cell3DsFaces3DTriangulations = std::vector<std::vector<std::vector<Eigen::Matrix3d>>>(), std::vector<std::vector<std::vector<Eigen::Matrix3d>>> Cell3DsFaces2DTriangulations = std::vector<std::vector<std::vector<Eigen::Matrix3d>>>(), std::vector<std::vector<double>> Cell3DsFacesAreas = std::vector<std::vector<double>>(), std::vector<std::vector<Eigen::Vector3d>> Cell3DsFaces2DCentroids = std::vector<std::vector<Eigen::Vector3d>>(), std::vector<std::vector<double>> Cell3DsFacesDiameters = std::vector<std::vector<double>>(), std::vector<std::vector<Eigen::VectorXd>> Cell3DsFacesEdgeLengths = std::vector<std::vector<Eigen::VectorXd>>(), std::vector<std::vector<Eigen::MatrixXd>> Cell3DsFacesEdge3DTangents = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<std::vector<Eigen::MatrixXd>> Cell3DsFacesEdges3DCentroid = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<std::vector<Eigen::MatrixXd>> Cell3DsFacesEdge2DTangents = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<std::vector<Eigen::MatrixXd>> Cell3DsFacesEdges2DCentroid = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<std::vector<Eigen::MatrixXd>> Cell3DsFacesEdge2DNormals = std::vector<std::vector<Eigen::MatrixXd>>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::MeshGeometricData3D>();
                    r_ctor_->Cell3DsVertices = Cell3DsVertices;
                    r_ctor_->Cell3DsEdges = Cell3DsEdges;
                    r_ctor_->Cell3DsFaces = Cell3DsFaces;
                    r_ctor_->Cell3DsBoundingBox = Cell3DsBoundingBox;
                    r_ctor_->Cell3DsVolumes = Cell3DsVolumes;
                    r_ctor_->Cell3DsDiameters = Cell3DsDiameters;
                    r_ctor_->Cell3DsCentroids = Cell3DsCentroids;
                    r_ctor_->Cell3DsEdgesCentroid = Cell3DsEdgesCentroid;
                    r_ctor_->Cell3DsEdgeLengths = Cell3DsEdgeLengths;
                    r_ctor_->Cell3DsEdgeTangents = Cell3DsEdgeTangents;
                    r_ctor_->Cell3DsEdgeDirections = Cell3DsEdgeDirections;
                    r_ctor_->Cell3DsTetrahedronPoints = Cell3DsTetrahedronPoints;
                    r_ctor_->Cell3DsFacesTranslations = Cell3DsFacesTranslations;
                    r_ctor_->Cell3DsFacesRotationMatrices = Cell3DsFacesRotationMatrices;
                    r_ctor_->Cell3DsFacesNormals = Cell3DsFacesNormals;
                    r_ctor_->Cell3DsFacesNormalDirections = Cell3DsFacesNormalDirections;
                    r_ctor_->Cell3DsFacesNormalGlobalDirection = Cell3DsFacesNormalGlobalDirection;
                    r_ctor_->Cell3DsFacesEdgeDirections = Cell3DsFacesEdgeDirections;
                    r_ctor_->Cell3DsFaces3DVertices = Cell3DsFaces3DVertices;
                    r_ctor_->Cell3DsFaces2DVertices = Cell3DsFaces2DVertices;
                    r_ctor_->Cell3DsFaces3DTriangulations = Cell3DsFaces3DTriangulations;
                    r_ctor_->Cell3DsFaces2DTriangulations = Cell3DsFaces2DTriangulations;
                    r_ctor_->Cell3DsFacesAreas = Cell3DsFacesAreas;
                    r_ctor_->Cell3DsFaces2DCentroids = Cell3DsFaces2DCentroids;
                    r_ctor_->Cell3DsFacesDiameters = Cell3DsFacesDiameters;
                    r_ctor_->Cell3DsFacesEdgeLengths = Cell3DsFacesEdgeLengths;
                    r_ctor_->Cell3DsFacesEdge3DTangents = Cell3DsFacesEdge3DTangents;
                    r_ctor_->Cell3DsFacesEdges3DCentroid = Cell3DsFacesEdges3DCentroid;
                    r_ctor_->Cell3DsFacesEdge2DTangents = Cell3DsFacesEdge2DTangents;
                    r_ctor_->Cell3DsFacesEdges2DCentroid = Cell3DsFacesEdges2DCentroid;
                    r_ctor_->Cell3DsFacesEdge2DNormals = Cell3DsFacesEdge2DNormals;
                    return r_ctor_;
                })
                , py::arg("cell3_ds_vertices") = std::vector<Eigen::MatrixXd>(), py::arg("cell3_ds_edges") = std::vector<Eigen::MatrixXi>(), py::arg("cell3_ds_faces") = std::vector<std::vector<Eigen::MatrixXi>>(), py::arg("cell3_ds_bounding_box") = std::vector<Eigen::MatrixXd>(), py::arg("cell3_ds_volumes") = std::vector<double>(), py::arg("cell3_ds_diameters") = std::vector<double>(), py::arg("cell3_ds_centroids") = std::vector<Eigen::Vector3d>(), py::arg("cell3_ds_edges_centroid") = std::vector<Eigen::MatrixXd>(), py::arg("cell3_ds_edge_lengths") = std::vector<Eigen::VectorXd>(), py::arg("cell3_ds_edge_tangents") = std::vector<Eigen::MatrixXd>(), py::arg("cell3_ds_edge_directions") = std::vector<std::vector<bool>>(), py::arg("cell3_ds_tetrahedron_points") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("cell3_ds_faces_translations") = std::vector<std::vector<Eigen::Vector3d>>(), py::arg("cell3_ds_faces_rotation_matrices") = std::vector<std::vector<Eigen::Matrix3d>>(), py::arg("cell3_ds_faces_normals") = std::vector<std::vector<Eigen::Vector3d>>(), py::arg("cell3_ds_faces_normal_directions") = std::vector<std::vector<bool>>(), py::arg("cell3_ds_faces_normal_global_direction") = std::vector<std::vector<bool>>(), py::arg("cell3_ds_faces_edge_directions") = std::vector<std::vector<std::vector<bool>>>(), py::arg("cell3_ds_faces3_d_vertices") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("cell3_ds_faces2_d_vertices") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("cell3_ds_faces3_d_triangulations") = std::vector<std::vector<std::vector<Eigen::Matrix3d>>>(), py::arg("cell3_ds_faces2_d_triangulations") = std::vector<std::vector<std::vector<Eigen::Matrix3d>>>(), py::arg("cell3_ds_faces_areas") = std::vector<std::vector<double>>(), py::arg("cell3_ds_faces2_d_centroids") = std::vector<std::vector<Eigen::Vector3d>>(), py::arg("cell3_ds_faces_diameters") = std::vector<std::vector<double>>(), py::arg("cell3_ds_faces_edge_lengths") = std::vector<std::vector<Eigen::VectorXd>>(), py::arg("cell3_ds_faces_edge3_d_tangents") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("cell3_ds_faces_edges3_d_centroid") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("cell3_ds_faces_edge2_d_tangents") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("cell3_ds_faces_edges2_d_centroid") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("cell3_ds_faces_edge2_d_normals") = std::vector<std::vector<Eigen::MatrixXd>>()
                )
                .def_readwrite("cell3_ds_vertices", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsVertices, "")
                .def_readwrite("cell3_ds_edges", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsEdges, "")
                .def_readwrite("cell3_ds_faces", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFaces, "")
                .def_readwrite("cell3_ds_bounding_box", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsBoundingBox, "")
                .def_readwrite("cell3_ds_volumes", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsVolumes, "")
                .def_readwrite("cell3_ds_diameters", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsDiameters, "")
                .def_readwrite("cell3_ds_centroids", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsCentroids, "")
                .def_readwrite("cell3_ds_edges_centroid", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsEdgesCentroid, "")
                .def_readwrite("cell3_ds_edge_lengths", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsEdgeLengths, "")
                .def_readwrite("cell3_ds_edge_tangents", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsEdgeTangents, "")
                .def_readwrite("cell3_ds_edge_directions", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsEdgeDirections, "")
                .def_readwrite("cell3_ds_tetrahedron_points", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsTetrahedronPoints, "")
                .def_readwrite("cell3_ds_faces_translations", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesTranslations, "")
                .def_readwrite("cell3_ds_faces_rotation_matrices", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesRotationMatrices, "")
                .def_readwrite("cell3_ds_faces_normals", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesNormals, "")
                .def_readwrite("cell3_ds_faces_tangents", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesTangents, "")
                .def_readwrite("cell3_ds_faces_normal_directions", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesNormalDirections, "")
                .def_readwrite("cell3_ds_faces_normal_global_direction", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesNormalGlobalDirection, "")
                .def_readwrite("cell3_ds_faces_tangents_global_direction", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesTangentsGlobalDirection, "")
                .def_readwrite("cell3_ds_faces_edge_directions", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesEdgeDirections, "")
                .def_readwrite("cell3_ds_faces3_d_vertices", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFaces3DVertices, "/< faces vertices 3D coordinates")
                .def_readwrite("cell3_ds_faces2_d_vertices", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFaces2DVertices, "/< faces vertices 2D coordinates")
                .def_readwrite("cell3_ds_faces3_d_triangulations", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFaces3DTriangulations, "/< faces triangulations")
                .def_readwrite("cell3_ds_faces2_d_triangulations", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFaces2DTriangulations, "/< faces triangulations")
                .def_readwrite("cell3_ds_faces_areas", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesAreas, "/< faces areas")
                .def_readwrite("cell3_ds_faces2_d_centroids", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFaces2DCentroids, "/< faces centroids")
                .def_readwrite("cell3_ds_faces_diameters", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesDiameters, "/< faces diameters")
                .def_readwrite("cell3_ds_faces_edge_lengths", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesEdgeLengths, "/< faces edge lengths")
                .def_readwrite("cell3_ds_faces_edge3_d_tangents", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesEdge3DTangents, "/< faces edge 3D tangents")
                .def_readwrite("cell3_ds_faces_edges3_d_centroid", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesEdges3DCentroid, "")
                .def_readwrite("cell3_ds_faces_edge2_d_tangents", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesEdge2DTangents, "/< faces edge 2D tangents")
                .def_readwrite("cell3_ds_faces_edges2_d_centroid", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesEdges2DCentroid, "")
                .def_readwrite("cell3_ds_faces_edge2_d_normals", &Gedim::MeshUtilities::MeshGeometricData3D::Cell3DsFacesEdge2DNormals, "/< faces edge normals")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassVTPPolyhedron =
                py::class_<Gedim::MeshUtilities::VTPPolyhedron>
                    (pyNsGedim_ClassMeshUtilities, "VTPPolyhedron", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd Vertices = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::VTPPolyhedron>();
                    r_ctor_->Vertices = Vertices;
                    return r_ctor_;
                })
                , py::arg("vertices") = Eigen::MatrixXd()
                )
                .def_readwrite("vertices", &Gedim::MeshUtilities::VTPPolyhedron::Vertices, "/ size 3xnumVertices")
                .def_readwrite("polyhedron_faces", &Gedim::MeshUtilities::VTPPolyhedron::PolyhedronFaces, "/ size numFaces x numFaceVertices")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassAgglomerateTrianglesResult =
                py::class_<Gedim::MeshUtilities::AgglomerateTrianglesResult>
                    (pyNsGedim_ClassMeshUtilities, "AgglomerateTrianglesResult", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("removed_edges", &Gedim::MeshUtilities::AgglomerateTrianglesResult::RemovedEdges, "")
                .def_readwrite("vertices_index", &Gedim::MeshUtilities::AgglomerateTrianglesResult::VerticesIndex, "")
                .def_readwrite("edges_index", &Gedim::MeshUtilities::AgglomerateTrianglesResult::EdgesIndex, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassAgglomerateMeshFromTriangularMeshResult =
                py::class_<Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult>
                    (pyNsGedim_ClassMeshUtilities, "AgglomerateMeshFromTriangularMeshResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of AgglomerateMeshFromTriangularMeshResult
                auto pyNsGedim_ClassMeshUtilities_ClassAgglomerateMeshFromTriangularMeshResult_ClassConcaveCell2D =
                    py::class_<Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::ConcaveCell2D>
                        (pyNsGedim_ClassMeshUtilities_ClassAgglomerateMeshFromTriangularMeshResult, "ConcaveCell2D", "")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("cell2_d_index", &Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::ConcaveCell2D::Cell2DIndex, "")
                    .def_readwrite("convex_cell2_ds_index", &Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::ConcaveCell2D::ConvexCell2DsIndex, "")
                    ;
            } // end of inner classes & enums of AgglomerateMeshFromTriangularMeshResult

            pyNsGedim_ClassMeshUtilities_ClassAgglomerateMeshFromTriangularMeshResult
                .def(py::init<>([](
                std::vector<Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::ConcaveCell2D> ConcaveCell2Ds = std::vector<Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::ConcaveCell2D>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult>();
                    r_ctor_->ConcaveCell2Ds = ConcaveCell2Ds;
                    return r_ctor_;
                })
                , py::arg("concave_cell2_ds") = std::vector<Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::ConcaveCell2D>()
                )
                .def_readwrite("concave_cell2_ds", &Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::ConcaveCell2Ds, "")
                .def_readwrite("removed_cell1_ds", &Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::RemovedCell1Ds, "")
                .def_readwrite("removed_cell2_ds", &Gedim::MeshUtilities::AgglomerateMeshFromTriangularMeshResult::RemovedCell2Ds, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassAgglomerationInformation =
                py::class_<Gedim::MeshUtilities::AgglomerationInformation>
                    (pyNsGedim_ClassMeshUtilities, "AgglomerationInformation", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("original_cell0_d_to_agglomerated_cell0_ds", &Gedim::MeshUtilities::AgglomerationInformation::OriginalCell0DToAgglomeratedCell0Ds, "")
                .def_readwrite("original_cell1_d_to_agglomerated_cell1_ds", &Gedim::MeshUtilities::AgglomerationInformation::OriginalCell1DToAgglomeratedCell1Ds, "")
                .def_readwrite("original_cell2_d_to_agglomerated_cell2_ds", &Gedim::MeshUtilities::AgglomerationInformation::OriginalCell2DToAgglomeratedCell2Ds, "")
                .def_readwrite("agglomerated_cell0_d_to_original_cell0_ds", &Gedim::MeshUtilities::AgglomerationInformation::AgglomeratedCell0DToOriginalCell0Ds, "")
                .def_readwrite("agglomerated_cell1_d_to_original_cell1_ds", &Gedim::MeshUtilities::AgglomerationInformation::AgglomeratedCell1DToOriginalCell1Ds, "")
                .def_readwrite("agglomerated_cell2_d_to_original_cell2_ds", &Gedim::MeshUtilities::AgglomerationInformation::AgglomeratedCell2DToOriginalCell2Ds, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassAgglomerateCell1DInformation =
                py::class_<Gedim::MeshUtilities::AgglomerateCell1DInformation>
                    (pyNsGedim_ClassMeshUtilities, "AgglomerateCell1DInformation", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("agglomerate_cell1_d_vertices", &Gedim::MeshUtilities::AgglomerateCell1DInformation::AgglomerateCell1DVertices, "")
                .def_readwrite("sub_cell1_ds_removed_vertices", &Gedim::MeshUtilities::AgglomerateCell1DInformation::SubCell1DsRemovedVertices, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassAgglomerateCell2DInformation =
                py::class_<Gedim::MeshUtilities::AgglomerateCell2DInformation>
                    (pyNsGedim_ClassMeshUtilities, "AgglomerateCell2DInformation", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("agglomerate_cell2_d_vertices", &Gedim::MeshUtilities::AgglomerateCell2DInformation::AgglomerateCell2DVertices, "")
                .def_readwrite("agglomerate_cell2_d_edges", &Gedim::MeshUtilities::AgglomerateCell2DInformation::AgglomerateCell2DEdges, "")
                .def_readwrite("sub_cell2_ds_removed_vertices", &Gedim::MeshUtilities::AgglomerateCell2DInformation::SubCell2DsRemovedVertices, "")
                .def_readwrite("sub_cell2_ds_removed_edges", &Gedim::MeshUtilities::AgglomerateCell2DInformation::SubCell2DsRemovedEdges, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassAgglomerateCell3DInformation =
                py::class_<Gedim::MeshUtilities::AgglomerateCell3DInformation>
                    (pyNsGedim_ClassMeshUtilities, "AgglomerateCell3DInformation", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("agglomerate_cell3_d_vertices", &Gedim::MeshUtilities::AgglomerateCell3DInformation::AgglomerateCell3DVertices, "")
                .def_readwrite("agglomerate_cell3_d_edges", &Gedim::MeshUtilities::AgglomerateCell3DInformation::AgglomerateCell3DEdges, "")
                .def_readwrite("agglomerate_cell3_d_faces", &Gedim::MeshUtilities::AgglomerateCell3DInformation::AgglomerateCell3DFaces, "")
                .def_readwrite("sub_cell3_ds_removed_vertices", &Gedim::MeshUtilities::AgglomerateCell3DInformation::SubCell3DsRemovedVertices, "")
                .def_readwrite("sub_cell3_ds_removed_edges", &Gedim::MeshUtilities::AgglomerateCell3DInformation::SubCell3DsRemovedEdges, "")
                .def_readwrite("sub_cell3_ds_removed_faces", &Gedim::MeshUtilities::AgglomerateCell3DInformation::SubCell3DsRemovedFaces, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassFindConcaveCell3DFacesConvexCell2DResult =
                py::class_<Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2DResult>
                    (pyNsGedim_ClassMeshUtilities, "FindConcaveCell3DFacesConvexCell2DResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of FindConcaveCell3DFacesConvexCell2DResult
                auto pyNsGedim_ClassMeshUtilities_ClassFindConcaveCell3DFacesConvexCell2DResult_ClassConvexCell2D =
                    py::class_<Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2DResult::ConvexCell2D>
                        (pyNsGedim_ClassMeshUtilities_ClassFindConcaveCell3DFacesConvexCell2DResult, "ConvexCell2D", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("convex_cell3_d_index", &Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2DResult::ConvexCell2D::ConvexCell3DIndex, "")
                    .def_readwrite("convex_cell3_d_face_index", &Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2DResult::ConvexCell2D::ConvexCell3DFaceIndex, "")
                    ;
            } // end of inner classes & enums of FindConcaveCell3DFacesConvexCell2DResult

            pyNsGedim_ClassMeshUtilities_ClassFindConcaveCell3DFacesConvexCell2DResult
                .def(py::init<>([](
                std::vector<Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2DResult::ConvexCell2D> ConcaveCell3DFacesConvexCell2D = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2DResult>();
                    r_ctor_->ConcaveCell3DFacesConvexCell2D = ConcaveCell3DFacesConvexCell2D;
                    return r_ctor_;
                })
                , py::arg("concave_cell3_d_faces_convex_cell2_d") = std::vector<Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2DResult::ConvexCell2D>{}
                )
                .def_readwrite("concave_cell3_d_faces_convex_cell2_d", &Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2DResult::ConcaveCell3DFacesConvexCell2D, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassMesh3DPolyhedron =
                py::class_<Gedim::MeshUtilities::Mesh3DPolyhedron>
                    (pyNsGedim_ClassMeshUtilities, "Mesh3DPolyhedron", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("vertices_index", &Gedim::MeshUtilities::Mesh3DPolyhedron::VerticesIndex, "")
                .def_readwrite("edges_index", &Gedim::MeshUtilities::Mesh3DPolyhedron::EdgesIndex, "")
                .def_readwrite("faces_index", &Gedim::MeshUtilities::Mesh3DPolyhedron::FacesIndex, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassFindPointMeshPositionResult =
                py::class_<Gedim::MeshUtilities::FindPointMeshPositionResult>
                    (pyNsGedim_ClassMeshUtilities, "FindPointMeshPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of FindPointMeshPositionResult
                auto pyNsGedim_ClassMeshUtilities_ClassFindPointMeshPositionResult_ClassPointMeshPosition =
                    py::class_<Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition>
                        (pyNsGedim_ClassMeshUtilities_ClassFindPointMeshPositionResult, "PointMeshPosition", py::is_final(), "\n(final class)");

                { // inner classes & enums of PointMeshPosition
                    auto pyEnumTypes =
                        py::enum_<Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types>(pyNsGedim_ClassMeshUtilities_ClassFindPointMeshPositionResult_ClassPointMeshPosition, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types::Unknown, "")
                            .value("outside", Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types::Outside, "")
                            .value("cell0_d", Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types::Cell0D, "")
                            .value("cell1_d", Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types::Cell1D, "")
                            .value("cell2_d", Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types::Cell2D, "")
                            .value("cell3_d", Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types::Cell3D, "");
                } // end of inner classes & enums of PointMeshPosition

                pyNsGedim_ClassMeshUtilities_ClassFindPointMeshPositionResult_ClassPointMeshPosition
                    .def(py::init<>([](
                    Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types Type = Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Types()
                    )
                    .def_readwrite("type", &Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Type, "")
                    .def_readwrite("cell_index", &Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition::Cell_index, "")
                    ;
            } // end of inner classes & enums of FindPointMeshPositionResult

            pyNsGedim_ClassMeshUtilities_ClassFindPointMeshPositionResult
                .def(py::init<>([](
                std::vector<Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition> MeshPositions = std::vector<Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::FindPointMeshPositionResult>();
                    r_ctor_->MeshPositions = MeshPositions;
                    return r_ctor_;
                })
                , py::arg("mesh_positions") = std::vector<Gedim::MeshUtilities::FindPointMeshPositionResult::PointMeshPosition>()
                )
                .def_readwrite("mesh_positions", &Gedim::MeshUtilities::FindPointMeshPositionResult::MeshPositions, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassFindPointCell2DResult =
                py::class_<Gedim::MeshUtilities::FindPointCell2DResult>
                    (pyNsGedim_ClassMeshUtilities, "FindPointCell2DResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of FindPointCell2DResult
                auto pyNsGedim_ClassMeshUtilities_ClassFindPointCell2DResult_ClassPointCell2DFound =
                    py::class_<Gedim::MeshUtilities::FindPointCell2DResult::PointCell2DFound>
                        (pyNsGedim_ClassMeshUtilities_ClassFindPointCell2DResult, "PointCell2DFound", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::PointPolygonPositionResult Cell2D_Position = Gedim::GeometryUtilities::PointPolygonPositionResult())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::FindPointCell2DResult::PointCell2DFound>();
                        r_ctor_->Cell2D_Position = Cell2D_Position;
                        return r_ctor_;
                    })
                    , py::arg("cell2_d_position") = Gedim::GeometryUtilities::PointPolygonPositionResult()
                    )
                    .def_readwrite("cell2_d_index", &Gedim::MeshUtilities::FindPointCell2DResult::PointCell2DFound::Cell2D_index, "")
                    .def_readwrite("cell2_d_position", &Gedim::MeshUtilities::FindPointCell2DResult::PointCell2DFound::Cell2D_Position, "")
                    ;
            } // end of inner classes & enums of FindPointCell2DResult

            pyNsGedim_ClassMeshUtilities_ClassFindPointCell2DResult
                .def(py::init<>([](
                std::vector<Gedim::MeshUtilities::FindPointCell2DResult::PointCell2DFound> Cell2Ds_found = std::vector<Gedim::MeshUtilities::FindPointCell2DResult::PointCell2DFound>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::FindPointCell2DResult>();
                    r_ctor_->Cell2Ds_found = Cell2Ds_found;
                    return r_ctor_;
                })
                , py::arg("cell2_ds_found") = std::vector<Gedim::MeshUtilities::FindPointCell2DResult::PointCell2DFound>()
                )
                .def_readwrite("cell2_ds_found", &Gedim::MeshUtilities::FindPointCell2DResult::Cell2Ds_found, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassFindPointCell3DResult =
                py::class_<Gedim::MeshUtilities::FindPointCell3DResult>
                    (pyNsGedim_ClassMeshUtilities, "FindPointCell3DResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of FindPointCell3DResult
                auto pyNsGedim_ClassMeshUtilities_ClassFindPointCell3DResult_ClassPointCell3DFound =
                    py::class_<Gedim::MeshUtilities::FindPointCell3DResult::PointCell3DFound>
                        (pyNsGedim_ClassMeshUtilities_ClassFindPointCell3DResult, "PointCell3DFound", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::GeometryUtilities::PointPolyhedronPositionResult Cell3D_Position = Gedim::GeometryUtilities::PointPolyhedronPositionResult())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::FindPointCell3DResult::PointCell3DFound>();
                        r_ctor_->Cell3D_Position = Cell3D_Position;
                        return r_ctor_;
                    })
                    , py::arg("cell3_d_position") = Gedim::GeometryUtilities::PointPolyhedronPositionResult()
                    )
                    .def_readwrite("cell3_d_index", &Gedim::MeshUtilities::FindPointCell3DResult::PointCell3DFound::Cell3D_index, "")
                    .def_readwrite("cell3_d_position", &Gedim::MeshUtilities::FindPointCell3DResult::PointCell3DFound::Cell3D_Position, "")
                    ;
            } // end of inner classes & enums of FindPointCell3DResult

            pyNsGedim_ClassMeshUtilities_ClassFindPointCell3DResult
                .def(py::init<>([](
                std::vector<Gedim::MeshUtilities::FindPointCell3DResult::PointCell3DFound> Cell3Ds_found = std::vector<Gedim::MeshUtilities::FindPointCell3DResult::PointCell3DFound>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::FindPointCell3DResult>();
                    r_ctor_->Cell3Ds_found = Cell3Ds_found;
                    return r_ctor_;
                })
                , py::arg("cell3_ds_found") = std::vector<Gedim::MeshUtilities::FindPointCell3DResult::PointCell3DFound>()
                )
                .def_readwrite("cell3_ds_found", &Gedim::MeshUtilities::FindPointCell3DResult::Cell3Ds_found, "")
                ;
            auto pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result =
                py::class_<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result>
                    (pyNsGedim_ClassMeshUtilities, "Intersect_mesh_polyhedron_result", py::is_final(), "\n(final class)");

            { // inner classes & enums of Intersect_mesh_polyhedron_result
                auto pyEnumTypes =
                    py::enum_<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Types>(pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result, "Types", py::arithmetic(), "")
                        .value("none", Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Types::None, "/< No intersection found")
                        .value("vertices", Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Types::Vertices, "/< Vertices");
                auto pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result_ClassPolyhedron_Intersection =
                    py::class_<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection>
                        (pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result, "Polyhedron_Intersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of Polyhedron_Intersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Types>(pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result_ClassPolyhedron_Intersection, "Types", py::arithmetic(), "")
                            .value("vertex", Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Types::Vertex, "")
                            .value("edge", Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Types::Edge, "")
                            .value("face", Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Types::Face, "")
                            .value("polyhedron", Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Types::Polyhedron, "");
                } // end of inner classes & enums of Polyhedron_Intersection

                pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result_ClassPolyhedron_Intersection
                    .def(py::init<>([](
                    Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Types Type = Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Types())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Types()
                    )
                    .def_readwrite("type", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Type, "")
                    .def_readwrite("geometry_index", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Geometry_index, "")
                    .def_readwrite("cell0_ds_index", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Cell0Ds_index, "")
                    .def_readwrite("cell1_ds_index", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Cell1Ds_index, "")
                    .def_readwrite("cell2_ds_index", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Cell2Ds_index, "")
                    .def_readwrite("cell3_ds_index", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection::Cell3Ds_index, "")
                    ;
                auto pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result_ClassMesh_Intersections =
                    py::class_<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_Intersections>
                        (pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result, "Mesh_Intersections", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("cell0_ds_intersections", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_Intersections::Cell0Ds_intersections, "")
                    .def_readwrite("cell1_ds_intersections", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_Intersections::Cell1Ds_intersections, "")
                    .def_readwrite("cell2_ds_intersections", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_Intersections::Cell2Ds_intersections, "")
                    .def_readwrite("cell3_ds_intersections", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_Intersections::Cell3Ds_intersections, "")
                    ;
            } // end of inner classes & enums of Intersect_mesh_polyhedron_result

            pyNsGedim_ClassMeshUtilities_ClassIntersect_mesh_polyhedron_result
                .def(py::init<>([](
                Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Types Type = Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Types(), Eigen::MatrixXd Intersections_Coordinates = Eigen::MatrixXd(), std::vector<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection> Polyhedron_intersections = std::vector<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection>(), Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_Intersections Mesh_intersections = Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_Intersections())
                {
                    auto r_ctor_ = std::make_unique<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result>();
                    r_ctor_->Type = Type;
                    r_ctor_->Intersections_Coordinates = Intersections_Coordinates;
                    r_ctor_->Polyhedron_intersections = Polyhedron_intersections;
                    r_ctor_->Mesh_intersections = Mesh_intersections;
                    return r_ctor_;
                })
                , py::arg("type") = Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Types(), py::arg("intersections_coordinates") = Eigen::MatrixXd(), py::arg("polyhedron_intersections") = std::vector<Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_Intersection>(), py::arg("mesh_intersections") = Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_Intersections()
                )
                .def_readwrite("type", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Type, "")
                .def_readwrite("intersections_coordinates", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Intersections_Coordinates, "")
                .def_readwrite("polyhedron_intersections", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Polyhedron_intersections, "")
                .def_readwrite("mesh_intersections", &Gedim::MeshUtilities::Intersect_mesh_polyhedron_result::Mesh_intersections, "")
                ;
        } // end of inner classes & enums of MeshUtilities

        pyNsGedim_ClassMeshUtilities
            .def(py::init<>())
            .def("extract_active_mesh",
                &Gedim::MeshUtilities::ExtractActiveMesh,
                py::arg("mesh"), py::arg("extraction_data"),
                "/ \\brief Extract Active Cells from mesh\n/ \note the resulting mesh has no inactive elements")
            .def("filter_active_mesh",
                &Gedim::MeshUtilities::FilterActiveMesh, py::arg("mesh"))
            .def("filter_mesh1_d",
                &Gedim::MeshUtilities::FilterMesh1D,
                py::arg("cell1_ds_filter"), py::arg("mesh"),
                "/ \\brief Extract mesh1D cells from a mesh")
            .def("filter_mesh2_d",
                &Gedim::MeshUtilities::FilterMesh2D,
                py::arg("cell2_ds_filter"), py::arg("mesh"),
                "/ \\brief Extract mesh2D cells from a mesh")
            .def("filter_mesh3_d",
                &Gedim::MeshUtilities::FilterMesh3D,
                py::arg("cell3_ds_filter"), py::arg("mesh"),
                "/ \\brief Extract mesh3D cells from a mesh")
            .def("extract_mesh1_d",
                &Gedim::MeshUtilities::ExtractMesh1D, py::arg("cell0_ds_filter"), py::arg("cell1_ds_filter"), py::arg("original_mesh"), py::arg("mesh"))
            .def("extract_mesh2_d",
                &Gedim::MeshUtilities::ExtractMesh2D, py::arg("cell0_ds_filter"), py::arg("cell1_ds_filter"), py::arg("cell2_ds_filter"), py::arg("original_mesh"), py::arg("mesh"))
            .def("extract_mesh3_d",
                &Gedim::MeshUtilities::ExtractMesh3D, py::arg("cell0_ds_filter"), py::arg("cell1_ds_filter"), py::arg("cell2_ds_filter"), py::arg("cell3_ds_filter"), py::arg("original_mesh"), py::arg("mesh"))
            .def("fill_mesh1_d",
                &Gedim::MeshUtilities::FillMesh1D,
                py::arg("geometry_utilities"), py::arg("segment_origin"), py::arg("segment_tangent"), py::arg("coordinates"), py::arg("mesh"),
                "/ \\brief Fill Mesh 1D From segment Coordinates\n/ \\param segmentOrigin the segment origin\n/ \\param segmentTangent the segment tangent vector\n/ \\param coordinates relative coordinates between [0.0, 1.0]\n/ \\param mesh the resulting mesh")
            .def("fill_mesh2_d",
                &Gedim::MeshUtilities::FillMesh2D,
                py::arg("cell0_ds"), py::arg("cell1_ds"), py::arg("cell2_ds"), py::arg("mesh"),
                "/ \\brief Fill a Mesh 2D with vertices, edges and polygons\n/ \\param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()\n/ \\param cell1Ds the origin and end as Eigen MatrixXd of cell1Ds, size 2xCell1DTotalNumber()\n/ \\param cell2Ds the vertices and edges indices of the cell2Ds ordered counterclockwise, size\n/ Cell2DTotalNumber()x2xCell2DNumberVertices()")
            .def("fill_mesh3_d",
                &Gedim::MeshUtilities::FillMesh3D, py::arg("cell0_ds"), py::arg("cell1_ds"), py::arg("cell2_ds"), py::arg("cell3_ds"), py::arg("mesh"))
            .def("compute_mesh2_d_cell1_ds",
                &Gedim::MeshUtilities::ComputeMesh2DCell1Ds,
                py::arg("cell0_ds"), py::arg("cell2_ds"),
                "/ \\brief Compute edges in a Mesh 2D with vertices and polygons\n/ \\param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()\n/ \\param cell2Ds the vertices indices of the cell2Ds ordered counterclockwise, size\n/ Cell2DTotalNumber()xCell2DNumberVertices() \\return the Cell1Ds data")
            .def("check_mesh2_d",
                &Gedim::MeshUtilities::CheckMesh2D,
                py::arg("configuration"), py::arg("geometry_utilities"), py::arg("convex_mesh"),
                "/ \\brief Check Mesh2D correctness\n/ \\param Gedim::GeometryUtilities the geometry utilities\n/ \\param convexMesh a convex 2D mesh")
            .def("check_mesh3_d",
                &Gedim::MeshUtilities::CheckMesh3D,
                py::arg("configuration"), py::arg("geometry_utilities"), py::arg("mesh"),
                "/ \\brief Check Mesh3D correctness\n/ \\param Gedim::GeometryUtilities the geometry utilities\n/ \\param mesh a 3D mesh")
            .def("compute_mesh3_d_aligned_cell1_ds",
                &Gedim::MeshUtilities::ComputeMesh3DAlignedCell1Ds,
                py::arg("cell3_ds_aligned_edges_vertices"), py::arg("cell3_ds_aligned_edges_edges"), py::arg("mesh"),
                "/ \\brief Compute edges in a Mesh 2D with vertices and polygons\n/ \\param cell0Ds the coordinates as Eigen MatrixXd of cell0Ds, size 3xCell0DTotalNumber()\n/ \\param cell2Ds the vertices indices of the cell2Ds ordered counterclockwise, size\n/ Cell2DTotalNumber()xCell2DNumberVertices() \\return the Cell1Ds data")
            .def("check_mesh_geometric_data3_d",
                &Gedim::MeshUtilities::CheckMeshGeometricData3D,
                py::arg("configuration"), py::arg("geometry_utilities"), py::arg("mesh"), py::arg("geometric_data"),
                "/ \\brief Check MeshGeometricData3D correctness\n/ \\param Gedim::GeometryUtilities the geometry utilities\n/ \\param mesh the 3D mesh\n/ \\param geometricData the mesh geometric data")
            .def("mesh1_d_from_segment",
                &Gedim::MeshUtilities::Mesh1DFromSegment,
                py::arg("geometry_utilities"), py::arg("segment_vertices"), py::arg("vertex_markers"), py::arg("mesh"),
                "/ \\brief Create a Mesh 1D with a segment\n/ \\param segmentVertices the segment coordinates, size 3x2\n/ \\param vertexMarkers mesh markers of vertices, size 1xNumPolygonVertices()")
            .def("mesh2_d_from_polygon",
                &Gedim::MeshUtilities::Mesh2DFromPolygon,
                py::arg("polygon_vertices"), py::arg("vertex_markers"), py::arg("edge_markers"), py::arg("mesh"),
                "/ \\brief Create a Mesh 2D with a polygon\n/ \\param polygonVertices the polygon coordinates, size 3xNumPolygonVertices()\n/ \\param vertexMarkers mesh markers of vertices, size 1xNumPolygonVertices()\n/ \\param edgeMarkers mesh markers of edges, size 1xNumPolygonVertices()")
            .def("set_mesh_markers_on_line",
                &Gedim::MeshUtilities::SetMeshMarkersOnLine,
                py::arg("geometry_utilities"), py::arg("line_origin"), py::arg("line_tangent"), py::arg("line_tangent_squared_length"), py::arg("marker"), py::arg("mesh"),
                "/ \\brief Set the marker on all the mesh 2D elements laying on the line\n/ \\param Gedim::GeometryUtilities the geometry utilities\n/ \\param lineTangent the line tangent\n/ \\param lineOrigin the line origin\n/ \\param lineTangentSquaredLength the line tangent squared length\n/ \\param marker the marker\n/ \\param mesh the mesh")
            .def("set_mesh_markers_on_segment",
                &Gedim::MeshUtilities::SetMeshMarkersOnSegment, py::arg("geometry_utilities"), py::arg("segment_origin"), py::arg("segment_tangent"), py::arg("segment_tangent_squared_length"), py::arg("marker"), py::arg("mesh"))
            .def("mesh3_d_from_polyhedron",
                &Gedim::MeshUtilities::Mesh3DFromPolyhedron,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("vertex_markers"), py::arg("edge_markers"), py::arg("face_markers"), py::arg("mesh"),
                "/ \\brief Create a Mesh 3D with a polyhedron\n/ \\param polyhedronVertices the polyhedron vertices, size 3 x numVertices\n/ \\param polyhedronEdges the polyhedron edges, size 2 x numEdges\n/ \\param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices\n/ \\param vertexMarkers mesh markers of vertices, size 1xnumVertices\n/ \\param edgeMarkers mesh markers of edges, size 1xnumEdges\n/ \\param faceMarkers mesh markers of faces, size 1xnumFaces")
            .def("set_mesh_markers_on_plane",
                &Gedim::MeshUtilities::SetMeshMarkersOnPlane,
                py::arg("geometry_utilities"), py::arg("plane_normal"), py::arg("plane_origin"), py::arg("marker"), py::arg("mesh"),
                "/ \\brief Set the marker on all the mesh 3D elements laying on the plane\n/ \\param Gedim::GeometryUtilities the geometry utilities\n/ \\param planeNormal the plane normal\n/ \\param planeOrigin the plane origin\n/ \\param marker the marker\n/ \\param mesh the mesh")
            .def("set_mesh_markers_by_face_normal",
                &Gedim::MeshUtilities::SetMeshMarkersByFaceNormal, py::arg("geometry_utilities"), py::arg("normal"), py::arg("cell2_ds_normal"), py::arg("marker"), py::arg("mesh"))
            .def("set_mesh_markers_on_polygon",
                py::overload_cast<const Gedim::GeometryUtilities &, const Eigen::Vector3d &, const Eigen::Vector3d &, const Eigen::MatrixXd &, const Eigen::Vector3d &, const Eigen::Matrix3d &, const unsigned int &, Gedim::IMeshDAO &>(&Gedim::MeshUtilities::SetMeshMarkersOnPolygon, py::const_),
                py::arg("geometry_utilities"), py::arg("polygon_plane_normal"), py::arg("polygon_plane_origin"), py::arg("polygon_vertices_2_d"), py::arg("polygon_translation"), py::arg("polygon_rotation_matrix"), py::arg("marker"), py::arg("mesh"),
                "/ \\warning Only for convex points")
            .def("set_mesh_markers_on_polygon",
                py::overload_cast<const Gedim::GeometryUtilities &, const Eigen::Vector3d &, const Eigen::Vector3d &, const Eigen::MatrixXd &, const Eigen::Vector3d &, const Eigen::Matrix3d &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Vector3d> &, const unsigned int &, Gedim::IMeshDAO &>(&Gedim::MeshUtilities::SetMeshMarkersOnPolygon, py::const_), py::arg("geometry_utilities"), py::arg("polygon_plane_normal"), py::arg("polygon_plane_origin"), py::arg("polygon_vertices_2_d"), py::arg("polygon_translation"), py::arg("polygon_rotation_matrix"), py::arg("cell1_ds_centroid"), py::arg("cell2_ds_centroid"), py::arg("marker"), py::arg("mesh"))
            .def("mesh_cell2_d_roots",
                &Gedim::MeshUtilities::MeshCell2DRoots,
                py::arg("mesh"),
                "/ \\brief Extract the mesh Cell2D Roots\n/ \\param mesh the mesh\n/ \\return the root cell for each cell2D, size 1xCell2DTotalNumber()")
            .def("fill_mesh1_d_geometric_data",
                &Gedim::MeshUtilities::FillMesh1DGeometricData,
                py::arg("geometry_utilities"), py::arg("convex_mesh"),
                "/ \\brief Fill Mesh1D Geometric Data given a mesh with convex mesh cells\n/ \\param convexMesh the convex mesh\n/ \\return the MeshGeometricData computed")
            .def("import_mesh_geometric_data1_d_from_txt",
                &Gedim::MeshUtilities::ImportMeshGeometricData1DFromTxt, py::arg("file_path"))
            .def("export_mesh_geometric_data1_d_to_txt",
                &Gedim::MeshUtilities::ExportMeshGeometricData1DToTxt, py::arg("mesh_geometric_data"), py::arg("file_path"))
            .def("fill_mesh2_d_geometric_data",
                py::overload_cast<const Gedim::GeometryUtilities &, const Gedim::IMeshDAO &>(&Gedim::MeshUtilities::FillMesh2DGeometricData, py::const_),
                py::arg("geometry_utilities"), py::arg("convex_mesh"),
                "/ \\brief Fill Mesh2D Geometric Data given a mesh with convex mesh cells\n/ \\param convexMesh the convex mesh\n/ \\return the MeshGeometricData computed")
            .def("fill_mesh2_d_geometric_data",
                py::overload_cast<const Gedim::GeometryUtilities &, const Gedim::IMeshDAO &, const std::vector<Gedim::GeometryUtilities::PolygonTypes> &>(&Gedim::MeshUtilities::FillMesh2DGeometricData, py::const_),
                py::arg("geometry_utilities"), py::arg("mesh"), py::arg("mesh_cell2_ds_polygon_type"),
                "/ \\brief Fill Mesh2D Geometric Data given a mesh with mesh cells type\n/ \\param mesh the mesh\n/ \\param meshCell2DsPolygonType the cell2D polygon type\n/ \\return the MeshGeometricData computed")
            .def("fill_mesh2_d_geometric_data",
                py::overload_cast<const Gedim::GeometryUtilities &, const Gedim::IMeshDAO &, const Gedim::IMeshDAO &, const std::vector<std::vector<unsigned int>> &>(&Gedim::MeshUtilities::FillMesh2DGeometricData, py::const_),
                py::arg("geometry_utilities"), py::arg("mesh"), py::arg("convex_mesh"), py::arg("mesh_cell2_d_to_convex_cell2_d_indices"),
                "/ \\brief Fill Mesh2D Geometric Data starting given a mesh with non convex mesh cells and its convex sub-mesh cells\n/ \\param mesh the mesh\n/ \\param convexMesh the convex mesh cells of mesh\n/ \\param meshCell2DToConvexCell2DIndices the collection of convex cell2Ds for each mesh cell2D\n/ \\return the MeshGeometricData computed")
            .def("import_mesh_geometric_data2_d_from_txt",
                &Gedim::MeshUtilities::ImportMeshGeometricData2DFromTxt, py::arg("file_path"))
            .def("export_mesh_geometric_data2_d_to_txt",
                &Gedim::MeshUtilities::ExportMeshGeometricData2DToTxt, py::arg("mesh_geometric_data"), py::arg("file_path"))
            .def("fill_mesh3_d_geometric_data",
                py::overload_cast<const Gedim::GeometryUtilities &, const Gedim::IMeshDAO &>(&Gedim::MeshUtilities::FillMesh3DGeometricData, py::const_),
                py::arg("geometry_utilities"), py::arg("convex_mesh"),
                "/ \\brief Fill Mesh3D Geometric Data given a mesh with convex mesh cells\n/ \\param convexMesh the convex mesh\n/ \\return the MeshGeometricData computed")
            .def("fill_mesh3_d_geometric_data",
                py::overload_cast<const Gedim::GeometryUtilities &, const Gedim::IMeshDAO &, const Gedim::IMeshDAO &, const std::vector<std::vector<unsigned int>> &>(&Gedim::MeshUtilities::FillMesh3DGeometricData, py::const_),
                py::arg("geometry_utilities"), py::arg("mesh"), py::arg("convex_mesh"), py::arg("mesh_cell3_d_to_convex_cell3_d_indices"),
                "/ \\brief Fill Mesh3D Geometric Data starting given a mesh with non convex mesh cells and its convex sub-mesh cells\n/ \\param mesh the mesh\n/ \\param convexMesh the convex mesh\n/ \\param meshCell2DToConvexCell2DIndices the collection of convex cell2Ds for each mesh cell2D\n/ \\param meshCell3DToConvexCell3DIndices the collection of convex cell3Ds for each mesh cell3D\n/ \\return the MeshGeometricData computed")
            .def("fill_mesh3_d_geometric_data",
                py::overload_cast<const Gedim::GeometryUtilities &, const Gedim::IMeshDAO &, const std::vector<std::vector<Eigen::MatrixXd>> &, const std::vector<std::vector<Eigen::Matrix3d>> &>(&Gedim::MeshUtilities::FillMesh3DGeometricData, py::const_), py::arg("geometry_utilities"), py::arg("mesh"), py::arg("cell3_ds_tetra_vertices"), py::arg("cell2_ds_triangles_3_d_vertices"))
            .def("import_mesh_geometric_data3_d_from_txt",
                &Gedim::MeshUtilities::ImportMeshGeometricData3DFromTxt, py::arg("file_path"))
            .def("export_mesh_geometric_data3_d_to_txt",
                &Gedim::MeshUtilities::ExportMeshGeometricData3DToTxt, py::arg("mesh_geometric_data"), py::arg("file_path"))
            .def("compute_cell0_d_cell1_d_neighbours",
                &Gedim::MeshUtilities::ComputeCell0DCell1DNeighbours, py::arg("mesh"))
            .def("compute_cell0_d_cell2_d_neighbours",
                &Gedim::MeshUtilities::ComputeCell0DCell2DNeighbours, py::arg("mesh"))
            .def("compute_cell0_d_cell3_d_neighbours",
                &Gedim::MeshUtilities::ComputeCell0DCell3DNeighbours, py::arg("mesh"))
            .def("compute_cell1_d_cell2_d_neighbours",
                &Gedim::MeshUtilities::ComputeCell1DCell2DNeighbours,
                py::arg("mesh"),
                "/ \\brief Compute Cell1D Cell2DNeighbours with given mesh data\n/ \\param mesh the resulting mesh")
            .def("compute_cell1_d_cell3_d_neighbours",
                &Gedim::MeshUtilities::ComputeCell1DCell3DNeighbours,
                py::arg("mesh"),
                "/ \\brief Compute Cell1D Cell3DNeighbours with given mesh data\n/ \\param mesh the resulting mesh")
            .def("compute_cell2_d_cell3_d_neighbours",
                &Gedim::MeshUtilities::ComputeCell2DCell3DNeighbours,
                py::arg("mesh"),
                "/ \\brief Compute Cell2D Cell3DNeighbours with given mesh data\n/ \\param mesh the resulting mesh")
            .def("create_rectangle_mesh",
                &Gedim::MeshUtilities::CreateRectangleMesh,
                py::arg("rectangle_origin"), py::arg("rectangle_base_tangent"), py::arg("rectangle_height_tangent"), py::arg("base_mesh_curvilinear_coordinates"), py::arg("height_mesh_curvilinear_coordinates"), py::arg("mesh"),
                "/ \\brief Crete rectange Mesh on rectangle base x height\n/ \\param rectangleOrigin the rectangle origin point\n/ \\param rectangleBaseTangent the rectangle base tangent vector\n/ \\param rectangleHeightTangent the rectangle height tangent vector\n/ \\param baseMeshCurvilinearCoordinates the base mesh 1D curvilinear coordinates\n/ \\param heightMeshCurvilinearCoordinates the height mesh 1D curvilinear coordinates\n/ \note markers on border are set as { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *\n/ numVertices } for cell1Ds")
            .def("create_parallelepiped_mesh",
                &Gedim::MeshUtilities::CreateParallelepipedMesh, py::arg("rectangle_origin"), py::arg("rectangle_length_tangent"), py::arg("rectangle_height_tangent"), py::arg("rectangle_width_tangent"), py::arg("length_mesh_curvilinear_coordinates"), py::arg("height_mesh_curvilinear_coordinates"), py::arg("width_mesh_curvilinear_coordinates"), py::arg("mesh"))
            .def("create_triangle_plus_hanging_nodes_mesh",
                &Gedim::MeshUtilities::CreateTrianglePlusHangingNodesMesh, py::arg("rectangle_origin"), py::arg("rectangle_base_tangent"), py::arg("rectangle_height_tangent"), py::arg("base_mesh_curvilinear_coordinates"), py::arg("height_mesh_curvilinear_coordinates"), py::arg("number_of_added_vertices_for_each_rectangle"), py::arg("geometry_utilities"), py::arg("mesh"))
            .def("create_rectangle_plus_hanging_nodes_mesh",
                &Gedim::MeshUtilities::CreateRectanglePlusHangingNodesMesh, py::arg("rectangle_origin"), py::arg("rectangle_base_tangent"), py::arg("rectangle_height_tangent"), py::arg("base_mesh_curvilinear_coordinates"), py::arg("height_mesh_curvilinear_coordinates"), py::arg("number_of_added_vertices_for_each_rectangle"), py::arg("geometry_utilities"), py::arg("mesh"))
            .def("create_triangular_mesh",
                &Gedim::MeshUtilities::CreateTriangularMesh,
                py::arg("polygon_vertices"), py::arg("max_triangle_area"), py::arg("mesh"), py::arg("options") = "-QDzpqnea",
                "/ \\brief Create triangular mesh on 2D polygon\n/ \\param polygonVertices the 2D polygon vertices, size 3xnumVertices\n/ \\param maxTriangleArea the maximum triangular area\n/ \\param options mesh options, see https://www.cs.cmu.edu/~quake/triangle.switch.html\n/ \note markers on border are set as { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *\n/ numVertices } for cell1Ds \note use triangle library")
            .def("create_polygonal_mesh",
                &Gedim::MeshUtilities::CreatePolygonalMesh, py::arg("geometry_utilities"), py::arg("polygon_vertices"), py::arg("num_points"), py::arg("num_iterations"), py::arg("mesh"), py::arg("random_seed") = 0)
            .def("create_tetrahedral_mesh",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::MatrixXi &, const std::vector<Eigen::MatrixXi> &, const double &, Gedim::IMeshDAO &, const std::string &>(&Gedim::MeshUtilities::CreateTetrahedralMesh, py::const_), py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("max_tetrahedron_volume"), py::arg("mesh"), py::arg("options") = "Qpqfezna")
            .def("create_tetrahedral_mesh",
                py::overload_cast<const Eigen::MatrixXd &, const std::vector<std::vector<unsigned int>> &, const double &, Gedim::IMeshDAO &, const std::string &>(&Gedim::MeshUtilities::CreateTetrahedralMesh, py::const_), py::arg("points"), py::arg("facets"), py::arg("max_tetrahedron_volume"), py::arg("mesh"), py::arg("options") = "Qpqfezna")
            .def("create_delaunay_mesh3_d",
                &Gedim::MeshUtilities::CreateDelaunayMesh3D, py::arg("points"), py::arg("points_marker"), py::arg("mesh"))
            .def("create_polyhedral_mesh",
                &Gedim::MeshUtilities::CreatePolyhedralMesh, py::arg("geometry_utilities"), py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("num_points"), py::arg("num_iterations"), py::arg("mesh"), py::arg("random_seed") = 0)
            .def("make_mesh_triangular_faces",
                &Gedim::MeshUtilities::MakeMeshTriangularFaces, py::arg("faces_triangulation"), py::arg("mesh"))
            .def("import_open_volume_mesh",
                &Gedim::MeshUtilities::ImportOpenVolumeMesh,
                py::arg("ovm_file_path"), py::arg("mesh"), py::arg("mesh_cell3_ds_faces_orientation"),
                "/ \\brief Import 3D mesh from OVM file")
            .def("export_mesh_to_open_volume",
                &Gedim::MeshUtilities::ExportMeshToOpenVolume,
                py::arg("mesh"), py::arg("mesh_cell3_ds_faces_orientation"), py::arg("ovm_file_path"),
                "/ \\brief Export 3D mesh to OVM file")
            .def("import_vtk_mesh3_d",
                &Gedim::MeshUtilities::ImportVtkMesh3D,
                py::arg("vtk_file_path"), py::arg("mesh"),
                "/ \\brief Import 3D mesh from VTK file")
            .def("import_object_file_format",
                &Gedim::MeshUtilities::ImportObjectFileFormat,
                py::arg("off_file_path"), py::arg("mesh"),
                "/ \\brief Import 2D mesh from OFF file")
            .def("export_mesh_to_object_file_format",
                &Gedim::MeshUtilities::ExportMeshToObjectFileFormat,
                py::arg("mesh"), py::arg("off_file_path"),
                "/ \\brief Export 2D mesh to OFF file")
            .def("change_polygon_mesh_markers",
                &Gedim::MeshUtilities::ChangePolygonMeshMarkers,
                py::arg("polygon_vertices"), py::arg("cell0_d_markers"), py::arg("cell1_d_markers"), py::arg("mesh"),
                "/ \\brief Change Polygon Mesh Markers from { 1, 2, 3, 4, ..., numVertices } for cell0Ds and { 5, 6, 7, 8, ..., 2 *\n/ numVertices } for cell1Ds to cell0DMarkers and cell1DMarkers \\param polygonVertices the 2D polygon vertices,\n/ size 3xnumVertices \\param cell0DMarkers the new cell0D markers, size 1xnumPolygonVertices \\param cell1DMarkers\n/ the new cell1D markers, size 1xnumPolygonVertices \\param mesh the mesh")
            .def("change_polyhedron_mesh_markers",
                &Gedim::MeshUtilities::ChangePolyhedronMeshMarkers, py::arg("geometry_utilities"), py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_edges_tangent"), py::arg("polyhedron_edges_length"), py::arg("polyhedron_faces_normal"), py::arg("polyhedron_faces_vertices"), py::arg("polyhedron_faces_vertices_2_d"), py::arg("polyhedron_faces_translation"), py::arg("polyhedron_faces_rotation_matrix"), py::arg("polyhedron_vertices_marker"), py::arg("polyhedron_edges_marker"), py::arg("polyhedron_faces_marker"), py::arg("cell1_ds_centroid"), py::arg("cell2_ds_centroid"), py::arg("mesh"))
            .def("export_mesh_to_vtu",
                &Gedim::MeshUtilities::ExportMeshToVTU,
                py::arg("mesh"), py::arg("export_folder"), py::arg("file_name"), py::arg("separate_file") = false,
                "/ \\brief Export Mesh To VTU\n/ \\param mesh the mesh\n/ \\param exportFolder the folder in which the mesh is exported")
            .def("export_mesh_to_ucd",
                &Gedim::MeshUtilities::ExportMeshToUCD,
                py::arg("mesh"), py::arg("export_folder"), py::arg("file_name"), py::arg("separate_file") = false,
                "/ \\brief Export Mesh To UCD\n/ \\param mesh the mesh\n/ \\param exportFolder the folder in which the mesh is exported")
            .def("export_cell2_d_to_vtu",
                &Gedim::MeshUtilities::ExportCell2DToVTU,
                py::arg("mesh"), py::arg("cell2_d_index"), py::arg("cell2_d_vertices"), py::arg("cell2_d_triangulations"), py::arg("cell2_d_area"), py::arg("cell2_d_centroid"), py::arg("export_folder"),
                "/ \\brief Export Cell2D To VTU\n/ \\param mesh the mesh\n/ \\param cell2DIndex the cell2D index\n/ \\param cell2DVertices the cell2D vertices\n/ \\param cell2DTriangulations the cell2D triangulation\n/ \\param cell2DArea the cell2D area\n/ \\param cell2DCentroid the cell2D centroid\n/ \\param exportFolder the folder in which to export")
            .def("export_cell3_d_to_vtu",
                &Gedim::MeshUtilities::ExportCell3DToVTU, py::arg("geometry_utilities"), py::arg("mesh"), py::arg("cell3_d_index"), py::arg("cell3_d_vertices"), py::arg("cell3_d_tetrahedrons"), py::arg("cell3_d_faces3_d_triangulations"), py::arg("cell3_d_volume"), py::arg("cell3_d_centroid"), py::arg("cell3_d_faces_translation"), py::arg("cell3_d_faces_rotation_matrix"), py::arg("cell3_d_faces_area"), py::arg("cell3_d_faces2_d_vertices"), py::arg("cell3_d_faces3_d_vertices"), py::arg("cell3_d_faces_edge_lengths"), py::arg("cell3_d_faces_edge_directions"), py::arg("cell3_d_faces_edges2_d_tangent"), py::arg("cell3_d_faces_edges2_d_normal"), py::arg("cell3_d_faces_normals"), py::arg("cell3_d_faces_normal_directions"), py::arg("cell3_d_faces2_d_centroids"), py::arg("export_folder"))
            .def("mesh_cell3_d_to_polyhedron",
                &Gedim::MeshUtilities::MeshCell3DToPolyhedron,
                py::arg("mesh"), py::arg("cell3_d_index"),
                "/ \\brief Convert a mesh cell3D to a geometric polydheron\n/ \\param mesh a mesh\n/ \\param cell3DIndex the cell3D index\n/ \\return polyhedron from mesh 3D cell")
            .def("mesh_cell3_d_to_vtp_polyhedron",
                &Gedim::MeshUtilities::MeshCell3DToVTPPolyhedron,
                py::arg("mesh"), py::arg("cell3_d_index"),
                "/ \\brief Convert a mesh cell3D to a VTP polydheron\n/ \\param mesh a mesh\n/ \\param cell3DIndex the cell3D index\n/ \\return VTP polyhedron from mesh 3D cell")
            .def("split_cell1_d",
                &Gedim::MeshUtilities::SplitCell1D,
                py::arg("cell1_d_index"), py::arg("sub_cell1_ds"), py::arg("mesh"),
                "/ \\brief Split cell2D into subcells\n/ \\param cell1DIndex the index of Cell1D from 0 to Cell1DTotalNumber()\n/ \\param subCell1Ds the list of sub-cells 1D mesh vertices indices, size 2 x numSubCells)\n/ \\param mesh the mesh to update\n/ \\return the list of new cell1Ds indices, from 0 to Cell1DTotalNumber()")
            .def("split_cell2_d",
                &Gedim::MeshUtilities::SplitCell2D,
                py::arg("cell2_d_index"), py::arg("sub_cell2_ds"), py::arg("mesh"),
                "/ \\brief Split cell2D into subcells\n/ \\param cell2DIndex the index of Cell2D from 0 to Cell2DTotalNumber()\n/ \\param subCell2Ds the list of sub-cells 2D mesh vertices and edges indices, size numSubCells x (2 x numVertices)\n/ \\param mesh the mesh to update\n/ \\return the list of new cell2Ds indices, from 0 to Cell2DTotalNumber()")
            .def("split_cell3_d",
                &Gedim::MeshUtilities::SplitCell3D,
                py::arg("cell3_d_index"), py::arg("sub_cell3_ds_vertices"), py::arg("sub_cell3_ds_edges"), py::arg("sub_cell3_ds_faces"), py::arg("mesh"),
                "/ \\brief Split cell3D into subcells\n/ \\param cell3DIndex the index of Cell3D from 0 to Cell3DTotalNumber()\n/ \\param subCell3Ds the list of sub-cells 3D mesh vertices and edges indices, size numSubCells x (2 x numVertices)\n/ \\param mesh the mesh to update\n/ \\return the list of new cell3Ds indices, from 0 to Cell3DTotalNumber()")
            .def("agglomerate_cell1_ds",
                py::overload_cast<const std::unordered_set<unsigned int> &, const Gedim::IMeshDAO &>(&Gedim::MeshUtilities::AgglomerateCell1Ds, py::const_), py::arg("cell1_ds_index"), py::arg("mesh"))
            .def("agglomerate_cell2_ds",
                py::overload_cast<const Gedim::GeometryUtilities &, const std::unordered_set<unsigned int> &, const Gedim::IMeshDAO &>(&Gedim::MeshUtilities::AgglomerateCell2Ds, py::const_), py::arg("geometry_utilities"), py::arg("cell2_ds_index"), py::arg("mesh"))
            .def("agglomerate_cell3_ds",
                py::overload_cast<const std::unordered_set<unsigned int> &, const Gedim::IMeshDAO &>(&Gedim::MeshUtilities::AgglomerateCell3Ds, py::const_), py::arg("cell3_ds_index"), py::arg("mesh"))
            .def("agglomerate_cell1_ds",
                py::overload_cast<const std::unordered_set<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, Gedim::IMeshDAO &, std::vector<std::vector<unsigned int>> &, const bool>(&Gedim::MeshUtilities::AgglomerateCell1Ds, py::const_), py::arg("sub_cell1_ds_index"), py::arg("agglomerate_cell1_d_vertices"), py::arg("sub_cell1_ds_removed_cell0_ds"), py::arg("mesh"), py::arg("mesh_cell1_ds_original_cell1_ds"), py::arg("mantain_neigh2_d_order") = false)
            .def("agglomerate_cell2_ds",
                py::overload_cast<const std::unordered_set<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, Gedim::IMeshDAO &, std::vector<std::vector<unsigned int>> &>(&Gedim::MeshUtilities::AgglomerateCell2Ds, py::const_), py::arg("sub_cell2_ds_index"), py::arg("agglomerate_cell2_d_vertices"), py::arg("agglomerate_cell2_d_edges"), py::arg("sub_cell2_ds_removed_cell0_ds"), py::arg("sub_cell2_ds_removed_cell1_ds"), py::arg("mesh"), py::arg("mesh_cell2_ds_original_cell2_ds"))
            .def("agglomerate_cell3_ds",
                py::overload_cast<const std::unordered_set<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, const std::vector<unsigned int> &, Gedim::IMeshDAO &, std::vector<std::vector<unsigned int>> &>(&Gedim::MeshUtilities::AgglomerateCell3Ds, py::const_), py::arg("sub_cell3_ds_index"), py::arg("agglomerate_cell3_d_vertices"), py::arg("agglomerate_cell3_d_edges"), py::arg("agglomerate_cell3_d_faces"), py::arg("sub_cell3_ds_removed_cell0_ds"), py::arg("sub_cell3_ds_removed_cell1_ds"), py::arg("sub_cell3_ds_removed_cell2_ds"), py::arg("mesh"), py::arg("mesh_cell3_ds_original_cell3_ds"))
            .def("create_randomly_deformed_quadrilaterals",
                &Gedim::MeshUtilities::CreateRandomlyDeformedQuadrilaterals, py::arg("geometry_utilities"), py::arg("rectangle_origin"), py::arg("rectangle_base_tangent"), py::arg("rectangle_height_tangent"), py::arg("num_quadrilaterals_base_tangent"), py::arg("num_quadrilaterals_height_tangent"), py::arg("max_deforming_percentage_base"), py::arg("max_deforming_percentage_height"), py::arg("mesh"))
            .def("create_distorted_quadrilaterals",
                &Gedim::MeshUtilities::CreateDistortedQuadrilaterals, py::arg("geometry_utilities"), py::arg("rectangle_origin"), py::arg("rectangle_base_tangent"), py::arg("rectangle_height_tangent"), py::arg("num_quadrilaterals_base_tangent"), py::arg("num_quadrilaterals_height_tangent"), py::arg("mesh"))
            .def("find_cell2_ds_common_vertices",
                &Gedim::MeshUtilities::FindCell2DsCommonVertices,
                py::arg("cell2_ds_index"), py::arg("mesh"),
                "/ \\brief Given a set of Cell2Ds find the common Cell0Ds\n/ \\param cell2DsIndex the cell2Ds index\n/ \\param mesh the mesh\n/ \\return the Cell0D indices")
            .def("find_cell2_ds_common_edges",
                &Gedim::MeshUtilities::FindCell2DsCommonEdges,
                py::arg("cell2_ds_index"), py::arg("mesh"),
                "/ \\brief Given a set of Cell2Ds find the common Cell1Ds\n/ \\param cell2DsIndex the cell2Ds index\n/ \\param mesh the mesh\n/ \\return the Cell1D indices")
            .def("find_concave_cell3_d_faces_convex_cell2_d",
                py::overload_cast<const Gedim::GeometryUtilities &, const unsigned int &, const Gedim::IMeshDAO &, const Gedim::IMeshDAO &, const std::vector<unsigned int> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<std::vector<Eigen::MatrixXd>> &, const std::vector<std::vector<std::vector<unsigned int>>> &>(&Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2D, py::const_), py::arg("geometry_utilities"), py::arg("concave_cell3_d_index"), py::arg("mesh"), py::arg("convex_mesh"), py::arg("convex_cell3_d_indices"), py::arg("concave_cell3_d_faces3_d_vertices"), py::arg("concave_cell3_d_faces2_d_vertices"), py::arg("concave_cell3_d_faces_translation"), py::arg("concave_cell3_d_faces_rotation_matrix"), py::arg("concave_cell3_d_faces_normal"), py::arg("convex_cell3_ds_faces3_d_vertices"), py::arg("convex_cell3_ds_faces_unaligned_vertices"))
            .def("find_concave_cell3_d_faces_convex_cell2_d",
                py::overload_cast<const Gedim::GeometryUtilities &, const unsigned int &, const Gedim::IMeshDAO &, const std::vector<Eigen::MatrixXd> &, const std::vector<std::vector<Eigen::Matrix3d>> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<std::vector<Eigen::MatrixXd>> &, const std::vector<std::vector<std::vector<unsigned int>>> &>(&Gedim::MeshUtilities::FindConcaveCell3DFacesConvexCell2D, py::const_), py::arg("geometry_utilities"), py::arg("concave_cell3_d_index"), py::arg("mesh"), py::arg("concave_cell3_d_tetra"), py::arg("concave_cell3_d_faces_2_d_triangles"), py::arg("concave_cell3_d_faces3_d_vertices"), py::arg("concave_cell3_d_faces_translation"), py::arg("concave_cell3_d_faces_rotation_matrix"), py::arg("concave_cell3_d_faces_normal"), py::arg("convex_cell3_ds_faces3_d_vertices"), py::arg("convex_cell3_ds_faces_unaligned_vertices"))
            .def("find_point_mesh_position",
                py::overload_cast<const Gedim::MeshUtilities::FindPointCell2DResult &, const Gedim::IMeshDAO &>(&Gedim::MeshUtilities::FindPointMeshPosition, py::const_), py::arg("find_cell2_d_result"), py::arg("mesh"))
            .def("find_point_mesh_position",
                py::overload_cast<const Gedim::MeshUtilities::FindPointCell3DResult &, const Gedim::IMeshDAO &>(&Gedim::MeshUtilities::FindPointMeshPosition, py::const_), py::arg("find_cell3_d_result"), py::arg("mesh"))
            .def("find_point_cell2_d",
                &Gedim::MeshUtilities::FindPointCell2D, py::arg("geometry_utilities"), py::arg("point"), py::arg("mesh"), py::arg("cell2_ds_vertices"), py::arg("cell2_ds_bounding_box"), py::arg("find_only_first_cell2_d") = true, py::arg("starting_cell2_d_index") = 0)
            .def("find_point_cell3_d",
                py::overload_cast<const Gedim::GeometryUtilities &, const Eigen::Vector3d &, const Gedim::IMeshDAO &, const std::vector<std::vector<Eigen::MatrixXi>> &, const std::vector<std::vector<Eigen::MatrixXd>> &, const std::vector<std::vector<Eigen::MatrixXd>> &, const std::vector<std::vector<Eigen::Vector3d>> &, const std::vector<std::vector<bool>> &, const std::vector<std::vector<Eigen::Vector3d>> &, const std::vector<std::vector<Eigen::Matrix3d>> &, const std::vector<Eigen::MatrixXd> &, const bool, const unsigned int>(&Gedim::MeshUtilities::FindPointCell3D, py::const_), py::arg("geometry_utilities"), py::arg("point"), py::arg("mesh"), py::arg("cell3_ds_faces"), py::arg("cell3_ds_face_vertices"), py::arg("cell3_ds_face_rotated_vertices"), py::arg("cell3_ds_face_normals"), py::arg("cell3_ds_face_normal_directions"), py::arg("cell3_ds_face_translations"), py::arg("cell3_ds_face_rotation_matrices"), py::arg("cell3_ds_bounding_box"), py::arg("find_only_first_cell3_d") = true, py::arg("starting_cell3_d_index") = 0)
            .def("find_point_cell3_d",
                py::overload_cast<const Gedim::GeometryUtilities &, const Eigen::Vector3d &, const Gedim::IMeshDAO &, const std::vector<std::vector<Eigen::MatrixXi>> &, const std::vector<std::vector<Eigen::MatrixXd>> &, const std::vector<std::vector<Eigen::MatrixXd>> &, const std::vector<std::vector<Eigen::Vector3d>> &, const std::vector<std::vector<bool>> &, const std::vector<std::vector<Eigen::Vector3d>> &, const std::vector<std::vector<Eigen::Matrix3d>> &, const std::vector<Eigen::MatrixXd> &, const std::vector<std::vector<Eigen::MatrixXd>> &, const bool, const unsigned int>(&Gedim::MeshUtilities::FindPointCell3D, py::const_), py::arg("geometry_utilities"), py::arg("point"), py::arg("mesh"), py::arg("cell3_ds_faces"), py::arg("cell3_ds_face_vertices"), py::arg("cell3_ds_face_rotated_vertices"), py::arg("cell3_ds_face_normals"), py::arg("cell3_ds_face_normal_directions"), py::arg("cell3_ds_face_translations"), py::arg("cell3_ds_face_rotation_matrices"), py::arg("cell3_ds_bounding_box"), py::arg("cell3_ds_tetrahedra"), py::arg("find_only_first_cell3_d"), py::arg("starting_cell3_d_index"))
            .def("agglomerate_triangles",
                &Gedim::MeshUtilities::AgglomerateTriangles,
                py::arg("triangles_index_to_agglomerate"), py::arg("triangular_mesh"),
                "/ \\brief Agglomerate Triangles with one vertex in common\n/ \\param trianglesIndexToAgglomerate the cell2Ds triangular index in the mesh\n/ \\param triangularMesh the triangular mesh\n/ \\return the agglomearted polygon indices\n/ \note the triangular index shall be done counterclockwise")
            .def("agglomerate_mesh_from_triangular_mesh",
                &Gedim::MeshUtilities::AgglomerateMeshFromTriangularMesh, py::arg("triangles_indices_to_agglomerate"), py::arg("triangular_mesh"))
            .def("import_agglomeration_information_from_csv",
                &Gedim::MeshUtilities::ImportAgglomerationInformationFromCsv,
                py::arg("geometry_utilities"), py::arg("original_mesh"), py::arg("agglomerated_mesh"), py::arg("file_name"), py::arg("separator"),
                "/ \\brief Import Agglomeration mesh Information From file Csv\n/ \\param Gedim::GeometryUtilities the geometry utilities\n/ \\param originalMesh the original mesh\n/ \\param agglomeratedMesh the agglomerated mesh\n/ \\param fileName the csv file name\n/ \\param separator the csv file separator\n/ \\param originalCell0DToAgglomeratedCell0Ds original Cell0Ds to agglomerated Cell0Ds\n/ \\param originalCell1DToAgglomeratedCell1Ds original Cell1Ds to agglomerated Cell1Ds\n/ \\param originalCell2DToAgglomeratedCell2Ds original Cell2Ds to agglomerated Cell2Ds\n/ \\param agglomeratedCell0DToOriginalCell0Ds agglomerated Cell0Ds to original Cell0Ds\n/ \\param agglomeratedCell1DToOriginalCell1Ds agglomerated Cell1Ds to original Cell1Ds\n/ \\param agglomeratedCell2DToOriginalCell2Ds agglomerated Cell2Ds to original Cell2Ds")
            .def("import_agglomeration_information_from_off",
                &Gedim::MeshUtilities::ImportAgglomerationInformationFromOFF,
                py::arg("geometry_utilities"), py::arg("original_mesh"), py::arg("agglomerated_mesh"), py::arg("file_name"), py::arg("separator"),
                "/ \\brief Import Agglomeration mesh Information From file OFF\n/ \\param Gedim::GeometryUtilities the geometry utilities\n/ \\param originalMesh the original mesh\n/ \\param agglomeratedMesh the agglomerated mesh\n/ \\param fileName the csv file name\n/ \\param separator the csv file separator\n/ \\param originalCell0DToAgglomeratedCell0Ds original Cell0Ds to agglomerated Cell0Ds\n/ \\param originalCell1DToAgglomeratedCell1Ds original Cell1Ds to agglomerated Cell1Ds\n/ \\param originalCell2DToAgglomeratedCell2Ds original Cell2Ds to agglomerated Cell2Ds\n/ \\param agglomeratedCell0DToOriginalCell0Ds agglomerated Cell0Ds to original Cell0Ds\n/ \\param agglomeratedCell1DToOriginalCell1Ds agglomerated Cell1Ds to original Cell1Ds\n/ \\param agglomeratedCell2DToOriginalCell2Ds agglomerated Cell2Ds to original Cell2Ds")
            .def("export_mesh_to_csv",
                &Gedim::MeshUtilities::ExportMeshToCsv,
                py::arg("mesh"), py::arg("separator"), py::arg("export_folder_path"),
                "/ \\brief Export mesh to csv file")
            .def("export_concave_mesh2_d_to_csv",
                &Gedim::MeshUtilities::ExportConcaveMesh2DToCsv,
                py::arg("mesh"), py::arg("convex_cell2_ds_index"), py::arg("separator"), py::arg("export_folder_path"),
                "/ \\brief Export 2D concave mesh to csv file")
            .def("mark_cells",
                &Gedim::MeshUtilities::MarkCells, py::arg("marking_function"), py::arg("cells_points"), py::arg("default_mark"))
            .def("intersect_mesh_polyhedron",
                &Gedim::MeshUtilities::Intersect_mesh_polyhedron, py::arg("geometry_utilities"), py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_edges_vertices"), py::arg("polyhedron_edges_tangent"), py::arg("polyhedron_edges_bouding_box"), py::arg("polyhedron_faces"), py::arg("polyhedron_faces_vertices"), py::arg("polyhedron_faces_rotated_vertices"), py::arg("polyhedron_faces_normals"), py::arg("polyhedron_faces_normal_direction"), py::arg("polyhedron_faces_translation"), py::arg("polyhedron_faces_rotation_matrix"), py::arg("polyhedron_faces_bouding_box"), py::arg("polyhedron_bouding_box"), py::arg("mesh"), py::arg("mesh_cell1_ds_bouding_box"), py::arg("mesh_cell1_ds_vertices"), py::arg("mesh_cell1_ds_tangent"), py::arg("mesh_cell2_ds_vertices"), py::arg("mesh_cell2_ds_normal"), py::arg("mesh_cell2_ds_2_d_vertices"), py::arg("mesh_cell2_ds_translation"), py::arg("mesh_cell2_ds_rotation_matrix"), py::arg("mesh_cell2_ds_bouding_box"), py::arg("mesh_cell3_ds_bouding_box"), py::arg("mesh_cell3_ds_faces"), py::arg("mesh_cell3_ds_faces_vertices"), py::arg("mesh_cell3_ds_faces_2_d_vertices"), py::arg("mesh_cell3_ds_faces_normal"), py::arg("mesh_cell3_ds_faces_normal_directions"), py::arg("mesh_cell3_ds_faces_translation"), py::arg("mesh_cell3_ds_faces_rotation_matrix"))
            .def("set_polygon_mesh_markers",
                &Gedim::MeshUtilities::SetPolygonMeshMarkers, py::arg("geometry_utilities"), py::arg("polygon_vertices"), py::arg("cell0_d_markers"), py::arg("cell1_d_markers"), py::arg("mesh"))
            .def("check_mesh_geometric_data2_d",
                &Gedim::MeshUtilities::CheckMeshGeometricData2D, py::arg("configuration"), py::arg("geometry_utilities"), py::arg("mesh"), py::arg("geometric_data"))
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:MeshUtilities.hpp>    ////////////////////


    ////////////////////    <generated_from:PlatonicSolid.hpp>    ////////////////////
    // #ifndef __PlatonicSolid_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassPlatonicSolid =
            py::class_<Gedim::PlatonicSolid>
                (pyNsGedim, "PlatonicSolid", py::is_final(), "/ \\brief MeshUtilities\n/ \\copyright See top level LICENSE file for details.\n/\n/ https://danielsieger.com/blog/2021/01/03/generating-platonic-solids.html\n(final class)")
            .def(py::init<const Gedim::GeometryUtilities &, const Gedim::MeshUtilities &>(),
                py::arg("geometry_utilities"), py::arg("mesh_utilities"))
            .def("project_to_unit_sphere",
                &Gedim::PlatonicSolid::project_to_unit_sphere, py::arg("polyhedron"))
            .def("project_to_unit_sphere_geodesic",
                &Gedim::PlatonicSolid::project_to_unit_sphere_geodesic, py::arg("mesh_data"), py::arg("mesh"))
            .def("project_to_unit_sphere_goldberg",
                &Gedim::PlatonicSolid::project_to_unit_sphere_goldberg, py::arg("mesh_data"), py::arg("mesh"))
            .def("dual_polyhedron",
                &Gedim::PlatonicSolid::dual_polyhedron, py::arg("polyhedron"))
            .def("first_class_geodesic_polyhedron",
                &Gedim::PlatonicSolid::first_class_geodesic_polyhedron, py::arg("starting_polyhedron"), py::arg("frequency"), py::arg("filter_mesh"))
            .def("second_class_geodesic_polyhedron",
                &Gedim::PlatonicSolid::second_class_geodesic_polyhedron, py::arg("starting_polyhedron"), py::arg("frequency"), py::arg("filter_mesh"))
            .def("goldberg_polyhedron",
                &Gedim::PlatonicSolid::goldberg_polyhedron, py::arg("p"), py::arg("q"), py::arg("b"), py::arg("c"))
            .def("geodesic_polyhedron",
                &Gedim::PlatonicSolid::geodesic_polyhedron, py::arg("p"), py::arg("q"), py::arg("b"), py::arg("c"))
            .def("tetrahedron",
                &Gedim::PlatonicSolid::tetrahedron)
            .def("hexahedron",
                &Gedim::PlatonicSolid::hexahedron)
            .def("octahedron",
                &Gedim::PlatonicSolid::octahedron)
            .def("icosahedron",
                &Gedim::PlatonicSolid::icosahedron)
            .def("dodecahedron",
                &Gedim::PlatonicSolid::dodecahedron)
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:PlatonicSolid.hpp>    ////////////////////


    ////////////////////    <generated_from:SphereMeshUtilities.hpp>    ////////////////////
    // #ifndef __SphereMeshUtilities_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassSphereMeshUtilities =
            py::class_<Gedim::SphereMeshUtilities>
                (pyNsGedim, "SphereMeshUtilities", py::is_final(), "/ \\brief MeshUtilities\n/ \\copyright See top level LICENSE file for details.\n/\n/ https://danielsieger.com/blog/2021/03/27/generating-spheres.html\n(final class)")
            .def(py::init<const Gedim::GeometryUtilities &, const Gedim::MeshUtilities &>(),
                py::arg("geometry_utilities"), py::arg("mesh_utilities"))
            .def("uv_sphere",
                &Gedim::SphereMeshUtilities::uv_sphere, py::arg("meridians"), py::arg("parallels"))
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:SphereMeshUtilities.hpp>    ////////////////////


    ////////////////////    <generated_from:Quadrature_Gauss2D_Triangle.hpp>    ////////////////////
    // #ifndef __Quadrature_Gauss2D_Triangle_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        { // <namespace Quadrature>
            py::module_ pyNsGedim_NsQuadrature = pyNsGedim.def_submodule("quadrature", "namespace Quadrature");
            auto pyNsGedim_NsQuadrature_ClassQuadrature_Gauss2D_Triangle =
                py::class_<Gedim::Quadrature::Quadrature_Gauss2D_Triangle>
                    (pyNsGedim_NsQuadrature, "Quadrature_Gauss2D_Triangle", "/ Gauss quadrature rule for triangles")
                .def(py::init<>()) // implicit default constructor
                .def_static("fill_points_and_weights",
                    &Gedim::Quadrature::Quadrature_Gauss2D_Triangle::FillPointsAndWeights, py::arg("order"))
                ;
        } // </namespace Quadrature>

    } // </namespace Gedim>
    ////////////////////    </generated_from:Quadrature_Gauss2D_Triangle.hpp>    ////////////////////


    ////////////////////    <generated_from:Quadrature_Gauss2D_Square.hpp>    ////////////////////
    // #ifndef __Quadrature_Gauss2D_Square_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        { // <namespace Quadrature>
            py::module_ pyNsGedim_NsQuadrature = pyNsGedim.def_submodule("quadrature", "namespace Quadrature");
            auto pyNsGedim_NsQuadrature_ClassQuadrature_Gauss2D_Square =
                py::class_<Gedim::Quadrature::Quadrature_Gauss2D_Square>
                    (pyNsGedim_NsQuadrature, "Quadrature_Gauss2D_Square", "/ Gauss quadrature rule for Squares")
                .def(py::init<>()) // implicit default constructor
                .def_static("fill_points_and_weights",
                    &Gedim::Quadrature::Quadrature_Gauss2D_Square::FillPointsAndWeights, py::arg("order"))
                ;
        } // </namespace Quadrature>

    } // </namespace Gedim>
    ////////////////////    </generated_from:Quadrature_Gauss2D_Square.hpp>    ////////////////////


    ////////////////////    <generated_from:Quadrature_Gauss3D_Hexahedron.hpp>    ////////////////////
    // #ifndef __Quadrature_Gauss3D_Hexahedron_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        { // <namespace Quadrature>
            py::module_ pyNsGedim_NsQuadrature = pyNsGedim.def_submodule("quadrature", "namespace Quadrature");
            auto pyNsGedim_NsQuadrature_ClassQuadrature_Gauss3D_Hexahedron =
                py::class_<Gedim::Quadrature::Quadrature_Gauss3D_Hexahedron>
                    (pyNsGedim_NsQuadrature, "Quadrature_Gauss3D_Hexahedron", "/ Gauss quadrature rule for Hexahedrons")
                .def(py::init<>()) // implicit default constructor
                .def_static("fill_points_and_weights",
                    &Gedim::Quadrature::Quadrature_Gauss3D_Hexahedron::FillPointsAndWeights, py::arg("order"))
                ;
        } // </namespace Quadrature>

    } // </namespace Gedim>
    ////////////////////    </generated_from:Quadrature_Gauss3D_Hexahedron.hpp>    ////////////////////


    ////////////////////    <generated_from:Quadrature_GaussLobatto1D.hpp>    ////////////////////
    // #ifndef __Quadrature_GaussLobatto1D_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        { // <namespace Quadrature>
            py::module_ pyNsGedim_NsQuadrature = pyNsGedim.def_submodule("quadrature", "namespace Quadrature");
            auto pyNsGedim_NsQuadrature_ClassQuadrature_GaussLobatto1D =
                py::class_<Gedim::Quadrature::Quadrature_GaussLobatto1D>
                    (pyNsGedim_NsQuadrature, "Quadrature_GaussLobatto1D", "/ Gauss quadrature rule for segments")
                .def(py::init<>()) // implicit default constructor
                .def_static("fill_points_and_weights",
                    &Gedim::Quadrature::Quadrature_GaussLobatto1D::FillPointsAndWeights, py::arg("order"))
                ;
        } // </namespace Quadrature>

    } // </namespace Gedim>
    ////////////////////    </generated_from:Quadrature_GaussLobatto1D.hpp>    ////////////////////


    ////////////////////    <generated_from:Quadrature_Gauss1D.hpp>    ////////////////////
    // #ifndef __Quadrature_Gauss1D_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        { // <namespace Quadrature>
            py::module_ pyNsGedim_NsQuadrature = pyNsGedim.def_submodule("quadrature", "namespace Quadrature");
            auto pyNsGedim_NsQuadrature_ClassQuadrature_Gauss1D =
                py::class_<Gedim::Quadrature::Quadrature_Gauss1D>
                    (pyNsGedim_NsQuadrature, "Quadrature_Gauss1D", "/ Gauss quadrature rule for segments")
                .def(py::init<>()) // implicit default constructor
                .def_static("fill_points_and_weights",
                    &Gedim::Quadrature::Quadrature_Gauss1D::FillPointsAndWeights, py::arg("order"))
                ;
        } // </namespace Quadrature>

    } // </namespace Gedim>
    ////////////////////    </generated_from:Quadrature_Gauss1D.hpp>    ////////////////////


    ////////////////////    <generated_from:QuadratureData.hpp>    ////////////////////
    // #ifndef __QuadratureData_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        { // <namespace Quadrature>
            py::module_ pyNsGedim_NsQuadrature = pyNsGedim.def_submodule("quadrature", "namespace Quadrature");
            auto pyNsGedim_NsQuadrature_ClassQuadratureData =
                py::class_<Gedim::Quadrature::QuadratureData>
                    (pyNsGedim_NsQuadrature, "QuadratureData", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd Points = Eigen::MatrixXd(), Eigen::VectorXd Weights = Eigen::VectorXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::Quadrature::QuadratureData>();
                    r_ctor_->Points = Points;
                    r_ctor_->Weights = Weights;
                    return r_ctor_;
                })
                , py::arg("points") = Eigen::MatrixXd(), py::arg("weights") = Eigen::VectorXd()
                )
                .def_readwrite("points", &Gedim::Quadrature::QuadratureData::Points, "")
                .def_readwrite("weights", &Gedim::Quadrature::QuadratureData::Weights, "")
                ;
        } // </namespace Quadrature>

    } // </namespace Gedim>
    ////////////////////    </generated_from:QuadratureData.hpp>    ////////////////////


    ////////////////////    <generated_from:Quadrature_Gauss3D_Tetrahedron_PositiveWeights.hpp>    ////////////////////
    // #ifndef __Quadrature_Gauss3D_Tetrahedron_PositiveWeights_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        { // <namespace Quadrature>
            py::module_ pyNsGedim_NsQuadrature = pyNsGedim.def_submodule("quadrature", "namespace Quadrature");
            auto pyNsGedim_NsQuadrature_ClassQuadrature_Gauss3D_Tetrahedron_PositiveWeights =
                py::class_<Gedim::Quadrature::Quadrature_Gauss3D_Tetrahedron_PositiveWeights>
                    (pyNsGedim_NsQuadrature, "Quadrature_Gauss3D_Tetrahedron_PositiveWeights", "/ Gauss quadrature rule for Tetrahedrons")
                .def(py::init<>()) // implicit default constructor
                .def_static("fill_points_and_weights",
                    &Gedim::Quadrature::Quadrature_Gauss3D_Tetrahedron_PositiveWeights::FillPointsAndWeights, py::arg("order"))
                ;
        } // </namespace Quadrature>

    } // </namespace Gedim>
    ////////////////////    </generated_from:Quadrature_Gauss3D_Tetrahedron_PositiveWeights.hpp>    ////////////////////


    ////////////////////    <generated_from:Quadrature_Gauss3D_Tetrahedron.hpp>    ////////////////////
    // #ifndef __Quadrature_Gauss3D_Tetrahedron_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        { // <namespace Quadrature>
            py::module_ pyNsGedim_NsQuadrature = pyNsGedim.def_submodule("quadrature", "namespace Quadrature");
            auto pyNsGedim_NsQuadrature_ClassQuadrature_Gauss3D_Tetrahedron =
                py::class_<Gedim::Quadrature::Quadrature_Gauss3D_Tetrahedron>
                    (pyNsGedim_NsQuadrature, "Quadrature_Gauss3D_Tetrahedron", "/ Gauss quadrature rule for Tetrahedrons")
                .def(py::init<>()) // implicit default constructor
                .def_static("fill_points_and_weights",
                    &Gedim::Quadrature::Quadrature_Gauss3D_Tetrahedron::FillPointsAndWeights, py::arg("order"))
                ;
        } // </namespace Quadrature>

    } // </namespace Gedim>
    ////////////////////    </generated_from:Quadrature_Gauss3D_Tetrahedron.hpp>    ////////////////////


    ////////////////////    <generated_from:lagrange_1D.hpp>    ////////////////////
    // #ifndef __Interpolation_Lagrange_1D_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Interpolation>
            py::module_ pyNsPolydim_NsInterpolation = pyNsPolydim.def_submodule("interpolation", "namespace Interpolation");
            { // <namespace Lagrange>
                py::module_ pyNsPolydim_NsInterpolation_NsLagrange = pyNsPolydim_NsInterpolation.def_submodule("lagrange", "namespace Lagrange");
                pyNsPolydim_NsInterpolation_NsLagrange.def("lagrange_1_d_coefficients",
                    Polydim::Interpolation::Lagrange::Lagrange_1D_coefficients, py::arg("interpolation_points_x"));

                pyNsPolydim_NsInterpolation_NsLagrange.def("lagrange_1_d_values",
                    Polydim::Interpolation::Lagrange::Lagrange_1D_values, py::arg("interpolation_points_x"), py::arg("lagrange_1_d_coefficients"), py::arg("evaluation_points_x"));

                pyNsPolydim_NsInterpolation_NsLagrange.def("lagrange_1_d_derivative_values",
                    Polydim::Interpolation::Lagrange::Lagrange_1D_derivative_values, py::arg("interpolation_points_x"), py::arg("lagrange_1_d_coefficients"), py::arg("evaluation_points_x"));
            } // </namespace Lagrange>

        } // </namespace Interpolation>

    } // </namespace Polydim>
    ////////////////////    </generated_from:lagrange_1D.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_Quadrature_2D.hpp>    ////////////////////
    // #ifndef __VEM_Quadrature_2D_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace Quadrature>
                py::module_ pyNsPolydim_NsVEM_NsQuadrature = pyNsPolydim_NsVEM.def_submodule("quadrature", "namespace Quadrature");
                auto pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_QuadratureData_2D =
                    py::class_<Polydim::VEM::Quadrature::VEM_QuadratureData_2D>
                        (pyNsPolydim_NsVEM_NsQuadrature, "VEM_QuadratureData_2D", "")
                    .def(py::init<>([](
                    Gedim::Quadrature::QuadratureData ReferenceSegmentQuadrature = Gedim::Quadrature::QuadratureData(), Gedim::Quadrature::QuadratureData ReferenceEdgeDOFsQuadrature = Gedim::Quadrature::QuadratureData(), Gedim::Quadrature::QuadratureData ReferenceTriangleQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd ReferenceSegmentInternalPoints = Eigen::MatrixXd(), Eigen::VectorXd ReferenceSegmentInternalWeights = Eigen::VectorXd(), Eigen::Vector2d ReferenceSegmentExtremaWeights = Eigen::Vector2d(), Eigen::MatrixXd ReferenceEdgeDOFsInternalPoints = Eigen::MatrixXd(), Eigen::VectorXd ReferenceEdgeDOFsInternalWeights = Eigen::VectorXd(), Eigen::Vector2d ReferenceEdgeDOFsExtremaWeights = Eigen::Vector2d())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::Quadrature::VEM_QuadratureData_2D>();
                        r_ctor_->ReferenceSegmentQuadrature = ReferenceSegmentQuadrature;
                        r_ctor_->ReferenceEdgeDOFsQuadrature = ReferenceEdgeDOFsQuadrature;
                        r_ctor_->ReferenceTriangleQuadrature = ReferenceTriangleQuadrature;
                        r_ctor_->ReferenceSegmentInternalPoints = ReferenceSegmentInternalPoints;
                        r_ctor_->ReferenceSegmentInternalWeights = ReferenceSegmentInternalWeights;
                        r_ctor_->ReferenceSegmentExtremaWeights = ReferenceSegmentExtremaWeights;
                        r_ctor_->ReferenceEdgeDOFsInternalPoints = ReferenceEdgeDOFsInternalPoints;
                        r_ctor_->ReferenceEdgeDOFsInternalWeights = ReferenceEdgeDOFsInternalWeights;
                        r_ctor_->ReferenceEdgeDOFsExtremaWeights = ReferenceEdgeDOFsExtremaWeights;
                        return r_ctor_;
                    })
                    , py::arg("reference_segment_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_edge_do_fs_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_triangle_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_segment_internal_points") = Eigen::MatrixXd(), py::arg("reference_segment_internal_weights") = Eigen::VectorXd(), py::arg("reference_segment_extrema_weights") = Eigen::Vector2d(), py::arg("reference_edge_do_fs_internal_points") = Eigen::MatrixXd(), py::arg("reference_edge_do_fs_internal_weights") = Eigen::VectorXd(), py::arg("reference_edge_do_fs_extrema_weights") = Eigen::Vector2d()
                    )
                    .def_readwrite("reference_segment_quadrature", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceSegmentQuadrature, "")
                    .def_readwrite("reference_edge_do_fs_quadrature", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceEdgeDOFsQuadrature, "")
                    .def_readwrite("reference_triangle_quadrature", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceTriangleQuadrature, "")
                    .def_readwrite("reference_segment_internal_points", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceSegmentInternalPoints, "")
                    .def_readwrite("reference_segment_internal_weights", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceSegmentInternalWeights, "")
                    .def_readwrite("reference_segment_extrema_weights", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceSegmentExtremaWeights, "")
                    .def_readwrite("reference_edge_do_fs_internal_points", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceEdgeDOFsInternalPoints, "")
                    .def_readwrite("reference_edge_do_fs_internal_weights", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceEdgeDOFsInternalWeights, "")
                    .def_readwrite("reference_edge_do_fs_extrema_weights", &Polydim::VEM::Quadrature::VEM_QuadratureData_2D::ReferenceEdgeDOFsExtremaWeights, "")
                    ;


                auto pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_2D =
                    py::class_<Polydim::VEM::Quadrature::VEM_Quadrature_2D>
                        (pyNsPolydim_NsVEM_NsQuadrature, "VEM_Quadrature_2D", py::is_final(), "\n(final class)");

                { // inner classes & enums of VEM_Quadrature_2D
                    auto pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_2D_ClassEdges_QuadratureData =
                        py::class_<Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData>
                            (pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_2D, "Edges_QuadratureData", "")
                        .def(py::init<>([](
                        Gedim::Quadrature::QuadratureData Quadrature = Gedim::Quadrature::QuadratureData(), std::vector<Eigen::VectorXd> WeightsTimesNormal = std::vector<Eigen::VectorXd>())
                        {
                            auto r_ctor_ = std::make_unique<Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData>();
                            r_ctor_->Quadrature = Quadrature;
                            r_ctor_->WeightsTimesNormal = WeightsTimesNormal;
                            return r_ctor_;
                        })
                        , py::arg("quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("weights_times_normal") = std::vector<Eigen::VectorXd>()
                        )
                        .def_readwrite("quadrature", &Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData::Quadrature, "")
                        .def_readwrite("weights_times_normal", &Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData::WeightsTimesNormal, "")
                        ;
                } // end of inner classes & enums of VEM_Quadrature_2D

                pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_2D
                    .def(py::init<>()) // implicit default constructor
                    .def("compute_pcc_2_d",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_2D::Compute_PCC_2D, py::arg("order"))
                    .def("compute_mcc_2_d",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_2D::Compute_MCC_2D, py::arg("order"))
                    .def("compute_mcc_edge_ortho_2_d",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_2D::Compute_MCC_EdgeOrtho_2D, py::arg("order"))
                    .def("compute_df_pcc_2_d",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_2D::Compute_DF_PCC_2D, py::arg("order"))
                    .def("compute_df_pcc_3_d",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_2D::Compute_DF_PCC_3D, py::arg("order"))
                    .def("polygon_internal_quadrature",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_2D::PolygonInternalQuadrature, py::arg("data"), py::arg("polygon_triangulation_vertices"))
                    .def("polygon_edges_lobatto_quadrature",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_2D::PolygonEdgesLobattoQuadrature, py::arg("reference_segment_internal_points"), py::arg("reference_segment_internal_weights"), py::arg("reference_segment_extrema_weights"), py::arg("polygon_vertices"), py::arg("edge_lengths"), py::arg("edge_directions"), py::arg("edge_tangents"), py::arg("edge_normals"))
                    .def("polygon_edges_quadrature",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_2D::PolygonEdgesQuadrature, py::arg("data"), py::arg("polygon_vertices"), py::arg("edge_lengths"), py::arg("edge_directions"), py::arg("edge_tangents"), py::arg("edge_normals"))
                    ;
            } // </namespace Quadrature>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_Quadrature_2D.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_Quadrature_3D.hpp>    ////////////////////
    // #ifndef __VEM_Quadrature_3D_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace Quadrature>
                py::module_ pyNsPolydim_NsVEM_NsQuadrature = pyNsPolydim_NsVEM.def_submodule("quadrature", "namespace Quadrature");
                auto pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_QuadratureData_3D =
                    py::class_<Polydim::VEM::Quadrature::VEM_QuadratureData_3D>
                        (pyNsPolydim_NsVEM_NsQuadrature, "VEM_QuadratureData_3D", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::Quadrature::QuadratureData ReferenceTetrahedronQuadrature = Gedim::Quadrature::QuadratureData(), Polydim::VEM::Quadrature::VEM_QuadratureData_2D QuadratureData_2D = Polydim::VEM::Quadrature::VEM_QuadratureData_2D())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::Quadrature::VEM_QuadratureData_3D>();
                        r_ctor_->ReferenceTetrahedronQuadrature = ReferenceTetrahedronQuadrature;
                        r_ctor_->QuadratureData_2D = QuadratureData_2D;
                        return r_ctor_;
                    })
                    , py::arg("reference_tetrahedron_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("quadrature_data_2_d") = Polydim::VEM::Quadrature::VEM_QuadratureData_2D()
                    )
                    .def_readwrite("reference_tetrahedron_quadrature", &Polydim::VEM::Quadrature::VEM_QuadratureData_3D::ReferenceTetrahedronQuadrature, "")
                    .def_readwrite("quadrature_data_2_d", &Polydim::VEM::Quadrature::VEM_QuadratureData_3D::QuadratureData_2D, "")
                    ;


                auto pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_3D =
                    py::class_<Polydim::VEM::Quadrature::VEM_Quadrature_3D>
                        (pyNsPolydim_NsVEM_NsQuadrature, "VEM_Quadrature_3D", py::is_final(), "\n(final class)");

                { // inner classes & enums of VEM_Quadrature_3D
                    auto pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_3D_ClassFaces_QuadratureData_PCC =
                        py::class_<Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC>
                            (pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_3D, "Faces_QuadratureData_PCC", "")
                        .def(py::init<>([](
                        Gedim::Quadrature::QuadratureData Quadrature = Gedim::Quadrature::QuadratureData(), std::vector<Eigen::VectorXd> WeightsTimesNormal = std::vector<Eigen::VectorXd>())
                        {
                            auto r_ctor_ = std::make_unique<Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC>();
                            r_ctor_->Quadrature = Quadrature;
                            r_ctor_->WeightsTimesNormal = WeightsTimesNormal;
                            return r_ctor_;
                        })
                        , py::arg("quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("weights_times_normal") = std::vector<Eigen::VectorXd>()
                        )
                        .def_readwrite("quadrature", &Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC::Quadrature, "")
                        .def_readwrite("weights_times_normal", &Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC::WeightsTimesNormal, "")
                        ;
                    auto pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_3D_ClassFaces_QuadratureData_MCC =
                        py::class_<Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_MCC>
                            (pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_3D, "Faces_QuadratureData_MCC", "")
                        .def(py::init<>([](
                        Gedim::Quadrature::QuadratureData Quadrature = Gedim::Quadrature::QuadratureData(), std::vector<Gedim::Quadrature::QuadratureData> FacesQuadrature = std::vector<Gedim::Quadrature::QuadratureData>())
                        {
                            auto r_ctor_ = std::make_unique<Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_MCC>();
                            r_ctor_->Quadrature = Quadrature;
                            r_ctor_->FacesQuadrature = FacesQuadrature;
                            return r_ctor_;
                        })
                        , py::arg("quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("faces_quadrature") = std::vector<Gedim::Quadrature::QuadratureData>()
                        )
                        .def_readwrite("quadrature", &Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_MCC::Quadrature, "")
                        .def_readwrite("faces_quadrature", &Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_MCC::FacesQuadrature, "")
                        ;
                } // end of inner classes & enums of VEM_Quadrature_3D

                pyNsPolydim_NsVEM_NsQuadrature_ClassVEM_Quadrature_3D
                    .def(py::init<>()) // implicit default constructor
                    .def("compute_pcc_3_d",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_3D::Compute_PCC_3D, py::arg("order"))
                    .def("compute_mcc_3_d",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_3D::Compute_MCC_3D, py::arg("order"))
                    .def("compute_df_pcc_3_d",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_3D::Compute_DF_PCC_3D, py::arg("order"))
                    .def("polyhedron_internal_quadrature",
                        py::overload_cast<const Polydim::VEM::Quadrature::VEM_QuadratureData_3D &, const Gedim::GeometryUtilities &, const std::vector<Eigen::MatrixXd> &>(&Polydim::VEM::Quadrature::VEM_Quadrature_3D::PolyhedronInternalQuadrature, py::const_), py::arg("data"), py::arg("geometry_utility"), py::arg("polyhedron_tetrahedron_vertices"))
                    .def("polyhedron_internal_quadrature",
                        py::overload_cast<const Gedim::GeometryUtilities &, const Gedim::Quadrature::QuadratureData &, const std::vector<Eigen::MatrixXd> &>(&Polydim::VEM::Quadrature::VEM_Quadrature_3D::PolyhedronInternalQuadrature, py::const_), py::arg("geometry_utility"), py::arg("data"), py::arg("polyhedron_tetrahedron_vertices"))
                    .def("polyhedron_faces_quadrature",
                        py::overload_cast<const Gedim::GeometryUtilities &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::Matrix3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<bool> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::VectorXd> &>(&Polydim::VEM::Quadrature::VEM_Quadrature_3D::PolyhedronFacesQuadrature, py::const_), py::arg("geometry_utility"), py::arg("polyhedron_faces"), py::arg("faces_rotation_matrix"), py::arg("faces_translation"), py::arg("faces_normals"), py::arg("face_normal_directions"), py::arg("faces_quadrature_points"), py::arg("faces_quadrature_weights"))
                    .def("polyhedron_internal_edges_quadrature_points",
                        &Polydim::VEM::Quadrature::VEM_Quadrature_3D::PolyhedronInternalEdgesQuadraturePoints, py::arg("reference_segment_internal_points"), py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("edge_directions"), py::arg("edge_tangents"))
                    .def("polyhedron_faces_quadrature",
                        py::overload_cast<const Polydim::VEM::Quadrature::VEM_QuadratureData_3D &, const Gedim::GeometryUtilities &, const std::vector<std::vector<Eigen::Matrix3d>> &, const std::vector<Eigen::Matrix3d> &, const std::vector<Eigen::Vector3d> &>(&Polydim::VEM::Quadrature::VEM_Quadrature_3D::PolyhedronFacesQuadrature, py::const_), py::arg("data"), py::arg("geometry_utility"), py::arg("faces_triangulations2_d"), py::arg("faces_rotation_matrix"), py::arg("faces_translation"))
                    ;
            } // </namespace Quadrature>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_Quadrature_3D.hpp>    ////////////////////


    ////////////////////    <generated_from:Monomials_Data.hpp>    ////////////////////
    // #ifndef __Monomials_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Utilities>
            py::module_ pyNsPolydim_NsUtilities = pyNsPolydim.def_submodule("utilities", "namespace Utilities");
            auto pyNsPolydim_NsUtilities_ClassMonomials_Data =
                py::class_<Polydim::Utilities::Monomials_Data>
                    (pyNsPolydim_NsUtilities, "Monomials_Data", "")
                .def(py::init<>([](
                std::vector<Eigen::VectorXi> Exponents = std::vector<Eigen::VectorXi>(), std::vector<Eigen::MatrixXd> DerivativeMatrices = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Laplacian = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Polydim::Utilities::Monomials_Data>();
                    r_ctor_->Exponents = Exponents;
                    r_ctor_->DerivativeMatrices = DerivativeMatrices;
                    r_ctor_->Laplacian = Laplacian;
                    return r_ctor_;
                })
                , py::arg("exponents") = std::vector<Eigen::VectorXi>(), py::arg("derivative_matrices") = std::vector<Eigen::MatrixXd>(), py::arg("laplacian") = Eigen::MatrixXd()
                )
                .def_readwrite("polynomial_degree", &Polydim::Utilities::Monomials_Data::PolynomialDegree, "/< Monomial space order")
                .def_readwrite("dimension", &Polydim::Utilities::Monomials_Data::Dimension, "/< The geometric dimension")
                .def_readwrite("num_monomials", &Polydim::Utilities::Monomials_Data::NumMonomials, "/< Number of monomials in the basis.")
                .def_readwrite("exponents", &Polydim::Utilities::Monomials_Data::Exponents, "/< Table of exponents of each monomial.")
                .def_readwrite("derivative_matrices", &Polydim::Utilities::Monomials_Data::DerivativeMatrices, "/< Matrices used to compute derivatives of monomials.")
                .def_readwrite("laplacian", &Polydim::Utilities::Monomials_Data::Laplacian, "/< Matrix used to compute the laplacian of monomials.")
                ;
        } // </namespace Utilities>

    } // </namespace Polydim>
    ////////////////////    </generated_from:Monomials_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:GBasis_Data.hpp>    ////////////////////
    // #ifndef __GBasis_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Utilities>
            py::module_ pyNsPolydim_NsUtilities = pyNsPolydim.def_submodule("utilities", "namespace Utilities");
            auto pyNsPolydim_NsUtilities_ClassGBasis_Data =
                py::class_<Polydim::Utilities::GBasis_Data>
                    (pyNsPolydim_NsUtilities, "GBasis_Data", "")
                .def(py::init<>([](
                Polydim::Utilities::Monomials_Data monomials_data = Polydim::Utilities::Monomials_Data(), std::vector<std::vector<Eigen::MatrixXd>> VectorDecomposition = std::vector<std::vector<Eigen::MatrixXd>>(), Eigen::MatrixXi MatrixExponents = Eigen::MatrixXi(), std::vector<int> MapFirstGroupVectorDecomposition = std::vector<int>())
                {
                    auto r_ctor_ = std::make_unique<Polydim::Utilities::GBasis_Data>();
                    r_ctor_->monomials_data = monomials_data;
                    r_ctor_->VectorDecomposition = VectorDecomposition;
                    r_ctor_->MatrixExponents = MatrixExponents;
                    r_ctor_->MapFirstGroupVectorDecomposition = MapFirstGroupVectorDecomposition;
                    return r_ctor_;
                })
                , py::arg("monomials_data") = Polydim::Utilities::Monomials_Data(), py::arg("vector_decomposition") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("matrix_exponents") = Eigen::MatrixXi(), py::arg("map_first_group_vector_decomposition") = std::vector<int>()
                )
                .def_readwrite("polynomial_degree", &Polydim::Utilities::GBasis_Data::PolynomialDegree, "")
                .def_readwrite("dimension", &Polydim::Utilities::GBasis_Data::Dimension, "")
                .def_readwrite("monomials_data", &Polydim::Utilities::GBasis_Data::monomials_data, "")
                .def_readwrite("nk", &Polydim::Utilities::GBasis_Data::Nk, "")
                .def_readwrite("nkm1", &Polydim::Utilities::GBasis_Data::Nkm1, "")
                .def_readwrite("nkp1", &Polydim::Utilities::GBasis_Data::Nkp1, "")
                .def_readwrite("nk_g_big_o_plus", &Polydim::Utilities::GBasis_Data::NkGBigOPlus, "")
                .def_readwrite("nk_g_nabla", &Polydim::Utilities::GBasis_Data::NkGNabla, "")
                .def_readwrite("vector_decomposition", &Polydim::Utilities::GBasis_Data::VectorDecomposition, "")
                .def_readwrite("matrix_exponents", &Polydim::Utilities::GBasis_Data::MatrixExponents, "")
                .def_readwrite("dim_first_basis", &Polydim::Utilities::GBasis_Data::DimFirstBasis, "")
                .def_readwrite("map_exponents", &Polydim::Utilities::GBasis_Data::MapExponents, "")
                .def_readwrite("save_first_group_vector_decomposition", &Polydim::Utilities::GBasis_Data::SaveFirstGroupVectorDecomposition, "")
                .def_readwrite("map_first_group_vector_decomposition", &Polydim::Utilities::GBasis_Data::MapFirstGroupVectorDecomposition, "")
                ;
        } // </namespace Utilities>

    } // </namespace Polydim>
    ////////////////////    </generated_from:GBasis_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:GBasis_2D.hpp>    ////////////////////
    // #ifndef __GBasis_2D_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Utilities>
            py::module_ pyNsPolydim_NsUtilities = pyNsPolydim.def_submodule("utilities", "namespace Utilities");
            auto pyNsPolydim_NsUtilities_ClassGBasis_2D =
                py::class_<Polydim::Utilities::GBasis_2D>
                    (pyNsPolydim_NsUtilities, "GBasis_2D", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def("compute",
                    &Polydim::Utilities::GBasis_2D::Compute, py::arg("polynomial_degree"))
                .def("vander_g_big_o_plus",
                    &Polydim::Utilities::GBasis_2D::VanderGBigOPlus, py::arg("data"), py::arg("vander"))
                ;
        } // </namespace Utilities>

    } // </namespace Polydim>
    ////////////////////    </generated_from:GBasis_2D.hpp>    ////////////////////


    ////////////////////    <generated_from:GBasis_3D.hpp>    ////////////////////
    // #ifndef __GBasis_3D_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Utilities>
            py::module_ pyNsPolydim_NsUtilities = pyNsPolydim.def_submodule("utilities", "namespace Utilities");
            auto pyNsPolydim_NsUtilities_ClassGBasis_3D =
                py::class_<Polydim::Utilities::GBasis_3D>
                    (pyNsPolydim_NsUtilities, "GBasis_3D", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def("compute",
                    &Polydim::Utilities::GBasis_3D::Compute, py::arg("polynomial_degree"))
                .def("vander_g_big_o_plus",
                    &Polydim::Utilities::GBasis_3D::VanderGBigOPlus, py::arg("data"), py::arg("vander"))
                .def("vector_decomposition",
                    &Polydim::Utilities::GBasis_3D::VectorDecomposition, py::arg("data"))
                ;
        } // </namespace Utilities>

    } // </namespace Polydim>
    ////////////////////    </generated_from:GBasis_3D.hpp>    ////////////////////


    ////////////////////    <generated_from:Monomials_1D.hpp>    ////////////////////
    // #ifndef __Monomials_1D_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Utilities>
            py::module_ pyNsPolydim_NsUtilities = pyNsPolydim.def_submodule("utilities", "namespace Utilities");
            auto pyNsPolydim_NsUtilities_ClassMonomials_1D =
                py::class_<Polydim::Utilities::Monomials_1D>
                    (pyNsPolydim_NsUtilities, "Monomials_1D", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def("compute",
                    &Polydim::Utilities::Monomials_1D::Compute, py::arg("polynomial_degree"))
                .def("exponents",
                    &Polydim::Utilities::Monomials_1D::Exponents, py::arg("data"))
                .def("derivative_matrix",
                    &Polydim::Utilities::Monomials_1D::DerivativeMatrix, py::arg("data"), py::arg("i"))
                .def("d_x",
                    &Polydim::Utilities::Monomials_1D::D_x, py::arg("data"))
                .def("index",
                    &Polydim::Utilities::Monomials_1D::Index, py::arg("exponents"))
                .def("derivative_indices",
                    &Polydim::Utilities::Monomials_1D::DerivativeIndices, py::arg("data"), py::arg("index"))
                .def("second_derivative_indices",
                    &Polydim::Utilities::Monomials_1D::SecondDerivativeIndices, py::arg("data"), py::arg("index"))
                .def("vander",
                    &Polydim::Utilities::Monomials_1D::Vander, py::arg("data"), py::arg("points"), py::arg("centroid"), py::arg("diam"))
                .def("vander_derivatives",
                    &Polydim::Utilities::Monomials_1D::VanderDerivatives, py::arg("data"), py::arg("vander"), py::arg("diam"))
                .def("vander_laplacian",
                    &Polydim::Utilities::Monomials_1D::VanderLaplacian, py::arg("data"), py::arg("vander"), py::arg("diam"))
                .def("mgs_orthonormalize",
                    &Polydim::Utilities::Monomials_1D::MGSOrthonormalize, py::arg("weights"), py::arg("vander"), py::arg("hmatrix"), py::arg("qmatrix_inv"), py::arg("qmatrix"))
                ;
        } // </namespace Utilities>

    } // </namespace Polydim>
    ////////////////////    </generated_from:Monomials_1D.hpp>    ////////////////////


    ////////////////////    <generated_from:Monomials_2D.hpp>    ////////////////////
    // #ifndef __Monomials_2D_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Utilities>
            py::module_ pyNsPolydim_NsUtilities = pyNsPolydim.def_submodule("utilities", "namespace Utilities");
            auto pyNsPolydim_NsUtilities_ClassMonomials_2D =
                py::class_<Polydim::Utilities::Monomials_2D>
                    (pyNsPolydim_NsUtilities, "Monomials_2D", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def("compute",
                    &Polydim::Utilities::Monomials_2D::Compute, py::arg("polynomial_degree"))
                .def("exponents",
                    &Polydim::Utilities::Monomials_2D::Exponents, py::arg("data"))
                .def("derivative_matrix",
                    &Polydim::Utilities::Monomials_2D::DerivativeMatrix, py::arg("data"), py::arg("i"))
                .def("d_x",
                    &Polydim::Utilities::Monomials_2D::D_x, py::arg("data"))
                .def("d_y",
                    &Polydim::Utilities::Monomials_2D::D_y, py::arg("data"))
                .def("index",
                    &Polydim::Utilities::Monomials_2D::Index, py::arg("exponents"))
                .def("derivative_indices",
                    &Polydim::Utilities::Monomials_2D::DerivativeIndices, py::arg("data"), py::arg("index"))
                .def("second_derivative_indices",
                    &Polydim::Utilities::Monomials_2D::SecondDerivativeIndices, py::arg("data"), py::arg("index"))
                .def("vander",
                    &Polydim::Utilities::Monomials_2D::Vander, py::arg("data"), py::arg("points"), py::arg("centroid"), py::arg("diam"))
                .def("vander_derivatives",
                    &Polydim::Utilities::Monomials_2D::VanderDerivatives, py::arg("data"), py::arg("vander"), py::arg("diam"))
                .def("vander_laplacian",
                    &Polydim::Utilities::Monomials_2D::VanderLaplacian, py::arg("data"), py::arg("vander"), py::arg("diam"))
                .def("mgs_orthonormalize",
                    &Polydim::Utilities::Monomials_2D::MGSOrthonormalize, py::arg("weights"), py::arg("vander"), py::arg("hmatrix"), py::arg("qmatrix_inv"), py::arg("qmatrix"))
                ;
        } // </namespace Utilities>

    } // </namespace Polydim>
    ////////////////////    </generated_from:Monomials_2D.hpp>    ////////////////////


    ////////////////////    <generated_from:Monomials_3D.hpp>    ////////////////////
    // #ifndef __Monomials_3D_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Utilities>
            py::module_ pyNsPolydim_NsUtilities = pyNsPolydim.def_submodule("utilities", "namespace Utilities");
            auto pyNsPolydim_NsUtilities_ClassMonomials_3D =
                py::class_<Polydim::Utilities::Monomials_3D>
                    (pyNsPolydim_NsUtilities, "Monomials_3D", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def("compute",
                    &Polydim::Utilities::Monomials_3D::Compute, py::arg("polynomial_degree"))
                .def("exponents",
                    &Polydim::Utilities::Monomials_3D::Exponents, py::arg("data"))
                .def("derivative_matrix",
                    &Polydim::Utilities::Monomials_3D::DerivativeMatrix, py::arg("data"), py::arg("i"))
                .def("d_x",
                    &Polydim::Utilities::Monomials_3D::D_x, py::arg("data"))
                .def("d_y",
                    &Polydim::Utilities::Monomials_3D::D_y, py::arg("data"))
                .def("d_z",
                    &Polydim::Utilities::Monomials_3D::D_z, py::arg("data"))
                .def("index",
                    &Polydim::Utilities::Monomials_3D::Index, py::arg("exponents"))
                .def("derivative_indices",
                    &Polydim::Utilities::Monomials_3D::DerivativeIndices, py::arg("data"), py::arg("index"))
                .def("second_derivative_indices",
                    &Polydim::Utilities::Monomials_3D::SecondDerivativeIndices, py::arg("data"), py::arg("index"))
                .def("vander",
                    &Polydim::Utilities::Monomials_3D::Vander, py::arg("data"), py::arg("points"), py::arg("centroid"), py::arg("diam"))
                .def("vander_derivatives",
                    &Polydim::Utilities::Monomials_3D::VanderDerivatives, py::arg("data"), py::arg("vander"), py::arg("diam"))
                .def("vander_laplacian",
                    &Polydim::Utilities::Monomials_3D::VanderLaplacian, py::arg("data"), py::arg("vander"), py::arg("diam"))
                .def("mgs_orthonormalize",
                    &Polydim::Utilities::Monomials_3D::MGSOrthonormalize, py::arg("weights"), py::arg("vander"), py::arg("hmatrix"), py::arg("qmatrix_inv"), py::arg("qmatrix"))
                ;
        } // </namespace Utilities>

    } // </namespace Polydim>
    ////////////////////    </generated_from:Monomials_3D.hpp>    ////////////////////


    ////////////////////    <generated_from:Inertia_Utilities.hpp>    ////////////////////
    // #ifndef __Inertia_Utilities_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace Utilities>
            py::module_ pyNsPolydim_NsUtilities = pyNsPolydim.def_submodule("utilities", "namespace Utilities");
            auto pyNsPolydim_NsUtilities_ClassInertia_Data =
                py::class_<Polydim::Utilities::Inertia_Data>
                    (pyNsPolydim_NsUtilities, "Inertia_Data", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::Matrix3d Fmatrix = Eigen::Matrix3d(), Eigen::Matrix3d FmatrixInv = Eigen::Matrix3d(), Eigen::Vector3d translation = Eigen::Vector3d(), double absDetFmatrix = double(), double signDetQ = double())
                {
                    auto r_ctor_ = std::make_unique<Polydim::Utilities::Inertia_Data>();
                    r_ctor_->Fmatrix = Fmatrix;
                    r_ctor_->FmatrixInv = FmatrixInv;
                    r_ctor_->translation = translation;
                    r_ctor_->absDetFmatrix = absDetFmatrix;
                    r_ctor_->signDetQ = signDetQ;
                    return r_ctor_;
                })
                , py::arg("fmatrix") = Eigen::Matrix3d(), py::arg("fmatrix_inv") = Eigen::Matrix3d(), py::arg("translation") = Eigen::Vector3d(), py::arg("abs_det_fmatrix") = double(), py::arg("sign_det_q") = double()
                )
                .def_readwrite("fmatrix", &Polydim::Utilities::Inertia_Data::Fmatrix, "")
                .def_readwrite("fmatrix_inv", &Polydim::Utilities::Inertia_Data::FmatrixInv, "")
                .def_readwrite("translation", &Polydim::Utilities::Inertia_Data::translation, "")
                .def_readwrite("abs_det_fmatrix", &Polydim::Utilities::Inertia_Data::absDetFmatrix, "")
                .def_readwrite("sign_det_q", &Polydim::Utilities::Inertia_Data::signDetQ, "")
                ;


            auto pyNsPolydim_NsUtilities_ClassInertia_Utilities =
                py::class_<Polydim::Utilities::Inertia_Utilities>
                    (pyNsPolydim_NsUtilities, "Inertia_Utilities", py::is_final(), "\n(final class)")
                .def(py::init<>()) // implicit default constructor
                .def("inertia_mapping2_d",
                    &Polydim::Utilities::Inertia_Utilities::InertiaMapping2D, py::arg("geometry_utilities"), py::arg("vertices"), py::arg("centroid"), py::arg("diameter"), py::arg("triangulation_vertices"), py::arg("inertia_data"))
                .def("inertia_mapping3_d",
                    &Polydim::Utilities::Inertia_Utilities::InertiaMapping3D, py::arg("geometry_utilities"), py::arg("vertices"), py::arg("centroid"), py::arg("diameter"), py::arg("tetrahedrons_vertices"), py::arg("inertia_data"))
                ;
        } // </namespace Utilities>

    } // </namespace Polydim>
    ////////////////////    </generated_from:Inertia_Utilities.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_2D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_PCC_2D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_2D_ReferenceElement =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_2D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_2D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_2D_LocalSpace_Data.hpp>    ////////////////////
    // #ifndef __VEM_PCC_2D_LocalSpace_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_2D_Polygon_Geometry =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_2D_Polygon_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), double Tolerance2D = double(), Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::Vector3d Centroid = Eigen::Vector3d(), double Measure = double(), double Diameter = double(), std::vector<Eigen::Matrix3d> TriangulationVertices = std::vector<Eigen::Matrix3d>(), Eigen::VectorXd EdgesLength = Eigen::VectorXd(), std::vector<bool> EdgesDirection = std::vector<bool>(), Eigen::MatrixXd EdgesTangent = Eigen::MatrixXd(), Eigen::MatrixXd EdgesNormal = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Tolerance2D = Tolerance2D;
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->TriangulationVertices = TriangulationVertices;
                        r_ctor_->EdgesLength = EdgesLength;
                        r_ctor_->EdgesDirection = EdgesDirection;
                        r_ctor_->EdgesTangent = EdgesTangent;
                        r_ctor_->EdgesNormal = EdgesNormal;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("tolerance2_d") = double(), py::arg("vertices") = Eigen::MatrixXd(), py::arg("centroid") = Eigen::Vector3d(), py::arg("measure") = double(), py::arg("diameter") = double(), py::arg("triangulation_vertices") = std::vector<Eigen::Matrix3d>(), py::arg("edges_length") = Eigen::VectorXd(), py::arg("edges_direction") = std::vector<bool>(), py::arg("edges_tangent") = Eigen::MatrixXd(), py::arg("edges_normal") = Eigen::MatrixXd()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::Tolerance1D, "")
                    .def_readwrite("tolerance2_d", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::Tolerance2D, "")
                    .def_readwrite("vertices", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::Vertices, "")
                    .def_readwrite("centroid", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::Centroid, "")
                    .def_readwrite("measure", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::Measure, "")
                    .def_readwrite("diameter", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::Diameter, "")
                    .def_readwrite("triangulation_vertices", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::TriangulationVertices, "")
                    .def_readwrite("edges_length", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::EdgesLength, "")
                    .def_readwrite("edges_direction", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::EdgesDirection, "")
                    .def_readwrite("edges_tangent", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::EdgesTangent, "")
                    .def_readwrite("edges_normal", &Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry::EdgesNormal, "")
                    ;


                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_2D_LocalSpace_Data =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_2D_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData BoundaryQuadrature = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), Gedim::Quadrature::QuadratureData InternalQuadratureKL = Gedim::Quadrature::QuadratureData(), Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData BoundaryQuadratureKL = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), double Diameter = double(), double Measure = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd VanderInternalKL = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderInternalDerivatives = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd VanderBoundary = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderBoundaryDerivatives = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd PiNabla = Eigen::MatrixXd(), Eigen::MatrixXd Pi0km1 = Eigen::MatrixXd(), Eigen::MatrixXd Pi0k = Eigen::MatrixXd(), Eigen::MatrixXd Pi0klm1 = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> Pi0km1Der = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd(), Eigen::MatrixXd H_klm1_matrix = Eigen::MatrixXd(), Eigen::MatrixXd Cmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Bmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Gmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Dmatrix = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> Ematrix = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Qmatrix = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixInv = Eigen::MatrixXd(), Eigen::MatrixXd Qmatrixkm1 = Eigen::MatrixXd(), Polydim::Utilities::Inertia_Data inertia_data = Polydim::Utilities::Inertia_Data(), Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry inertia_polygon = Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry(), double constantStiff = double(), double constantMass = double())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data>();
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        r_ctor_->InternalQuadratureKL = InternalQuadratureKL;
                        r_ctor_->BoundaryQuadratureKL = BoundaryQuadratureKL;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->VanderInternalKL = VanderInternalKL;
                        r_ctor_->VanderInternalDerivatives = VanderInternalDerivatives;
                        r_ctor_->VanderBoundary = VanderBoundary;
                        r_ctor_->VanderBoundaryDerivatives = VanderBoundaryDerivatives;
                        r_ctor_->PiNabla = PiNabla;
                        r_ctor_->Pi0km1 = Pi0km1;
                        r_ctor_->Pi0k = Pi0k;
                        r_ctor_->Pi0klm1 = Pi0klm1;
                        r_ctor_->Pi0km1Der = Pi0km1Der;
                        r_ctor_->Hmatrix = Hmatrix;
                        r_ctor_->H_klm1_matrix = H_klm1_matrix;
                        r_ctor_->Cmatrix = Cmatrix;
                        r_ctor_->Bmatrix = Bmatrix;
                        r_ctor_->Gmatrix = Gmatrix;
                        r_ctor_->Dmatrix = Dmatrix;
                        r_ctor_->Ematrix = Ematrix;
                        r_ctor_->Qmatrix = Qmatrix;
                        r_ctor_->QmatrixInv = QmatrixInv;
                        r_ctor_->Qmatrixkm1 = Qmatrixkm1;
                        r_ctor_->inertia_data = inertia_data;
                        r_ctor_->inertia_polygon = inertia_polygon;
                        r_ctor_->constantStiff = constantStiff;
                        r_ctor_->constantMass = constantMass;
                        return r_ctor_;
                    })
                    , py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), py::arg("internal_quadrature_kl") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature_kl") = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), py::arg("diameter") = double(), py::arg("measure") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("vander_internal_kl") = Eigen::MatrixXd(), py::arg("vander_internal_derivatives") = std::vector<Eigen::MatrixXd>(), py::arg("vander_boundary") = Eigen::MatrixXd(), py::arg("vander_boundary_derivatives") = std::vector<Eigen::MatrixXd>(), py::arg("pi_nabla") = Eigen::MatrixXd(), py::arg("pi0km1") = Eigen::MatrixXd(), py::arg("pi0k") = Eigen::MatrixXd(), py::arg("pi0klm1") = Eigen::MatrixXd(), py::arg("pi0km1_der") = std::vector<Eigen::MatrixXd>(), py::arg("hmatrix") = Eigen::MatrixXd(), py::arg("h_klm1_matrix") = Eigen::MatrixXd(), py::arg("cmatrix") = Eigen::MatrixXd(), py::arg("bmatrix") = Eigen::MatrixXd(), py::arg("gmatrix") = Eigen::MatrixXd(), py::arg("dmatrix") = Eigen::MatrixXd(), py::arg("ematrix") = std::vector<Eigen::MatrixXd>(), py::arg("qmatrix") = Eigen::MatrixXd(), py::arg("qmatrix_inv") = Eigen::MatrixXd(), py::arg("qmatrixkm1") = Eigen::MatrixXd(), py::arg("inertia_data") = Polydim::Utilities::Inertia_Data(), py::arg("inertia_polygon") = Polydim::VEM::PCC::VEM_PCC_2D_Polygon_Geometry(), py::arg("constant_stiff") = double(), py::arg("constant_mass") = double()
                    )
                    .def_readwrite("dimension", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Order, "")
                    .def_readwrite("num_vertex_basis_functions", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::NumVertexBasisFunctions, "")
                    .def_readwrite("num_edge_basis_functions", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::NumEdgeBasisFunctions, "")
                    .def_readwrite("num_boundary_basis_functions", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::NumBoundaryBasisFunctions, "")
                    .def_readwrite("num_internal_basis_functions", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::NumInternalBasisFunctions, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("num_edge_dofs", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::NumEdgeDofs, "")
                    .def_readwrite("num_projector_basis_functions", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::NumProjectorBasisFunctions, "")
                    .def_readwrite("nkm1", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Nkm1, "")
                    .def_readwrite("nkm2", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Nkm2, "")
                    .def_readwrite("nklm1", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Nklm1, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("internal_quadrature_kl", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::InternalQuadratureKL, "")
                    .def_readwrite("boundary_quadrature_kl", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::BoundaryQuadratureKL, "")
                    .def_readwrite("diameter", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Diameter, "")
                    .def_readwrite("measure", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Measure, "")
                    .def_readwrite("centroid", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Centroid, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("vander_internal_kl", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::VanderInternalKL, "")
                    .def_readwrite("vander_internal_derivatives", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::VanderInternalDerivatives, "")
                    .def_readwrite("vander_boundary", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::VanderBoundary, "")
                    .def_readwrite("vander_boundary_derivatives", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::VanderBoundaryDerivatives, "")
                    .def_readwrite("pi_nabla", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::PiNabla, "")
                    .def_readwrite("pi0km1", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Pi0km1, "")
                    .def_readwrite("pi0k", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Pi0k, "")
                    .def_readwrite("pi0klm1", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Pi0klm1, "")
                    .def_readwrite("pi0km1_der", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Pi0km1Der, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Hmatrix, "")
                    .def_readwrite("h_klm1_matrix", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::H_klm1_matrix, "")
                    .def_readwrite("cmatrix", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Cmatrix, "")
                    .def_readwrite("bmatrix", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Bmatrix, "")
                    .def_readwrite("gmatrix", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Gmatrix, "")
                    .def_readwrite("dmatrix", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Dmatrix, "")
                    .def_readwrite("ematrix", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Ematrix, "")
                    .def_readwrite("qmatrix", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Qmatrix, "")
                    .def_readwrite("qmatrix_inv", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::QmatrixInv, "")
                    .def_readwrite("qmatrixkm1", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::Qmatrixkm1, "")
                    .def_readwrite("inertia_data", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::inertia_data, "")
                    .def_readwrite("inertia_polygon", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::inertia_polygon, "")
                    .def_readwrite("constant_stiff", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::constantStiff, "")
                    .def_readwrite("constant_mass", &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data::constantMass, "")
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_2D_LocalSpace_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_3D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_PCC_3D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_3D_ReferenceElement =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_3D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_3D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_3D_LocalSpace_Data.hpp>    ////////////////////
    // #ifndef __VEM_MCC_3D_LocalSpace_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_3D_Polyhedron_Geometry =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_3D_Polyhedron_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), double Tolerance2D = double(), double Tolerance3D = double(), Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::Vector3d Centroid = Eigen::Vector3d(), double Measure = double(), double Diameter = double(), std::vector<Eigen::MatrixXd> TetrahedronVertices = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::Matrix3d> FacesRotationMatrix = std::vector<Eigen::Matrix3d>(), std::vector<Eigen::Vector3d> FacesTranslation = std::vector<Eigen::Vector3d>(), std::vector<Eigen::Vector3d> FacesNormal = std::vector<Eigen::Vector3d>(), std::vector<bool> FacesNormalDirection = std::vector<bool>(), std::vector<bool> FacesGlobalNormalDirection = std::vector<bool>(), std::vector<double> FacesMeasure = std::vector<double>(), std::vector<Eigen::Vector3d> FacesCentroid2D = std::vector<Eigen::Vector3d>(), std::vector<double> FacesDiameter = std::vector<double>(), std::vector<std::vector<Eigen::Matrix3d>> FacesTriangulationVertices2D = std::vector<std::vector<Eigen::Matrix3d>>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Tolerance2D = Tolerance2D;
                        r_ctor_->Tolerance3D = Tolerance3D;
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->TetrahedronVertices = TetrahedronVertices;
                        r_ctor_->FacesRotationMatrix = FacesRotationMatrix;
                        r_ctor_->FacesTranslation = FacesTranslation;
                        r_ctor_->FacesNormal = FacesNormal;
                        r_ctor_->FacesNormalDirection = FacesNormalDirection;
                        r_ctor_->FacesGlobalNormalDirection = FacesGlobalNormalDirection;
                        r_ctor_->FacesMeasure = FacesMeasure;
                        r_ctor_->FacesCentroid2D = FacesCentroid2D;
                        r_ctor_->FacesDiameter = FacesDiameter;
                        r_ctor_->FacesTriangulationVertices2D = FacesTriangulationVertices2D;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("tolerance2_d") = double(), py::arg("tolerance3_d") = double(), py::arg("vertices") = Eigen::MatrixXd(), py::arg("centroid") = Eigen::Vector3d(), py::arg("measure") = double(), py::arg("diameter") = double(), py::arg("tetrahedron_vertices") = std::vector<Eigen::MatrixXd>(), py::arg("faces_rotation_matrix") = std::vector<Eigen::Matrix3d>(), py::arg("faces_translation") = std::vector<Eigen::Vector3d>(), py::arg("faces_normal") = std::vector<Eigen::Vector3d>(), py::arg("faces_normal_direction") = std::vector<bool>(), py::arg("faces_global_normal_direction") = std::vector<bool>(), py::arg("faces_measure") = std::vector<double>(), py::arg("faces_centroid2_d") = std::vector<Eigen::Vector3d>(), py::arg("faces_diameter") = std::vector<double>(), py::arg("faces_triangulation_vertices2_d") = std::vector<std::vector<Eigen::Matrix3d>>()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::Tolerance1D, "")
                    .def_readwrite("tolerance2_d", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::Tolerance2D, "")
                    .def_readwrite("tolerance3_d", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::Tolerance3D, "")
                    .def_readwrite("vertices", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::Vertices, "")
                    .def_readwrite("centroid", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::Centroid, "")
                    .def_readwrite("measure", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::Measure, "")
                    .def_readwrite("diameter", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::Diameter, "")
                    .def_readwrite("tetrahedron_vertices", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::TetrahedronVertices, "")
                    .def_readwrite("faces_rotation_matrix", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesRotationMatrix, "")
                    .def_readwrite("faces_translation", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesTranslation, "")
                    .def_readwrite("faces_normal", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesNormal, "")
                    .def_readwrite("faces_normal_direction", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesNormalDirection, "")
                    .def_readwrite("faces_global_normal_direction", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesGlobalNormalDirection, "")
                    .def_readwrite("faces_measure", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesMeasure, "")
                    .def_readwrite("faces_centroid2_d", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesCentroid2D, "")
                    .def_readwrite("faces_diameter", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesDiameter, "")
                    .def_readwrite("faces_triangulation_vertices2_d", &Polydim::VEM::MCC::VEM_MCC_3D_Polyhedron_Geometry::FacesTriangulationVertices2D, "")
                    ;


                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_3D_Velocity_LocalSpace_Data =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_3D_Velocity_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_MCC BoundaryQuadrature = Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_MCC(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd VanderInternalKp1 = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> FacesVanderInternal = std::vector<Eigen::MatrixXd>(), Eigen::VectorXd EdgeBasisCoefficients = Eigen::VectorXd(), Eigen::MatrixXd Pi0k = Eigen::MatrixXd(), Eigen::MatrixXd Wmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd(), Eigen::MatrixXd VanderBoundary = Eigen::MatrixXd(), Eigen::MatrixXd VanderBoundaryKp1 = Eigen::MatrixXd(), Eigen::MatrixXd TkNabla = Eigen::MatrixXd(), Eigen::MatrixXd TkBigOPlus = Eigen::MatrixXd(), Eigen::MatrixXd GkVanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd GkVanderBoundaryTimesNormal = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixKp1 = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixInvKp1 = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixTkNablaInv = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixTkNabla = Eigen::MatrixXd(), double Diameter = double(), double Measure = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Eigen::MatrixXd TkNablaDof = Eigen::MatrixXd(), Eigen::MatrixXd Bmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Dmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Gmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Vmatrix = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderBasisFunctionValuesOnFace = std::vector<Eigen::MatrixXd>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data>();
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->VanderInternalKp1 = VanderInternalKp1;
                        r_ctor_->FacesVanderInternal = FacesVanderInternal;
                        r_ctor_->EdgeBasisCoefficients = EdgeBasisCoefficients;
                        r_ctor_->Pi0k = Pi0k;
                        r_ctor_->Wmatrix = Wmatrix;
                        r_ctor_->Hmatrix = Hmatrix;
                        r_ctor_->VanderBoundary = VanderBoundary;
                        r_ctor_->VanderBoundaryKp1 = VanderBoundaryKp1;
                        r_ctor_->TkNabla = TkNabla;
                        r_ctor_->TkBigOPlus = TkBigOPlus;
                        r_ctor_->GkVanderInternal = GkVanderInternal;
                        r_ctor_->GkVanderBoundaryTimesNormal = GkVanderBoundaryTimesNormal;
                        r_ctor_->QmatrixKp1 = QmatrixKp1;
                        r_ctor_->QmatrixInvKp1 = QmatrixInvKp1;
                        r_ctor_->QmatrixTkNablaInv = QmatrixTkNablaInv;
                        r_ctor_->QmatrixTkNabla = QmatrixTkNabla;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->TkNablaDof = TkNablaDof;
                        r_ctor_->Bmatrix = Bmatrix;
                        r_ctor_->Dmatrix = Dmatrix;
                        r_ctor_->Gmatrix = Gmatrix;
                        r_ctor_->Vmatrix = Vmatrix;
                        r_ctor_->VanderBasisFunctionValuesOnFace = VanderBasisFunctionValuesOnFace;
                        return r_ctor_;
                    })
                    , py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_MCC(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("vander_internal_kp1") = Eigen::MatrixXd(), py::arg("faces_vander_internal") = std::vector<Eigen::MatrixXd>(), py::arg("edge_basis_coefficients") = Eigen::VectorXd(), py::arg("pi0k") = Eigen::MatrixXd(), py::arg("wmatrix") = Eigen::MatrixXd(), py::arg("hmatrix") = Eigen::MatrixXd(), py::arg("vander_boundary") = Eigen::MatrixXd(), py::arg("vander_boundary_kp1") = Eigen::MatrixXd(), py::arg("tk_nabla") = Eigen::MatrixXd(), py::arg("tk_big_o_plus") = Eigen::MatrixXd(), py::arg("gk_vander_internal") = Eigen::MatrixXd(), py::arg("gk_vander_boundary_times_normal") = Eigen::MatrixXd(), py::arg("qmatrix_kp1") = Eigen::MatrixXd(), py::arg("qmatrix_inv_kp1") = Eigen::MatrixXd(), py::arg("qmatrix_tk_nabla_inv") = Eigen::MatrixXd(), py::arg("qmatrix_tk_nabla") = Eigen::MatrixXd(), py::arg("diameter") = double(), py::arg("measure") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("tk_nabla_dof") = Eigen::MatrixXd(), py::arg("bmatrix") = Eigen::MatrixXd(), py::arg("dmatrix") = Eigen::MatrixXd(), py::arg("gmatrix") = Eigen::MatrixXd(), py::arg("vmatrix") = Eigen::MatrixXd(), py::arg("vander_basis_function_values_on_face") = std::vector<Eigen::MatrixXd>()
                    )
                    .def_readwrite("order", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Order, "")
                    .def_readwrite("dimension", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Dimension, "")
                    .def_readwrite("num_boundary_basis_functions", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::NumBoundaryBasisFunctions, "")
                    .def_readwrite("num_nabla_internal_basis_functions", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::NumNablaInternalBasisFunctions, "")
                    .def_readwrite("num_big_o_plus_internal_basis_functions", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::NumBigOPlusInternalBasisFunctions, "")
                    .def_readwrite("num_internal_basis_functions", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::NumInternalBasisFunctions, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("vander_internal_kp1", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::VanderInternalKp1, "")
                    .def_readwrite("faces_vander_internal", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::FacesVanderInternal, "")
                    .def_readwrite("edge_basis_coefficients", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::EdgeBasisCoefficients, "")
                    .def_readwrite("pi0k", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Pi0k, "")
                    .def_readwrite("wmatrix", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Wmatrix, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Hmatrix, "")
                    .def_readwrite("vander_boundary", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::VanderBoundary, "")
                    .def_readwrite("vander_boundary_kp1", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::VanderBoundaryKp1, "")
                    .def_readwrite("nk", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Nk, "")
                    .def_readwrite("nk_nabla", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::NkNabla, "")
                    .def_readwrite("tk_nabla", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::TkNabla, "")
                    .def_readwrite("tk_big_o_plus", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::TkBigOPlus, "")
                    .def_readwrite("gk_vander_internal", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::GkVanderInternal, "")
                    .def_readwrite("gk_vander_boundary_times_normal", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::GkVanderBoundaryTimesNormal, "")
                    .def_readwrite("qmatrix_kp1", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::QmatrixKp1, "")
                    .def_readwrite("qmatrix_inv_kp1", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::QmatrixInvKp1, "")
                    .def_readwrite("qmatrix_tk_nabla_inv", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::QmatrixTkNablaInv, "")
                    .def_readwrite("qmatrix_tk_nabla", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::QmatrixTkNabla, "")
                    .def_readwrite("diameter", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Diameter, "")
                    .def_readwrite("measure", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Measure, "")
                    .def_readwrite("centroid", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Centroid, "")
                    .def_readwrite("tk_nabla_dof", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::TkNablaDof, "")
                    .def_readwrite("bmatrix", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Bmatrix, "")
                    .def_readwrite("dmatrix", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Dmatrix, "")
                    .def_readwrite("gmatrix", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Gmatrix, "")
                    .def_readwrite("vmatrix", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::Vmatrix, "")
                    .def_readwrite("vander_basis_function_values_on_face", &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data::VanderBasisFunctionValuesOnFace, "")
                    ;


                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_3D_Pressure_LocalSpace_Data =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_3D_Pressure_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Diameter = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd Qmatrix = Eigen::MatrixXd(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data>();
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->Qmatrix = Qmatrix;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->Hmatrix = Hmatrix;
                        return r_ctor_;
                    })
                    , py::arg("diameter") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("qmatrix") = Eigen::MatrixXd(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("hmatrix") = Eigen::MatrixXd()
                    )
                    .def_readwrite("order", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::Order, "")
                    .def_readwrite("dimension", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::Dimension, "")
                    .def_readwrite("nk", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::Nk, "")
                    .def_readwrite("nkm1", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::Nkm1, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("diameter", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::Diameter, "")
                    .def_readwrite("centroid", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::Centroid, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("qmatrix", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::Qmatrix, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data::Hmatrix, "")
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_3D_LocalSpace_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_EdgeOrtho_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_EdgeOrtho_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_EdgeOrtho_Pressure_ReferenceElement =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Pressure_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_EdgeOrtho_Pressure_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Pressure_ReferenceElement::Create, py::arg("order"))
                    ;


                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_EdgeOrtho_Velocity_ReferenceElement =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_EdgeOrtho_Velocity_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_EdgeOrtho_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_2D_Creator.hpp>    ////////////////////
    // #ifndef __VEM_PCC_2D_Creator_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyEnumVEM_PCC_2D_LocalSpace_Types =
                    py::enum_<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Types>(pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_2D_LocalSpace_Types", py::arithmetic(), "")
                        .value("vem_pcc_2_d_local_space", Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Types::VEM_PCC_2D_LocalSpace, "")
                        .value("vem_pcc_2_d_inertia_local_space", Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Types::VEM_PCC_2D_Inertia_LocalSpace, "")
                        .value("vem_pcc_2_d_ortho_local_space", Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Types::VEM_PCC_2D_Ortho_LocalSpace, "");


                pyNsPolydim_NsVEM_NsPCC.def("create_vem_pcc_2_d_reference_element",
                    Polydim::VEM::PCC::create_VEM_PCC_2D_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsPCC.def("create_vem_pcc_2_d_local_space",
                    Polydim::VEM::PCC::create_VEM_PCC_2D_local_space, py::arg("type"));
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_2D_Creator.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_2D_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_PCC_2D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_2D_LocalSpace =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_2D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute3_d_utilities",
                        &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::Compute3DUtilities, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute3_d_utilities_df_pcc",
                        &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::Compute3DUtilities_DF_PCC, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_values_on_edge",
                        &Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace::ComputeValuesOnEdge, py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_2D_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_2D_Inertia_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_PCC_2D_Inertia_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_2D_Inertia_LocalSpace =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_2D_Inertia_LocalSpace", py::is_final(), "/ \\brief Primal Conforming Constant degree Virtual Element Methods 2D with improvements for high-order \\cite\n/ Teora2024.\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute3_d_utilities",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::Compute3DUtilities, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_values_on_edge",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputeValuesOnEdge, py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("param_0"), py::arg("param_1"), py::arg("param_2"), py::arg("param_3"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Inertia_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("param_0"), py::arg("param_1"), py::arg("param_2"))
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_2D_Inertia_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_2D_Ortho_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_PCC_2D_Ortho_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_2D_Ortho_LocalSpace =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_2D_Ortho_LocalSpace", py::is_final(), "/ \\brief Interface class for Primal Conforming Constant degree 2D Virtual Element Methods \\cite Mascotto2018 \\cite\n/ Teora2024.\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute3_d_utilities",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::Compute3DUtilities, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_polynomials_dofs",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputePolynomialsDofs, py::arg("polytope_measure"), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_values_on_edge",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputeValuesOnEdge, py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_2D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("param_0"), py::arg("param_1"), py::arg("param_2"), py::arg("param_3"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::PCC::VEM_PCC_2D_Ortho_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("param_0"), py::arg("param_1"), py::arg("param_2"))
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_2D_Ortho_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_3D_Creator.hpp>    ////////////////////
    // #ifndef __VEM_PCC_3D_Creator_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyEnumVEM_PCC_3D_LocalSpace_Types =
                    py::enum_<Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Types>(pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_3D_LocalSpace_Types", py::arithmetic(), "")
                        .value("vem_pcc_3_d_local_space", Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Types::VEM_PCC_3D_LocalSpace, "")
                        .value("vem_pcc_3_d_inertia_local_space", Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Types::VEM_PCC_3D_Inertia_LocalSpace, "")
                        .value("vem_pcc_3_d_ortho_local_space", Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Types::VEM_PCC_3D_Ortho_LocalSpace, "");


                pyNsPolydim_NsVEM_NsPCC.def("create_vem_pcc_3_d_reference_element_2_d",
                    Polydim::VEM::PCC::create_VEM_PCC_3D_reference_element_2D, py::arg("type"));

                pyNsPolydim_NsVEM_NsPCC.def("create_vem_pcc_3_d_reference_element_3_d",
                    Polydim::VEM::PCC::create_VEM_PCC_3D_reference_element_3D, py::arg("type"));

                pyNsPolydim_NsVEM_NsPCC.def("create_vem_pcc_3_d_local_space_2_d",
                    Polydim::VEM::PCC::create_VEM_PCC_3D_local_space_2D, py::arg("type"));

                pyNsPolydim_NsVEM_NsPCC.def("create_vem_pcc_3_d_local_space_3_d",
                    Polydim::VEM::PCC::create_VEM_PCC_3D_local_space_3D, py::arg("type"));
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_3D_Creator.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_3D_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_PCC_3D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_3D_LocalSpace =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_3D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data_2_d"), py::arg("reference_element_data_3_d"), py::arg("polygonal_faces"), py::arg("polyhedron"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_d_recipe_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeDRecipeStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"), py::arg("coercivity_matrix"), py::arg("vector_coefficients"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_values_on_edge",
                        &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace::ComputeValuesOnEdge, py::arg("reference_element_data"), py::arg("local_space"), py::arg("points_curvilinear_coordinates"))
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_3D_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_3D_Inertia_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_PCC_3D_Inertia_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_3D_Inertia_LocalSpace =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_3D_Inertia_LocalSpace", py::is_final(), "/ \\brief Interface class for Primal Conforming Constant degree 3D Virtual Element Methods \\cite Teora2024.\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::CreateLocalSpace, py::arg("reference_element_data_2_d"), py::arg("reference_element_data_3_d"), py::arg("polygonal_faces"), py::arg("polyhedron"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_d_recipe_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeDRecipeStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"), py::arg("coercivity_matrix"), py::arg("vector_coefficients"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("param_0"), py::arg("param_1"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("param_0"), py::arg("param_1"), py::arg("param_2"), py::arg("param_3"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("param_0"), py::arg("param_1"), py::arg("param_2"))
                    .def("compute_values_on_edge",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Inertia_LocalSpace::ComputeValuesOnEdge, py::arg("reference_element_data"), py::arg("local_space"), py::arg("points_curvilinear_coordinates"))
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_3D_Inertia_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_3D_Ortho_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_PCC_3D_Ortho_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_3D_Ortho_LocalSpace =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_3D_Ortho_LocalSpace", py::is_final(), "/ \\brief Interface class for Primal Conforming Constant degree 3D Virtual Element Methods \\cite DassiMascotto2018\n/ \\cite Teora2024.\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::CreateLocalSpace, py::arg("reference_element_data_2_d"), py::arg("reference_element_data_3_d"), py::arg("polygonal_faces"), py::arg("polyhedron"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_d_recipe_stabilization_matrix",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeDRecipeStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"), py::arg("coercivity_matrix"), py::arg("vector_coefficients"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_values_on_edge",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeValuesOnEdge, py::arg("reference_element_data"), py::arg("local_space"), py::arg("points_curvilinear_coordinates"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("param_0"), py::arg("param_1"))
                    .def("compute_basis_functions_laplacian_values",
                        py::overload_cast<const Polydim::VEM::PCC::VEM_PCC_3D_ReferenceElement_Data &, const Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data &, const Polydim::VEM::PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::const_), py::arg("param_0"), py::arg("param_1"), py::arg("param_2"), py::arg("param_3"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::PCC::VEM_PCC_3D_Ortho_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("param_0"), py::arg("param_1"), py::arg("param_2"))
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_3D_Ortho_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_PCC_3D_LocalSpace_Data.hpp>    ////////////////////
    // #ifndef __VEM_PCC_3D_LocalSpace_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsVEM_NsPCC = pyNsPolydim_NsVEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_3D_Polyhedron_Geometry =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_3D_Polyhedron_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), double Tolerance2D = double(), double Tolerance3D = double(), Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::MatrixXi Edges = Eigen::MatrixXi(), std::vector<Eigen::MatrixXi> Faces = std::vector<Eigen::MatrixXi>(), Eigen::Vector3d Centroid = Eigen::Vector3d(), double Measure = double(), double Diameter = double(), std::vector<Eigen::MatrixXd> TetrahedronVertices = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::Matrix3d> FacesRotationMatrix = std::vector<Eigen::Matrix3d>(), std::vector<Eigen::Vector3d> FacesTranslation = std::vector<Eigen::Vector3d>(), std::vector<Eigen::Vector3d> FacesNormal = std::vector<Eigen::Vector3d>(), std::vector<bool> FacesNormalDirection = std::vector<bool>(), std::vector<bool> EdgesDirection = std::vector<bool>(), Eigen::MatrixXd EdgesTangent = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Tolerance2D = Tolerance2D;
                        r_ctor_->Tolerance3D = Tolerance3D;
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->Edges = Edges;
                        r_ctor_->Faces = Faces;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->TetrahedronVertices = TetrahedronVertices;
                        r_ctor_->FacesRotationMatrix = FacesRotationMatrix;
                        r_ctor_->FacesTranslation = FacesTranslation;
                        r_ctor_->FacesNormal = FacesNormal;
                        r_ctor_->FacesNormalDirection = FacesNormalDirection;
                        r_ctor_->EdgesDirection = EdgesDirection;
                        r_ctor_->EdgesTangent = EdgesTangent;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("tolerance2_d") = double(), py::arg("tolerance3_d") = double(), py::arg("vertices") = Eigen::MatrixXd(), py::arg("edges") = Eigen::MatrixXi(), py::arg("faces") = std::vector<Eigen::MatrixXi>(), py::arg("centroid") = Eigen::Vector3d(), py::arg("measure") = double(), py::arg("diameter") = double(), py::arg("tetrahedron_vertices") = std::vector<Eigen::MatrixXd>(), py::arg("faces_rotation_matrix") = std::vector<Eigen::Matrix3d>(), py::arg("faces_translation") = std::vector<Eigen::Vector3d>(), py::arg("faces_normal") = std::vector<Eigen::Vector3d>(), py::arg("faces_normal_direction") = std::vector<bool>(), py::arg("edges_direction") = std::vector<bool>(), py::arg("edges_tangent") = Eigen::MatrixXd()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Tolerance1D, "")
                    .def_readwrite("tolerance2_d", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Tolerance2D, "")
                    .def_readwrite("tolerance3_d", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Tolerance3D, "")
                    .def_readwrite("vertices", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Vertices, "")
                    .def_readwrite("edges", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Edges, "")
                    .def_readwrite("faces", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Faces, "")
                    .def_readwrite("centroid", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Centroid, "")
                    .def_readwrite("measure", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Measure, "")
                    .def_readwrite("diameter", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::Diameter, "")
                    .def_readwrite("tetrahedron_vertices", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::TetrahedronVertices, "")
                    .def_readwrite("faces_rotation_matrix", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::FacesRotationMatrix, "")
                    .def_readwrite("faces_translation", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::FacesTranslation, "")
                    .def_readwrite("faces_normal", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::FacesNormal, "")
                    .def_readwrite("faces_normal_direction", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::FacesNormalDirection, "")
                    .def_readwrite("edges_direction", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::EdgesDirection, "")
                    .def_readwrite("edges_tangent", &Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry::EdgesTangent, "")
                    ;


                auto pyNsPolydim_NsVEM_NsPCC_ClassVEM_PCC_3D_LocalSpace_Data =
                    py::class_<Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsPCC, "VEM_PCC_3D_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC BoundaryQuadrature = Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC(), std::vector<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data> facesLocalSpace = std::vector<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data>(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderInternalDerivatives = std::vector<Eigen::MatrixXd>(), double Diameter = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), double Measure = double(), Eigen::VectorXd EdgeBasisCoefficients = Eigen::VectorXd(), Eigen::MatrixXd PiNabla = Eigen::MatrixXd(), Eigen::MatrixXd Pi0km1 = Eigen::MatrixXd(), Eigen::MatrixXd Pi0k = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> Pi0km1Der = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd StabMatrix = Eigen::MatrixXd(), Eigen::MatrixXd StabMatrixPi0k = Eigen::MatrixXd(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Cmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Bmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Gmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Dmatrix = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> Ematrix = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd VanderBoundary = Eigen::MatrixXd(), Eigen::MatrixXd VanderEdgeDofs = Eigen::MatrixXd(), Eigen::MatrixXd ScaledHmatrixOnBoundary = Eigen::MatrixXd(), Eigen::MatrixXd VanderFaceProjections = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> FaceScaledMomentsBasis = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> FaceProjectedBasisFunctionsValues = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd PointEdgeDofsCoordinates = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderBoundaryDerivatives = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Qmatrix = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixInv = Eigen::MatrixXd(), Eigen::MatrixXd Qmatrixkm1 = Eigen::MatrixXd(), Polydim::Utilities::Inertia_Data inertia_data = Polydim::Utilities::Inertia_Data(), Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry inertia_polyhedron = Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry(), double constantStiff = double(), double constantMass = double(), Eigen::RowVectorXd EdgeInternalPoints = Eigen::RowVectorXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data>();
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        r_ctor_->facesLocalSpace = facesLocalSpace;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->VanderInternalDerivatives = VanderInternalDerivatives;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->Measure = Measure;
                        r_ctor_->EdgeBasisCoefficients = EdgeBasisCoefficients;
                        r_ctor_->PiNabla = PiNabla;
                        r_ctor_->Pi0km1 = Pi0km1;
                        r_ctor_->Pi0k = Pi0k;
                        r_ctor_->Pi0km1Der = Pi0km1Der;
                        r_ctor_->StabMatrix = StabMatrix;
                        r_ctor_->StabMatrixPi0k = StabMatrixPi0k;
                        r_ctor_->Hmatrix = Hmatrix;
                        r_ctor_->Cmatrix = Cmatrix;
                        r_ctor_->Bmatrix = Bmatrix;
                        r_ctor_->Gmatrix = Gmatrix;
                        r_ctor_->Dmatrix = Dmatrix;
                        r_ctor_->Ematrix = Ematrix;
                        r_ctor_->VanderBoundary = VanderBoundary;
                        r_ctor_->VanderEdgeDofs = VanderEdgeDofs;
                        r_ctor_->ScaledHmatrixOnBoundary = ScaledHmatrixOnBoundary;
                        r_ctor_->VanderFaceProjections = VanderFaceProjections;
                        r_ctor_->FaceScaledMomentsBasis = FaceScaledMomentsBasis;
                        r_ctor_->FaceProjectedBasisFunctionsValues = FaceProjectedBasisFunctionsValues;
                        r_ctor_->PointEdgeDofsCoordinates = PointEdgeDofsCoordinates;
                        r_ctor_->VanderBoundaryDerivatives = VanderBoundaryDerivatives;
                        r_ctor_->Qmatrix = Qmatrix;
                        r_ctor_->QmatrixInv = QmatrixInv;
                        r_ctor_->Qmatrixkm1 = Qmatrixkm1;
                        r_ctor_->inertia_data = inertia_data;
                        r_ctor_->inertia_polyhedron = inertia_polyhedron;
                        r_ctor_->constantStiff = constantStiff;
                        r_ctor_->constantMass = constantMass;
                        r_ctor_->EdgeInternalPoints = EdgeInternalPoints;
                        return r_ctor_;
                    })
                    , py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC(), py::arg("faces_local_space") = std::vector<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data>(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("vander_internal_derivatives") = std::vector<Eigen::MatrixXd>(), py::arg("diameter") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("measure") = double(), py::arg("edge_basis_coefficients") = Eigen::VectorXd(), py::arg("pi_nabla") = Eigen::MatrixXd(), py::arg("pi0km1") = Eigen::MatrixXd(), py::arg("pi0k") = Eigen::MatrixXd(), py::arg("pi0km1_der") = std::vector<Eigen::MatrixXd>(), py::arg("stab_matrix") = Eigen::MatrixXd(), py::arg("stab_matrix_pi0k") = Eigen::MatrixXd(), py::arg("hmatrix") = Eigen::MatrixXd(), py::arg("cmatrix") = Eigen::MatrixXd(), py::arg("bmatrix") = Eigen::MatrixXd(), py::arg("gmatrix") = Eigen::MatrixXd(), py::arg("dmatrix") = Eigen::MatrixXd(), py::arg("ematrix") = std::vector<Eigen::MatrixXd>(), py::arg("vander_boundary") = Eigen::MatrixXd(), py::arg("vander_edge_dofs") = Eigen::MatrixXd(), py::arg("scaled_hmatrix_on_boundary") = Eigen::MatrixXd(), py::arg("vander_face_projections") = Eigen::MatrixXd(), py::arg("face_scaled_moments_basis") = std::vector<Eigen::MatrixXd>(), py::arg("face_projected_basis_functions_values") = std::vector<Eigen::MatrixXd>(), py::arg("point_edge_dofs_coordinates") = Eigen::MatrixXd(), py::arg("vander_boundary_derivatives") = std::vector<Eigen::MatrixXd>(), py::arg("qmatrix") = Eigen::MatrixXd(), py::arg("qmatrix_inv") = Eigen::MatrixXd(), py::arg("qmatrixkm1") = Eigen::MatrixXd(), py::arg("inertia_data") = Polydim::Utilities::Inertia_Data(), py::arg("inertia_polyhedron") = Polydim::VEM::PCC::VEM_PCC_3D_Polyhedron_Geometry(), py::arg("constant_stiff") = double(), py::arg("constant_mass") = double(), py::arg("edge_internal_points") = Eigen::RowVectorXd()
                    )
                    .def_readwrite("internal_quadrature", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("faces_local_space", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::facesLocalSpace, "")
                    .def_readwrite("dimension", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Order, "")
                    .def_readwrite("num_vertex_basis_functions", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumVertexBasisFunctions, "")
                    .def_readwrite("num_edge_basis_functions", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumEdgeBasisFunctions, "")
                    .def_readwrite("num_face_basis_functions", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumFaceBasisFunctions, "")
                    .def_readwrite("num_internal_basis_functions", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumInternalBasisFunctions, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("num_edge_dofs", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumEdgeDofs, "")
                    .def_readwrite("num_face_dofs", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumFaceDofs, "")
                    .def_readwrite("num_boundary_basis_functions", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumBoundaryBasisFunctions, "")
                    .def_readwrite("num_projector_basis_functions", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::NumProjectorBasisFunctions, "")
                    .def_readwrite("nkm1", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Nkm1, "")
                    .def_readwrite("nkm2", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Nkm2, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("vander_internal_derivatives", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::VanderInternalDerivatives, "")
                    .def_readwrite("diameter", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Diameter, "")
                    .def_readwrite("centroid", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Centroid, "")
                    .def_readwrite("measure", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Measure, "")
                    .def_readwrite("edge_basis_coefficients", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::EdgeBasisCoefficients, "")
                    .def_readwrite("pi_nabla", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::PiNabla, "")
                    .def_readwrite("pi0km1", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Pi0km1, "")
                    .def_readwrite("pi0k", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Pi0k, "")
                    .def_readwrite("pi0km1_der", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Pi0km1Der, "")
                    .def_readwrite("stab_matrix", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::StabMatrix, "")
                    .def_readwrite("stab_matrix_pi0k", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::StabMatrixPi0k, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Hmatrix, "")
                    .def_readwrite("cmatrix", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Cmatrix, "")
                    .def_readwrite("bmatrix", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Bmatrix, "")
                    .def_readwrite("gmatrix", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Gmatrix, "")
                    .def_readwrite("dmatrix", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Dmatrix, "")
                    .def_readwrite("ematrix", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Ematrix, "")
                    .def_readwrite("vander_boundary", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::VanderBoundary, "")
                    .def_readwrite("vander_edge_dofs", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::VanderEdgeDofs, "")
                    .def_readwrite("scaled_hmatrix_on_boundary", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::ScaledHmatrixOnBoundary, "")
                    .def_readwrite("vander_face_projections", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::VanderFaceProjections, "")
                    .def_readwrite("face_scaled_moments_basis", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::FaceScaledMomentsBasis, "")
                    .def_readwrite("face_projected_basis_functions_values", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::FaceProjectedBasisFunctionsValues, "")
                    .def_readwrite("point_edge_dofs_coordinates", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::PointEdgeDofsCoordinates, "")
                    .def_readwrite("vander_boundary_derivatives", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::VanderBoundaryDerivatives, "")
                    .def_readwrite("qmatrix", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Qmatrix, "change of basis matrix: pV = mV*Q'")
                    .def_readwrite("qmatrix_inv", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::QmatrixInv, "")
                    .def_readwrite("qmatrixkm1", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::Qmatrixkm1, "")
                    .def_readwrite("inertia_data", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::inertia_data, "")
                    .def_readwrite("inertia_polyhedron", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::inertia_polyhedron, "")
                    .def_readwrite("constant_stiff", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::constantStiff, "")
                    .def_readwrite("constant_mass", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::constantMass, "")
                    .def_readwrite("edge_internal_points", &Polydim::VEM::PCC::VEM_PCC_3D_LocalSpace_Data::EdgeInternalPoints, "")
                    ;
            } // </namespace PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_PCC_3D_LocalSpace_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_Creator.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_Creator_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyEnumVEM_MCC_2D_LocalSpace_Types =
                    py::enum_<Polydim::VEM::MCC::VEM_MCC_2D_LocalSpace_Types>(pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_LocalSpace_Types", py::arithmetic(), "")
                        .value("vem_mcc_2_d_local_space", Polydim::VEM::MCC::VEM_MCC_2D_LocalSpace_Types::VEM_MCC_2D_LocalSpace, "")
                        .value("vem_mcc_2_d_partial_local_space", Polydim::VEM::MCC::VEM_MCC_2D_LocalSpace_Types::VEM_MCC_2D_Partial_LocalSpace, "")
                        .value("vem_mcc_2_d_ortho_local_space", Polydim::VEM::MCC::VEM_MCC_2D_LocalSpace_Types::VEM_MCC_2D_Ortho_LocalSpace, "")
                        .value("vem_mcc_2_d_edge_ortho_local_space", Polydim::VEM::MCC::VEM_MCC_2D_LocalSpace_Types::VEM_MCC_2D_EdgeOrtho_LocalSpace, "")
                        .value("vem_mcc_2_d_ortho_edge_ortho_local_space", Polydim::VEM::MCC::VEM_MCC_2D_LocalSpace_Types::VEM_MCC_2D_Ortho_EdgeOrtho_LocalSpace, "");


                pyNsPolydim_NsVEM_NsMCC.def("create_vem_mcc_2_d_pressure_reference_element",
                    Polydim::VEM::MCC::create_VEM_MCC_2D_pressure_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsMCC.def("create_vem_mcc_2_d_velocity_reference_element",
                    Polydim::VEM::MCC::create_VEM_MCC_2D_velocity_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsMCC.def("create_vem_mcc_2_d_pressure_local_space",
                    Polydim::VEM::MCC::create_VEM_MCC_2D_pressure_local_space, py::arg("type"));

                pyNsPolydim_NsVEM_NsMCC.def("create_vem_mcc_2_d_velocity_local_space",
                    Polydim::VEM::MCC::create_VEM_MCC_2D_velocity_local_space, py::arg("type"));
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_Creator.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_EdgeOrtho_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_LocalSpace_Data.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_LocalSpace_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Polygon_Geometry =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Polygon_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), double Tolerance2D = double(), Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::Vector3d Centroid = Eigen::Vector3d(), double Measure = double(), double Diameter = double(), std::vector<Eigen::Matrix3d> TriangulationVertices = std::vector<Eigen::Matrix3d>(), Eigen::VectorXd EdgesLength = Eigen::VectorXd(), std::vector<bool> EdgesDirection = std::vector<bool>(), Eigen::MatrixXd EdgesTangent = Eigen::MatrixXd(), Eigen::MatrixXd EdgesNormal = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Tolerance2D = Tolerance2D;
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->TriangulationVertices = TriangulationVertices;
                        r_ctor_->EdgesLength = EdgesLength;
                        r_ctor_->EdgesDirection = EdgesDirection;
                        r_ctor_->EdgesTangent = EdgesTangent;
                        r_ctor_->EdgesNormal = EdgesNormal;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("tolerance2_d") = double(), py::arg("vertices") = Eigen::MatrixXd(), py::arg("centroid") = Eigen::Vector3d(), py::arg("measure") = double(), py::arg("diameter") = double(), py::arg("triangulation_vertices") = std::vector<Eigen::Matrix3d>(), py::arg("edges_length") = Eigen::VectorXd(), py::arg("edges_direction") = std::vector<bool>(), py::arg("edges_tangent") = Eigen::MatrixXd(), py::arg("edges_normal") = Eigen::MatrixXd()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::Tolerance1D, "")
                    .def_readwrite("tolerance2_d", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::Tolerance2D, "")
                    .def_readwrite("vertices", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::Vertices, "")
                    .def_readwrite("centroid", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::Centroid, "")
                    .def_readwrite("measure", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::Measure, "")
                    .def_readwrite("diameter", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::Diameter, "")
                    .def_readwrite("triangulation_vertices", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::TriangulationVertices, "")
                    .def_readwrite("edges_length", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::EdgesLength, "")
                    .def_readwrite("edges_direction", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::EdgesDirection, "")
                    .def_readwrite("edges_tangent", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::EdgesTangent, "")
                    .def_readwrite("edges_normal", &Polydim::VEM::MCC::VEM_MCC_2D_Polygon_Geometry::EdgesNormal, "")
                    ;


                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Velocity_LocalSpace_Data =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Velocity_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData BoundaryQuadrature = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd VanderInternalKp1 = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> FacesVanderInternal = std::vector<Eigen::MatrixXd>(), Eigen::VectorXd EdgeBasisCoefficients = Eigen::VectorXd(), Eigen::MatrixXd Pi0k = Eigen::MatrixXd(), Eigen::MatrixXd Wmatrix = Eigen::MatrixXd(), double Diameter = double(), double Measure = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd(), Eigen::MatrixXd VanderBoundary = Eigen::MatrixXd(), Eigen::MatrixXd VanderBoundaryKp1 = Eigen::MatrixXd(), Eigen::MatrixXd TkNabla = Eigen::MatrixXd(), Eigen::MatrixXd TkBigOPlus = Eigen::MatrixXd(), Eigen::MatrixXd GkVanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd GkVanderBoundaryTimesNormal = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixKp1 = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixInvKp1 = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixTkNablaInv = Eigen::MatrixXd(), Eigen::MatrixXd QmatrixTkNabla = Eigen::MatrixXd(), Eigen::MatrixXd TkNablaDof = Eigen::MatrixXd(), Eigen::MatrixXd Bmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Dmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Gmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Vmatrix = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderBasisFunctionValuesOnFace = std::vector<Eigen::MatrixXd>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data>();
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->VanderInternalKp1 = VanderInternalKp1;
                        r_ctor_->FacesVanderInternal = FacesVanderInternal;
                        r_ctor_->EdgeBasisCoefficients = EdgeBasisCoefficients;
                        r_ctor_->Pi0k = Pi0k;
                        r_ctor_->Wmatrix = Wmatrix;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->Hmatrix = Hmatrix;
                        r_ctor_->VanderBoundary = VanderBoundary;
                        r_ctor_->VanderBoundaryKp1 = VanderBoundaryKp1;
                        r_ctor_->TkNabla = TkNabla;
                        r_ctor_->TkBigOPlus = TkBigOPlus;
                        r_ctor_->GkVanderInternal = GkVanderInternal;
                        r_ctor_->GkVanderBoundaryTimesNormal = GkVanderBoundaryTimesNormal;
                        r_ctor_->QmatrixKp1 = QmatrixKp1;
                        r_ctor_->QmatrixInvKp1 = QmatrixInvKp1;
                        r_ctor_->QmatrixTkNablaInv = QmatrixTkNablaInv;
                        r_ctor_->QmatrixTkNabla = QmatrixTkNabla;
                        r_ctor_->TkNablaDof = TkNablaDof;
                        r_ctor_->Bmatrix = Bmatrix;
                        r_ctor_->Dmatrix = Dmatrix;
                        r_ctor_->Gmatrix = Gmatrix;
                        r_ctor_->Vmatrix = Vmatrix;
                        r_ctor_->VanderBasisFunctionValuesOnFace = VanderBasisFunctionValuesOnFace;
                        return r_ctor_;
                    })
                    , py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("vander_internal_kp1") = Eigen::MatrixXd(), py::arg("faces_vander_internal") = std::vector<Eigen::MatrixXd>(), py::arg("edge_basis_coefficients") = Eigen::VectorXd(), py::arg("pi0k") = Eigen::MatrixXd(), py::arg("wmatrix") = Eigen::MatrixXd(), py::arg("diameter") = double(), py::arg("measure") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("hmatrix") = Eigen::MatrixXd(), py::arg("vander_boundary") = Eigen::MatrixXd(), py::arg("vander_boundary_kp1") = Eigen::MatrixXd(), py::arg("tk_nabla") = Eigen::MatrixXd(), py::arg("tk_big_o_plus") = Eigen::MatrixXd(), py::arg("gk_vander_internal") = Eigen::MatrixXd(), py::arg("gk_vander_boundary_times_normal") = Eigen::MatrixXd(), py::arg("qmatrix_kp1") = Eigen::MatrixXd(), py::arg("qmatrix_inv_kp1") = Eigen::MatrixXd(), py::arg("qmatrix_tk_nabla_inv") = Eigen::MatrixXd(), py::arg("qmatrix_tk_nabla") = Eigen::MatrixXd(), py::arg("tk_nabla_dof") = Eigen::MatrixXd(), py::arg("bmatrix") = Eigen::MatrixXd(), py::arg("dmatrix") = Eigen::MatrixXd(), py::arg("gmatrix") = Eigen::MatrixXd(), py::arg("vmatrix") = Eigen::MatrixXd(), py::arg("vander_basis_function_values_on_face") = std::vector<Eigen::MatrixXd>()
                    )
                    .def_readwrite("order", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Order, "")
                    .def_readwrite("dimension", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Dimension, "")
                    .def_readwrite("num_boundary_basis_functions", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::NumBoundaryBasisFunctions, "")
                    .def_readwrite("num_nabla_internal_basis_functions", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::NumNablaInternalBasisFunctions, "")
                    .def_readwrite("num_big_o_plus_internal_basis_functions", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::NumBigOPlusInternalBasisFunctions, "")
                    .def_readwrite("num_internal_basis_functions", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::NumInternalBasisFunctions, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("vander_internal_kp1", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::VanderInternalKp1, "")
                    .def_readwrite("faces_vander_internal", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::FacesVanderInternal, "")
                    .def_readwrite("edge_basis_coefficients", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::EdgeBasisCoefficients, "")
                    .def_readwrite("pi0k", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Pi0k, "")
                    .def_readwrite("wmatrix", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Wmatrix, "")
                    .def_readwrite("diameter", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Diameter, "")
                    .def_readwrite("measure", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Measure, "")
                    .def_readwrite("centroid", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Centroid, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Hmatrix, "")
                    .def_readwrite("vander_boundary", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::VanderBoundary, "")
                    .def_readwrite("vander_boundary_kp1", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::VanderBoundaryKp1, "")
                    .def_readwrite("nk", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Nk, "")
                    .def_readwrite("nk_nabla", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::NkNabla, "")
                    .def_readwrite("tk_nabla", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::TkNabla, "")
                    .def_readwrite("tk_big_o_plus", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::TkBigOPlus, "")
                    .def_readwrite("gk_vander_internal", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::GkVanderInternal, "")
                    .def_readwrite("gk_vander_boundary_times_normal", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::GkVanderBoundaryTimesNormal, "")
                    .def_readwrite("qmatrix_kp1", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::QmatrixKp1, "")
                    .def_readwrite("qmatrix_inv_kp1", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::QmatrixInvKp1, "")
                    .def_readwrite("qmatrix_tk_nabla_inv", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::QmatrixTkNablaInv, "")
                    .def_readwrite("qmatrix_tk_nabla", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::QmatrixTkNabla, "")
                    .def_readwrite("tk_nabla_dof", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::TkNablaDof, "")
                    .def_readwrite("bmatrix", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Bmatrix, "")
                    .def_readwrite("dmatrix", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Dmatrix, "")
                    .def_readwrite("gmatrix", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Gmatrix, "")
                    .def_readwrite("vmatrix", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::Vmatrix, "")
                    .def_readwrite("vander_basis_function_values_on_face", &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data::VanderBasisFunctionValuesOnFace, "")
                    ;


                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Pressure_LocalSpace_Data =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Pressure_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Diameter = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd Qmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data>();
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->Qmatrix = Qmatrix;
                        r_ctor_->Hmatrix = Hmatrix;
                        return r_ctor_;
                    })
                    , py::arg("diameter") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("qmatrix") = Eigen::MatrixXd(), py::arg("hmatrix") = Eigen::MatrixXd()
                    )
                    .def_readwrite("order", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::Order, "")
                    .def_readwrite("dimension", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::Dimension, "")
                    .def_readwrite("nk", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::Nk, "")
                    .def_readwrite("nkm1", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::Nkm1, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("diameter", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::Diameter, "")
                    .def_readwrite("centroid", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::Centroid, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("qmatrix", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::Qmatrix, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data::Hmatrix, "")
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_LocalSpace_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_Ortho_EdgeOrtho_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_Ortho_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_Ortho_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Ortho_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Ortho_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Ortho_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Ortho_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Ortho_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Ortho_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Ortho_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_2D_Ortho_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_2D_Ortho_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_Ortho_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_Partial_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_Partial_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Partial_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Partial_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Partial_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Partial_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Partial_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Partial_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Partial_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_2D_Partial_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_2D_Partial_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_Partial_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_Pressure_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_Presure_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Pressure_LocalSpace =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Pressure_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Pressure_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Pressure_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_2D_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_Pressure_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Pressure_ReferenceElement =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Pressure_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Pressure_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Pressure_ReferenceElement::Create, py::arg("order"))
                    ;


                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Velocity_ReferenceElement =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Velocity_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Velocity_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_2D_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_MCC_2D_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_2D_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_2D_Velocity_LocalSpace", py::is_final(), "/ \\brief Interface class for the velocity space of 2D Mixed Conforming Constant degree Virtual Element Methods \\cite\n/ secondMixed \\cite DaVeiga2016.\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_2D_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_2D_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_3D_Creator.hpp>    ////////////////////
    // #ifndef __VEM_MCC_3D_Creator_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyEnumVEM_MCC_3D_LocalSpace_Types =
                    py::enum_<Polydim::VEM::MCC::VEM_MCC_3D_LocalSpace_Types>(pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_3D_LocalSpace_Types", py::arithmetic(), "")
                        .value("vem_mcc_3_d_local_space", Polydim::VEM::MCC::VEM_MCC_3D_LocalSpace_Types::VEM_MCC_3D_LocalSpace, "");


                pyNsPolydim_NsVEM_NsMCC.def("create_vem_mcc_3_d_pressure_reference_element",
                    Polydim::VEM::MCC::create_VEM_MCC_3D_pressure_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsMCC.def("create_vem_mcc_3_d_velocity_reference_element",
                    Polydim::VEM::MCC::create_VEM_MCC_3D_velocity_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsMCC.def("create_vem_mcc_3_d_pressure_local_space",
                    Polydim::VEM::MCC::create_VEM_MCC_3D_pressure_local_space, py::arg("type"));

                pyNsPolydim_NsVEM_NsMCC.def("create_vem_mcc_3_d_velocity_local_space",
                    Polydim::VEM::MCC::create_VEM_MCC_3D_velocity_local_space, py::arg("type"));
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_3D_Creator.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_3D_Pressure_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_MCC_3D_Pressure_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_3D_Pressure_LocalSpace =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_3D_Pressure_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_3D_Pressure_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_3D_Pressure_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_3D_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_3D_Pressure_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_3D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_MCC_3D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_3D_Pressure_ReferenceElement =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_3D_Pressure_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_3D_Pressure_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::MCC::VEM_MCC_3D_Pressure_ReferenceElement::Create, py::arg("order"))
                    ;


                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_3D_Velocity_ReferenceElement =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_3D_Velocity_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_3D_Velocity_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_3D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_MCC_3D_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_MCC_3D_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace MCC>
                py::module_ pyNsPolydim_NsVEM_NsMCC = pyNsPolydim_NsVEM.def_submodule("mcc", "namespace MCC");
                auto pyNsPolydim_NsVEM_NsMCC_ClassVEM_MCC_3D_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsMCC, "VEM_MCC_3D_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polyhedron"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data &>(&Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::MCC::VEM_MCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::MCC::VEM_MCC_3D_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace MCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_MCC_3D_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_2D_Creator.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_2D_Creator_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyEnumVEM_DF_PCC_2D_LocalSpace_Types =
                    py::enum_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_LocalSpace_Types>(pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_LocalSpace_Types", py::arithmetic(), "")
                        .value("vem_df_pcc_2_d_local_space", Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_LocalSpace_Types::VEM_DF_PCC_2D_LocalSpace, "")
                        .value("vem_df_pcc_2_d_reduced_local_space", Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_LocalSpace_Types::VEM_DF_PCC_2D_Reduced_LocalSpace, "");


                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_2_d_full_pressure_reference_element",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_2D_full_pressure_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_2_d_full_velocity_reference_element",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_2D_full_velocity_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_2_d_full_pressure_local_space",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_2D_full_pressure_local_space, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_2_d_full_velocity_local_space",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_2D_full_velocity_local_space, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_2_d_pressure_reference_element",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_2D_pressure_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_2_d_velocity_reference_element",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_2D_velocity_reference_element, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_2_d_pressure_local_space",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_2D_pressure_local_space, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_2_d_velocity_local_space",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_2D_velocity_local_space, py::arg("type"));
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_2D_Creator.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_2D_LocalSpace_Data.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_2D_LocalSpace_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Polygon_Geometry =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Polygon_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), double Tolerance2D = double(), Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::Vector3d Centroid = Eigen::Vector3d(), double Measure = double(), double Diameter = double(), std::vector<Eigen::Matrix3d> TriangulationVertices = std::vector<Eigen::Matrix3d>(), Eigen::VectorXd EdgesLength = Eigen::VectorXd(), std::vector<bool> EdgesDirection = std::vector<bool>(), Eigen::MatrixXd EdgesTangent = Eigen::MatrixXd(), Eigen::MatrixXd EdgesNormal = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Tolerance2D = Tolerance2D;
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->TriangulationVertices = TriangulationVertices;
                        r_ctor_->EdgesLength = EdgesLength;
                        r_ctor_->EdgesDirection = EdgesDirection;
                        r_ctor_->EdgesTangent = EdgesTangent;
                        r_ctor_->EdgesNormal = EdgesNormal;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("tolerance2_d") = double(), py::arg("vertices") = Eigen::MatrixXd(), py::arg("centroid") = Eigen::Vector3d(), py::arg("measure") = double(), py::arg("diameter") = double(), py::arg("triangulation_vertices") = std::vector<Eigen::Matrix3d>(), py::arg("edges_length") = Eigen::VectorXd(), py::arg("edges_direction") = std::vector<bool>(), py::arg("edges_tangent") = Eigen::MatrixXd(), py::arg("edges_normal") = Eigen::MatrixXd()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::Tolerance1D, "")
                    .def_readwrite("tolerance2_d", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::Tolerance2D, "")
                    .def_readwrite("vertices", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::Vertices, "")
                    .def_readwrite("centroid", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::Centroid, "")
                    .def_readwrite("measure", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::Measure, "")
                    .def_readwrite("diameter", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::Diameter, "")
                    .def_readwrite("triangulation_vertices", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::TriangulationVertices, "")
                    .def_readwrite("edges_length", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::EdgesLength, "")
                    .def_readwrite("edges_direction", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::EdgesDirection, "")
                    .def_readwrite("edges_tangent", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::EdgesTangent, "")
                    .def_readwrite("edges_normal", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry::EdgesNormal, "")
                    ;


                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Velocity_LocalSpace_Data =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Velocity_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData BoundaryQuadrature = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData EdgesDOFs = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), double Diameter = double(), double Measure = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderInternalDerivatives = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd VanderBoundary = Eigen::MatrixXd(), Eigen::MatrixXd VanderBoundaryKp1 = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderBoundaryDerivatives = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd VanderKp1EdgeProjections = Eigen::MatrixXd(), std::vector<std::vector<Eigen::MatrixXd>> VectorDecompositionMatrices = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<Eigen::MatrixXd> VanderGBigOPlus = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> VanderGBigOPluskm2 = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd(), Eigen::MatrixXd HmatrixKp1 = Eigen::MatrixXd(), Eigen::VectorXd ReferenceEdgeInternalPoints = Eigen::VectorXd(), Eigen::VectorXd ReferenceEdgeDofInternalPoints = Eigen::VectorXd(), Eigen::VectorXd EdgeBasisCoefficients = Eigen::VectorXd(), std::vector<Eigen::MatrixXd> PiNabla = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Pi0km2 = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Pi0k = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Pi0km1Der = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Wmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Vmatrix = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> Bmatrix = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Dmatrix = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Gmatrix = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> Cmatrix = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Cmatrixkm2 = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Ematrix = std::vector<Eigen::MatrixXd>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data>();
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        r_ctor_->EdgesDOFs = EdgesDOFs;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->VanderInternalDerivatives = VanderInternalDerivatives;
                        r_ctor_->VanderBoundary = VanderBoundary;
                        r_ctor_->VanderBoundaryKp1 = VanderBoundaryKp1;
                        r_ctor_->VanderBoundaryDerivatives = VanderBoundaryDerivatives;
                        r_ctor_->VanderKp1EdgeProjections = VanderKp1EdgeProjections;
                        r_ctor_->VectorDecompositionMatrices = VectorDecompositionMatrices;
                        r_ctor_->VanderGBigOPlus = VanderGBigOPlus;
                        r_ctor_->VanderGBigOPluskm2 = VanderGBigOPluskm2;
                        r_ctor_->Hmatrix = Hmatrix;
                        r_ctor_->HmatrixKp1 = HmatrixKp1;
                        r_ctor_->ReferenceEdgeInternalPoints = ReferenceEdgeInternalPoints;
                        r_ctor_->ReferenceEdgeDofInternalPoints = ReferenceEdgeDofInternalPoints;
                        r_ctor_->EdgeBasisCoefficients = EdgeBasisCoefficients;
                        r_ctor_->PiNabla = PiNabla;
                        r_ctor_->Pi0km2 = Pi0km2;
                        r_ctor_->Pi0k = Pi0k;
                        r_ctor_->Pi0km1Der = Pi0km1Der;
                        r_ctor_->Wmatrix = Wmatrix;
                        r_ctor_->Vmatrix = Vmatrix;
                        r_ctor_->Bmatrix = Bmatrix;
                        r_ctor_->Dmatrix = Dmatrix;
                        r_ctor_->Gmatrix = Gmatrix;
                        r_ctor_->Cmatrix = Cmatrix;
                        r_ctor_->Cmatrixkm2 = Cmatrixkm2;
                        r_ctor_->Ematrix = Ematrix;
                        return r_ctor_;
                    })
                    , py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), py::arg("edges_do_fs") = Polydim::VEM::Quadrature::VEM_Quadrature_2D::Edges_QuadratureData(), py::arg("diameter") = double(), py::arg("measure") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("vander_internal_derivatives") = std::vector<Eigen::MatrixXd>(), py::arg("vander_boundary") = Eigen::MatrixXd(), py::arg("vander_boundary_kp1") = Eigen::MatrixXd(), py::arg("vander_boundary_derivatives") = std::vector<Eigen::MatrixXd>(), py::arg("vander_kp1_edge_projections") = Eigen::MatrixXd(), py::arg("vector_decomposition_matrices") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("vander_g_big_o_plus") = std::vector<Eigen::MatrixXd>(), py::arg("vander_g_big_o_pluskm2") = std::vector<Eigen::MatrixXd>(), py::arg("hmatrix") = Eigen::MatrixXd(), py::arg("hmatrix_kp1") = Eigen::MatrixXd(), py::arg("reference_edge_internal_points") = Eigen::VectorXd(), py::arg("reference_edge_dof_internal_points") = Eigen::VectorXd(), py::arg("edge_basis_coefficients") = Eigen::VectorXd(), py::arg("pi_nabla") = std::vector<Eigen::MatrixXd>(), py::arg("pi0km2") = std::vector<Eigen::MatrixXd>(), py::arg("pi0k") = std::vector<Eigen::MatrixXd>(), py::arg("pi0km1_der") = std::vector<Eigen::MatrixXd>(), py::arg("wmatrix") = Eigen::MatrixXd(), py::arg("vmatrix") = Eigen::MatrixXd(), py::arg("bmatrix") = std::vector<Eigen::MatrixXd>(), py::arg("dmatrix") = std::vector<Eigen::MatrixXd>(), py::arg("gmatrix") = Eigen::MatrixXd(), py::arg("cmatrix") = std::vector<Eigen::MatrixXd>(), py::arg("cmatrixkm2") = std::vector<Eigen::MatrixXd>(), py::arg("ematrix") = std::vector<Eigen::MatrixXd>()
                    )
                    .def_readwrite("order", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Order, "")
                    .def_readwrite("dimension", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Dimension, "")
                    .def_readwrite("n_kp1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::NKp1, "")
                    .def_readwrite("nk", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Nk, "")
                    .def_readwrite("nkm1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Nkm1, "")
                    .def_readwrite("nkm2", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Nkm2, "")
                    .def_readwrite("nkm3", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Nkm3, "")
                    .def_readwrite("nkm4", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Nkm4, "")
                    .def_readwrite("num_vertex_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::NumVertexBasisFunctions, "")
                    .def_readwrite("num_edge_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::NumEdgeBasisFunctions, "")
                    .def_readwrite("num_boundary_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::NumBoundaryBasisFunctions, "")
                    .def_readwrite("num_divergence_internal_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::NumDivergenceInternalBasisFunctions, "")
                    .def_readwrite("num_big_o_plus_internal_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::NumBigOPlusInternalBasisFunctions, "")
                    .def_readwrite("num_internal_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::NumInternalBasisFunctions, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("edges_do_fs", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::EdgesDOFs, "")
                    .def_readwrite("diameter", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Diameter, "")
                    .def_readwrite("measure", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Measure, "")
                    .def_readwrite("centroid", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Centroid, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("vander_internal_derivatives", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VanderInternalDerivatives, "")
                    .def_readwrite("vander_boundary", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VanderBoundary, "")
                    .def_readwrite("vander_boundary_kp1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VanderBoundaryKp1, "")
                    .def_readwrite("vander_boundary_derivatives", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VanderBoundaryDerivatives, "")
                    .def_readwrite("vander_kp1_edge_projections", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VanderKp1EdgeProjections, "")
                    .def_readwrite("vector_decomposition_matrices", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VectorDecompositionMatrices, "")
                    .def_readwrite("vander_g_big_o_plus", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VanderGBigOPlus, "")
                    .def_readwrite("vander_g_big_o_pluskm2", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::VanderGBigOPluskm2, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Hmatrix, "")
                    .def_readwrite("hmatrix_kp1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::HmatrixKp1, "")
                    .def_readwrite("reference_edge_internal_points", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::ReferenceEdgeInternalPoints, "")
                    .def_readwrite("reference_edge_dof_internal_points", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::ReferenceEdgeDofInternalPoints, "")
                    .def_readwrite("edge_basis_coefficients", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::EdgeBasisCoefficients, "")
                    .def_readwrite("pi_nabla", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::PiNabla, "")
                    .def_readwrite("pi0km2", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Pi0km2, "")
                    .def_readwrite("pi0k", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Pi0k, "")
                    .def_readwrite("pi0km1_der", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Pi0km1Der, "")
                    .def_readwrite("wmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Wmatrix, "")
                    .def_readwrite("vmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Vmatrix, "")
                    .def_readwrite("bmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Bmatrix, "")
                    .def_readwrite("dmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Dmatrix, "")
                    .def_readwrite("gmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Gmatrix, "")
                    .def_readwrite("cmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Cmatrix, "")
                    .def_readwrite("cmatrixkm2", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Cmatrixkm2, "")
                    .def_readwrite("ematrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data::Ematrix, "")
                    ;


                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Pressure_LocalSpace_Data =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Pressure_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Diameter = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data>();
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->Hmatrix = Hmatrix;
                        return r_ctor_;
                    })
                    , py::arg("diameter") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("hmatrix") = Eigen::MatrixXd()
                    )
                    .def_readwrite("order", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::Order, "")
                    .def_readwrite("dimension", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::Dimension, "")
                    .def_readwrite("nk", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::Nk, "")
                    .def_readwrite("nkm1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::Nkm1, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("diameter", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::Diameter, "")
                    .def_readwrite("centroid", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::Centroid, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data::Hmatrix, "")
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_2D_LocalSpace_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_2D_Pressure_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_2D_Presure_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Pressure_LocalSpace =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Pressure_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_2D_Pressure_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Reduced_Pressure_LocalSpace =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_2D_Reduced_Pressure_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_2D_Reduced_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_2D_Reduced_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Reduced_Pressure_ReferenceElement =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Pressure_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Reduced_Pressure_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Pressure_ReferenceElement::Create, py::arg("order"))
                    ;


                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Reduced_Velocity_ReferenceElement =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Reduced_Velocity_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_2D_Reduced_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Reduced_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_values_on_edge",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputeValuesOnEdge, py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("polygon"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("polygon"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("polygon"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("polygon"), py::arg("points"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("reference_element_data"), py::arg("polygon"), py::arg("points"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_2D_Reduced_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_2D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_2D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Pressure_ReferenceElement =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Pressure_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Pressure_ReferenceElement::Create, py::arg("order"))
                    ;


                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Velocity_ReferenceElement =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Velocity_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_2D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_2D_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_2D_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_2D_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_2D_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_values_on_edge",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputeValuesOnEdge, py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("polygon"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("polygon"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("polygon"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Polygon_Geometry &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("polygon"), py::arg("points"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("reference_element_data"), py::arg("polygon"), py::arg("points"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_2D_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_2D_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_3D_Creator.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_3D_Creator_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyEnumVEM_DF_PCC_3D_LocalSpace_Types =
                    py::enum_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_LocalSpace_Types>(pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_LocalSpace_Types", py::arithmetic(), "")
                        .value("vem_df_pcc_3_d_local_space", Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_LocalSpace_Types::VEM_DF_PCC_3D_LocalSpace, "")
                        .value("vem_df_pcc_3_d_reduced_local_space", Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_LocalSpace_Types::VEM_DF_PCC_3D_Reduced_LocalSpace, "");


                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_velocity_reference_element_2_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_velocity_reference_element_2D, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_full_pressure_reference_element_3_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_full_pressure_reference_element_3D, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_full_velocity_reference_element_3_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_full_velocity_reference_element_3D, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_full_pressure_local_space_3_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_full_pressure_local_space_3D, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_full_velocity_local_space_3_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_full_velocity_local_space_3D, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_pressure_reference_element_3_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_pressure_reference_element_3D, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_velocity_reference_element_3_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_velocity_reference_element_3D, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_pressure_local_space_3_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_pressure_local_space_3D, py::arg("type"));

                pyNsPolydim_NsVEM_NsDF_PCC.def("create_vem_df_pcc_3_d_velocity_local_space_3_d",
                    Polydim::VEM::DF_PCC::create_VEM_DF_PCC_3D_velocity_local_space_3D, py::arg("type"));
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_3D_Creator.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_3D_LocalSpace_Data.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_3D_LocalSpace_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Polyhedron_Geometry =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Polyhedron_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), double Tolerance2D = double(), double Tolerance3D = double(), Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::MatrixXi Edges = Eigen::MatrixXi(), std::vector<Eigen::MatrixXi> Faces = std::vector<Eigen::MatrixXi>(), Eigen::Vector3d Centroid = Eigen::Vector3d(), double Measure = double(), double Diameter = double(), std::vector<Eigen::MatrixXd> TetrahedronVertices = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::Matrix3d> FacesRotationMatrix = std::vector<Eigen::Matrix3d>(), std::vector<Eigen::Vector3d> FacesTranslation = std::vector<Eigen::Vector3d>(), std::vector<Eigen::Vector3d> FacesNormal = std::vector<Eigen::Vector3d>(), std::vector<bool> FacesNormalDirection = std::vector<bool>(), std::vector<bool> FacesNormalGlobalDirection = std::vector<bool>(), std::vector<bool> EdgesDirection = std::vector<bool>(), Eigen::MatrixXd EdgesTangent = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Tolerance2D = Tolerance2D;
                        r_ctor_->Tolerance3D = Tolerance3D;
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->Edges = Edges;
                        r_ctor_->Faces = Faces;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->TetrahedronVertices = TetrahedronVertices;
                        r_ctor_->FacesRotationMatrix = FacesRotationMatrix;
                        r_ctor_->FacesTranslation = FacesTranslation;
                        r_ctor_->FacesNormal = FacesNormal;
                        r_ctor_->FacesNormalDirection = FacesNormalDirection;
                        r_ctor_->FacesNormalGlobalDirection = FacesNormalGlobalDirection;
                        r_ctor_->EdgesDirection = EdgesDirection;
                        r_ctor_->EdgesTangent = EdgesTangent;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("tolerance2_d") = double(), py::arg("tolerance3_d") = double(), py::arg("vertices") = Eigen::MatrixXd(), py::arg("edges") = Eigen::MatrixXi(), py::arg("faces") = std::vector<Eigen::MatrixXi>(), py::arg("centroid") = Eigen::Vector3d(), py::arg("measure") = double(), py::arg("diameter") = double(), py::arg("tetrahedron_vertices") = std::vector<Eigen::MatrixXd>(), py::arg("faces_rotation_matrix") = std::vector<Eigen::Matrix3d>(), py::arg("faces_translation") = std::vector<Eigen::Vector3d>(), py::arg("faces_normal") = std::vector<Eigen::Vector3d>(), py::arg("faces_normal_direction") = std::vector<bool>(), py::arg("faces_normal_global_direction") = std::vector<bool>(), py::arg("edges_direction") = std::vector<bool>(), py::arg("edges_tangent") = Eigen::MatrixXd()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Tolerance1D, "")
                    .def_readwrite("tolerance2_d", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Tolerance2D, "")
                    .def_readwrite("tolerance3_d", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Tolerance3D, "")
                    .def_readwrite("vertices", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Vertices, "")
                    .def_readwrite("edges", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Edges, "")
                    .def_readwrite("faces", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Faces, "")
                    .def_readwrite("centroid", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Centroid, "")
                    .def_readwrite("measure", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Measure, "")
                    .def_readwrite("diameter", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::Diameter, "")
                    .def_readwrite("tetrahedron_vertices", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::TetrahedronVertices, "")
                    .def_readwrite("faces_rotation_matrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::FacesRotationMatrix, "")
                    .def_readwrite("faces_translation", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::FacesTranslation, "")
                    .def_readwrite("faces_normal", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::FacesNormal, "")
                    .def_readwrite("faces_normal_direction", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::FacesNormalDirection, "")
                    .def_readwrite("faces_normal_global_direction", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::FacesNormalGlobalDirection, "")
                    .def_readwrite("faces_tangents", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::FacesTangents, "")
                    .def_readwrite("faces_tangents_global_direction", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::FacesTangentsGlobalDirection, "")
                    .def_readwrite("edges_direction", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::EdgesDirection, "")
                    .def_readwrite("edges_tangent", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry::EdgesTangent, "")
                    ;


                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Velocity_LocalSpace_Data =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Velocity_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    std::vector<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data> facesLocalSpace = std::vector<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data>(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC BoundaryQuadrature = Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC(), Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC BoundaryQuadratureKL = Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC(), double Diameter = double(), double Measure = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderInternalDerivatives = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd VanderBoundary = Eigen::MatrixXd(), Eigen::MatrixXd VanderBoundaryKL = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderBoundaryDerivatives = std::vector<Eigen::MatrixXd>(), std::vector<std::vector<Eigen::MatrixXd>> VectorDecompositionMatrices = std::vector<std::vector<Eigen::MatrixXd>>(), std::vector<Eigen::MatrixXd> VanderGBigOPlus = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> VanderGBigOPluskm2 = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd(), Eigen::MatrixXd HmatrixKp1 = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> VanderFaceProjectionsKm1 = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd VanderEdgeDofs = Eigen::MatrixXd(), Eigen::MatrixXd VanderFaceProjectionsKp1TimesNormal = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> FaceScaledMomentsBasis = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> ScaledHmatrixOnBoundary = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> PiNabla = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Pi0km2 = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Pi0k = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Pi0km1Der = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Wmatrix = Eigen::MatrixXd(), Eigen::MatrixXd Vmatrix = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> Bmatrix = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Dmatrix = std::vector<Eigen::MatrixXd>(), Eigen::MatrixXd Gmatrix = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> Cmatrix = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Cmatrixkm2 = std::vector<Eigen::MatrixXd>(), std::vector<Eigen::MatrixXd> Ematrix = std::vector<Eigen::MatrixXd>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data>();
                        r_ctor_->facesLocalSpace = facesLocalSpace;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        r_ctor_->BoundaryQuadratureKL = BoundaryQuadratureKL;
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Measure = Measure;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->VanderInternalDerivatives = VanderInternalDerivatives;
                        r_ctor_->VanderBoundary = VanderBoundary;
                        r_ctor_->VanderBoundaryKL = VanderBoundaryKL;
                        r_ctor_->VanderBoundaryDerivatives = VanderBoundaryDerivatives;
                        r_ctor_->VectorDecompositionMatrices = VectorDecompositionMatrices;
                        r_ctor_->VanderGBigOPlus = VanderGBigOPlus;
                        r_ctor_->VanderGBigOPluskm2 = VanderGBigOPluskm2;
                        r_ctor_->Hmatrix = Hmatrix;
                        r_ctor_->HmatrixKp1 = HmatrixKp1;
                        r_ctor_->VanderFaceProjectionsKm1 = VanderFaceProjectionsKm1;
                        r_ctor_->VanderEdgeDofs = VanderEdgeDofs;
                        r_ctor_->VanderFaceProjectionsKp1TimesNormal = VanderFaceProjectionsKp1TimesNormal;
                        r_ctor_->FaceScaledMomentsBasis = FaceScaledMomentsBasis;
                        r_ctor_->ScaledHmatrixOnBoundary = ScaledHmatrixOnBoundary;
                        r_ctor_->PiNabla = PiNabla;
                        r_ctor_->Pi0km2 = Pi0km2;
                        r_ctor_->Pi0k = Pi0k;
                        r_ctor_->Pi0km1Der = Pi0km1Der;
                        r_ctor_->Wmatrix = Wmatrix;
                        r_ctor_->Vmatrix = Vmatrix;
                        r_ctor_->Bmatrix = Bmatrix;
                        r_ctor_->Dmatrix = Dmatrix;
                        r_ctor_->Gmatrix = Gmatrix;
                        r_ctor_->Cmatrix = Cmatrix;
                        r_ctor_->Cmatrixkm2 = Cmatrixkm2;
                        r_ctor_->Ematrix = Ematrix;
                        return r_ctor_;
                    })
                    , py::arg("faces_local_space") = std::vector<Polydim::VEM::PCC::VEM_PCC_2D_LocalSpace_Data>(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC(), py::arg("boundary_quadrature_kl") = Polydim::VEM::Quadrature::VEM_Quadrature_3D::Faces_QuadratureData_PCC(), py::arg("diameter") = double(), py::arg("measure") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("vander_internal_derivatives") = std::vector<Eigen::MatrixXd>(), py::arg("vander_boundary") = Eigen::MatrixXd(), py::arg("vander_boundary_kl") = Eigen::MatrixXd(), py::arg("vander_boundary_derivatives") = std::vector<Eigen::MatrixXd>(), py::arg("vector_decomposition_matrices") = std::vector<std::vector<Eigen::MatrixXd>>(), py::arg("vander_g_big_o_plus") = std::vector<Eigen::MatrixXd>(), py::arg("vander_g_big_o_pluskm2") = std::vector<Eigen::MatrixXd>(), py::arg("hmatrix") = Eigen::MatrixXd(), py::arg("hmatrix_kp1") = Eigen::MatrixXd(), py::arg("vander_face_projections_km1") = std::vector<Eigen::MatrixXd>(), py::arg("vander_edge_dofs") = Eigen::MatrixXd(), py::arg("vander_face_projections_kp1_times_normal") = Eigen::MatrixXd(), py::arg("face_scaled_moments_basis") = std::vector<Eigen::MatrixXd>(), py::arg("scaled_hmatrix_on_boundary") = std::vector<Eigen::MatrixXd>(), py::arg("pi_nabla") = std::vector<Eigen::MatrixXd>(), py::arg("pi0km2") = std::vector<Eigen::MatrixXd>(), py::arg("pi0k") = std::vector<Eigen::MatrixXd>(), py::arg("pi0km1_der") = std::vector<Eigen::MatrixXd>(), py::arg("wmatrix") = Eigen::MatrixXd(), py::arg("vmatrix") = Eigen::MatrixXd(), py::arg("bmatrix") = std::vector<Eigen::MatrixXd>(), py::arg("dmatrix") = std::vector<Eigen::MatrixXd>(), py::arg("gmatrix") = Eigen::MatrixXd(), py::arg("cmatrix") = std::vector<Eigen::MatrixXd>(), py::arg("cmatrixkm2") = std::vector<Eigen::MatrixXd>(), py::arg("ematrix") = std::vector<Eigen::MatrixXd>()
                    )
                    .def_readwrite("order", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Order, "")
                    .def_readwrite("dimension", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Dimension, "")
                    .def_readwrite("n_kp1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NKp1, "")
                    .def_readwrite("nk", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Nk, "")
                    .def_readwrite("nkm1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Nkm1, "")
                    .def_readwrite("nkm2", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Nkm2, "")
                    .def_readwrite("nkm3", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Nkm3, "")
                    .def_readwrite("nkm4", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Nkm4, "")
                    .def_readwrite("faces_local_space", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::facesLocalSpace, "")
                    .def_readwrite("num_vertex_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumVertexBasisFunctions, "")
                    .def_readwrite("num_edge_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumEdgeBasisFunctions, "")
                    .def_readwrite("num_face_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumFaceBasisFunctions, "")
                    .def_readwrite("num_normal_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumNormalBasisFunctions, "")
                    .def_readwrite("num_tangents_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumTangentsBasisFunctions, "")
                    .def_readwrite("num_boundary_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumBoundaryBasisFunctions, "")
                    .def_readwrite("num_divergence_internal_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumDivergenceInternalBasisFunctions, "")
                    .def_readwrite("num_big_o_plus_internal_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumBigOPlusInternalBasisFunctions, "")
                    .def_readwrite("num_internal_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumInternalBasisFunctions, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("boundary_quadrature_kl", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::BoundaryQuadratureKL, "")
                    .def_readwrite("diameter", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Diameter, "")
                    .def_readwrite("measure", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Measure, "")
                    .def_readwrite("centroid", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Centroid, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("vander_internal_derivatives", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderInternalDerivatives, "")
                    .def_readwrite("vander_boundary", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderBoundary, "")
                    .def_readwrite("vander_boundary_kl", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderBoundaryKL, "")
                    .def_readwrite("vander_boundary_derivatives", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderBoundaryDerivatives, "")
                    .def_readwrite("vector_decomposition_matrices", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VectorDecompositionMatrices, "")
                    .def_readwrite("vander_g_big_o_plus", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderGBigOPlus, "")
                    .def_readwrite("vander_g_big_o_pluskm2", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderGBigOPluskm2, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Hmatrix, "")
                    .def_readwrite("hmatrix_kp1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::HmatrixKp1, "")
                    .def_readwrite("vander_face_projections_km1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderFaceProjectionsKm1, "")
                    .def_readwrite("vander_edge_dofs", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderEdgeDofs, "")
                    .def_readwrite("vander_face_projections_kp1_times_normal", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::VanderFaceProjectionsKp1TimesNormal, "")
                    .def_readwrite("face_scaled_moments_basis", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::FaceScaledMomentsBasis, "")
                    .def_readwrite("scaled_hmatrix_on_boundary", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::ScaledHmatrixOnBoundary, "")
                    .def_readwrite("pi_nabla", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::PiNabla, "")
                    .def_readwrite("pi0km2", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Pi0km2, "")
                    .def_readwrite("pi0k", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Pi0k, "")
                    .def_readwrite("pi0km1_der", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Pi0km1Der, "")
                    .def_readwrite("wmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Wmatrix, "")
                    .def_readwrite("vmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Vmatrix, "")
                    .def_readwrite("bmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Bmatrix, "")
                    .def_readwrite("dmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Dmatrix, "")
                    .def_readwrite("gmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Gmatrix, "")
                    .def_readwrite("cmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Cmatrix, "")
                    .def_readwrite("cmatrixkm2", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Cmatrixkm2, "")
                    .def_readwrite("ematrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data::Ematrix, "")
                    ;


                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Pressure_LocalSpace_Data =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Pressure_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Diameter = double(), Eigen::Vector3d Centroid = Eigen::Vector3d(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd VanderInternal = Eigen::MatrixXd(), Eigen::MatrixXd Hmatrix = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data>();
                        r_ctor_->Diameter = Diameter;
                        r_ctor_->Centroid = Centroid;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->VanderInternal = VanderInternal;
                        r_ctor_->Hmatrix = Hmatrix;
                        return r_ctor_;
                    })
                    , py::arg("diameter") = double(), py::arg("centroid") = Eigen::Vector3d(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("vander_internal") = Eigen::MatrixXd(), py::arg("hmatrix") = Eigen::MatrixXd()
                    )
                    .def_readwrite("order", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::Order, "")
                    .def_readwrite("dimension", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::Dimension, "")
                    .def_readwrite("nk", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::Nk, "")
                    .def_readwrite("nkm1", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::Nkm1, "")
                    .def_readwrite("num_basis_functions", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::NumBasisFunctions, "")
                    .def_readwrite("diameter", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::Diameter, "")
                    .def_readwrite("centroid", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::Centroid, "")
                    .def_readwrite("internal_quadrature", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("vander_internal", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::VanderInternal, "")
                    .def_readwrite("hmatrix", &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data::Hmatrix, "")
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_3D_LocalSpace_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_3D_Pressure_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_3D_Pressure_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Pressure_LocalSpace =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Pressure_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polyhedron"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_3D_Pressure_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Reduced_Pressure_LocalSpace =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace::CreateLocalSpace, py::arg("reference_element_data_3_d"), py::arg("polyhedron"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_3D_Reduced_Pressure_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_3D_Reduced_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_3D_Reduced_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Reduced_Pressure_ReferenceElement =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Pressure_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Reduced_Pressure_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Pressure_ReferenceElement::Create, py::arg("order"))
                    ;


                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Reduced_Velocity_ReferenceElement =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Reduced_Velocity_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_3D_Reduced_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Reduced_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data_2_d"), py::arg("reference_element_data_3_d"), py::arg("polygonal_faces"), py::arg("polyhedron"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("points"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("points"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_3D_Reduced_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_3D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_3D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Pressure_ReferenceElement =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Pressure_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Pressure_ReferenceElement::Create, py::arg("order"))
                    ;


                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Velocity_ReferenceElement =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Velocity_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_3D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:VEM_DF_PCC_3D_Velocity_LocalSpace.hpp>    ////////////////////
    // #ifndef __VEM_DF_PCC_3D_Velocity_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace VEM>
            py::module_ pyNsPolydim_NsVEM = pyNsPolydim.def_submodule("vem", "namespace VEM");
            { // <namespace DF_PCC>
                py::module_ pyNsPolydim_NsVEM_NsDF_PCC = pyNsPolydim_NsVEM.def_submodule("df_pcc", "namespace DF_PCC");
                auto pyNsPolydim_NsVEM_NsDF_PCC_ClassVEM_DF_PCC_3D_Velocity_LocalSpace =
                    py::class_<Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace>
                        (pyNsPolydim_NsVEM_NsDF_PCC, "VEM_DF_PCC_3D_Velocity_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::CreateLocalSpace, py::arg("reference_element_data_2_d"), py::arg("reference_element_data_3_d"), py::arg("polygonal_faces"), py::arg("polyhedron"))
                    .def("compute_dofi_dofi_stabilization_matrix",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputeDofiDofiStabilizationMatrix, py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("local_space"), py::arg("projection_type"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &, const Polydim::VEM::DF_PCC::ProjectionTypes &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("local_space"), py::arg("projection_type"), py::arg("points"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputePolynomialsValues, py::const_), py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("points"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace_Data &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("local_space"))
                    .def("compute_polynomials_derivative_values",
                        py::overload_cast<const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_ReferenceElement_Data &, const Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Polyhedron_Geometry &, const Eigen::MatrixXd &>(&Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputePolynomialsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("points"))
                    .def("compute_polynomials_laplacian_values",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputePolynomialsLaplacianValues, py::arg("reference_element_data"), py::arg("polyhedron"), py::arg("points"))
                    .def("compute_basis_functions_divergence_values",
                        &Polydim::VEM::DF_PCC::VEM_DF_PCC_3D_Velocity_LocalSpace::ComputeBasisFunctionsDivergenceValues, py::arg("local_space"))
                    ;
            } // </namespace DF_PCC>

        } // </namespace VEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:VEM_DF_PCC_3D_Velocity_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_PCC_1D_LocalSpace.hpp>    ////////////////////
    // #ifndef __FEM_PCC_1D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_1D_Segment_Geometry =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_1D_Segment_Geometry>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_1D_Segment_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), Eigen::Vector3d Origin = Eigen::Vector3d(), Eigen::Vector3d Tangent = Eigen::Vector3d(), double Length = double())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_1D_Segment_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Origin = Origin;
                        r_ctor_->Tangent = Tangent;
                        r_ctor_->Length = Length;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("origin") = Eigen::Vector3d(), py::arg("tangent") = Eigen::Vector3d(), py::arg("length") = double()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::FEM::PCC::FEM_PCC_1D_Segment_Geometry::Tolerance1D, "")
                    .def_readwrite("origin", &Polydim::FEM::PCC::FEM_PCC_1D_Segment_Geometry::Origin, "")
                    .def_readwrite("tangent", &Polydim::FEM::PCC::FEM_PCC_1D_Segment_Geometry::Tangent, "")
                    .def_readwrite("length", &Polydim::FEM::PCC::FEM_PCC_1D_Segment_Geometry::Length, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_1D_LocalSpace_Data =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_1D_LocalSpace_Data", py::is_final(), "\n(final class)");

                { // inner classes & enums of FEM_PCC_1D_LocalSpace_Data
                    auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_1D_LocalSpace_Data_ClassSegmentMapData =
                        py::class_<Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData>
                            (pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_1D_LocalSpace_Data, "SegmentMapData", "")
                        .def(py::init<>([](
                        Eigen::Vector3d Origin = Eigen::Vector3d(), Eigen::Vector3d Tangent = Eigen::Vector3d(), double Length = double(), double SquaredLength = double())
                        {
                            auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData>();
                            r_ctor_->Origin = Origin;
                            r_ctor_->Tangent = Tangent;
                            r_ctor_->Length = Length;
                            r_ctor_->SquaredLength = SquaredLength;
                            return r_ctor_;
                        })
                        , py::arg("origin") = Eigen::Vector3d(), py::arg("tangent") = Eigen::Vector3d(), py::arg("length") = double(), py::arg("squared_length") = double()
                        )
                        .def_readwrite("origin", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData::Origin, "")
                        .def_readwrite("tangent", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData::Tangent, "")
                        .def_readwrite("length", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData::Length, "")
                        .def_readwrite("squared_length", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData::SquaredLength, "")
                        ;
                } // end of inner classes & enums of FEM_PCC_1D_LocalSpace_Data

                pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_1D_LocalSpace_Data
                    .def(py::init<>([](
                    Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData MapData = Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData(), Eigen::MatrixXd Dofs = Eigen::MatrixXd(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data>();
                        r_ctor_->MapData = MapData;
                        r_ctor_->Dofs = Dofs;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        return r_ctor_;
                    })
                    , py::arg("map_data") = Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::SegmentMapData(), py::arg("dofs") = Eigen::MatrixXd(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData()
                    )
                    .def_readwrite("map_data", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::MapData, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::Order, "")
                    .def_readwrite("number_of_basis_functions", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::NumberOfBasisFunctions, "")
                    .def_readwrite("dofs", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::Dofs, "")
                    .def_readwrite("dofs_mesh_order", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::DofsMeshOrder, "")
                    .def_readwrite("dof0_ds_index", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::Dof0DsIndex, "")
                    .def_readwrite("dof1_ds_index", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::Dof1DsIndex, "")
                    .def_readwrite("internal_quadrature", &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data::InternalQuadrature, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_1D_LocalSpace =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_1D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("segment"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_PCC_1D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_PCC_1D_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_PCC_1D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __FEM_PCC_1D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyEnumFEM_PCC_1D_Types =
                    py::enum_<Polydim::FEM::PCC::FEM_PCC_1D_Types>(pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_1D_Types", py::arithmetic(), "")
                        .value("equispaced", Polydim::FEM::PCC::FEM_PCC_1D_Types::Equispaced, "")
                        .value("gauss_lobatto", Polydim::FEM::PCC::FEM_PCC_1D_Types::GaussLobatto, "");


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_1D_ReferenceElement_Data =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_1D_ReferenceElement_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Eigen::MatrixXd DofPositions = Eigen::MatrixXd(), Eigen::VectorXd Interpolation_coefficients = Eigen::VectorXd(), Gedim::Quadrature::QuadratureData ReferenceSegmentQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd ReferenceBasisFunctionValues = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> ReferenceBasisFunctionDerivativeValues = std::vector<Eigen::MatrixXd>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data>();
                        r_ctor_->DofPositions = DofPositions;
                        r_ctor_->Interpolation_coefficients = Interpolation_coefficients;
                        r_ctor_->ReferenceSegmentQuadrature = ReferenceSegmentQuadrature;
                        r_ctor_->ReferenceBasisFunctionValues = ReferenceBasisFunctionValues;
                        r_ctor_->ReferenceBasisFunctionDerivativeValues = ReferenceBasisFunctionDerivativeValues;
                        return r_ctor_;
                    })
                    , py::arg("dof_positions") = Eigen::MatrixXd(), py::arg("interpolation_coefficients") = Eigen::VectorXd(), py::arg("reference_segment_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_basis_function_values") = Eigen::MatrixXd(), py::arg("reference_basis_function_derivative_values") = std::vector<Eigen::MatrixXd>()
                    )
                    .def_readwrite("dimension", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::Order, "")
                    .def_readwrite("num_dofs0_d", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::NumDofs0D, "")
                    .def_readwrite("num_dofs1_d", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::NumDofs1D, "")
                    .def_readwrite("num_basis_functions", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::NumBasisFunctions, "")
                    .def_readwrite("dof_positions", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::DofPositions, "")
                    .def_readwrite("interpolation_coefficients", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::Interpolation_coefficients, "")
                    .def_readwrite("reference_segment_quadrature", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::ReferenceSegmentQuadrature, "")
                    .def_readwrite("reference_basis_function_values", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::ReferenceBasisFunctionValues, "")
                    .def_readwrite("reference_basis_function_derivative_values", &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data::ReferenceBasisFunctionDerivativeValues, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_1D_ReferenceElement =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_1D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement::Create, py::arg("order"), py::arg("type") = Polydim::FEM::PCC::FEM_PCC_1D_Types::Equispaced)
                    .def("evaluate_lambda",
                        &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement::EvaluateLambda,
                        py::arg("points"),
                        "***************************************************************************")
                    .def("evaluate_grad_lambda",
                        &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement::EvaluateGradLambda,
                        py::arg("points"),
                        "***************************************************************************")
                    .def("evaluate_basis_functions",
                        &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement::EvaluateBasisFunctions,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    .def("evaluate_basis_function_derivatives",
                        &Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement::EvaluateBasisFunctionDerivatives,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_PCC_1D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_PCC_2D_LocalSpace_Data.hpp>    ////////////////////
    // #ifndef __FEM_PCC_2D_LocalSpace_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyEnumFEM_PCC_2D_Types =
                    py::enum_<Polydim::FEM::PCC::FEM_PCC_2D_Types>(pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_2D_Types", py::arithmetic(), "")
                        .value("triangle", Polydim::FEM::PCC::FEM_PCC_2D_Types::Triangle, "")
                        .value("quadrilateral", Polydim::FEM::PCC::FEM_PCC_2D_Types::Quadrilateral, "");


                auto pyEnumQuadrilateralType =
                    py::enum_<Polydim::FEM::PCC::QuadrilateralType>(pyNsPolydim_NsFEM_NsPCC, "QuadrilateralType", py::arithmetic(), "")
                        .value("parallelogram", Polydim::FEM::PCC::QuadrilateralType::Parallelogram, "")
                        .value("generic", Polydim::FEM::PCC::QuadrilateralType::Generic, "");


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_2D_Polygon_Geometry =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_2D_Polygon_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), double Tolerance2D = double(), Eigen::MatrixXd Vertices = Eigen::MatrixXd(), std::vector<bool> EdgesDirection = std::vector<bool>(), Eigen::MatrixXd EdgesTangent = Eigen::MatrixXd(), Eigen::VectorXd EdgesLength = Eigen::VectorXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Tolerance2D = Tolerance2D;
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->EdgesDirection = EdgesDirection;
                        r_ctor_->EdgesTangent = EdgesTangent;
                        r_ctor_->EdgesLength = EdgesLength;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("tolerance2_d") = double(), py::arg("vertices") = Eigen::MatrixXd(), py::arg("edges_direction") = std::vector<bool>(), py::arg("edges_tangent") = Eigen::MatrixXd(), py::arg("edges_length") = Eigen::VectorXd()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry::Tolerance1D, "")
                    .def_readwrite("tolerance2_d", &Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry::Tolerance2D, "")
                    .def_readwrite("vertices", &Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry::Vertices, "")
                    .def_readwrite("edges_direction", &Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry::EdgesDirection, "")
                    .def_readwrite("edges_tangent", &Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry::EdgesTangent, "")
                    .def_readwrite("edges_length", &Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry::EdgesLength, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Triangle_PCC_2D_LocalSpace_Data =
                    py::class_<Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Triangle_PCC_2D_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::MapTriangle::MapTriangleData MapData = Gedim::MapTriangle::MapTriangleData(), Eigen::Matrix3d B_lap = Eigen::Matrix3d(), Eigen::MatrixXd Dofs = Eigen::MatrixXd(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), std::vector<Gedim::Quadrature::QuadratureData> BoundaryQuadrature = std::vector<Gedim::Quadrature::QuadratureData>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data>();
                        r_ctor_->MapData = MapData;
                        r_ctor_->B_lap = B_lap;
                        r_ctor_->Dofs = Dofs;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        return r_ctor_;
                    })
                    , py::arg("map_data") = Gedim::MapTriangle::MapTriangleData(), py::arg("b_lap") = Eigen::Matrix3d(), py::arg("dofs") = Eigen::MatrixXd(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = std::vector<Gedim::Quadrature::QuadratureData>()
                    )
                    .def_readwrite("map_data", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::MapData, "")
                    .def_readwrite("b_lap", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::B_lap, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::Order, "")
                    .def_readwrite("number_of_basis_functions", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::NumberOfBasisFunctions, "")
                    .def_readwrite("dofs", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::Dofs, "")
                    .def_readwrite("dofs_mesh_order", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::DofsMeshOrder, "")
                    .def_readwrite("dof0_ds_index", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::Dof0DsIndex, "")
                    .def_readwrite("dof1_ds_index", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::Dof1DsIndex, "")
                    .def_readwrite("dof2_ds_index", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::Dof2DsIndex, "")
                    .def_readwrite("internal_quadrature", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data::BoundaryQuadrature, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Quadrilateral_PCC_2D_LocalSpace_Data =
                    py::class_<Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Quadrilateral_PCC_2D_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Gedim::MapParallelogram::MapParallelogramData MapData = Gedim::MapParallelogram::MapParallelogramData(), Eigen::Matrix3d B_lap = Eigen::Matrix3d(), Eigen::MatrixXd Dofs = Eigen::MatrixXd(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), std::vector<Gedim::Quadrature::QuadratureData> BoundaryQuadrature = std::vector<Gedim::Quadrature::QuadratureData>(), Polydim::FEM::PCC::QuadrilateralType quadrilateral_type = Polydim::FEM::PCC::QuadrilateralType())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data>();
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->MapData = MapData;
                        r_ctor_->B_lap = B_lap;
                        r_ctor_->Dofs = Dofs;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        r_ctor_->quadrilateral_type = quadrilateral_type;
                        return r_ctor_;
                    })
                    , py::arg("vertices") = Eigen::MatrixXd(), py::arg("map_data") = Gedim::MapParallelogram::MapParallelogramData(), py::arg("b_lap") = Eigen::Matrix3d(), py::arg("dofs") = Eigen::MatrixXd(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = std::vector<Gedim::Quadrature::QuadratureData>(), py::arg("quadrilateral_type") = Polydim::FEM::PCC::QuadrilateralType()
                    )
                    .def_readwrite("vertices", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::Vertices, "")
                    .def_readwrite("map_data", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::MapData, "")
                    .def_readwrite("b_lap", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::B_lap, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::Order, "")
                    .def_readwrite("number_of_basis_functions", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::NumberOfBasisFunctions, "")
                    .def_readwrite("dofs", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::Dofs, "")
                    .def_readwrite("dofs_mesh_order", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::DofsMeshOrder, "")
                    .def_readwrite("dof0_ds_index", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::Dof0DsIndex, "")
                    .def_readwrite("dof1_ds_index", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::Dof1DsIndex, "")
                    .def_readwrite("dof2_ds_index", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::Dof2DsIndex, "")
                    .def_readwrite("internal_quadrature", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("quadrilateral_type", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data::quadrilateral_type, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_2D_LocalSpace_Data =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_2D_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data triangle_local_space_data = Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data(), Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data quadrilateral_local_space_data = Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data(), Polydim::FEM::PCC::FEM_PCC_2D_Types fem_type = Polydim::FEM::PCC::FEM_PCC_2D_Types(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), std::vector<Gedim::Quadrature::QuadratureData> BoundaryQuadrature = std::vector<Gedim::Quadrature::QuadratureData>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data>();
                        r_ctor_->triangle_local_space_data = triangle_local_space_data;
                        r_ctor_->quadrilateral_local_space_data = quadrilateral_local_space_data;
                        r_ctor_->fem_type = fem_type;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        return r_ctor_;
                    })
                    , py::arg("triangle_local_space_data") = Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data(), py::arg("quadrilateral_local_space_data") = Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data(), py::arg("fem_type") = Polydim::FEM::PCC::FEM_PCC_2D_Types(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = std::vector<Gedim::Quadrature::QuadratureData>()
                    )
                    .def_readwrite("triangle_local_space_data", &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data::triangle_local_space_data, "")
                    .def_readwrite("quadrilateral_local_space_data", &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data::quadrilateral_local_space_data, "")
                    .def_readwrite("fem_type", &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data::fem_type, "")
                    .def_readwrite("internal_quadrature", &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("number_of_basis_functions", &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data::NumberOfBasisFunctions, "")
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_PCC_2D_LocalSpace_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_Quadrilateral_PCC_2D_LocalSpace.hpp>    ////////////////////
    // #ifndef __FEM_Quadrilateral_PCC_2D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Quadrilateral_PCC_2D_LocalSpace =
                    py::class_<Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Quadrilateral_PCC_2D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_laplacian_values",
                        &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("edge_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::EdgeDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("edge_local_index"))
                    .def("compute_basis_functions_values_on_edge",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data &>(&Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::const_), py::arg("reference_element_data"))
                    .def("compute_basis_functions_values_on_edge",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data &, const Eigen::VectorXd &>(&Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::const_), py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_Quadrilateral_PCC_2D_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_Quadrilateral_PCC_2D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __FEM_Quadrilateral_PCC_2D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Quadrilateral_PCC_2D_ReferenceElement_Data =
                    py::class_<Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Quadrilateral_PCC_2D_ReferenceElement_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Eigen::MatrixXd DofPositions = Eigen::MatrixXd(), Gedim::Quadrature::QuadratureData ReferenceTriangleQuadrature = Gedim::Quadrature::QuadratureData(), Gedim::Quadrature::QuadratureData ReferenceSquareQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd ReferenceBasisFunctionValues = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> ReferenceBasisFunctionDerivativeValues = std::vector<Eigen::MatrixXd>(), Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data BoundaryReferenceElement_Data = Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data>();
                        r_ctor_->DofPositions = DofPositions;
                        r_ctor_->ReferenceTriangleQuadrature = ReferenceTriangleQuadrature;
                        r_ctor_->ReferenceSquareQuadrature = ReferenceSquareQuadrature;
                        r_ctor_->ReferenceBasisFunctionValues = ReferenceBasisFunctionValues;
                        r_ctor_->ReferenceBasisFunctionDerivativeValues = ReferenceBasisFunctionDerivativeValues;
                        r_ctor_->BoundaryReferenceElement_Data = BoundaryReferenceElement_Data;
                        return r_ctor_;
                    })
                    , py::arg("dof_positions") = Eigen::MatrixXd(), py::arg("reference_triangle_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_square_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_basis_function_values") = Eigen::MatrixXd(), py::arg("reference_basis_function_derivative_values") = std::vector<Eigen::MatrixXd>(), py::arg("boundary_reference_element_data") = Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data()
                    )
                    .def_readwrite("dimension", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::Order, "")
                    .def_readwrite("num_dofs0_d", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::NumDofs0D, "")
                    .def_readwrite("num_dofs1_d", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::NumDofs1D, "")
                    .def_readwrite("num_dofs2_d", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::NumDofs2D, "")
                    .def_readwrite("num_basis_functions", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::NumBasisFunctions, "")
                    .def_readwrite("dof_positions", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::DofPositions, "")
                    .def_readwrite("dof_types", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::DofTypes, "")
                    .def_readwrite("edges_by_vertices", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::Edges_by_vertices, "")
                    .def_readwrite("reference_triangle_quadrature", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::ReferenceTriangleQuadrature, "")
                    .def_readwrite("reference_square_quadrature", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::ReferenceSquareQuadrature, "")
                    .def_readwrite("reference_basis_function_values", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::ReferenceBasisFunctionValues, "")
                    .def_readwrite("reference_basis_function_derivative_values", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::ReferenceBasisFunctionDerivativeValues, "")
                    .def_readwrite("reference_basis_function_second_derivative_values", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::ReferenceBasisFunctionSecondDerivativeValues, "")
                    .def_readwrite("boundary_reference_element_data", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data::BoundaryReferenceElement_Data, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Quadrilateral_PCC_2D_ReferenceElement =
                    py::class_<Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Quadrilateral_PCC_2D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def_readwrite("vertices", &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement::Vertices, "")
                    .def(py::init<>())
                    .def("create",
                        &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement::Create, py::arg("order"))
                    .def("evaluate_basis_functions",
                        &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement::EvaluateBasisFunctions,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    .def("evaluate_basis_function_derivatives",
                        &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement::EvaluateBasisFunctionDerivatives,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    .def("evaluate_basis_function_second_derivatives",
                        &Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement::EvaluateBasisFunctionSecondDerivatives,
                        py::arg("param_0"), py::arg("param_1"),
                        "***************************************************************************")
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_Quadrilateral_PCC_2D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_Triangle_PCC_2D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __FEM_Triangle_PCC_2D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Triangle_PCC_2D_ReferenceElement_Data =
                    py::class_<Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Triangle_PCC_2D_ReferenceElement_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Eigen::MatrixXd DofPositions = Eigen::MatrixXd(), Eigen::MatrixXi DofTypes = Eigen::MatrixXi(), Gedim::Quadrature::QuadratureData ReferenceTriangleQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd ReferenceBasisFunctionValues = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> ReferenceBasisFunctionDerivativeValues = std::vector<Eigen::MatrixXd>(), Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data BoundaryReferenceElement_Data = Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data(), Eigen::RowVectorXd EdgeInternalPoints = Eigen::RowVectorXd(), Eigen::VectorXd EdgeBasisCoefficients = Eigen::VectorXd())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data>();
                        r_ctor_->DofPositions = DofPositions;
                        r_ctor_->DofTypes = DofTypes;
                        r_ctor_->ReferenceTriangleQuadrature = ReferenceTriangleQuadrature;
                        r_ctor_->ReferenceBasisFunctionValues = ReferenceBasisFunctionValues;
                        r_ctor_->ReferenceBasisFunctionDerivativeValues = ReferenceBasisFunctionDerivativeValues;
                        r_ctor_->BoundaryReferenceElement_Data = BoundaryReferenceElement_Data;
                        r_ctor_->EdgeInternalPoints = EdgeInternalPoints;
                        r_ctor_->EdgeBasisCoefficients = EdgeBasisCoefficients;
                        return r_ctor_;
                    })
                    , py::arg("dof_positions") = Eigen::MatrixXd(), py::arg("dof_types") = Eigen::MatrixXi(), py::arg("reference_triangle_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_basis_function_values") = Eigen::MatrixXd(), py::arg("reference_basis_function_derivative_values") = std::vector<Eigen::MatrixXd>(), py::arg("boundary_reference_element_data") = Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data(), py::arg("edge_internal_points") = Eigen::RowVectorXd(), py::arg("edge_basis_coefficients") = Eigen::VectorXd()
                    )
                    .def_readwrite("dimension", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::Order, "")
                    .def_readwrite("num_dofs0_d", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::NumDofs0D, "")
                    .def_readwrite("num_dofs1_d", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::NumDofs1D, "")
                    .def_readwrite("num_dofs2_d", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::NumDofs2D, "")
                    .def_readwrite("num_basis_functions", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::NumBasisFunctions, "")
                    .def_readwrite("dof_positions", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::DofPositions, "")
                    .def_readwrite("dof_types", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::DofTypes, "")
                    .def_readwrite("reference_triangle_quadrature", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::ReferenceTriangleQuadrature, "")
                    .def_readwrite("reference_basis_function_values", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::ReferenceBasisFunctionValues, "")
                    .def_readwrite("reference_basis_function_derivative_values", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::ReferenceBasisFunctionDerivativeValues, "")
                    .def_readwrite("reference_basis_function_second_derivative_values", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::ReferenceBasisFunctionSecondDerivativeValues, "")
                    .def_readwrite("boundary_reference_element_data", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::BoundaryReferenceElement_Data, "")
                    .def_readwrite("edge_internal_points", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::EdgeInternalPoints, "")
                    .def_readwrite("edge_basis_coefficients", &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data::EdgeBasisCoefficients, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Triangle_PCC_2D_ReferenceElement =
                    py::class_<Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Triangle_PCC_2D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement::Create, py::arg("order"))
                    .def("evaluate_basis_functions",
                        &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement::EvaluateBasisFunctions,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    .def("evaluate_basis_function_derivatives",
                        &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement::EvaluateBasisFunctionDerivatives,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    .def("evaluate_basis_function_second_derivatives",
                        &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement::EvaluateBasisFunctionSecondDerivatives,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_Triangle_PCC_2D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_Triangle_PCC_2D_LocalSpace.hpp>    ////////////////////
    // #ifndef __FEM_Triangle_PCC_2D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Triangle_PCC_2D_LocalSpace =
                    py::class_<Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Triangle_PCC_2D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("edge_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::EdgeDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("edge_local_index"))
                    .def("compute_basis_functions_laplacian_values",
                        &Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_values_on_edge",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data &>(&Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::const_), py::arg("reference_element_data"))
                    .def("compute_basis_functions_values_on_edge",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data &, const Eigen::VectorXd &>(&Polydim::FEM::PCC::FEM_Triangle_PCC_2D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::const_), py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_Triangle_PCC_2D_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_PCC_2D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __FEM_PCC_2D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_2D_ReferenceElement_Data =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_2D_ReferenceElement_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data triangle_reference_element_data = Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data(), Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data quadrilateral_reference_element_data = Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data>();
                        r_ctor_->triangle_reference_element_data = triangle_reference_element_data;
                        r_ctor_->quadrilateral_reference_element_data = quadrilateral_reference_element_data;
                        return r_ctor_;
                    })
                    , py::arg("triangle_reference_element_data") = Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data(), py::arg("quadrilateral_reference_element_data") = Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data()
                    )
                    .def_readwrite("dimension", &Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data::Order, "")
                    .def_readwrite("num_dofs0_d", &Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data::NumDofs0D, "")
                    .def_readwrite("num_dofs1_d", &Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data::NumDofs1D, "")
                    .def_readwrite("triangle_reference_element_data", &Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data::triangle_reference_element_data, "")
                    .def_readwrite("quadrilateral_reference_element_data", &Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data::quadrilateral_reference_element_data, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_2D_ReferenceElement =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_2D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>())
                    .def("create",
                        &Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_PCC_2D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_PCC_2D_LocalSpace.hpp>    ////////////////////
    // #ifndef __FEM_PCC_2D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_2D_LocalSpace =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_2D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polygon"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_laplacian_values",
                        &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::ComputeBasisFunctionsLaplacianValues, py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_values_on_edge",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_values_on_edge",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_2D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace_Data &, const Eigen::VectorXd &>(&Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points_curvilinear_coordinates"))
                    .def("edge_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_PCC_2D_LocalSpace::EdgeDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("edge_local_index"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_PCC_2D_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_Hexahedron_PCC_3D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __FEM_Hexahedron_PCC_3D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Hexahedron_PCC_3D_ReferenceElement_Data =
                    py::class_<Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Hexahedron_PCC_3D_ReferenceElement_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Eigen::MatrixXd DofPositions = Eigen::MatrixXd(), Gedim::Quadrature::QuadratureData ReferenceHexahedronQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd ReferenceBasisFunctionValues = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> ReferenceBasisFunctionDerivativeValues = std::vector<Eigen::MatrixXd>(), Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data EdgeReferenceElement_Data = Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data(), Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data BoundaryReferenceElement_Data = Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data>();
                        r_ctor_->DofPositions = DofPositions;
                        r_ctor_->ReferenceHexahedronQuadrature = ReferenceHexahedronQuadrature;
                        r_ctor_->ReferenceBasisFunctionValues = ReferenceBasisFunctionValues;
                        r_ctor_->ReferenceBasisFunctionDerivativeValues = ReferenceBasisFunctionDerivativeValues;
                        r_ctor_->EdgeReferenceElement_Data = EdgeReferenceElement_Data;
                        r_ctor_->BoundaryReferenceElement_Data = BoundaryReferenceElement_Data;
                        return r_ctor_;
                    })
                    , py::arg("dof_positions") = Eigen::MatrixXd(), py::arg("reference_hexahedron_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_basis_function_values") = Eigen::MatrixXd(), py::arg("reference_basis_function_derivative_values") = std::vector<Eigen::MatrixXd>(), py::arg("edge_reference_element_data") = Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data(), py::arg("boundary_reference_element_data") = Polydim::FEM::PCC::FEM_Quadrilateral_PCC_2D_ReferenceElement_Data()
                    )
                    .def_readwrite("dimension", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::Order, "")
                    .def_readwrite("num_dofs0_d", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::NumDofs0D, "")
                    .def_readwrite("num_dofs1_d", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::NumDofs1D, "")
                    .def_readwrite("num_dofs2_d", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::NumDofs2D, "")
                    .def_readwrite("num_dofs3_d", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::NumDofs3D, "")
                    .def_readwrite("edges_by_vertices", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::Edges_by_vertices, "")
                    .def_readwrite("faces_by_edges", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::Faces_by_edges, "")
                    .def_readwrite("num_basis_functions", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::NumBasisFunctions, "")
                    .def_readwrite("dof_positions", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::DofPositions, "")
                    .def_readwrite("dof_types", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::DofTypes, "")
                    .def_readwrite("reference_hexahedron_quadrature", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::ReferenceHexahedronQuadrature, "")
                    .def_readwrite("reference_basis_function_values", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::ReferenceBasisFunctionValues, "")
                    .def_readwrite("reference_basis_function_derivative_values", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::ReferenceBasisFunctionDerivativeValues, "")
                    .def_readwrite("edge_reference_element_data", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::EdgeReferenceElement_Data, "")
                    .def_readwrite("boundary_reference_element_data", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data::BoundaryReferenceElement_Data, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Hexahedron_PCC_3D_ReferenceElement =
                    py::class_<Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Hexahedron_PCC_3D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def_readwrite("vertices", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement::Vertices, "")
                    .def(py::init<>())
                    .def("create",
                        &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement::Create, py::arg("order"))
                    .def("evaluate_basis_functions",
                        &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement::EvaluateBasisFunctions,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    .def("evaluate_basis_function_derivatives",
                        &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement::EvaluateBasisFunctionDerivatives,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    .def("evaluate_basis_function_second_derivatives",
                        &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement::EvaluateBasisFunctionSecondDerivatives,
                        py::arg("param_0"), py::arg("param_1"),
                        "***************************************************************************")
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_Hexahedron_PCC_3D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_Hexahedron_PCC_3D_LocalSpace.hpp>    ////////////////////
    // #ifndef __FEM_Hexahedron_PCC_3D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Hexahedron_PCC_3D_LocalSpace =
                    py::class_<Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Hexahedron_PCC_3D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polyhedron"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_values_on_face",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data &, const unsigned int>(&Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnFace, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_index"))
                    .def("compute_basis_functions_values_on_face",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data &, const unsigned int, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnFace, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_index"), py::arg("points2_d"))
                    .def("edge_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::EdgeDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("edge_local_index"))
                    .def("face_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::FaceDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_local_index"))
                    .def("compute_basis_functions_values_on_edge",
                        &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_Hexahedron_PCC_3D_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_Tetrahedron_PCC_3D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __FEM_Tetrahedron_PCC_3D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Tetrahedron_PCC_3D_ReferenceElement_Data =
                    py::class_<Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Tetrahedron_PCC_3D_ReferenceElement_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Eigen::MatrixXd DofPositions = Eigen::MatrixXd(), Gedim::Quadrature::QuadratureData ReferenceTetrahedronQuadrature = Gedim::Quadrature::QuadratureData(), Eigen::MatrixXd ReferenceBasisFunctionValues = Eigen::MatrixXd(), std::vector<Eigen::MatrixXd> ReferenceBasisFunctionDerivativeValues = std::vector<Eigen::MatrixXd>(), Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data EdgeReferenceElement_Data = Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data(), Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data BoundaryReferenceElement_Data = Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data>();
                        r_ctor_->DofPositions = DofPositions;
                        r_ctor_->ReferenceTetrahedronQuadrature = ReferenceTetrahedronQuadrature;
                        r_ctor_->ReferenceBasisFunctionValues = ReferenceBasisFunctionValues;
                        r_ctor_->ReferenceBasisFunctionDerivativeValues = ReferenceBasisFunctionDerivativeValues;
                        r_ctor_->EdgeReferenceElement_Data = EdgeReferenceElement_Data;
                        r_ctor_->BoundaryReferenceElement_Data = BoundaryReferenceElement_Data;
                        return r_ctor_;
                    })
                    , py::arg("dof_positions") = Eigen::MatrixXd(), py::arg("reference_tetrahedron_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("reference_basis_function_values") = Eigen::MatrixXd(), py::arg("reference_basis_function_derivative_values") = std::vector<Eigen::MatrixXd>(), py::arg("edge_reference_element_data") = Polydim::FEM::PCC::FEM_PCC_1D_ReferenceElement_Data(), py::arg("boundary_reference_element_data") = Polydim::FEM::PCC::FEM_Triangle_PCC_2D_ReferenceElement_Data()
                    )
                    .def_readwrite("dimension", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::Order, "")
                    .def_readwrite("num_dofs0_d", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::NumDofs0D, "")
                    .def_readwrite("num_dofs1_d", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::NumDofs1D, "")
                    .def_readwrite("num_dofs2_d", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::NumDofs2D, "")
                    .def_readwrite("num_dofs3_d", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::NumDofs3D, "")
                    .def_readwrite("edges_by_vertices", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::Edges_by_vertices, "")
                    .def_readwrite("faces_by_edge_vertex", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::Faces_by_edge_vertex, "")
                    .def_readwrite("faces_by_edges", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::Faces_by_edges, "")
                    .def_readwrite("num_basis_functions", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::NumBasisFunctions, "")
                    .def_readwrite("dof_positions", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::DofPositions, "")
                    .def_readwrite("dof_types", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::DofTypes, "")
                    .def_readwrite("reference_tetrahedron_quadrature", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::ReferenceTetrahedronQuadrature, "")
                    .def_readwrite("reference_basis_function_values", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::ReferenceBasisFunctionValues, "")
                    .def_readwrite("reference_basis_function_derivative_values", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::ReferenceBasisFunctionDerivativeValues, "")
                    .def_readwrite("edge_reference_element_data", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::EdgeReferenceElement_Data, "")
                    .def_readwrite("boundary_reference_element_data", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data::BoundaryReferenceElement_Data, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Tetrahedron_PCC_3D_ReferenceElement =
                    py::class_<Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Tetrahedron_PCC_3D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement::Create, py::arg("order"))
                    .def("evaluate_lambda",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement::EvaluateLambda,
                        py::arg("points"),
                        "***************************************************************************")
                    .def("evaluate_grad_lambda",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement::EvaluateGradLambda,
                        py::arg("points"),
                        "***************************************************************************")
                    .def("evaluate_basis_functions",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement::EvaluateBasisFunctions,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    .def("evaluate_basis_function_derivatives",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement::EvaluateBasisFunctionDerivatives,
                        py::arg("points"), py::arg("reference_element_data"),
                        "***************************************************************************")
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_Tetrahedron_PCC_3D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_Tetrahedron_PCC_3D_LocalSpace.hpp>    ////////////////////
    // #ifndef __FEM_Tetrahedron_PCC_3D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Tetrahedron_PCC_3D_LocalSpace =
                    py::class_<Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Tetrahedron_PCC_3D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polyhedron"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("edge_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::EdgeDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("edge_local_index"))
                    .def("face_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::FaceDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_local_index"))
                    .def("compute_basis_functions_values_on_face",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data &, const unsigned int>(&Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnFace, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_index"))
                    .def("compute_basis_functions_values_on_face",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data &, const unsigned int, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnFace, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_index"), py::arg("points2_d"))
                    .def("compute_basis_functions_values_on_edge",
                        &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::arg("reference_element_data"), py::arg("points_curvilinear_coordinates"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_Tetrahedron_PCC_3D_LocalSpace.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_PCC_3D_ReferenceElement.hpp>    ////////////////////
    // #ifndef __FEM_PCC_3D_ReferenceElement_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_3D_ReferenceElement_Data =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_3D_ReferenceElement_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data tetrahedron_reference_element_data = Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data(), Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data hexahedron_reference_element_data = Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data>();
                        r_ctor_->tetrahedron_reference_element_data = tetrahedron_reference_element_data;
                        r_ctor_->hexahedron_reference_element_data = hexahedron_reference_element_data;
                        return r_ctor_;
                    })
                    , py::arg("tetrahedron_reference_element_data") = Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_ReferenceElement_Data(), py::arg("hexahedron_reference_element_data") = Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_ReferenceElement_Data()
                    )
                    .def_readwrite("dimension", &Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data::Dimension, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data::Order, "")
                    .def_readwrite("num_dofs0_d", &Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data::NumDofs0D, "")
                    .def_readwrite("num_dofs1_d", &Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data::NumDofs1D, "")
                    .def_readwrite("tetrahedron_reference_element_data", &Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data::tetrahedron_reference_element_data, "")
                    .def_readwrite("hexahedron_reference_element_data", &Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data::hexahedron_reference_element_data, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_3D_ReferenceElement =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_3D_ReferenceElement", py::is_final(), "\n(final class)")
                    .def(py::init<>())
                    .def("create",
                        &Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement::Create, py::arg("order"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_PCC_3D_ReferenceElement.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_PCC_3D_LocalSpace_Data.hpp>    ////////////////////
    // #ifndef __FEM_Hexahedron_PCC_3D_LocalSpace_Data_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyEnumFEM_PCC_3D_Types =
                    py::enum_<Polydim::FEM::PCC::FEM_PCC_3D_Types>(pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_3D_Types", py::arithmetic(), "")
                        .value("tetrahedron", Polydim::FEM::PCC::FEM_PCC_3D_Types::Tetrahedron, "")
                        .value("hexahedron", Polydim::FEM::PCC::FEM_PCC_3D_Types::Hexahedron, "");


                auto pyEnumHexahedronType =
                    py::enum_<Polydim::FEM::PCC::HexahedronType>(pyNsPolydim_NsFEM_NsPCC, "HexahedronType", py::arithmetic(), "")
                        .value("parallelepiped", Polydim::FEM::PCC::HexahedronType::Parallelepiped, "")
                        .value("generic", Polydim::FEM::PCC::HexahedronType::Generic, "");


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_3D_Polyhedron_Geometry =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_3D_Polyhedron_Geometry", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    double Tolerance1D = double(), double Tolerance2D = double(), double Tolerance3D = double(), Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::MatrixXi Edges = Eigen::MatrixXi(), std::vector<Eigen::MatrixXi> Faces = std::vector<Eigen::MatrixXi>(), std::vector<Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry> Faces_2D_Geometry = std::vector<Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry>(), std::vector<bool> EdgesDirection = std::vector<bool>(), std::vector<bool> FacesDirection = std::vector<bool>(), std::vector<Eigen::Matrix3d> FacesRotationMatrix = std::vector<Eigen::Matrix3d>(), std::vector<Eigen::Vector3d> FacesTranslation = std::vector<Eigen::Vector3d>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry>();
                        r_ctor_->Tolerance1D = Tolerance1D;
                        r_ctor_->Tolerance2D = Tolerance2D;
                        r_ctor_->Tolerance3D = Tolerance3D;
                        r_ctor_->Vertices = Vertices;
                        r_ctor_->Edges = Edges;
                        r_ctor_->Faces = Faces;
                        r_ctor_->Faces_2D_Geometry = Faces_2D_Geometry;
                        r_ctor_->EdgesDirection = EdgesDirection;
                        r_ctor_->FacesDirection = FacesDirection;
                        r_ctor_->FacesRotationMatrix = FacesRotationMatrix;
                        r_ctor_->FacesTranslation = FacesTranslation;
                        return r_ctor_;
                    })
                    , py::arg("tolerance1_d") = double(), py::arg("tolerance2_d") = double(), py::arg("tolerance3_d") = double(), py::arg("vertices") = Eigen::MatrixXd(), py::arg("edges") = Eigen::MatrixXi(), py::arg("faces") = std::vector<Eigen::MatrixXi>(), py::arg("faces_2_d_geometry") = std::vector<Polydim::FEM::PCC::FEM_PCC_2D_Polygon_Geometry>(), py::arg("edges_direction") = std::vector<bool>(), py::arg("faces_direction") = std::vector<bool>(), py::arg("faces_rotation_matrix") = std::vector<Eigen::Matrix3d>(), py::arg("faces_translation") = std::vector<Eigen::Vector3d>()
                    )
                    .def_readwrite("tolerance1_d", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::Tolerance1D, "")
                    .def_readwrite("tolerance2_d", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::Tolerance2D, "")
                    .def_readwrite("tolerance3_d", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::Tolerance3D, "")
                    .def_readwrite("vertices", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::Vertices, "")
                    .def_readwrite("edges", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::Edges, "")
                    .def_readwrite("faces", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::Faces, "")
                    .def_readwrite("faces_2_d_geometry", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::Faces_2D_Geometry, "")
                    .def_readwrite("edges_direction", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::EdgesDirection, "")
                    .def_readwrite("faces_direction", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::FacesDirection, "")
                    .def_readwrite("faces_rotation_matrix", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::FacesRotationMatrix, "")
                    .def_readwrite("faces_translation", &Polydim::FEM::PCC::FEM_PCC_3D_Polyhedron_Geometry::FacesTranslation, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Hexahedron_PCC_3D_LocalSpace_Data =
                    py::class_<Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Hexahedron_PCC_3D_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::MapParallelepiped::MapParallelepipedData MapDataParallelepiped = Gedim::MapParallelepiped::MapParallelepipedData(), Gedim::MapHexahedron::MapHexahedronData MapDataHexahedron = Gedim::MapHexahedron::MapHexahedronData(), Eigen::MatrixXd Dofs = Eigen::MatrixXd(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), Polydim::FEM::PCC::HexahedronType hexahedron_type = Polydim::FEM::PCC::HexahedronType())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data>();
                        r_ctor_->MapDataParallelepiped = MapDataParallelepiped;
                        r_ctor_->MapDataHexahedron = MapDataHexahedron;
                        r_ctor_->Dofs = Dofs;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->hexahedron_type = hexahedron_type;
                        return r_ctor_;
                    })
                    , py::arg("map_data_parallelepiped") = Gedim::MapParallelepiped::MapParallelepipedData(), py::arg("map_data_hexahedron") = Gedim::MapHexahedron::MapHexahedronData(), py::arg("dofs") = Eigen::MatrixXd(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("hexahedron_type") = Polydim::FEM::PCC::HexahedronType()
                    )
                    .def_readwrite("map_data_parallelepiped", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::MapDataParallelepiped, "")
                    .def_readwrite("map_data_hexahedron", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::MapDataHexahedron, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::Order, "")
                    .def_readwrite("number_of_basis_functions", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::NumberOfBasisFunctions, "")
                    .def_readwrite("dofs", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::Dofs, "")
                    .def_readwrite("polyhedron_to_reference_edge_index", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::polyhedron_to_reference_edge_index, "")
                    .def_readwrite("polyhedron_to_reference_edge_direction", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::polyhedron_to_reference_edge_direction, "")
                    .def_readwrite("polyhedron_to_reference_face_index", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::polyhedron_to_reference_face_index, "")
                    .def_readwrite("dofs_mesh_order", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::DofsMeshOrder, "")
                    .def_readwrite("dof0_ds_index", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::Dof0DsIndex, "")
                    .def_readwrite("dof1_ds_index", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::Dof1DsIndex, "")
                    .def_readwrite("dof2_ds_index", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::Dof2DsIndex, "")
                    .def_readwrite("dof3_ds_index", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::Dof3DsIndex, "")
                    .def_readwrite("internal_quadrature", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_local_space_data", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::Boundary_LocalSpace_Data, "")
                    .def_readwrite("boundary_quadrature", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("hexahedron_type", &Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data::hexahedron_type, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_Tetrahedron_PCC_3D_LocalSpace_Data =
                    py::class_<Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_Tetrahedron_PCC_3D_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Gedim::MapTetrahedron::MapTetrahedronData MapData = Gedim::MapTetrahedron::MapTetrahedronData(), Eigen::MatrixXd Dofs = Eigen::MatrixXd(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data>();
                        r_ctor_->MapData = MapData;
                        r_ctor_->Dofs = Dofs;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        return r_ctor_;
                    })
                    , py::arg("map_data") = Gedim::MapTetrahedron::MapTetrahedronData(), py::arg("dofs") = Eigen::MatrixXd(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData()
                    )
                    .def_readwrite("map_data", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::MapData, "")
                    .def_readwrite("order", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::Order, "")
                    .def_readwrite("number_of_basis_functions", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::NumberOfBasisFunctions, "")
                    .def_readwrite("dofs", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::Dofs, "")
                    .def_readwrite("polyhedron_to_reference_edge_index", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::polyhedron_to_reference_edge_index, "")
                    .def_readwrite("polyhedron_to_reference_edge_direction", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::polyhedron_to_reference_edge_direction, "")
                    .def_readwrite("polyhedron_to_reference_face_index", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::polyhedron_to_reference_face_index, "")
                    .def_readwrite("polyhedron_to_reference_face_direction", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::polyhedron_to_reference_face_direction, "")
                    .def_readwrite("polyhedron_to_reference_face_starting_index", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::polyhedron_to_reference_face_starting_index, "")
                    .def_readwrite("dofs_mesh_order", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::DofsMeshOrder, "")
                    .def_readwrite("dof0_ds_index", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::Dof0DsIndex, "")
                    .def_readwrite("dof1_ds_index", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::Dof1DsIndex, "")
                    .def_readwrite("dof2_ds_index", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::Dof2DsIndex, "")
                    .def_readwrite("dof3_ds_index", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::Dof3DsIndex, "")
                    .def_readwrite("internal_quadrature", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_local_space_data", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::Boundary_LocalSpace_Data, "")
                    .def_readwrite("boundary_quadrature", &Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data::BoundaryQuadrature, "")
                    ;


                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_3D_LocalSpace_Data =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_3D_LocalSpace_Data", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data hexahedron_local_space_data = Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data(), Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data tetrahedron_local_space_data = Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data(), Polydim::FEM::PCC::FEM_PCC_3D_Types fem_type = Polydim::FEM::PCC::FEM_PCC_3D_Types(), Gedim::Quadrature::QuadratureData InternalQuadrature = Gedim::Quadrature::QuadratureData(), std::vector<Gedim::Quadrature::QuadratureData> BoundaryQuadrature = std::vector<Gedim::Quadrature::QuadratureData>())
                    {
                        auto r_ctor_ = std::make_unique<Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data>();
                        r_ctor_->hexahedron_local_space_data = hexahedron_local_space_data;
                        r_ctor_->tetrahedron_local_space_data = tetrahedron_local_space_data;
                        r_ctor_->fem_type = fem_type;
                        r_ctor_->InternalQuadrature = InternalQuadrature;
                        r_ctor_->BoundaryQuadrature = BoundaryQuadrature;
                        return r_ctor_;
                    })
                    , py::arg("hexahedron_local_space_data") = Polydim::FEM::PCC::FEM_Hexahedron_PCC_3D_LocalSpace_Data(), py::arg("tetrahedron_local_space_data") = Polydim::FEM::PCC::FEM_Tetrahedron_PCC_3D_LocalSpace_Data(), py::arg("fem_type") = Polydim::FEM::PCC::FEM_PCC_3D_Types(), py::arg("internal_quadrature") = Gedim::Quadrature::QuadratureData(), py::arg("boundary_quadrature") = std::vector<Gedim::Quadrature::QuadratureData>()
                    )
                    .def_readwrite("hexahedron_local_space_data", &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data::hexahedron_local_space_data, "")
                    .def_readwrite("tetrahedron_local_space_data", &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data::tetrahedron_local_space_data, "")
                    .def_readwrite("fem_type", &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data::fem_type, "")
                    .def_readwrite("internal_quadrature", &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data::InternalQuadrature, "")
                    .def_readwrite("boundary_quadrature", &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data::BoundaryQuadrature, "")
                    .def_readwrite("number_of_basis_functions", &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data::NumberOfBasisFunctions, "")
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_PCC_3D_LocalSpace_Data.hpp>    ////////////////////


    ////////////////////    <generated_from:FEM_PCC_3D_LocalSpace.hpp>    ////////////////////
    // #ifndef __FEM_PCC_3D_LocalSpace_HPP
    //
    // #endif
    //

    { // <namespace Polydim>
        py::module_ pyNsPolydim = m.def_submodule("polydim", "namespace Polydim");
        { // <namespace FEM>
            py::module_ pyNsPolydim_NsFEM = pyNsPolydim.def_submodule("fem", "namespace FEM");
            { // <namespace PCC>
                py::module_ pyNsPolydim_NsFEM_NsPCC = pyNsPolydim_NsFEM.def_submodule("pcc", "namespace PCC");
                auto pyNsPolydim_NsFEM_NsPCC_ClassFEM_PCC_3D_LocalSpace =
                    py::class_<Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace>
                        (pyNsPolydim_NsFEM_NsPCC, "FEM_PCC_3D_LocalSpace", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def("create_local_space",
                        &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::CreateLocalSpace, py::arg("reference_element_data"), py::arg("polyhedron"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data &>(&Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"))
                    .def("compute_basis_functions_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::ComputeBasisFunctionsValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_derivative_values",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data &, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::ComputeBasisFunctionsDerivativeValues, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("points"))
                    .def("compute_basis_functions_values_on_face",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data &, const unsigned int>(&Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnFace, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_index"))
                    .def("compute_basis_functions_values_on_face",
                        py::overload_cast<const Polydim::FEM::PCC::FEM_PCC_3D_ReferenceElement_Data &, const Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace_Data &, const unsigned int, const Eigen::MatrixXd &>(&Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnFace, py::const_), py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_index"), py::arg("points2_d"))
                    .def("face_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::FaceDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("face_local_index"))
                    .def("edge_do_fs_coordinates",
                        &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::EdgeDOFsCoordinates, py::arg("reference_element_data"), py::arg("local_space"), py::arg("edge_local_index"))
                    .def("compute_basis_functions_values_on_edge",
                        &Polydim::FEM::PCC::FEM_PCC_3D_LocalSpace::ComputeBasisFunctionsValuesOnEdge, py::arg("reference_element_data"), py::arg("local_space"), py::arg("points_curvilinear_coordinates"))
                    ;
            } // </namespace PCC>

        } // </namespace FEM>

    } // </namespace Polydim>
    ////////////////////    </generated_from:FEM_PCC_3D_LocalSpace.hpp>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_glue_code>  // Autogenerated code below! Do not edit!

    // </litgen_glue_code> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}
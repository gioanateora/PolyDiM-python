#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/functional.h>
#include <pybind11/numpy.h>

// Include PolyDiM headers
#include "all_includes.hpp"

namespace py = pybind11;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// <litgen_glue_code>  // Autogenerated code below! Do not edit!

// </litgen_glue_code> // Autogenerated code end
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// You can add any code here
void py_init_module_polypy(py::module &m);

PYBIND11_MODULE(polypy, m)
{
    m.doc() = "PolyDiM library for python";

    py_init_module_polypy(m);
}

void py_init_module_polypy(py::module &m) //  rename this function name!!!
{
    // You can add any code here

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // <litgen_pydef> // Autogenerated code below! Do not edit!
    ////////////////////    <generated_from:GeometryUtilities.hpp>    ////////////////////
    // #ifndef __GEOMETRYUTILITIES_H
    //
    // #endif

    { // <namespace Gedim>
        py::module_ pyNsGedim = m.def_submodule("gedim", "namespace Gedim");
        auto pyNsGedim_ClassGeometryUtilitiesConfig =
            py::class_<Gedim::GeometryUtilitiesConfig>
                (pyNsGedim, "GeometryUtilitiesConfig", py::is_final(), "\n(final class)")
            .def(py::init<>([](
            double MinTolerance = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance(), double Tolerance1D = Gedim::GeometryUtilitiesConfig::MinTolerance, double Tolerance2D = Gedim::GeometryUtilitiesConfig::MinTolerance, double Tolerance3D = Gedim::GeometryUtilitiesConfig::MinTolerance)
            {
                auto r_ctor_ = std::make_unique<Gedim::GeometryUtilitiesConfig>();
                r_ctor_->MinTolerance = MinTolerance;
                r_ctor_->Tolerance1D = Tolerance1D;
                r_ctor_->Tolerance2D = Tolerance2D;
                r_ctor_->Tolerance3D = Tolerance3D;
                return r_ctor_;
            })
            , py::arg("min_tolerance") = Gedim::GeometryUtilitiesConfig::DefaultMinTolerance(), py::arg("tolerance1_d") = Gedim::GeometryUtilitiesConfig::MinTolerance, py::arg("tolerance2_d") = Gedim::GeometryUtilitiesConfig::MinTolerance, py::arg("tolerance3_d") = Gedim::GeometryUtilitiesConfig::MinTolerance
            )
            .def_static("default_min_tolerance",
                &Gedim::GeometryUtilitiesConfig::DefaultMinTolerance)
            .def_readwrite("min_tolerance", &Gedim::GeometryUtilitiesConfig::MinTolerance, "")
            .def_readwrite("tolerance1_d", &Gedim::GeometryUtilitiesConfig::Tolerance1D, "")
            .def_readwrite("tolerance2_d", &Gedim::GeometryUtilitiesConfig::Tolerance2D, "")
            .def_readwrite("tolerance3_d", &Gedim::GeometryUtilitiesConfig::Tolerance3D, "")
            ;


        auto pyNsGedim_ClassGeometryUtilities =
            py::class_<Gedim::GeometryUtilities>
                (pyNsGedim, "GeometryUtilities", py::is_final(), "/ \\brief The GeometryUtilities class intersects 3D segments\n(final class)");

        { // inner classes & enums of GeometryUtilities
            auto pyEnumCompareTypes =
                py::enum_<Gedim::GeometryUtilities::CompareTypes>(pyNsGedim_ClassGeometryUtilities, "CompareTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::CompareTypes::Unknown, "")
                    .value("first_before_second", Gedim::GeometryUtilities::CompareTypes::FirstBeforeSecond, "")
                    .value("coincident", Gedim::GeometryUtilities::CompareTypes::Coincident, "")
                    .value("second_before_first", Gedim::GeometryUtilities::CompareTypes::SecondBeforeFirst, "");
            auto pyEnumPolygonTypes =
                py::enum_<Gedim::GeometryUtilities::PolygonTypes>(pyNsGedim_ClassGeometryUtilities, "PolygonTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PolygonTypes::Unknown, "")
                    .value("triangle", Gedim::GeometryUtilities::PolygonTypes::Triangle, "")
                    .value("quadrilateral_convex", Gedim::GeometryUtilities::PolygonTypes::Quadrilateral_Convex, "")
                    .value("quadrilateral_concave", Gedim::GeometryUtilities::PolygonTypes::Quadrilateral_Concave, "")
                    .value("generic_convex", Gedim::GeometryUtilities::PolygonTypes::Generic_Convex, "")
                    .value("generic_concave", Gedim::GeometryUtilities::PolygonTypes::Generic_Concave, "");
            auto pyEnumPolygonOrientations =
                py::enum_<Gedim::GeometryUtilities::PolygonOrientations>(pyNsGedim_ClassGeometryUtilities, "PolygonOrientations", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PolygonOrientations::Unknown, "")
                    .value("clockwise", Gedim::GeometryUtilities::PolygonOrientations::Clockwise, "")
                    .value("counter_clockwise", Gedim::GeometryUtilities::PolygonOrientations::CounterClockwise, "");
            auto pyEnumPointSegmentPositionTypes =
                py::enum_<Gedim::GeometryUtilities::PointSegmentPositionTypes>(pyNsGedim_ClassGeometryUtilities, "PointSegmentPositionTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PointSegmentPositionTypes::Unknown, "")
                    .value("on_segment_line_before_origin", Gedim::GeometryUtilities::PointSegmentPositionTypes::OnSegmentLineBeforeOrigin, "")
                    .value("on_segment_origin", Gedim::GeometryUtilities::PointSegmentPositionTypes::OnSegmentOrigin, "")
                    .value("inside_segment", Gedim::GeometryUtilities::PointSegmentPositionTypes::InsideSegment, "")
                    .value("on_segment_end", Gedim::GeometryUtilities::PointSegmentPositionTypes::OnSegmentEnd, "")
                    .value("on_segment_line_after_end", Gedim::GeometryUtilities::PointSegmentPositionTypes::OnSegmentLineAfterEnd, "")
                    .value("left_the_segment", Gedim::GeometryUtilities::PointSegmentPositionTypes::LeftTheSegment, "")
                    .value("right_the_segment", Gedim::GeometryUtilities::PointSegmentPositionTypes::RightTheSegment, "");
            auto pyEnumPointPlanePositionTypes =
                py::enum_<Gedim::GeometryUtilities::PointPlanePositionTypes>(pyNsGedim_ClassGeometryUtilities, "PointPlanePositionTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PointPlanePositionTypes::Unknown, "")
                    .value("negative", Gedim::GeometryUtilities::PointPlanePositionTypes::Negative, "")
                    .value("on_plane", Gedim::GeometryUtilities::PointPlanePositionTypes::OnPlane, "")
                    .value("positive", Gedim::GeometryUtilities::PointPlanePositionTypes::Positive, "");
            auto pyEnumPolygonCirclePositionTypes =
                py::enum_<Gedim::GeometryUtilities::PolygonCirclePositionTypes>(pyNsGedim_ClassGeometryUtilities, "PolygonCirclePositionTypes", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PolygonCirclePositionTypes::Unknown, "")
                    .value("polygon_outside_circle_no_intersection", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonOutsideCircleNoIntersection, "")
                    .value("polygon_outside_circle_one_intersection_on_vertex", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonOutsideCircleOneIntersectionOnVertex, "")
                    .value("polygon_outside_circle_one_intersection_tangent_on_edge", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonOutsideCircleOneIntersectionTangentOnEdge, "")
                    .value("circle_inside_polygon_no_intersection", Gedim::GeometryUtilities::PolygonCirclePositionTypes::CircleInsidePolygonNoIntersection, "")
                    .value("circle_inside_polygon_one_intersection_tangent_on_edge", Gedim::GeometryUtilities::PolygonCirclePositionTypes::CircleInsidePolygonOneIntersectionTangentOnEdge, "")
                    .value("polygon_inside_circle_no_intersection", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonInsideCircleNoIntersection, "")
                    .value("polygon_inside_circle_one_vertex_intersection", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonInsideCircleOneVertexIntersection, "")
                    .value("polygon_inside_circle_intersection_only_on_vertices", Gedim::GeometryUtilities::PolygonCirclePositionTypes::PolygonInsideCircleIntersectionOnlyOnVertices, "")
                    .value("circle_polygon_multiple_intersections", Gedim::GeometryUtilities::PolygonCirclePositionTypes::CirclePolygonMultipleIntersections, "");
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult =
                py::class_<Gedim::GeometryUtilities::IntersectionPolygonCircleResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionPolygonCircleResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionPolygonCircleResult
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult_ClassIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult, "Intersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of Intersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult_ClassIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types::Unknown, "")
                            .value("secant", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types::Secant, "")
                            .value("tangent", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Types::Tangent, "");
                    auto pyEnumIndexTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult_ClassIntersection, "IndexTypes", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes::Unknown, "")
                            .value("vertex", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes::Vertex, "")
                            .value("edge", Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexTypes::Edge, "");
                } // end of inner classes & enums of Intersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult_ClassIntersection
                    .def(py::init<>([](
                    Types Type = Types::Unknown, IndexTypes IndexType = IndexTypes::Unknown, double CurvilinearCoordinate = double())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection>();
                        r_ctor_->Type = Type;
                        r_ctor_->IndexType = IndexType;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = Intersection::Types::Unknown, py::arg("index_type") = Intersection::IndexTypes::Unknown, py::arg("curvilinear_coordinate") = double()
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Type, "")
                    .def_readwrite("index_type", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::IndexType, "")
                    .def_readwrite("index", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::Index, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersection::CurvilinearCoordinate, "/< Valid only in IndexType Edge")
                    ;
            } // end of inner classes & enums of IntersectionPolygonCircleResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolygonCircleResult
                .def(py::init<>([](
                std::vector<Intersection> Intersections = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolygonCircleResult>();
                    r_ctor_->Intersections = Intersections;
                    return r_ctor_;
                })
                , py::arg("intersections") = std::vector<Intersection>{}
                )
                .def_readwrite("intersections", &Gedim::GeometryUtilities::IntersectionPolygonCircleResult::Intersections, "/< ordered by edge order")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassPolygonDivisionByAngleQuadrantResult =
                py::class_<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult>
                    (pyNsGedim_ClassGeometryUtilities, "PolygonDivisionByAngleQuadrantResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of PolygonDivisionByAngleQuadrantResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassPolygonDivisionByAngleQuadrantResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types::Unknown, "")
                        .value("external_origin", Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types::ExternalOrigin, "")
                        .value("internal", Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types::Internal, "")
                        .value("external_end", Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Types::ExternalEnd, "");
            } // end of inner classes & enums of PolygonDivisionByAngleQuadrantResult

            pyNsGedim_ClassGeometryUtilities_ClassPolygonDivisionByAngleQuadrantResult
                .def(py::init<>([](
                Eigen::MatrixXd Points = Eigen::MatrixXd(), std::vector<Types> SubPolygonTypes = std::vector<Types>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult>();
                    r_ctor_->Points = Points;
                    r_ctor_->SubPolygonTypes = SubPolygonTypes;
                    return r_ctor_;
                })
                , py::arg("points") = Eigen::MatrixXd(), py::arg("sub_polygon_types") = std::vector<Types>()
                )
                .def_readwrite("points", &Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::Points, "/< Coordinates of generated points")
                .def_readwrite("sub_polygons", &Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::SubPolygons, "/< Subpolygon formed")
                .def_readwrite("sub_polygon_types", &Gedim::GeometryUtilities::PolygonDivisionByAngleQuadrantResult::SubPolygonTypes, "/< SubPolygon types")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassPolygonDivisionByCircleResult =
                py::class_<Gedim::GeometryUtilities::PolygonDivisionByCircleResult>
                    (pyNsGedim_ClassGeometryUtilities, "PolygonDivisionByCircleResult", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd Points = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::PolygonDivisionByCircleResult>();
                    r_ctor_->Points = Points;
                    return r_ctor_;
                })
                , py::arg("points") = Eigen::MatrixXd()
                )
                .def_readwrite("points", &Gedim::GeometryUtilities::PolygonDivisionByCircleResult::Points, "/< Coordinates of generated points")
                .def_readwrite("sub_triangles", &Gedim::GeometryUtilities::PolygonDivisionByCircleResult::SubTriangles, "/< Triangle formed with sub-polygons and circle Center")
                .def_readwrite("internal_triangles", &Gedim::GeometryUtilities::PolygonDivisionByCircleResult::InternalTriangles, "/< Triangle formed with circle Center and new points")
                .def_readwrite("sub_polygons", &Gedim::GeometryUtilities::PolygonDivisionByCircleResult::SubPolygons, "/< Subpolygon formed")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassCircleDivisionByPolygonResult =
                py::class_<Gedim::GeometryUtilities::CircleDivisionByPolygonResult>
                    (pyNsGedim_ClassGeometryUtilities, "CircleDivisionByPolygonResult", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd Points = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::CircleDivisionByPolygonResult>();
                    r_ctor_->Points = Points;
                    return r_ctor_;
                })
                , py::arg("points") = Eigen::MatrixXd()
                )
                .def_readwrite("points", &Gedim::GeometryUtilities::CircleDivisionByPolygonResult::Points, "/< Coordinates of generated points")
                .def_readwrite("sub_triangles", &Gedim::GeometryUtilities::CircleDivisionByPolygonResult::SubTriangles, "/< Triangle formed with sub-polygons and circle Center")
                .def_readwrite("internal_triangles", &Gedim::GeometryUtilities::CircleDivisionByPolygonResult::InternalTriangles, "/< Triangle formed with circle Center and new points")
                .def_readwrite("sub_polygons", &Gedim::GeometryUtilities::CircleDivisionByPolygonResult::SubPolygons, "/< Subpolygon formed")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput =
                py::class_<Gedim::GeometryUtilities::SplitPolygonInput>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolygonInput", py::is_final(), "\n(final class)");

            { // inner classes & enums of SplitPolygonInput
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassAlignedEdge =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput, "AlignedEdge", "")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("origin_vertex_index", &Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge::OriginVertexIndex, "")
                    .def_readwrite("end_vertex_index", &Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdge::EndVertexIndex, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput, "SplitSegment", "");

                { // inner classes & enums of SplitSegment
                    auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment_ClassVertex =
                        py::class_<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex>
                            (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment, "Vertex", py::is_final(), "\n(final class)");

                    { // inner classes & enums of Vertex
                        auto pyEnumTypes =
                            py::enum_<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment_ClassVertex, "Types", py::arithmetic(), "")
                                .value("unknown", Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types::Unknown, "")
                                .value("vertex", Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types::Vertex, "")
                                .value("edge", Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Types::Edge, "");
                    } // end of inner classes & enums of Vertex

                    pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment_ClassVertex
                        .def(py::init<>([](
                        Types Type = Types())
                        {
                            auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex>();
                            r_ctor_->Type = Type;
                            return r_ctor_;
                        })
                        , py::arg("type") = Types()
                        )
                        .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Type, "")
                        .def_readwrite("index", &Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Vertex::Index, "")
                        ;
                } // end of inner classes & enums of SplitSegment

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput_ClassSplitSegment
                    .def(py::init<>([](
                    Vertex Origin = Vertex(), Vertex End = Vertex())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment>();
                        r_ctor_->Origin = Origin;
                        r_ctor_->End = End;
                        return r_ctor_;
                    })
                    , py::arg("origin") = Vertex(), py::arg("end") = Vertex()
                    )
                    .def_readwrite("origin", &Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::Origin, "")
                    .def_readwrite("end", &Gedim::GeometryUtilities::SplitPolygonInput::SplitSegment::End, "")
                    ;
            } // end of inner classes & enums of SplitPolygonInput

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonInput
                .def(py::init<>([](
                std::vector<AlignedEdge> AlignedEdges = std::vector<AlignedEdge>(), SplitSegment Segment = SplitSegment())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonInput>();
                    r_ctor_->AlignedEdges = AlignedEdges;
                    r_ctor_->Segment = Segment;
                    return r_ctor_;
                })
                , py::arg("aligned_edges") = std::vector<AlignedEdge>(), py::arg("segment") = SplitSegment()
                )
                .def_readwrite("number_polygon_vertices", &Gedim::GeometryUtilities::SplitPolygonInput::NumberPolygonVertices, "")
                .def_readwrite("aligned_edges", &Gedim::GeometryUtilities::SplitPolygonInput::AlignedEdges, "")
                .def_readwrite("segment", &Gedim::GeometryUtilities::SplitPolygonInput::Segment, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult =
                py::class_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolygonWithSegmentResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of SplitPolygonWithSegmentResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::Unknown, "")
                        .value("no_action", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::NoAction, "")
                        .value("polygon_update", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::PolygonUpdate, "")
                        .value("polygon_creation", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Types::PolygonCreation, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewVertex =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult, "NewVertex", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewVertex
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewVertex, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types::Unknown, "")
                            .value("segment_origin", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types::SegmentOrigin, "")
                            .value("segment_end", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Types::SegmentEnd, "");
                } // end of inner classes & enums of NewVertex

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewVertex
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = NewVertex::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertex::Type, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewEdge =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult, "NewEdge", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewEdge
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewEdge, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types::Unknown, "")
                            .value("edge_new", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types::EdgeNew, "")
                            .value("edge_update", Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Types::EdgeUpdate, "");
                } // end of inner classes & enums of NewEdge

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewEdge
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = NewEdge::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Type, "")
                    .def_readwrite("old_edge_id", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::OldEdgeId, "")
                    .def_readwrite("origin_id", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::OriginId, "")
                    .def_readwrite("end_id", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::EndId, "")
                    .def_readwrite("cell2_d_neighbours", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdge::Cell2DNeighbours, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult_ClassNewPolygon =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygon>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult, "NewPolygon", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygon::Vertices, "")
                    .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygon::Edges, "")
                    ;
            } // end of inner classes & enums of SplitPolygonWithSegmentResult

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithSegmentResult
                .def(py::init<>([](
                Types Type = Types::Unknown, std::list<NewVertex> NewVertices = {}, std::list<NewEdge> NewEdges = {}, std::vector<NewPolygon> NewPolygons = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithSegmentResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->NewVertices = NewVertices;
                    r_ctor_->NewEdges = NewEdges;
                    r_ctor_->NewPolygons = NewPolygons;
                    return r_ctor_;
                })
                , py::arg("type") = SplitPolygonWithSegmentResult::Types::Unknown, py::arg("new_vertices") = std::list<NewVertex>{}, py::arg("new_edges") = std::list<NewEdge>{}, py::arg("new_polygons") = std::vector<NewPolygon>{}
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::Type, "")
                .def_readwrite("new_vertices", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewVertices, "")
                .def_readwrite("new_edges", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewEdges, "")
                .def_readwrite("new_polygons", &Gedim::GeometryUtilities::SplitPolygonWithSegmentResult::NewPolygons, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult =
                py::class_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolygonWithCircleResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of SplitPolygonWithCircleResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::Unknown, "")
                        .value("no_action", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::NoAction, "")
                        .value("polygon_update", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::PolygonUpdate, "")
                        .value("polygon_creation", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Types::PolygonCreation, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewVertex =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult, "NewVertex", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewVertex
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewVertex, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::Unknown, "")
                            .value("polygon_vertex", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::PolygonVertex, "")
                            .value("circle_intersection", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::CircleIntersection, "")
                            .value("both", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Types::Both, "");
                } // end of inner classes & enums of NewVertex

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewVertex
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = NewVertex::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::Type, "")
                    .def_readwrite("polygon_index", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::PolygonIndex, "/< Index in polygon vertices")
                    .def_readwrite("intersection_index", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertex::IntersectionIndex, "/< Index in circle intersections")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewEdge =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult, "NewEdge", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewEdge
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewEdge, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types::Unknown, "")
                            .value("segment", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types::Segment, "")
                            .value("arc", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Types::Arc, "");
                    auto pyEnumArcTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewEdge, "ArcTypes", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes::Unknown, "")
                            .value("inside_polygon", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes::InsidePolygon, "")
                            .value("outside_polygon", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcTypes::OutsidePolygon, "");
                } // end of inner classes & enums of NewEdge

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewEdge
                    .def(py::init<>([](
                    Types Type = Types::Unknown, ArcTypes ArcType = ArcTypes::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge>();
                        r_ctor_->Type = Type;
                        r_ctor_->ArcType = ArcType;
                        return r_ctor_;
                    })
                    , py::arg("type") = NewEdge::Types::Unknown, py::arg("arc_type") = NewEdge::ArcTypes::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::Type, "")
                    .def_readwrite("arc_type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::ArcType, "/< Valid only if Type is Arc")
                    .def_readwrite("vertex_indices", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::VertexIndices, "/< Index of vertices in NewVertices")
                    .def_readwrite("polygon_index", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdge::PolygonIndex, "/< Index of Edge in polygon intersections")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewPolygon =
                    py::class_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult, "NewPolygon", py::is_final(), "\n(final class)");

                { // inner classes & enums of NewPolygon
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewPolygon, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::Unknown, "")
                            .value("inside_only_circle", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::InsideOnlyCircle, "")
                            .value("inside_only_polygon", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::InsideOnlyPolygon, "")
                            .value("inside_circle_and_polygon", Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Types::InsideCircleAndPolygon, "");
                } // end of inner classes & enums of NewPolygon

                pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult_ClassNewPolygon
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = NewPolygon::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Type, "")
                    .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Vertices, "")
                    .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygon::Edges, "")
                    ;
            } // end of inner classes & enums of SplitPolygonWithCircleResult

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithCircleResult
                .def(py::init<>([](
                Types Type = Types::Unknown, std::vector<NewVertex> NewVertices = {}, std::vector<NewEdge> NewEdges = {}, std::vector<NewPolygon> NewPolygons = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithCircleResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->NewVertices = NewVertices;
                    r_ctor_->NewEdges = NewEdges;
                    r_ctor_->NewPolygons = NewPolygons;
                    return r_ctor_;
                })
                , py::arg("type") = SplitPolygonWithCircleResult::Types::Unknown, py::arg("new_vertices") = std::vector<NewVertex>{}, py::arg("new_edges") = std::vector<NewEdge>{}, py::arg("new_polygons") = std::vector<NewPolygon>{}
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::Type, "")
                .def_readwrite("polygon_vertices_new_vertices_position", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::PolygonVerticesNewVerticesPosition, "")
                .def_readwrite("circle_intersections_new_vertices_position", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::CircleIntersectionsNewVerticesPosition, "")
                .def_readwrite("new_vertices", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewVertices, "")
                .def_readwrite("new_edges", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewEdges, "")
                .def_readwrite("new_polygons", &Gedim::GeometryUtilities::SplitPolygonWithCircleResult::NewPolygons, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult =
                py::class_<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionSegmentSegmentResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionSegmentSegmentResult
                auto pyEnumIntersectionLineTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult, "IntersectionLineTypes", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::Unknown, "")
                        .value("on_different_planes", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::OnDifferentPlanes, "")
                        .value("co_planar_parallel", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::CoPlanarParallel, "")
                        .value("co_planar_intersecting", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLineTypes::CoPlanarIntersecting, "");
                auto pyEnumIntersectionSegmentTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult, "IntersectionSegmentTypes", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::Unknown, "")
                        .value("no_intersection", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::NoIntersection, "")
                        .value("single_intersection", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::SingleIntersection, "")
                        .value("multiple_intersections", Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentTypes::MultipleIntersections, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult_ClassIntersectionPosition =
                    py::class_<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult, "IntersectionPosition", "")
                    .def(py::init<>([](
                    PointSegmentPositionTypes Type = PointSegmentPositionTypes::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition>();
                        r_ctor_->Type = Type;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = PointSegmentPositionTypes::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition::Type, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionPosition::CurvilinearCoordinate, "")
                    ;
            } // end of inner classes & enums of IntersectionSegmentSegmentResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentSegmentResult
                .def(py::init<>([](
                IntersectionLineTypes IntersectionLinesType = IntersectionLineTypes::Unknown, IntersectionSegmentTypes IntersectionSegmentsType = IntersectionSegmentTypes::Unknown, std::vector<IntersectionPosition> FirstSegmentIntersections = std::vector<IntersectionPosition>(), std::vector<IntersectionPosition> SecondSegmentIntersections = std::vector<IntersectionPosition>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentSegmentResult>();
                    r_ctor_->IntersectionLinesType = IntersectionLinesType;
                    r_ctor_->IntersectionSegmentsType = IntersectionSegmentsType;
                    r_ctor_->FirstSegmentIntersections = FirstSegmentIntersections;
                    r_ctor_->SecondSegmentIntersections = SecondSegmentIntersections;
                    return r_ctor_;
                })
                , py::arg("intersection_lines_type") = IntersectionSegmentSegmentResult::IntersectionLineTypes::Unknown, py::arg("intersection_segments_type") = IntersectionSegmentSegmentResult::IntersectionSegmentTypes::Unknown, py::arg("first_segment_intersections") = std::vector<IntersectionPosition>(), py::arg("second_segment_intersections") = std::vector<IntersectionPosition>()
                )
                .def_readwrite("intersection_lines_type", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionLinesType, "")
                .def_readwrite("intersection_segments_type", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::IntersectionSegmentsType, "")
                .def_readwrite("second_intersection_relation", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::SecondIntersectionRelation, "/ \\brief relation between first and second intersection.\n/ Values are the indeces of the SecondSegmentIntersections vector respect the FirstSegmentIntersections vector\n/ \\example in MultipleIntersection case, if SecondIntersectionRelation[0] = 1,\n/ then the second intersection point SecondSegmentIntersections[1] is equal to FirstSegmentIntersections[0]\n/ point")
                .def_readwrite("first_segment_intersections", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::FirstSegmentIntersections, "/ \\brief intersections of the first segment,\n/ \note if multiple intersections are found, than the origin and the end coordinate are stored")
                .def_readwrite("second_segment_intersections", &Gedim::GeometryUtilities::IntersectionSegmentSegmentResult::SecondSegmentIntersections, "/ intersections of the second segment")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult =
                py::class_<Gedim::GeometryUtilities::IntersectionSegmentCircleResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionSegmentCircleResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionSegmentCircleResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::Unknown, "")
                        .value("no_intersection", Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::NoIntersection, "")
                        .value("tangent_intersection", Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::TangentIntersection, "")
                        .value("two_intersections", Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Types::TwoIntersections, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult_ClassIntersectionPosition =
                    py::class_<Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult, "IntersectionPosition", "")
                    .def(py::init<>([](
                    PointSegmentPositionTypes Type = PointSegmentPositionTypes::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition>();
                        r_ctor_->Type = Type;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = PointSegmentPositionTypes::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition::Type, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionSegmentCircleResult::IntersectionPosition::CurvilinearCoordinate, "")
                    ;
            } // end of inner classes & enums of IntersectionSegmentCircleResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentCircleResult
                .def(py::init<>([](
                Types Type = Types::Unknown, std::vector<IntersectionPosition> SegmentIntersections = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentCircleResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->SegmentIntersections = SegmentIntersections;
                    return r_ctor_;
                })
                , py::arg("type") = IntersectionSegmentCircleResult::Types::Unknown, py::arg("segment_intersections") = std::vector<IntersectionPosition>{}
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentCircleResult::Type, "")
                .def_readwrite("segment_intersections", &Gedim::GeometryUtilities::IntersectionSegmentCircleResult::SegmentIntersections, "/ \\brief intersections of the segment,")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult =
                py::class_<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionSegmentPlaneResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionSegmentPlaneResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::Unknown, "")
                        .value("single_intersection", Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::SingleIntersection, "")
                        .value("no_intersection", Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::NoIntersection, "")
                        .value("multiple_intersections", Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Types::MultipleIntersections, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult_ClassIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult, "Intersection", "")
                    .def(py::init<>([](
                    PointSegmentPositionTypes Type = PointSegmentPositionTypes::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection>();
                        r_ctor_->Type = Type;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = PointSegmentPositionTypes::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection::Type, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Intersection::CurvilinearCoordinate, "")
                    ;
            } // end of inner classes & enums of IntersectionSegmentPlaneResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionSegmentPlaneResult
                .def(py::init<>([](
                Types Type = Types::Unknown, Intersection SingleIntersection = Intersection())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionSegmentPlaneResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->SingleIntersection = SingleIntersection;
                    return r_ctor_;
                })
                , py::arg("type") = IntersectionSegmentPlaneResult::Types::Unknown, py::arg("single_intersection") = Intersection()
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::Type, "/< The intersection type")
                .def_readwrite("single_intersection", &Gedim::GeometryUtilities::IntersectionSegmentPlaneResult::SingleIntersection, "/< The single intersection, available only is Type is SingleIntersection")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult =
                py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionPolyhedronLineResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionPolyhedronLineResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::Unknown, "")
                        .value("none", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::None, "/< No intersection found")
                        .value("one_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::OneIntersection, "/< One intersection found")
                        .value("two_intersections", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::TwoIntersections, "/< Two intersection found")
                        .value("multiple_intersections", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Types::MultipleIntersections, "/< Multiple intersection found");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronFaceIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "PolyhedronFaceIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of PolyhedronFaceIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronFaceIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of PolyhedronFaceIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronFaceIntersection
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = PolyhedronFaceIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::Type, "")
                    .def_readwrite("line_intersection_index", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersection::LineIntersectionIndex, "/< Index of line intersection collection")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronEdgeIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "PolyhedronEdgeIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of PolyhedronEdgeIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronEdgeIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of PolyhedronEdgeIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronEdgeIntersection
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = PolyhedronEdgeIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::Type, "")
                    .def_readwrite("line_intersection_index", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersection::LineIntersectionIndex, "/< Index of line intersection collection")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronVertexIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "PolyhedronVertexIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of PolyhedronVertexIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronVertexIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of PolyhedronVertexIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassPolyhedronVertexIntersection
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = PolyhedronVertexIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::Type, "")
                    .def_readwrite("line_intersection_index", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersection::LineIntersectionIndex, "/< Index of line intersection collection")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassLineIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult, "LineIntersection", "");

                { // inner classes & enums of LineIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassLineIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::Unknown, "")
                            .value("on_vertex", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::OnVertex, "/< On polyhedron vertex")
                            .value("on_edge", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::OnEdge, "/< On polyhedron edge")
                            .value("on_face", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::OnFace, "/< On polyhedron face")
                            .value("inside", Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::Types::Inside, "/< Inside polyhedron");
                } // end of inner classes & enums of LineIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult_ClassLineIntersection
                    .def(py::init<>([](
                    Types PolyhedronType = Types::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection>();
                        r_ctor_->PolyhedronType = PolyhedronType;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("polyhedron_type") = LineIntersection::Types::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("polyhedron_type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::PolyhedronType, "/< Type of intersection")
                    .def_readwrite("polyhedron_index", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::PolyhedronIndex, "/<  Index of the intersecting element of the Polyhedron (face, edge or")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersection::CurvilinearCoordinate, "/< Curvilinear coordinate in the line")
                    ;
            } // end of inner classes & enums of IntersectionPolyhedronLineResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronLineResult
                .def(py::init<>([](
                Types Type = Types::Unknown, std::vector<LineIntersection> LineIntersections = std::vector<LineIntersection>(), std::vector<PolyhedronVertexIntersection> PolyhedronVertexIntersections = {}, std::vector<PolyhedronEdgeIntersection> PolyhedronEdgeIntersections = {}, std::vector<PolyhedronFaceIntersection> PolyhedronFaceIntersections = {})
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronLineResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->LineIntersections = LineIntersections;
                    r_ctor_->PolyhedronVertexIntersections = PolyhedronVertexIntersections;
                    r_ctor_->PolyhedronEdgeIntersections = PolyhedronEdgeIntersections;
                    r_ctor_->PolyhedronFaceIntersections = PolyhedronFaceIntersections;
                    return r_ctor_;
                })
                , py::arg("type") = IntersectionPolyhedronLineResult::Types::Unknown, py::arg("line_intersections") = std::vector<LineIntersection>(), py::arg("polyhedron_vertex_intersections") = std::vector<PolyhedronVertexIntersection>{}, py::arg("polyhedron_edge_intersections") = std::vector<PolyhedronEdgeIntersection>{}, py::arg("polyhedron_face_intersections") = std::vector<PolyhedronFaceIntersection>{}
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::Type, "/ The")
                .def_readwrite("line_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::LineIntersections, "/< The line intersections")
                .def_readwrite("polyhedron_vertex_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronVertexIntersections, "/< Polyhedron Vertex")
                .def_readwrite("polyhedron_edge_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronEdgeIntersections, "/< Polyhedron Edge intersections,")
                .def_readwrite("polyhedron_face_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronLineResult::PolyhedronFaceIntersections, "/< Polyhedron Face intersections,")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult =
                py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionPolyhedronsSegmentResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionPolyhedronsSegmentResult
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult_ClassIntersectionPoint =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionPoint>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult, "IntersectionPoint", py::is_final(), "\n(final class)")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("cell3_d_indices", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionPoint::Cell3DIndices, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult_ClassIntersectionSegment =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult, "IntersectionSegment", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    std::vector<double> Points = {})
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment>();
                        r_ctor_->Points = Points;
                        return r_ctor_;
                    })
                    , py::arg("points") = std::vector<double>{}
                    )
                    .def_readwrite("points", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment::Points, "")
                    .def_readwrite("cell3_d_indices", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::IntersectionSegment::Cell3DIndices, "")
                    ;
            } // end of inner classes & enums of IntersectionPolyhedronsSegmentResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronsSegmentResult
                .def(py::init<>([](
                std::vector<IntersectionSegment> Segments = std::vector<IntersectionSegment>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult>();
                    r_ctor_->Segments = Segments;
                    return r_ctor_;
                })
                , py::arg("segments") = std::vector<IntersectionSegment>()
                )
                .def_readwrite("points", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::Points, "")
                .def_readwrite("segments", &Gedim::GeometryUtilities::IntersectionPolyhedronsSegmentResult::Segments, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult =
                py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult>
                    (pyNsGedim_ClassGeometryUtilities, "IntersectionPolyhedronPlaneResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of IntersectionPolyhedronPlaneResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::Unknown, "")
                        .value("none", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::None, "/< No intersection found")
                        .value("on_vertex", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::OnVertex, "/< On polyhedron vertex")
                        .value("on_edge", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::OnEdge, "/< On polyhedron edge")
                        .value("on_face", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::OnFace, "/< On polyhedron face")
                        .value("new_polygon", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Types::NewPolygon, "/< New polygon intersection");
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassFaceIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "FaceIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of FaceIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassFaceIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of FaceIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassFaceIntersection
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = FaceIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersection::Type, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassEdgeIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "EdgeIntersection", py::is_final(), "\n(final class)")
                    .def(py::init<>([](
                    IntersectionSegmentPlaneResult Intersection = IntersectionSegmentPlaneResult())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersection>();
                        r_ctor_->Intersection = Intersection;
                        return r_ctor_;
                    })
                    , py::arg("intersection") = IntersectionSegmentPlaneResult()
                    )
                    .def_readwrite("intersection", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersection::Intersection, "/< Intersection between edge and plane")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassVertexIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "VertexIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of VertexIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassVertexIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types::Unknown, "")
                            .value("intersection", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types::Intersection, "")
                            .value("no_intersection", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Types::NoIntersection, "");
                } // end of inner classes & enums of VertexIntersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassVertexIntersection
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = VertexIntersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersection::Type, "")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassIntersection =
                    py::class_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult, "Intersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of Intersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types::Unknown, "")
                            .value("vertex", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types::Vertex, "")
                            .value("edge", Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Types::Edge, "");
                } // end of inner classes & enums of Intersection

                pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult_ClassIntersection
                    .def(py::init<>([](
                    Types Type = Types::Unknown)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection>();
                        r_ctor_->Type = Type;
                        return r_ctor_;
                    })
                    , py::arg("type") = Intersection::Types::Unknown
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::Type, "")
                    .def_readwrite("edge_id", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::EdgeId, "/<  Edge index of the Polyhedron")
                    .def_readwrite("vertex_id", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersection::VertexId, "/<  Vertex index of the Polyhedron, available only if Type is Types::Vertex")
                    ;
            } // end of inner classes & enums of IntersectionPolyhedronPlaneResult

            pyNsGedim_ClassGeometryUtilities_ClassIntersectionPolyhedronPlaneResult
                .def(py::init<>([](
                Types Type = Types::Unknown, std::vector<VertexIntersection> VertexIntersections = {}, std::vector<EdgeIntersection> EdgeIntersections = {}, std::vector<FaceIntersection> FaceIntersections = {}, std::vector<Intersection> Intersections = {}, Eigen::MatrixXd IntersectionCoordinates = Eigen::MatrixXd())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult>();
                    r_ctor_->Type = Type;
                    r_ctor_->VertexIntersections = VertexIntersections;
                    r_ctor_->EdgeIntersections = EdgeIntersections;
                    r_ctor_->FaceIntersections = FaceIntersections;
                    r_ctor_->Intersections = Intersections;
                    r_ctor_->IntersectionCoordinates = IntersectionCoordinates;
                    return r_ctor_;
                })
                , py::arg("type") = IntersectionPolyhedronPlaneResult::Types::Unknown, py::arg("vertex_intersections") = std::vector<VertexIntersection>{}, py::arg("edge_intersections") = std::vector<EdgeIntersection>{}, py::arg("face_intersections") = std::vector<FaceIntersection>{}, py::arg("intersections") = std::vector<Intersection>{}, py::arg("intersection_coordinates") = Eigen::MatrixXd()
                )
                .def_readwrite("type", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Type, "/< The intersection type")
                .def_readwrite("intersection_id", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::IntersectionId, "/< The geometry id of the intersection, available only with Types::OnVertex,")
                .def_readwrite("vertex_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::VertexIntersections, "/< Vertex intersections")
                .def_readwrite("edge_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::EdgeIntersections, "/< Edge intersections")
                .def_readwrite("face_intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::FaceIntersections, "/< Face intersections")
                .def_readwrite("intersections", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::Intersections, "/< The resulting intersections")
                .def_readwrite("intersection_coordinates", &Gedim::GeometryUtilities::IntersectionPolyhedronPlaneResult::IntersectionCoordinates, "/< The resulting intersection coordinates")
                ;
            auto pyEnumPointCirclePositionResult =
                py::enum_<Gedim::GeometryUtilities::PointCirclePositionResult>(pyNsGedim_ClassGeometryUtilities, "PointCirclePositionResult", py::arithmetic(), "")
                    .value("unknown", Gedim::GeometryUtilities::PointCirclePositionResult::Unknown, "")
                    .value("outside", Gedim::GeometryUtilities::PointCirclePositionResult::Outside, "")
                    .value("on_border", Gedim::GeometryUtilities::PointCirclePositionResult::OnBorder, "")
                    .value("inside", Gedim::GeometryUtilities::PointCirclePositionResult::Inside, "");
            auto pyNsGedim_ClassGeometryUtilities_ClassPointPolygonPositionResult =
                py::class_<Gedim::GeometryUtilities::PointPolygonPositionResult>
                    (pyNsGedim_ClassGeometryUtilities, "PointPolygonPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of PointPolygonPositionResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::PointPolygonPositionResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassPointPolygonPositionResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::Unknown, "")
                        .value("outside", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::Outside, "")
                        .value("border_edge", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::BorderEdge, "")
                        .value("border_vertex", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::BorderVertex, "")
                        .value("inside", Gedim::GeometryUtilities::PointPolygonPositionResult::Types::Inside, "");
            } // end of inner classes & enums of PointPolygonPositionResult

            pyNsGedim_ClassGeometryUtilities_ClassPointPolygonPositionResult
                .def(py::init<>([](
                Types Type = Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::PointPolygonPositionResult>();
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("type") = PointPolygonPositionResult::Types::Unknown
                )
                .def_readwrite("border_index", &Gedim::GeometryUtilities::PointPolygonPositionResult::BorderIndex, "/< index of vertex/edge of border")
                .def_readwrite("type", &Gedim::GeometryUtilities::PointPolygonPositionResult::Type, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult =
                py::class_<Gedim::GeometryUtilities::LinePolygonPositionResult>
                    (pyNsGedim_ClassGeometryUtilities, "LinePolygonPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of LinePolygonPositionResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::LinePolygonPositionResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::LinePolygonPositionResult::Types::Unknown, "")
                        .value("outside", Gedim::GeometryUtilities::LinePolygonPositionResult::Types::Outside, "")
                        .value("intersecting", Gedim::GeometryUtilities::LinePolygonPositionResult::Types::Intersecting, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult_ClassEdgeIntersection =
                    py::class_<Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection>
                        (pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult, "EdgeIntersection", py::is_final(), "\n(final class)");

                { // inner classes & enums of EdgeIntersection
                    auto pyEnumTypes =
                        py::enum_<Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types>(pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult_ClassEdgeIntersection, "Types", py::arithmetic(), "")
                            .value("unknown", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::Unknown, "")
                            .value("on_edge_origin", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::OnEdgeOrigin, "")
                            .value("inside_edge", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::InsideEdge, "")
                            .value("on_edge_end", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::OnEdgeEnd, "")
                            .value("parallel", Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Types::Parallel, "");
                } // end of inner classes & enums of EdgeIntersection

                pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult_ClassEdgeIntersection
                    .def(py::init<>([](
                    Types Type = Types::Unknown, double CurvilinearCoordinate = 0.0)
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection>();
                        r_ctor_->Type = Type;
                        r_ctor_->CurvilinearCoordinate = CurvilinearCoordinate;
                        return r_ctor_;
                    })
                    , py::arg("type") = EdgeIntersection::Types::Unknown, py::arg("curvilinear_coordinate") = 0.0
                    )
                    .def_readwrite("type", &Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Type, "")
                    .def_readwrite("index", &Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::Index, "")
                    .def_readwrite("curvilinear_coordinate", &Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersection::CurvilinearCoordinate, "")
                    ;
            } // end of inner classes & enums of LinePolygonPositionResult

            pyNsGedim_ClassGeometryUtilities_ClassLinePolygonPositionResult
                .def(py::init<>([](
                std::vector<EdgeIntersection> EdgeIntersections = {}, Types Type = Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::LinePolygonPositionResult>();
                    r_ctor_->EdgeIntersections = EdgeIntersections;
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("edge_intersections") = std::vector<EdgeIntersection>{}, py::arg("type") = LinePolygonPositionResult::Types::Unknown
                )
                .def_readwrite("edge_intersections", &Gedim::GeometryUtilities::LinePolygonPositionResult::EdgeIntersections, "")
                .def_readwrite("type", &Gedim::GeometryUtilities::LinePolygonPositionResult::Type, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassPointPolyhedronPositionResult =
                py::class_<Gedim::GeometryUtilities::PointPolyhedronPositionResult>
                    (pyNsGedim_ClassGeometryUtilities, "PointPolyhedronPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of PointPolyhedronPositionResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassPointPolyhedronPositionResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::Unknown, "")
                        .value("outside", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::Outside, "")
                        .value("border_face", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::BorderFace, "")
                        .value("border_edge", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::BorderEdge, "")
                        .value("border_vertex", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::BorderVertex, "")
                        .value("inside", Gedim::GeometryUtilities::PointPolyhedronPositionResult::Types::Inside, "");
            } // end of inner classes & enums of PointPolyhedronPositionResult

            pyNsGedim_ClassGeometryUtilities_ClassPointPolyhedronPositionResult
                .def(py::init<>([](
                Types Type = Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::PointPolyhedronPositionResult>();
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("type") = PointPolyhedronPositionResult::Types::Unknown
                )
                .def_readwrite("border_index", &Gedim::GeometryUtilities::PointPolyhedronPositionResult::BorderIndex, "/< index of vertex/edge/face of border")
                .def_readwrite("internal_indices", &Gedim::GeometryUtilities::PointPolyhedronPositionResult::Internal_indices, "/< list of index of internal cell (usually tetrahedrons)")
                .def_readwrite("type", &Gedim::GeometryUtilities::PointPolyhedronPositionResult::Type, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSegmentPolyhedronPositionResult =
                py::class_<Gedim::GeometryUtilities::SegmentPolyhedronPositionResult>
                    (pyNsGedim_ClassGeometryUtilities, "SegmentPolyhedronPositionResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of SegmentPolyhedronPositionResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSegmentPolyhedronPositionResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::Unknown, "")
                        .value("outside", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::Outside, "")
                        .value("border_face", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::BorderFace, "")
                        .value("border_edge", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::BorderEdge, "")
                        .value("inside", Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Types::Inside, "");
            } // end of inner classes & enums of SegmentPolyhedronPositionResult

            pyNsGedim_ClassGeometryUtilities_ClassSegmentPolyhedronPositionResult
                .def(py::init<>([](
                Types Type = Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SegmentPolyhedronPositionResult>();
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("type") = SegmentPolyhedronPositionResult::Types::Unknown
                )
                .def_readwrite("border_index", &Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::BorderIndex, "/< index of edge/face of border")
                .def_readwrite("type", &Gedim::GeometryUtilities::SegmentPolyhedronPositionResult::Type, "")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassPolyhedron =
                py::class_<Gedim::GeometryUtilities::Polyhedron>
                    (pyNsGedim_ClassGeometryUtilities, "Polyhedron", py::is_final(), "\n(final class)")
                .def(py::init<>([](
                Eigen::MatrixXd Vertices = Eigen::MatrixXd(), Eigen::MatrixXi Edges = Eigen::MatrixXi(), std::vector<Eigen::MatrixXi> Faces = std::vector<Eigen::MatrixXi>())
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::Polyhedron>();
                    r_ctor_->Vertices = Vertices;
                    r_ctor_->Edges = Edges;
                    r_ctor_->Faces = Faces;
                    return r_ctor_;
                })
                , py::arg("vertices") = Eigen::MatrixXd(), py::arg("edges") = Eigen::MatrixXi(), py::arg("faces") = std::vector<Eigen::MatrixXi>()
                )
                .def_readwrite("vertices", &Gedim::GeometryUtilities::Polyhedron::Vertices, "/< vertices, size 3 x numVertices")
                .def_readwrite("edges", &Gedim::GeometryUtilities::Polyhedron::Edges, "/< edges, size 2 x numEdges")
                .def_readwrite("faces", &Gedim::GeometryUtilities::Polyhedron::Faces, "/< faces vertices and edges˝, size numFaces x 2 x numFaceVertices")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithPlaneResult =
                py::class_<Gedim::GeometryUtilities::SplitPolygonWithPlaneResult>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolygonWithPlaneResult", py::is_final(), "\n(final class)");

            { // inner classes & enums of SplitPolygonWithPlaneResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithPlaneResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Unknown, "")
                        .value("split", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Split, "")
                        .value("positive", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Positive, "")
                        .value("negative", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::Negative, "")
                        .value("on_plane", Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Types::OnPlane, "");
            } // end of inner classes & enums of SplitPolygonWithPlaneResult

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolygonWithPlaneResult
                .def(py::init<>([](
                std::vector<Eigen::Vector3d> NewVertices = std::vector<Eigen::Vector3d>(), Types Type = Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolygonWithPlaneResult>();
                    r_ctor_->NewVertices = NewVertices;
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("new_vertices") = std::vector<Eigen::Vector3d>(), py::arg("type") = SplitPolygonWithPlaneResult::Types::Unknown
                )
                .def_readwrite("positive_vertices", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::PositiveVertices, "/ vertices indices of the positive sub-polygon")
                .def_readwrite("negative_vertices", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::NegativeVertices, "/ vertices indices of the negative sub-polygon")
                .def_readwrite("points_on_plane", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::PointsOnPlane, "/ vertices indices of the points on plane")
                .def_readwrite("new_vertices", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::NewVertices, "/ new vertices coordinates")
                .def_readwrite("new_vertices_edge_index", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::NewVerticesEdgeIndex, "/ new vertices edge indices")
                .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolygonWithPlaneResult::Type, "/ type of split")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult =
                py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult>
                    (pyNsGedim_ClassGeometryUtilities, "SplitPolyhedronWithPlaneResult", "");

            { // inner classes & enums of SplitPolyhedronWithPlaneResult
                auto pyEnumTypes =
                    py::enum_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types>(pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "Types", py::arithmetic(), "")
                        .value("unknown", Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types::Unknown, "")
                        .value("split", Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types::Split, "")
                        .value("none", Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Types::None, "");
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult_ClassNewVertices =
                    py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "NewVertices", "")
                    .def(py::init<>([](
                    Eigen::MatrixXd Vertices = Eigen::MatrixXd())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices>();
                        r_ctor_->Vertices = Vertices;
                        return r_ctor_;
                    })
                    , py::arg("vertices") = Eigen::MatrixXd()
                    )
                    .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices::Vertices, "/< all vertices contained in the new polyhedra")
                    .def_readwrite("new_vertices_original_edge", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewVertices::NewVerticesOriginalEdge, "/< For each new vertex the index of the original edge")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult_ClassNewEdges =
                    py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "NewEdges", "")
                    .def(py::init<>([](
                    Eigen::MatrixXi Edges = Eigen::MatrixXi(), std::vector<int> NewEdgesOriginalEdges = std::vector<int>(), std::vector<int> NewEdgesOriginalFace = std::vector<int>())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges>();
                        r_ctor_->Edges = Edges;
                        r_ctor_->NewEdgesOriginalEdges = NewEdgesOriginalEdges;
                        r_ctor_->NewEdgesOriginalFace = NewEdgesOriginalFace;
                        return r_ctor_;
                    })
                    , py::arg("edges") = Eigen::MatrixXi(), py::arg("new_edges_original_edges") = std::vector<int>(), py::arg("new_edges_original_face") = std::vector<int>()
                    )
                    .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges::Edges, "/< all edges contained in the new polyhedra")
                    .def_readwrite("new_edges_original_edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges::NewEdgesOriginalEdges, "/< indices of original edges for new edges, -1 means no original")
                    .def_readwrite("new_edges_original_face", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewEdges::NewEdgesOriginalFace, "/< For each new vertex the index of the original edge to which is")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult_ClassNewFaces =
                    py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "NewFaces", "")
                    .def(py::init<>([](
                    std::vector<Eigen::MatrixXi> Faces = std::vector<Eigen::MatrixXi>(), std::vector<int> NewFacesOriginalFaces = std::vector<int>())
                    {
                        auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces>();
                        r_ctor_->Faces = Faces;
                        r_ctor_->NewFacesOriginalFaces = NewFacesOriginalFaces;
                        return r_ctor_;
                    })
                    , py::arg("faces") = std::vector<Eigen::MatrixXi>(), py::arg("new_faces_original_faces") = std::vector<int>()
                    )
                    .def_readwrite("faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces::Faces, "")
                    .def_readwrite("new_faces_original_faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewFaces::NewFacesOriginalFaces, "/< indices of original faces for new faces, -1 means no original")
                    ;
                auto pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult_ClassNewPolyhedron =
                    py::class_<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron>
                        (pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult, "NewPolyhedron", "")
                    .def(py::init<>()) // implicit default constructor
                    .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron::Vertices, "")
                    .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron::Edges, "")
                    .def_readwrite("faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NewPolyhedron::Faces, "")
                    ;
            } // end of inner classes & enums of SplitPolyhedronWithPlaneResult

            pyNsGedim_ClassGeometryUtilities_ClassSplitPolyhedronWithPlaneResult
                .def(py::init<>([](
                NewVertices Vertices = NewVertices(), NewEdges Edges = NewEdges(), NewFaces Faces = NewFaces(), NewPolyhedron PositivePolyhedron = NewPolyhedron(), NewPolyhedron NegativePolyhedron = NewPolyhedron(), Types Type = Types::Unknown)
                {
                    auto r_ctor_ = std::make_unique<Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult>();
                    r_ctor_->Vertices = Vertices;
                    r_ctor_->Edges = Edges;
                    r_ctor_->Faces = Faces;
                    r_ctor_->PositivePolyhedron = PositivePolyhedron;
                    r_ctor_->NegativePolyhedron = NegativePolyhedron;
                    r_ctor_->Type = Type;
                    return r_ctor_;
                })
                , py::arg("vertices") = NewVertices(), py::arg("edges") = NewEdges(), py::arg("faces") = NewFaces(), py::arg("positive_polyhedron") = NewPolyhedron(), py::arg("negative_polyhedron") = NewPolyhedron(), py::arg("type") = SplitPolyhedronWithPlaneResult::Types::Unknown
                )
                .def_readwrite("original_edges_new_edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::OriginalEdgesNewEdges, "")
                .def_readwrite("original_faces_new_faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::OriginalFacesNewFaces, "")
                .def_readwrite("vertices", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Vertices, "")
                .def_readwrite("edges", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Edges, "")
                .def_readwrite("faces", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Faces, "")
                .def_readwrite("positive_polyhedron", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::PositivePolyhedron, "")
                .def_readwrite("negative_polyhedron", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::NegativePolyhedron, "")
                .def_readwrite("type", &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResult::Type, "/ type of split")
                ;
            auto pyNsGedim_ClassGeometryUtilities_ClassAlignedPolyhedronEdgesResult =
                py::class_<Gedim::GeometryUtilities::AlignedPolyhedronEdgesResult>
                    (pyNsGedim_ClassGeometryUtilities, "AlignedPolyhedronEdgesResult", "")
                .def(py::init<>()) // implicit default constructor
                .def_readwrite("aligned_edges_vertices", &Gedim::GeometryUtilities::AlignedPolyhedronEdgesResult::AlignedEdgesVertices, "")
                .def_readwrite("aligned_edges_edges", &Gedim::GeometryUtilities::AlignedPolyhedronEdgesResult::AlignedEdgesEdges, "")
                ;
        } // end of inner classes & enums of GeometryUtilities

        pyNsGedim_ClassGeometryUtilities
            .def(py::init<const Gedim::GeometryUtilitiesConfig &>(),
                py::arg("configuration"))
            .def("tolerance1_d",
                &Gedim::GeometryUtilities::Tolerance1D, "/ \\return tolerance used for segment length")
            .def("tolerance1_d_squared",
                &Gedim::GeometryUtilities::Tolerance1DSquared, "/ \\return tolerance used for squared segment length")
            .def("tolerance2_d",
                &Gedim::GeometryUtilities::Tolerance2D, "/ \\return tolerance used for polygon area")
            .def("tolerance3_d",
                &Gedim::GeometryUtilities::Tolerance3D, "/ \\return tolerance used for polyhedron volume")
            .def("relative_difference",
                &Gedim::GeometryUtilities::RelativeDifference,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\param first the first value\n/ \\param second the second value\n/ \\return the relative difference between the two values according the first")
            .def("compare_values",
                &Gedim::GeometryUtilities::CompareValues,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\brief Compare two values according to tolerance\n/ \\param first the first value\n/ \\param second the second value\n/ \\return the result\n/ \note the interval [-tolerance, tolerance] is considered 0.0")
            .def("are_values_equal",
                &Gedim::GeometryUtilities::AreValuesEqual,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\brief Check if two values are equal according to tolerance\n/ \\param first the first value\n/ \\param second the second value\n/ \\return the result")
            .def("is_value_greater",
                &Gedim::GeometryUtilities::IsValueGreater,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\param first the first value\n/ \\param second the second value\n/ \\return True if first is greater than second")
            .def("is_value_greater_or_equal",
                &Gedim::GeometryUtilities::IsValueGreaterOrEqual,
                py::arg("first"), py::arg("second"), py::arg("tolerance"),
                "/ \\param first the first value\n/ \\param second the second value\n/ \\return True if first is greater or equal than second")
            .def("is_value_lower",
                &Gedim::GeometryUtilities::IsValueLower, py::arg("first"), py::arg("second"), py::arg("tolerance"))
            .def("is_value_lower_or_equal",
                &Gedim::GeometryUtilities::IsValueLowerOrEqual, py::arg("first"), py::arg("second"), py::arg("tolerance"))
            .def("is_value_positive",
                &Gedim::GeometryUtilities::IsValuePositive,
                py::arg("value"), py::arg("tolerance"),
                "/ \\param value the value\n/ \\return True if value is positive")
            .def("is_value_negative",
                &Gedim::GeometryUtilities::IsValueNegative,
                py::arg("value"), py::arg("tolerance"),
                "/ \\param value the value\n/ \\return True if value is negative")
            .def("is_value_zero",
                &Gedim::GeometryUtilities::IsValueZero,
                py::arg("value"), py::arg("tolerance"),
                "/ \\param value the value\n/ \\return True if value is zero")
            .def("fibonacci_sphere",
                &Gedim::GeometryUtilities::fibonacci_sphere, py::arg("num_points"))
            .def("generate_uniform_random_points_in_sphere",
                &Gedim::GeometryUtilities::generate_uniform_random_points_in_sphere, py::arg("num_points"), py::arg("radius") = 1.0)
            .def("equispace_coordinates",
                py::overload_cast<const double &, const bool &>(&Gedim::GeometryUtilities::EquispaceCoordinates, py::const_),
                py::arg("step"), py::arg("insert_extremes"),
                "/ \\param step the distance between each coordinate\n/ \\param insertExtremes if True keeps the extremes\n/ \\return the equispace coordinates between [0.0, 1.0], size 1 x numCoordinates")
            .def("equispace_coordinates",
                py::overload_cast<const unsigned int &, const double &, const double &, const bool &>(&Gedim::GeometryUtilities::EquispaceCoordinates, py::const_),
                py::arg("size"), py::arg("origin"), py::arg("end"), py::arg("insert_extremes"),
                "/ \\param size the number of resulting coordinates\n/ \\param origin the starting curvilinear coordinate\n/ \\param end the ending curvilinear coordinate\n/ \\param insertExtremes if True keeps the extremes\n/ \\return equispaced curvilinear coordinates in the interval [origin, end]\n/ \note if size < 2 then size will be considered as 2")
            .def("random_coordinates",
                &Gedim::GeometryUtilities::RandomCoordinates,
                py::arg("size"), py::arg("insert_extremes"), py::arg("min_distance"), py::arg("seed") = time(nullptr),
                "/ \\param size the number of resulting coordinates\n/ \\param origin the starting curvilinear coordinate\n/ \\param end the ending curvilinear coordinate\n/ \\param insertExtremes if True keeps the extremes\n/ \\return random curvilinear coordinates in the interval [0.0, 1.0], size 1 x numCoordinates\n/ \note if size < 2 then size will be considered as 2")
            .def("polar_angle",
                &Gedim::GeometryUtilities::PolarAngle,
                py::arg("v_prev"), py::arg("v"), py::arg("v_next"), py::arg("norm_v_prev_v"), py::arg("norm_v_next_v"),
                "/ \\param v_prev the previous point\n/ \\param v the middle point\n/ \\param v_next the next point\n/ \\return the polar angle between the three points, computed as the cross product (v_next-v) x (v_prev-v)\n/ \note positive is convex (counter-clockwise), negative is concave (clockwise), zero is collinear")
            .def("point_distance",
                &Gedim::GeometryUtilities::PointDistance,
                py::arg("first_point"), py::arg("second_point"),
                "/ \\brief compute the Point distance\n/ \\param firstPoint the first point\n/ \\param secondPoint the second point\n/ \\return the distance")
            .def("point_distances",
                &Gedim::GeometryUtilities::PointDistances,
                py::arg("points"), py::arg("point"),
                "/ \\brief compute the distance between a point and a list of points\n/ \\param points the point collection, size 3 x numPoints\n/ \\param point the point\n/ \\return the collection of distances, size 1 x numPoints")
            .def("points_distance",
                &Gedim::GeometryUtilities::PointsDistance,
                py::arg("points"),
                "/ \\param points the point collection, size 3 x numPoints\n/ \\return the distances between the points collected in matrix, size numPoints x numPoints.")
            .def("points_bounding_box",
                &Gedim::GeometryUtilities::PointsBoundingBox,
                py::arg("points"),
                "/ \\param points the point collection, size 3 x numPoints\n/ \\return the extreme bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints")
            .def("is_point_in_bounding_box",
                &Gedim::GeometryUtilities::IsPointInBoundingBox,
                py::arg("point"), py::arg("bouding_box"),
                "/ \\param point the point\n/ \\param boudingBox the bounding box points (xmin, ymin, zmin) and (xmax, ymax, zmax), size 2 x numPoints\n/ \\return False if the point is outside the bounding box, True otherwise (border or inside)")
            .def("bounding_boxes_intersects",
                &Gedim::GeometryUtilities::BoundingBoxesIntersects, py::arg("bouding_box_1"), py::arg("bouding_box_2"))
            .def("points_max_distance",
                &Gedim::GeometryUtilities::PointsMaxDistance,
                py::arg("points"),
                "/ \\param points the point collection, size 3 x numPoints\n/ \\return the maximum distance between the points.")
            .def("is_point_zero",
                &Gedim::GeometryUtilities::IsPointZero, py::arg("point"))
            .def("points_are_coincident",
                &Gedim::GeometryUtilities::PointsAreCoincident,
                py::arg("first_point"), py::arg("second_point"),
                "/ \\param firstPoint the first point\n/ \\param secondPoint the second point\n/ \\return True if the points are coincident")
            .def("find_point_in_points",
                &Gedim::GeometryUtilities::FindPointInPoints,
                py::arg("points"), py::arg("point"),
                "/ \\brief Find a point in point list\n/ \\param points the point list, size 3 x numPoints\n/ \\param point the point to find\n/ \\return the collection of point found")
            .def("point_line_distance",
                &Gedim::GeometryUtilities::PointLineDistance,
                py::arg("point"), py::arg("line_origin"), py::arg("normal_to_line"),
                "/ \\brief Compute the distance between a point and a line\n/ \\param point a point P\n/ \\param lineOrigin the line origin O\n/ \\param normalToLine a normal vector n to the line, in the same plane of P and the line\n/ \\return the distance d\n/ \note The distance is computed as d = n^T * (P - O) / ||n||")
            .def("point_is2_d",
                &Gedim::GeometryUtilities::PointIs2D,
                py::arg("point"),
                "/ \\param point the point\n/ \\return True if the point is 2D (z == 0)")
            .def("points_are2_d",
                &Gedim::GeometryUtilities::PointsAre2D,
                py::arg("points"),
                "/ \\param points the points to test, size 3 x numPoints\n/ \\return True if the points are 2D (z == 0)")
            .def("point_curvilinear_coordinate",
                &Gedim::GeometryUtilities::PointCurvilinearCoordinate,
                py::arg("point"), py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief compute the Point Curvilinear Coordinate of segment\n/ \\param point the point\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the curvilinear coordinate computed")
            .def("point_line_curvilinear_coordinate",
                &Gedim::GeometryUtilities::PointLineCurvilinearCoordinate,
                py::arg("point"), py::arg("line_origin"), py::arg("line_tangent"), py::arg("line_tangent_squared_length"),
                "/ \\brief compute the Point Curvilinear Coordinate of line\n/ \\param point the point\n/ \\param lineOrigin the line origin\n/ \\param lineTangent the line tangent\n/ \\param lineTangentSquaredLength the line tangent length squared\n/ \\return the curvilinear coordinate computed")
            .def("is_point_on_line",
                &Gedim::GeometryUtilities::IsPointOnLine,
                py::arg("point"), py::arg("line_origin"), py::arg("line_tangent"), py::arg("line_tangent_squared_length"),
                "/ \\param point the point\n/ \\param lineOrigin the line origin\n/ \\param lineTangent the line tangent\n/ \\param lineTangentSquaredLength the line tangent length squared\n/ \\return True if the point belongs on line")
            .def("point_segment_position",
                py::overload_cast<const Eigen::Vector3d &, const Eigen::Vector3d &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::PointSegmentPosition, py::const_),
                py::arg("point"), py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Compute point position respect to a segment\n/ \\param point the point\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return result the point position\n/ \\warning left and right point positions work only in xy plane")
            .def("point_segment_position",
                py::overload_cast<const double &>(&Gedim::GeometryUtilities::PointSegmentPosition, py::const_),
                py::arg("curvilinear_coordinate"),
                "/ \\brief Compute point position on a segment line given the curvilinear Coordinate\n/ \\param curvilinearCoordinate the curvilinear coordinate, segment is between 0.0 and 1.0\n/ \\param result the point position on the line")
            .def("point_segment_projection",
                &Gedim::GeometryUtilities::PointSegmentProjection,
                py::arg("point"), py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Project point on a segment line\n/ \\param point the point\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the projected point curvilinear coordinate")
            .def("point_plane_distance",
                py::overload_cast<const Eigen::Vector3d &, const std::array<Eigen::Vector3d, 3> &>(&Gedim::GeometryUtilities::PointPlaneDistance, py::const_),
                py::arg("point"), py::arg("plane_points"),
                "/ \\brief Compute point position respect to a plane formed by 3 points\n/ \\param planePoints the 3 plane points\n/ \\param point the point\n/ \\return the signed point distance, 0.0 on plane, positive above, negative bottom")
            .def("point_plane_distance",
                py::overload_cast<const Eigen::Vector3d &, const Eigen::Vector3d &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::PointPlaneDistance, py::const_),
                py::arg("point"), py::arg("plane_normal"), py::arg("plane_origin"),
                "/ \\brief Compute point position respect to a plane normal\n/ \\param planeNormal the plane normal\n/ \\param planeOrigin the plane origin\n/ \\param point the point\n/ \\return the signed point distance, 0.0 on plane, positive above, negative bottom")
            .def("point_plane_position",
                &Gedim::GeometryUtilities::PointPlanePosition,
                py::arg("point_plane_distance"),
                "/ \\brief Compute point position respect to a plane\n/ \\param pointPlaneDistance the point plane distance\n/ \\return result the point position")
            .def("is_point_on_plane",
                py::overload_cast<const double &>(&Gedim::GeometryUtilities::IsPointOnPlane, py::const_),
                py::arg("point_plane_distance"),
                "/ \\param pointPlaneDistance the point plane distance\n/ \\return True if point is on the plane")
            .def("is_point_on_plane",
                py::overload_cast<const Eigen::Vector3d &, const Eigen::Vector3d &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::IsPointOnPlane, py::const_),
                py::arg("point"), py::arg("plane_normal"), py::arg("plane_origin"),
                "/ \\param point the point\n/ \\param planeNormal the plane normal\n/ \\param planeOrigin the plane origin\n/ \\return True if point is on the plane")
            .def("segment_length",
                &Gedim::GeometryUtilities::SegmentLength,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment length")
            .def("segment_tangent",
                &Gedim::GeometryUtilities::SegmentTangent,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment tangent")
            .def("segment_normal",
                &Gedim::GeometryUtilities::SegmentNormal,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment normal normalized, rotation of the normalized tangent (x,y,0) with 90° clockwise (y, -x,0)\n/ \note the segment shall be 2D")
            .def("segment_slope",
                &Gedim::GeometryUtilities::SegmentSlope,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Compute the segment slope m of line y = m * x + q\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment slope\n/ \note the segment shall be 2D")
            .def("segment_intercept",
                &Gedim::GeometryUtilities::SegmentIntercept,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Compute the segment intercept q of line y = m * x + q\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\return the segment intercept\n/ \note the segment shall be 2D")
            .def("make_concatenation",
                &Gedim::GeometryUtilities::MakeConcatenation, py::arg("segments"), py::arg("starting_vertex"))
            .def("check_no_spheres_intersection",
                &Gedim::GeometryUtilities::CheckNoSpheresIntersection,
                py::arg("first_sphere_center"), py::arg("second_sphere_center"), py::arg("first_sphere_diameter"), py::arg("second_sphere_diameter"),
                "/ \\brief Check if two spheres do not intersect\n/ \\param firstSphereCenter the first sphere center\n/ \\param secondSphereCenter the second sphere center\n/ \\param firstSphereDiameter the first sphere diameter\n/ \\param secondSphereDiameter the second sphere diameter\n/ \\return True if the two segments do not intersect\n/ \note if the function returns True it does not mean that the two segments intersects")
            .def("check_triangles_intersection",
                &Gedim::GeometryUtilities::CheckTrianglesIntersection,
                py::arg("triangle_one"), py::arg("triangle_two"), py::arg("admit_boundary") = true,
                "/ \note works only for 2D triangles\n/ \\see https://rosettacode.org/wiki/Determine_if_two_triangles_overlap#C++")
            .def("are_line_coplanar",
                &Gedim::GeometryUtilities::AreLineCoplanar,
                py::arg("first_line_origin"), py::arg("first_line_tangent"), py::arg("second_line_origin"), py::arg("second_line_tangent"),
                "/ \\param firstLineOrigin first line origin\n/ \\param firstLineTangent first line tangent\n/ \\param secondLineOrigin second line origin\n/ \\param secondLineTangent second line tangent\n/ \\return line coplanarity")
            .def("is_polygon_coplanar",
                &Gedim::GeometryUtilities::IsPolygonCoplanar,
                py::arg("plane_normal"), py::arg("plane_origin"), py::arg("polygon_vertices"), py::arg("polygon_unaligned_vertices"),
                "/ \\brief verify if the polygon is in the coplana to a plane")
            .def("intersection_segment_segment",
                &Gedim::GeometryUtilities::IntersectionSegmentSegment,
                py::arg("first_segment_origin"), py::arg("first_segment_end"), py::arg("second_segment_origin"), py::arg("second_segment_end"),
                "/ \\brief Compute the intersection between the two segments\n/ \\param firstSegmentOrigin first segment origin\n/ \\param firstSegmentEnd first segment end\n/ \\param secondSegmentOrigin second segment origin\n/ \\param secondSegmentEnd second segment end\n/ \\return the resulting intersection\n/ \note no check is performed")
            .def("intersections_between_segments",
                &Gedim::GeometryUtilities::IntersectionsBetweenSegments,
                py::arg("segments_vertices"), py::arg("segments_tangent"), py::arg("segments_barycenter"), py::arg("segments_length"),
                "/ \\brief Compute the intersection between a collection of segments\n/ \\param segmentsVertices the segments vertices\n/ \\param segmentsTangent the segments tangent\n/ \\param segmentsBarycenter the segments barycenter\n/ \\param segmentsLength the segments length\n/ \\return for each segment the list of intersections curvilinear coordinate")
            .def("intersection_segment_circle",
                &Gedim::GeometryUtilities::IntersectionSegmentCircle,
                py::arg("segment_origin"), py::arg("segment_end"), py::arg("circle_center"), py::arg("circle_radius"),
                "/ \\brief Compute the intersection between the a segment and a circle\n/ \\param segmentOrigin first segment origin\n/ \\param segmentEnd first segment end\n/ \\param circleCenter circle center\n/ \\param circleRadius circle radius\n/ \\return the resulting intersection\n/ \note tested only in 2D")
            .def("intersection_segment_plane",
                &Gedim::GeometryUtilities::IntersectionSegmentPlane,
                py::arg("segment_origin"), py::arg("segment_end"), py::arg("plane_normal"), py::arg("plane_origin"),
                "/ \\brief Intersection between a Segment, represented by origin and end and a plane\n/ represented by the normal and a point\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segement end\n/ \\param planeNormal the plane normal normalized\n/ \\param planeOrigin a plane point\n/ \\return the resulting intersection")
            .def("intersection_polyhedron_plane",
                &Gedim::GeometryUtilities::IntersectionPolyhedronPlane,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("plane_normal"), py::arg("plane_origin"), py::arg("plane_rotation_matrix"), py::arg("plane_translation"),
                "/ \\brief Intersection between a Polyhedron and a Plane\n/ \\param polyhedronVertices the polyhedron vertices, size 3 x numVertices\n/ \\param polyhedronEdges the polyhedron edges, size 2 x numEdges\n/ \\param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices\n/ \\param planeNormal the plane normal normalized\n/ \\param planeOrigin the plane origin\n/ \\param planeRotationMatrix the plane rotation from 3D to 2D\n/ \\param planeTranslation the plane translation vector\n/ \\return the intersection result\n/ \note works only with convex polyhedra")
            .def("split_polyhedron_with_plane",
                &Gedim::GeometryUtilities::SplitPolyhedronWithPlane, py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_edge_tangents"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"), py::arg("plane_normal"), py::arg("plane_origin"), py::arg("plane_rotation_matrix"), py::arg("plane_translation"))
            .def("split_polyhedron_with_plane_result_to_polyhedra",
                &Gedim::GeometryUtilities::SplitPolyhedronWithPlaneResultToPolyhedra, py::arg("result"))
            .def("intersection_polyhedron_line",
                &Gedim::GeometryUtilities::IntersectionPolyhedronLine,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("line_tangent"), py::arg("line_origin"),
                "/ \\brief Intersection between a Polyhedron and a line\n/ \\param polyhedronVertices the polyhedron vertices, size 3 x numVertices\n/ \\param polyhedronEdges the polyhedron edges, size 2 x numEdges\n/ \\param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices\n/ \\param lineTangent the line tangent\n/ \\param lineOrigin the line origin\n/ \\return the intersection result\n/ \\warning NOT TESTED PROPERLY")
            .def("intersection_polyhedron_segment",
                &Gedim::GeometryUtilities::IntersectionPolyhedronSegment,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("segment_origin"), py::arg("segment_end"), py::arg("segment_tangent"), py::arg("polyhedron_line_intersections"),
                "/ \\brief Intersection between a Polyhedron and a segment\n/ \\param polyhedronVertices the polyhedron vertices, size 3 x numVertices\n/ \\param polyhedronEdges the polyhedron edges, size 2 x numEdges\n/ \\param polyhedronFaces the polyhedron face vertices and edges, size numFaces x 2 x numVertices\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\param segmentTangent the segment tangent\n/ \\param polyhedronLineIntersections the intersection between the polyhedron and the line of the segment\n/ \\return the intersection result\n/ /// \\warning NOT TESTED PROPERLY")
            .def("intersection_polyhedrons_segment",
                &Gedim::GeometryUtilities::IntersectionPolyhedronsSegment,
                py::arg("polyhedrons"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("segment_origin"), py::arg("segment_end"), py::arg("segment_tangent"),
                "/ \\brief Intersection between a collectio of Polyhedrons and a segment\n/ \\param polyhedrons the polyhedron collection\n/ \\param polyhedronFaceNormals polyhedron face normals\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end\n/ \\param segmentTangent the segment tangent\n/ \\return the intersection result\n/ \\warning NOT TESTED PROPERLY")
            .def("point_polygon_position",
                &Gedim::GeometryUtilities::PointPolygonPosition,
                py::arg("point"), py::arg("polygon_vertices"),
                "/ \\brief Check if point is inside a polygon\n/ \\param point the point\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting position\n/ \\warning works only in 2D with convex polygons")
            .def("point_polygon_position_ray_casting",
                &Gedim::GeometryUtilities::PointPolygonPosition_RayCasting, py::arg("point"), py::arg("polygon_vertices"))
            .def("is_point_inside_polygon",
                &Gedim::GeometryUtilities::IsPointInsidePolygon,
                py::arg("point"), py::arg("polygon_vertices"),
                "/ \\param point the point\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return False if it is outside, True the other cases\n/ \\warning works only in 2D with convex polygons")
            .def("is_point_inside_polygon_ray_casting",
                &Gedim::GeometryUtilities::IsPointInsidePolygon_RayCasting,
                py::arg("point"), py::arg("polygon_vertices"),
                "/ \\brief IsPointInsidePolygon using RayCasting algorithm\n/ (see https://en.wikipedia.org/wiki/Point_in_polygon)\n/ \\param point the point\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return False if it is outside, True the other cases")
            .def("line_polygon_position",
                &Gedim::GeometryUtilities::LinePolygonPosition, py::arg("line_tangent"), py::arg("line_origin"), py::arg("polygon_vertices"))
            .def("point_polyhedron_position",
                py::overload_cast<const Eigen::Vector3d &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<bool> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &>(&Gedim::GeometryUtilities::PointPolyhedronPosition, py::const_),
                py::arg("point"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_rotated_vertices"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"),
                "/ \\brief Check if point is inside a polyhedron\n/ \\param point the point\n/ \\param polyhedronFaces the polyhedron faces, size numPolyhedronFaces\n/ \\param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces\n/ \\param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces\n/ \\param polyhedronFaceNormals the polyhedron face normals\n/ \\param polyhedronFaceNormalDirections the polyhedron face normal directions\n/ \\param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D\n/ \\param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D\n/ \\return the point position respect the polyhedron\n/ \note works only for convex polyhedrons")
            .def("point_polyhedron_position",
                py::overload_cast<const Eigen::Vector3d &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<bool> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &, const std::vector<Eigen::MatrixXd> &>(&Gedim::GeometryUtilities::PointPolyhedronPosition, py::const_),
                py::arg("point"), py::arg("polyhedron_faces"), py::arg("polyhedron_faces_3_d_vertices"), py::arg("polyhedron_faces_2_d_vertices"), py::arg("polyhedron_faces_normals"), py::arg("polyhedron_faces_normal_direction"), py::arg("polyhedron_faces_translation"), py::arg("polyhedron_faces_rotation_matrix"), py::arg("polyhedron_tetrahedrons"),
                "/ \\brief Check if point is inside a polyhedron\n/ \\param point the point\n/ \\param polyhedronFaces the polyhedron faces, size numPolyhedronFaces\n/ \\param polyhedronFaceVertices the polyhedron face 3D vertices, size numPolyhedronFaces\n/ \\param polyhedronFaceRotatedVertices the polyhedron face 2D vertices, size numPolyhedronFaces\n/ \\param polyhedronFaceNormals the polyhedron face normals\n/ \\param polyhedronFaceNormalDirections the polyhedron face normal directions\n/ \\param polyhedronFaceTranslations the polyhedron face translation from 2D to 3D\n/ \\param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D\n/ \\return the point position respect the polyhedron\n/ \note works for concave and convex polyhedrons")
            .def("is_point_inside_tetrahedron",
                &Gedim::GeometryUtilities::IsPointInsideTetrahedron, py::arg("tetrahedron"), py::arg("point"))
            .def("point_circle_position",
                &Gedim::GeometryUtilities::PointCirclePosition,
                py::arg("point"), py::arg("circle_center"), py::arg("circle_radius"),
                "/ \\brief Check if point is inside a circle\n/ \\param point the point\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\param result the resulting position\n/ \note tested only in 2D")
            .def("point_circle_positions",
                &Gedim::GeometryUtilities::PointCirclePositions,
                py::arg("points"), py::arg("circle_center"), py::arg("circle_radius"),
                "/ \\brief Check if points are inside a circle\n/ \\param points the matrix of points (size 3 x numVertices)\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\param result the resulting positions\n/ \note tested only in 2D")
            .def("polygon_circle_position",
                &Gedim::GeometryUtilities::PolygonCirclePosition,
                py::arg("polygon_vertices"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("vertex_positions"), py::arg("polygon_circle_intersections"),
                "/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\param vertexPositions the polygon vertices positions respect the circle\n/ \\param polygonCircleIntersections the polygon center intersections\n/ \\return the Polygon Circle reciprocal position\n/ \note tested only in 2D")
            .def("intersection_polygon_circle",
                &Gedim::GeometryUtilities::IntersectionPolygonCircle,
                py::arg("polygon_vertices"), py::arg("circle_center"), py::arg("circle_radius"),
                "/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\return the Polygon Circle reciprocal intersections\n/ \note tested only in 2D")
            .def("polygon_triangulation_by_first_vertex",
                &Gedim::GeometryUtilities::PolygonTriangulationByFirstVertex,
                py::arg("polygon_vertices"),
                "/ \\brief Convex Polygon simple Triangulation from the first vertex\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\return the sub-division triangulation, size 1 x 3 * numTriangles\n/ \note works only for convex polygon")
            .def("polygon_triangulation_by_ear_clipping",
                &Gedim::GeometryUtilities::PolygonTriangulationByEarClipping,
                py::arg("polygon_vertices"),
                "/ \\brief Concave Polygon Triangulation with ear clipping algorithm\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\return the sub-division triangulation, size 1 x 3 * numTriangles")
            .def("polygon_triangulation_by_internal_point",
                &Gedim::GeometryUtilities::PolygonTriangulationByInternalPoint,
                py::arg("polygon_vertices"), py::arg("internal_point"),
                "/ \\brief Convex Polygon simple Triangulation from an internal point\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param point internal polygon point\n/ \\return the sub-division triangulation, size 1 x 3 * numPolygonVertices,\n/ \note the internal point index is numPolygonVertices")
            .def("polygon_outside_circle_division_by_angle_quadrant",
                &Gedim::GeometryUtilities::PolygonOutsideCircleDivisionByAngleQuadrant,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("curved_edge_index"),
                "/ \\brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param circleCenter the circle center from which the curved edge derives\n/ \\param circleRadius the radius of the circle from which the curved edge derives\n/ \\param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices\n/ \\return the sub-division polygons result")
            .def("polygon_inside_circle_division_by_angle_quadrant",
                &Gedim::GeometryUtilities::PolygonInsideCircleDivisionByAngleQuadrant,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("curved_edge_index"),
                "/ \\brief Convex Polygon sub division by angle quadrant which intersects a polygon in a curved edge\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param circleCenter the circle center from which the curved edge derives\n/ \\param circleRadius the radius of the circle from which the curved edge derives\n/ \\param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices\n/ \\return the sub-division polygons result")
            .def("polygon_division_by_circle",
                &Gedim::GeometryUtilities::PolygonDivisionByCircle,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("curved_edge_index"),
                "/ \\brief Convex Polygon sub division from a circle which intersects a polygon in a curved edge\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param circleCenter the circle center from which the curved edge derives\n/ \\param circleRadius the radius of the circle from which the curved edge derives\n/ \\param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices\n/ \\return the sub-division polygons result\n/ \note the polygon should be inside the angle quadrant formed by the curved edge\n/ \note otherwise use PolygonDivisionByAngleQuadrant function to split the polygon")
            .def("circle_division_by_polygon",
                &Gedim::GeometryUtilities::CircleDivisionByPolygon,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("curved_edge_index"),
                "/ \\brief Circle division from Convex Polygon sub division which intersects a polygon in a curved edge\n/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\param circleCenter the circle center from which the curved edge derives\n/ \\param circleRadius the radius of the circle from which the curved edge derives\n/ \\param curvedEdgeIndex curved edge index, from 0 to numPolygonVertices\n/ \\return the sub-division circle result\n/ \note the polygon should be inside the angle quadrant formed by the curved edge")
            .def("polygon_area",
                &Gedim::GeometryUtilities::PolygonArea,
                py::arg("polygon_vertices"),
                "/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\return the polygon area\n/ \note the polygon shall be 2D")
            .def("polygon_area3_d",
                &Gedim::GeometryUtilities::PolygonArea3D,
                py::arg("polygon_vertices"),
                "/ \\param polygonVertices the polygon vertices, size 3 x numPolygonVertices\n/ \\return the polygon area")
            .def("polygon_mass",
                &Gedim::GeometryUtilities::PolygonMass,
                py::arg("polygon_centroid"), py::arg("polygon_triangulation_points"),
                "/ \\param polygonCentroid the centroid\n/ \\param polygonTriangulationPoints the internal polygon sub-triangulation\n/ \\return the polygon mass matrix")
            .def("polygon_inertia",
                &Gedim::GeometryUtilities::PolygonInertia,
                py::arg("polygon_centroid"), py::arg("polygon_triangulation_points"),
                "/ \\param polygonCentroid the centroid\n/ \\param polygonTriangulationPoints the internal polygon sub-triangulation\n/ \\return the polygon intertia tensor")
            .def("split_polygon_with_segment",
                &Gedim::GeometryUtilities::SplitPolygonWithSegment,
                py::arg("input"),
                "/ \\brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a segment contained inside\n/ \\param input the input data\n/ \\param result the resulting split\n/ \note only indices are threated in this function, no space points")
            .def("split_polygon_with_circle",
                &Gedim::GeometryUtilities::SplitPolygonWithCircle,
                py::arg("polygon_vertices"), py::arg("circle_center"), py::arg("circle_radius"), py::arg("vertex_positions"), py::arg("polygon_circle_intersections"), py::arg("polygon_circle_position"),
                "/ \\brief Split a polygon with n vertices numbered from 0 to n counterclockwise given a cirle\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\param circleCenter the circle center\n/ \\param circleRadius the circle radius\n/ \\param vertexPositions the polygon vertices positions respect the circle\n/ \\param polygonCircleIntersections the polygon center intersections\n/ \\param polygonCirclePosition the polygon position respect the circle\n/ \note tested only in 2D\n/ \\return the split result\n/ \note only indices are threated in this function, no space points")
            .def("split_polygon_with_circle_build_sub_polygon",
                &Gedim::GeometryUtilities::SplitPolygonWithCircleBuildSubPolygon,
                py::arg("split_result"), py::arg("sub_polygon_index"), py::arg("polygon_vertices"), py::arg("polygon_circle_intersections"),
                "/ \\brief Build the subpolygon coordinates from split result\n/ \\param splitResult the split result\n/ \\param subPolygonIndex the subpolygon index, from 0 to SplitPolygonWithCircleResult::NewPolygons.size()\n/ \\param polygonVertices the original polygon vertices\n/ \\param polygonCircleIntersections the polygon circle intersection\n/ \\return the resulting subpolygon coordinates")
            .def("split_polygon_with_plane",
                &Gedim::GeometryUtilities::SplitPolygonWithPlane,
                py::arg("polygon_vertices"), py::arg("polygon_edge_tangents"), py::arg("plane_normal"), py::arg("plane_origin"), py::arg("polygon_translation"), py::arg("polygon_rotation_matrix"),
                "/ \\brief Split 3 Polygon With Plane\n/ \\param polygonVertices the 3D polygon vertices\n/ \\param polygonEdgeTangents the 3D polygon edge tangents\n/ \\param planeNormal the plane normal\n/ \\param planeOrigin the plane origin\n/ \\param polygonTranslation the polygon translation vector for rotation\n/ \\param polygonRotationMatrix the polygon rotation matrix from 2D to 3D\n/ \\return the splitted polygons")
            .def("polygon_normal",
                &Gedim::GeometryUtilities::PolygonNormal,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon tridimensional normalized Normal\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting normalized normal")
            .def("polygon_tangents",
                &Gedim::GeometryUtilities::PolygonTangents, py::arg("polygon_vertices"), py::arg("polygon_normal"))
            .def("polygon_edges_centroid",
                &Gedim::GeometryUtilities::PolygonEdgesCentroid,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon edges centroid\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting edges centroid, size 3 x numVertices")
            .def("polygon_edge_lengths",
                &Gedim::GeometryUtilities::PolygonEdgeLengths,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon edge lengths\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting edge lengths, size 1 x numVertices")
            .def("polygon_edge_tangents",
                &Gedim::GeometryUtilities::PolygonEdgeTangents,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon edge tangents\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting edge tangents, size 3 x numVertices")
            .def("polygon_edge_normals",
                &Gedim::GeometryUtilities::PolygonEdgeNormals,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon edge normals outgoing the polygon\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\return the resulting edge normals outgoing the polygon, size 3 x numVertices")
            .def("simplex_barycenter",
                &Gedim::GeometryUtilities::SimplexBarycenter,
                py::arg("vertices"),
                "/ \\brief Compute the simplex barycenter as a mean of all vertices\n/ \\param vertices the matrix of vertices of the simplex (size 3 x numVertices)")
            .def("simplex_measure",
                &Gedim::GeometryUtilities::SimplexMeasure, py::arg("vertices"))
            .def("segment_barycenter",
                &Gedim::GeometryUtilities::SegmentBarycenter,
                py::arg("segment_origin"), py::arg("segment_end"),
                "/ \\brief Compute the segment barycenter as a mean of all vertices\n/ \\param segmentOrigin the segment origin\n/ \\param segmentEnd the segment end")
            .def("polygon_barycenter",
                &Gedim::GeometryUtilities::PolygonBarycenter,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon barycenter as a mean of all vertices\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)")
            .def("polyhedron_barycenter",
                &Gedim::GeometryUtilities::PolyhedronBarycenter,
                py::arg("polyhedron_vertices"),
                "/ \\brief Compute the polyhedron barycenter as a mean of all vertices\n/ \\param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)")
            .def("polygon_centroid",
                py::overload_cast<const Eigen::MatrixXd &, const double &>(&Gedim::GeometryUtilities::PolygonCentroid, py::const_),
                py::arg("polygon_vertices"), py::arg("polygon_area"),
                "/ \\brief Compute the Polygon centroid as described in https://en.wikipedia.org/wiki/Centroid\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)\n/ \\param polygonArea the area of the polygon\n/ \note the polygon shall be 2D")
            .def("polygon_centroid",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::VectorXd &, const double &>(&Gedim::GeometryUtilities::PolygonCentroid, py::const_),
                py::arg("sub_polygon_centroids"), py::arg("sub_polygon_areas"), py::arg("polygon_area"),
                "/ \\brief Compute the Polygon centroid using polygon sub-division\n/ \\param subPolygonCentroids the centroid of each subPolygon (size 3 x numSubPolygons)\n/ \\param subPolygonAreas the areas of each subPolygon, size 1 x numSubPolygons\n/ \\param polygonArea the total area of the polygon")
            .def("polygon_area_by_boundary_integral",
                &Gedim::GeometryUtilities::PolygonAreaByBoundaryIntegral,
                py::arg("polygon_vertices"), py::arg("edge_lengths"), py::arg("edge_tangents"), py::arg("edge_normals"), py::arg("reference_quadrature_points") = (Eigen::MatrixXd(3, 1) << 0.5, 0.0, 0.0).finished(), py::arg("reference_quadrature_weights") = Eigen::VectorXd::Ones(1),
                "/ \\brief Polygon Area By Integral on edges\n/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param edgeLengths the edge lengths, size numEdges\n/ \\param edgeTangents the edge tangents, size 3 x numEdges\n/ \\param edgeNormals the edge outgoint normals, size 3 x numEdges\n/ \\param referenceQuadraturePoints quadrature points on reference segment [0,1]\n/ \\param referenceQuadratureWeights quadrature weights on reference segment [0,1]\n/ \\return the polygon area\n/ \note the area is computed as integral_edges x dot n_x with gauss formula on edges of order 1")
            .def("polygon_area_by_internal_integral",
                &Gedim::GeometryUtilities::PolygonAreaByInternalIntegral,
                py::arg("polygon_triangulation_points"), py::arg("reference_quadrature_weights") = Eigen::VectorXd::Constant(1, 0.5),
                "/ \\brief Polygon Area By Internal Integral\n/ \\param polygonTriangulationPoints the internal polygon sub-triangulation\n/ \\param referenceQuadratureWeights the reference triangle quadrature weights [0,1]x[0,1]\n/ \\return the area computed as integral on sub-triangles")
            .def("polygon_centroid_by_integral",
                &Gedim::GeometryUtilities::PolygonCentroidByIntegral,
                py::arg("polygon_vertices"), py::arg("edge_lengths"), py::arg("edge_tangents"), py::arg("edge_normals"), py::arg("polygon_area"),
                "/ \\brief Polygon Area By Integral on edges\n/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param edgeLengths the edge lengths, size numEdges\n/ \\param edgeTangents the edge tangents, size 3 x numEdges\n/ \\param edgeNormals the edge outgoint normals, size 3 x numEdges\n/ \\param polygonArea the polygon area\n/ \\return the polygon centroid\n/ \note the area is computed as integral_edges (x^2, y^2) dot n with gauss formula on edges of order 2")
            .def("polygon_centroid_edges_distance",
                &Gedim::GeometryUtilities::PolygonCentroidEdgesDistance,
                py::arg("polygon_vertices"), py::arg("polygon_centroid"), py::arg("polygon_edge_normals"),
                "/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param polygonCentroid the polygon centroid\n/ \\param polygonEdgeNormals the polygon edge normals outgoing the polygon, size 3 x numEdges\n/ \\return the distance between the centroid and all the polygon edges, size 1 x numEdges")
            .def("polygon_centroid_vertices_distance",
                &Gedim::GeometryUtilities::PolygonCentroidVerticesDistance,
                py::arg("polygon_vertices"), py::arg("polygon_centroid"),
                "/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param polygonCentroid the polygon centroid\n/ \\return the distance between the centroid and all the polygon vertices, size 1 x numEdges")
            .def("polygon_in_radius",
                &Gedim::GeometryUtilities::PolygonInRadius,
                py::arg("polygon_centroid_edges_distance"),
                "/ \\param polygonCentroidEdgesDistance the polygon centroid edges distance, size 1 x numEdges\n/ \\return the polygon in radius, as the minimum distance between the polygon centroid and the edges")
            .def("polygon_aspect_ratio",
                &Gedim::GeometryUtilities::PolygonAspectRatio,
                py::arg("polygon_diameter"), py::arg("polygon_in_radius"),
                "/ \\param polygonDiameter the polygon diameter\n/ \\param polygonInRadius the polygon in radius\n/ \\return the polygon aspect ratio, defined as the ratio bewteen the in and out diameter")
            .def("polygon_diameter",
                &Gedim::GeometryUtilities::PolygonDiameter,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the Polygon diameter defined as the maximum distance between the vertices\n/ \\param polygonVertices the matrix of vertices of the polygon (size 3 x numVertices)")
            .def("polygon_translation",
                &Gedim::GeometryUtilities::PolygonTranslation,
                py::arg("polygon_vertices"),
                "/ \\brief Compute the translation vector of a tridimensional Polygon\n/ \\param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)\n/ \\return the resulting translation vector t which corresponds to the first vertex of the polygon\n/ \note to rotate some point P from 2D to 3D use Q * P + t\n/ \note to rotate some point P from 3D to 2D use Q^T * (P - t)")
            .def("polygon_rotation_matrix",
                &Gedim::GeometryUtilities::PolygonRotationMatrix,
                py::arg("polygon_vertices"), py::arg("polygon_normal"), py::arg("polygon_translation"),
                "/ \\brief Compute the rotation matrix and translation vector of a tridimensional Polygon\n/ \\param polygonVertices the vertices of the polygon counterclockwise (size 3 x numVertices)\n/ \\param polygonNormal the normalized normal of the plane which contains the polygon\n/ \\param polygonTranslation the translation vector t\n/ \\return the resulting rotation matrix Q which rotates 2D points to 3D points\n/ \note to rotate some point P from 2D to 3D use Q * P + t\n/ \note to rotate some point P from 3D to 2D use Q^T * (P - t)")
            .def("polygon_is_convex",
                &Gedim::GeometryUtilities::PolygonIsConvex,
                py::arg("polygon_vertices"), py::arg("convex_hull"),
                "/ \\brief Check if Polygon is Convex\n/ \\param polygonVertices the polygon vertices, size 3 x numVertices\n/ \\param convexHull the convex hull vertices counterclockwise\n/ \\return True if polygon is convex, False otherwise\n/ \note works only in 2D-plane")
            .def("polygon_type",
                &Gedim::GeometryUtilities::PolygonType,
                py::arg("num_polygon_vertices"), py::arg("is_polygon_convex"),
                "/ \\param numPolygonVertices the number of polygon vertices\n/ \\param isPolygonConvex True if the polygon is convex\n/ \\return the polygon type")
            .def("polygon_orientation",
                &Gedim::GeometryUtilities::PolygonOrientation,
                py::arg("convex_hull"),
                "/ \\param convexHull the polygon convex hull vertices indices counterclockwise\n/ \\return the polygon 2D orientation\n/ \note works only in 2D-plane")
            .def("change_polygon_orientation",
                &Gedim::GeometryUtilities::ChangePolygonOrientation,
                py::arg("num_polygon_vertices"),
                "/ \\param numPolygonVertices the number of polygon vertices\n/ \\return the new polygon vertices indices oriented in the opposite direction")
            .def("plane_rotation_matrix",
                &Gedim::GeometryUtilities::PlaneRotationMatrix,
                py::arg("plane_normal"),
                "/ \\brief Compute the rotation matrix of a plane from 2D to 3D\n/ \\param planeNormal the normalized normal of the plane\n/ \\return the resulting rotation matrix Q which rotates 2D points to 3D points\n/ \note to rotate some point P from 2D to 3D use Q * P + t\n/ \note to rotate some point P from 3D to 2D use Q^T * (P - t)")
            .def("plane_translation",
                &Gedim::GeometryUtilities::PlaneTranslation,
                py::arg("plane_origin"),
                "/ \\brief Compute the translation vector of a plane from 2D to 3D\n/ \\param planeNormal the normalized normal of the plane\n/ \\param planeOrigin the 3D plane origin\n/ \\return the resulting translation vector t which translates 2D points to 3D points\n/ \note to rotate some point P from 2D to 3D use Q * P + t\n/ \note to rotate some point P from 3D to 2D use Q^T * (P - t)")
            .def("rotate_points",
                &Gedim::GeometryUtilities::RotatePoints,
                py::arg("points"), py::arg("rotation_matrix"), py::arg("translation") = Eigen::Vector3d::Zero(),
                "/ \\brief Rotate Points P using rotation matrix Q and translation t: Q * P + t\n/ \\param points the points (size 3 x numPoints)\n/ \\param rotationMatrix the rotation matrix, size 3x3\n/ \\param translation the translation vector, size 1x3\n/ \\param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t")
            .def("rotate_points_from2_d_to3_d",
                &Gedim::GeometryUtilities::RotatePointsFrom2DTo3D,
                py::arg("points"), py::arg("rotation_matrix"), py::arg("translation") = Eigen::Vector3d::Zero(),
                "/ \\brief Rotate Points P From 2D To 3D using rotation matrix Q and translation t: Q * P + t\n/ \\param points the points (size 3 x numPoints)\n/ \\param rotationMatrix the rotation matrix from 2D to 3D\n/ \\param translation the translation vector\n/ \\param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * P + t")
            .def("rotate_points_from3_d_to2_d",
                &Gedim::GeometryUtilities::RotatePointsFrom3DTo2D,
                py::arg("points"), py::arg("rotation_matrix"), py::arg("translation") = Eigen::Vector3d::Zero(),
                "/ \\brief Rotate Points P From 3D To 2D using rotation matrix Q and translation t: Q * (P - t)\n/ \\param points the points (size 3 x numPoints)\n/ \\param rotationMatrix the rotation matrix from 3D to 2D\n/ \\param translation the translation vector\n/ \\param rotatedPoints the resulting rotated points (size 3 x numPoints) rP = Q * (P - t)")
            .def("convex_hull",
                &Gedim::GeometryUtilities::ConvexHull,
                py::arg("points"), py::arg("include_collinear") = true,
                "/ \\brief Compute the Convex Hull of 2D points\n/ \\param points the points, size 3 x numPoints\n/ \\param includeCollinear include the collinear points, default True\n/ \\return the convex hull indices counterclockwise, size numConvexHullPoints, numConvexHullPoints <= numPoints\n/ \note works in 2D, use the Graham_scan algorithm https://en.wikipedia.org/wiki/Graham_scan")
            .def("points_are_aligned",
                &Gedim::GeometryUtilities::PointsAreAligned,
                py::arg("segment_origin"), py::arg("segment_end"), py::arg("points"),
                "/ \\brief Check if a set of points are aligned to a line identified by a segment\n/ \\param segmentOrigin segment origin of the line\n/ \\param segmentEnd segment end of the line\n/ \\param points the points, size 3 x numPoints\n/ \\return True if the i-th point is aligned, size 1 x numPoints")
            .def("points_are_on_line",
                &Gedim::GeometryUtilities::PointsAreOnLine,
                py::arg("points"), py::arg("line_origin"), py::arg("line_tangent"),
                "/ \\brief Check if a set of points are on a line\n/ \\param points the points, size 3 x numPoints\n/ \\param lineTangent the line tangent\n/ \\param lineOrigin the line origin\n/ \\return True if the i-th point is aligned, size 1 x numPoints")
            .def("point_is_aligned",
                &Gedim::GeometryUtilities::PointIsAligned,
                py::arg("segment_origin"), py::arg("segment_end"), py::arg("point"),
                "/ \\brief Check if a point is aligned to a line identified by a segment\n/ \\param segmentOrigin segment origin of the line\n/ \\param segmentEnd segment end of the line\n/ \\param point the point\n/ \\return True if the point is aligned")
            .def("point_is_on_line",
                &Gedim::GeometryUtilities::PointIsOnLine,
                py::arg("point"), py::arg("line_origin"), py::arg("line_tangent"),
                "/ \\brief Check if a point is on a line\n/ \\param point the point\n/ \\param lineTangent the line tangent\n/ \\param lineOrigin the line origin\n/ \\return True if the point is aligned")
            .def("unaligned_points",
                &Gedim::GeometryUtilities::UnalignedPoints,
                py::arg("points"), py::arg("num_desired_unaligned_points") = 0,
                "/ \\brief Extract the circumscribed unaligned points (minimum 2) in a set of points\n/ \\param points the points, size 3 x numPoints\n/ \\param numDesiredUnalignedPoints the number of desired unaligned points, if 0 all the points are computed\n/ \\return the unaligned points indices counterclockwise, size numUnalignedPoints, 2 <= numUnalignedPoints <=\n/ numPoints")
            .def("unaligned_polyhedron_points",
                &Gedim::GeometryUtilities::UnalignedPolyhedronPoints,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"), py::arg("polyhedron_faces_translation"), py::arg("polyhedron_faces_rotation_matrix"), py::arg("polyhedron_unaliged_faces"), py::arg("polyhedron_faces_unaligned_vertices"),
                "/ \\brief Extract the circumscribed unaligned points (minimum 4) in a polyhedron\n/ \\return the unaligned points, size numUnalignedPoints, 4 <= numUnalignedPoints <= numPoints\n/ \\warning works only for convex polyhedron")
            .def("aligned_polyhedron_edges",
                &Gedim::GeometryUtilities::AlignedPolyhedronEdges, py::arg("polyhedron_vertices"), py::arg("vertices_adjacency"), py::arg("edges_adjacency"), py::arg("adjacency_vertices_map"), py::arg("polyhedron_edge_tangents"), py::arg("polyhedron_edge_squared_lenghts"))
            .def("extract_points",
                &Gedim::GeometryUtilities::ExtractPoints,
                py::arg("points"), py::arg("filter"),
                "/ \\param points the points, size 3 x numPoints\n/ \\param filter indices counterclockwise, size numFilterPoints, numFilterPoints <= numPoints\n/ \\return the points coordinates filtered, size 3 x numFilterPoints")
            .def("extract_triangulation_points",
                &Gedim::GeometryUtilities::ExtractTriangulationPoints,
                py::arg("points"), py::arg("points_triangulation"),
                "/ \\param points the points, size 3 x numPoints\n/ \\param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles\n/ \\return the triangles coordinates, size 1 x numTriangles")
            .def("extract_triangulation_points_by_internal_point",
                &Gedim::GeometryUtilities::ExtractTriangulationPointsByInternalPoint,
                py::arg("points"), py::arg("internal_point"), py::arg("points_triangulation"),
                "/ \\param points the points, size 3 x numPoints\n/ \\param externalPoint the external point coordinates\n/ \\param pointsTriangulation the polygon sub-division triangulation, size 1 x 3 * numTriangles\n/ \\return the triangles coordinates, size 1 x numTriangles")
            .def("create_ellipse",
                &Gedim::GeometryUtilities::CreateEllipse,
                py::arg("axis_major_length"), py::arg("axis_minor_length"), py::arg("resolution"),
                "/ \\brief Create 2D Ellipse approximation with 2D polygon\n/ \\param axisMajorLength the ellipse axis major length\n/ \\param axisMinorLength the ellipse axis minor length\n/ \\param resolution the number of points on each ellipse quadrant\n/ \\return the polygon which approximate the ellipse\n/ \note the ellipse is centered in the origin and parallel to xy-axis")
            .def("create_triangle",
                &Gedim::GeometryUtilities::CreateTriangle,
                py::arg("p1"), py::arg("p2"), py::arg("p3"),
                "/ \\brief Create a triangle with points")
            .def("create_parallelogram",
                &Gedim::GeometryUtilities::CreateParallelogram,
                py::arg("origin"), py::arg("length_vector"), py::arg("width_vector"),
                "/ \\brief Create a parallelogram with origin and dimension\n/ \\param origin the origin\n/ \\param lengthVector the length vector\n/ \\param widthVector the width vector")
            .def("create_rectangle",
                &Gedim::GeometryUtilities::CreateRectangle,
                py::arg("origin"), py::arg("base"), py::arg("height"),
                "/ \\brief Create a rectangle with origin and dimensions parallel to axis\n/ \\param origin the origin\n/ \\param base the base length\n/ \\param height the height length")
            .def("create_square",
                &Gedim::GeometryUtilities::CreateSquare,
                py::arg("origin"), py::arg("edge_length"),
                "/ \\brief Create a square with origin and dimensions parallel to axis\n/ \\param origin the origin\n/ \\param edgeLength the edge length")
            .def("create_tetrahedron_with_origin",
                &Gedim::GeometryUtilities::CreateTetrahedronWithOrigin,
                py::arg("origin"), py::arg("length_vector"), py::arg("height_vector"), py::arg("width_vector"),
                "/ \\brief Create a Tetrahedron with origin and dimension\n/ \\param origin the origin\n/ \\param lengthVector the length vector\n/ \\param heightVector the heigth vector\n/ \\param widthVector the width vector\n/ \\return the tetrahedron created")
            .def("create_tetrahedron_with_vertices",
                &Gedim::GeometryUtilities::CreateTetrahedronWithVertices,
                py::arg("v1"), py::arg("v2"), py::arg("v3"), py::arg("v4"),
                "/ \\brief Create a Tetrahedron with the four vertices\n/ \\param v1 the first vertex\n/ \\param v2 the second vertex\n/ \\param v3 the third vertex\n/ \\param v4 the fourth vertex\n/ \\return the tetrahedron created")
            .def("create_parallelepiped_with_origin",
                &Gedim::GeometryUtilities::CreateParallelepipedWithOrigin,
                py::arg("origin"), py::arg("length_vector"), py::arg("height_vector"), py::arg("width_vector"),
                "/ \\brief Create a Parallelepiped with origin and dimension\n/ \\param origin the origin\n/ \\param lengthVector the length vector\n/ \\param heightVector the heigth vector\n/ \\param widthVector the width vector\n/ \\return the parallelepiped created")
            .def("create_polyhedron_with_extrusion",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::CreatePolyhedronWithExtrusion, py::const_),
                py::arg("polygon_vertices"), py::arg("height_vector"),
                "/ \\brief Create Polyhedron With Extrusion\n/ \\param polygon the 2D polygon vertices\n/ \\param heightVector  the height vector\n/ \\return the polyhedron created")
            .def("create_polyhedron_with_extrusion",
                py::overload_cast<const Eigen::MatrixXd &, const std::vector<Eigen::Vector3d> &>(&Gedim::GeometryUtilities::CreatePolyhedronWithExtrusion, py::const_),
                py::arg("polygon_vertices"), py::arg("height_vectors"),
                "/ \\brief Create Polyhedron With Extrusion\n/ \\param polygon the 2D polygon vertices, size 3 x numPolygonVertices\n/ \\param heightVectors the height vector to be used for each polygon vertex, size numPolygonVertices\n/ \\return the polyhedron created")
            .def("create_cube_with_origin",
                &Gedim::GeometryUtilities::CreateCubeWithOrigin,
                py::arg("origin"), py::arg("edge_length"),
                "/ \\brief Create a Cube with origin aligned to axis\n/ \\param origin the origin\n/ \\param edgeLength the edge length\n/ \\return the cube created")
            .def("polyhedron_volume_by_boundary_integral",
                &Gedim::GeometryUtilities::PolyhedronVolumeByBoundaryIntegral,
                py::arg("polyhedron_face_rotated_triangulation_points"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"), py::arg("reference_quadrature_points") = (Eigen::MatrixXd(3, 1) << 1.0 / 3.0, 1.0 / 3.0, 0.0).finished(), py::arg("reference_quadrature_weights") = Eigen::VectorXd::Constant(1, 0.5),
                "/ \\brief Compute the Polyhedron Volume\n/ \\param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces\n/ x numTrianglesPerFace \\param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \\param\n/ polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \\param\n/ polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \\param\n/ polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \\param referenceQuadraturePoints\n/ the reference tetrahedron quadrature points [0,1]x[0,1]x[0,1] \\param referenceQuadratureWeights the reference\n/ tetrahedron quadrature weights [0,1]x[0,1]x[0,1] \\return the polyhedron volume \note use the divergence theorem,\n/ with F = 1/3 (x, y, z), see https://en.wikipedia.org/wiki/Divergence_theorem")
            .def("polyhedron_volume_by_internal_integral",
                &Gedim::GeometryUtilities::PolyhedronVolumeByInternalIntegral,
                py::arg("polyhedron_tetrahedron_vertices"), py::arg("reference_quadrature_weights") = Eigen::VectorXd::Constant(1, 1.0 / 6.0),
                "/ \\brief Polyhedron Volume By Internal Integral\n/ \\param polyhedronTetrahedronVertices the internal polyhedron sub-tetrahedra\n/ \\param referenceQuadratureWeights the reference tetrahedron quadrature weights [0,1]x[0,1]x[0,1]\n/ \\return the area computed as integral on sub-tetrahedra")
            .def("polyhedron_centroid",
                &Gedim::GeometryUtilities::PolyhedronCentroid,
                py::arg("polyhedron_face_rotated_triangulation_points"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"), py::arg("polyhedron_volume"),
                "/ \\brief Compute the Polyhedron centroid\n/ \\param polyhedronRotatedFaceTriangulationPoints polyhedron face triangulation points 2D, size numPolyhedronFaces\n/ x numTrianglesPerFace \\param polyhedronFaceNormals polyhedron face normals, size numPolyhedronFaces \\param\n/ polyhedronFaceNormalDirections polyhedron face normal directions, size numPolyhedronFaces \\param\n/ polyhedronFaceTranslations polyhedron face translation vector from 2D to 3D \\param\n/ polyhedronFaceRotationMatrices polyhedron face rotation matrix from 2D to 3D \\param polyhedronVolume the\n/ polyhedron volume \\return the polyhedron centroid \note use the divergence theorem, with F_x = 1/2 (x^2, 0, 0),\n/ F_y = 1/2 (0, y^2, 0), F_z = 1/2 (0, 0, z^2), see https://en.wikipedia.org/wiki/Divergence_theorem")
            .def("polyhedron_diameter",
                &Gedim::GeometryUtilities::PolyhedronDiameter,
                py::arg("polyhedron_vertices"),
                "/ \\brief Compute the Polyhedron diameter defined as the maximum distance between the vertices\n/ \\param polyhedronVertices the matrix of vertices of the polyhedron (size 3 x numVertices)")
            .def("polyhedron_edges_centroid",
                &Gedim::GeometryUtilities::PolyhedronEdgesCentroid,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"),
                "/ \\brief Compute Polyhedron Edges Centroid\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\return for each edge the centroid, size 3xnumEdges")
            .def("polyhedron_edges_length",
                &Gedim::GeometryUtilities::PolyhedronEdgesLength,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"),
                "/ \\brief Compute Polyhedron Edges Lenght\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\return for each edge the length, size 1xnumEdges")
            .def("polyhedron_edge_tangents",
                &Gedim::GeometryUtilities::PolyhedronEdgeTangents,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"),
                "/ \\brief Compute Polyhedron Edges Tangent\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\return for each edge the tangent, size 3xnumEdges")
            .def("polyhedron_face_vertices",
                &Gedim::GeometryUtilities::PolyhedronFaceVertices,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"),
                "/ \\brief Compute Polyhedron Faces Vertices\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\return for each face the vertices, size 1xnumFaces")
            .def("polyhedron_face_edge_directions",
                &Gedim::GeometryUtilities::PolyhedronFaceEdgeDirections,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"),
                "/ \\brief Compute Polyhedron Faces Edge Direction\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\return for each face the edge direction compare to polyhedron edge directions, size 1xnumFaces")
            .def("polyhedron_face_edge_tangents",
                &Gedim::GeometryUtilities::PolyhedronFaceEdgeTangents,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_edge_directions"), py::arg("polyhedron_edge_tangents"),
                "/ \\brief Compute Polyhedron Faces Edge Tangents\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param polyhedronEdgeTangents for each polyhedron edge the tangent, size 3xnumEdges\n/ \\return for each face the edge tangents, size 1xnumFaces")
            .def("polyhedron_face_rotation_matrices",
                &Gedim::GeometryUtilities::PolyhedronFaceRotationMatrices,
                py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_translations"),
                "/ \\brief Compute Polyhedron Faces Rotation matrix\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each polyhedron face the rotation matrix from 2D to 3D")
            .def("polyhedron_face_translations",
                &Gedim::GeometryUtilities::PolyhedronFaceTranslations,
                py::arg("polyhedron_face_vertices"),
                "/ \\brief Compute Polyhedron Faces translation vectors\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each polyhedron face the translation vector")
            .def("polyhedron_face_rotated_vertices",
                &Gedim::GeometryUtilities::PolyhedronFaceRotatedVertices,
                py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"),
                "/ \\brief Compute Polyhedron Faces Rotated Vertices 2D\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronFaceTranslations the polyhedron face translations from 2D to 3D\n/ \\param polyhedronFaceRotationMatrices the polyhedron face rotation matrix from 2D to 3D\n/ \\return for each face the 2D vertices, size 1xnumFaces")
            .def("polyhedron_faces_unaligned_vertices",
                &Gedim::GeometryUtilities::PolyhedronFacesUnalignedVertices,
                py::arg("polyhedron_faces_rotated_vertices"),
                "/ \\brief Compute Polyhedron Faces Unaligned Vertices Indices\n/ \\param polyhedronFacesRotatedVertices the polyhedron faces 2D vertices\n/ \\return for each face the unaligned vertices indices, size 1 x numFaces")
            .def("polyhedron_face_normals",
                &Gedim::GeometryUtilities::PolyhedronFaceNormals,
                py::arg("polyhedron_face_vertices"),
                "/ \\brief Compute Polyhedron Faces Normals\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each polyhedron face the normal")
            .def("polyhedron_face_tangents",
                &Gedim::GeometryUtilities::PolyhedronFaceTangents, py::arg("polyhedron_faces_vertices"), py::arg("polyhedron_faces_normal"), py::arg("polyhedron_faces_normal_direction"))
            .def("polyhedron_face_barycenter",
                &Gedim::GeometryUtilities::PolyhedronFaceBarycenter,
                py::arg("polyhedron_face_vertices"),
                "/ \\brief Compute Polyhedron Faces barycenters\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each polyhedron face the barycenter")
            .def("polyhedron_mass",
                &Gedim::GeometryUtilities::PolyhedronMass, py::arg("polyhedron_centroid"), py::arg("polyhedron_tetrahedron_points"))
            .def("polyhedron_inertia",
                &Gedim::GeometryUtilities::PolyhedronInertia, py::arg("polyhedron_centroid"), py::arg("polyhedron_tetrahedra_points"))
            .def("polyhedron_centroid_faces_distance",
                &Gedim::GeometryUtilities::PolyhedronCentroidFacesDistance, py::arg("polyhedron_centroid"), py::arg("polyhedron_faces_normal"), py::arg("polyhedron_face_vertices"))
            .def("polyhedron_in_radius",
                &Gedim::GeometryUtilities::PolyhedronInRadius, py::arg("polyhedron_centroid_faces_distance"))
            .def("polyhedron_is_convex",
                &Gedim::GeometryUtilities::PolyhedronIsConvex,
                py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_rotated_vertices"), py::arg("polyhedron_face_internal_points"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_normal_directions"), py::arg("polyhedron_internal_point"),
                "/ \\brief Check if Polyhedron is Convex\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\param polyhedronFaceInternalPoints the polyhedron face internal points\n/ \\param polyhedronFaceNormals the normal of each face\n/ \\param polyhedronFaceNormalDirections the normal outgoing direction\n/ \\param pointInsidePolyhedron a point inside polyhedron\n/ \\return True if polyhedron is convex, False otherwise\n/ \\warning still not working")
            .def("polyhedron_face_normal_directions",
                py::overload_cast<const std::vector<Eigen::MatrixXd> &, const Eigen::Vector3d &, const std::vector<Eigen::Vector3d> &>(&Gedim::GeometryUtilities::PolyhedronFaceNormalDirections, py::const_),
                py::arg("polyhedron_face_vertices"), py::arg("point_inside_polyhedron"), py::arg("polyhedron_face_normals"),
                "/ \\brief Compute Polyhedron Face Normal Directions\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\param pointInsidePolyhedron a point inside polyhedron\n/ \\param polyhedronFaceNormals the normal of each face\n/ \\return True if the face has normal outgoing\n/ \\warning works only for convex polyhedrons")
            .def("polyhedron_face_normal_directions",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::MatrixXi &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::MatrixXd> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &>(&Gedim::GeometryUtilities::PolyhedronFaceNormalDirections, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_internal_points"), py::arg("polyhedron_face_rotated_vertices"), py::arg("polyhedron_face_normals"), py::arg("polyhedron_face_translations"), py::arg("polyhedron_face_rotation_matrices"),
                "/ \\brief Compute Polyhedron Face Normal Directions for generic polyhedron (slower)\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\param pointInsidePolyhedron a point inside polyhedron\n/ \\param polyhedronFaceNormals the normal of each face\n/ \\return True if the face has normal outgoing\n/ \\warning NOT WORKING in all cases")
            .def("polyhedron_face_triangulations",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulations,
                py::arg("polyhedron_faces"), py::arg("local_face_triangulations"),
                "/ \\brief Polyhedron Face Triangulations of each face\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param localFaceTriangulations the local faces triangulations indices, size 1xnumFaces x (3xnumTriangles)\n/ \\return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)")
            .def("polyhedron_face_triangulations_by_first_vertex",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulationsByFirstVertex,
                py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"),
                "/ \\brief Polyhedron Face Triangulations by first vertex of each face\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)")
            .def("polyhedron_face_triangulations_by_ear_clipping",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulationsByEarClipping,
                py::arg("num_polyhedron_faces"), py::arg("polyhedron_faces2_d_vertices"),
                "/ \\brief Polyhedron Face Triangulations by ear clipping of each face\n/ \\param numPolyhedronFaces the number of polyhedron faces\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)")
            .def("polyhedron_face_extract_triangulation_points",
                &Gedim::GeometryUtilities::PolyhedronFaceExtractTriangulationPoints, py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_triangulations"))
            .def("polyhedron_face_triangulation_points_by_internal_point",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulationPointsByInternalPoint, py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_internal_points"), py::arg("polyhedron_face_triangulations"))
            .def("polyhedron_face_triangulations_by_internal_point",
                &Gedim::GeometryUtilities::PolyhedronFaceTriangulationsByInternalPoint,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_vertices"), py::arg("polyhedron_face_internal_points"),
                "/ \\brief Polyhedron Face Triangulations by internal point of each face\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param polyhedronFaceVertices the polyhedron faces vertices\n/ \\param polyhedronFaceInternalPoints the polyhedron face internal points\n/ \\return for each face the triangulation indices by first vertex, size 1xnumFaces x (3xnumTriangles)\n/ \note the internal point index is polyhedronVertices.size()")
            .def("polyhedron_tetrahedrons_by_face_triangulations",
                py::overload_cast<const Eigen::MatrixXd &, const std::vector<Eigen::MatrixXi> &, const std::vector<std::vector<unsigned int>> &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::PolyhedronTetrahedronsByFaceTriangulations, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_triangulations"), py::arg("polyhedron_internal_point"),
                "/ \\brief Polyhedron Tetrahedrons By Face Triangulations\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param faceTriangulations the triangulation on face vertices\n/ \\param polyhedronInternalPoint a polyhedron internal point\n/ \\return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)\n/ \note the polyhedron internal point index is polyhedronVertices.size() + f")
            .def("polyhedron_tetrahedrons_by_face_triangulations",
                py::overload_cast<const Eigen::MatrixXd &, const std::vector<Eigen::MatrixXi> &, const std::vector<std::vector<unsigned int>> &, const std::vector<Eigen::Vector3d> &, const Eigen::Vector3d &>(&Gedim::GeometryUtilities::PolyhedronTetrahedronsByFaceTriangulations, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_faces"), py::arg("polyhedron_face_triangulations"), py::arg("polyhedron_face_internal_points"), py::arg("polyhedron_internal_point"),
                "/ \\brief Polyhedron Tetrahedrons By Face Triangulations with face internal points\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param faceTriangulations the triangulation on face vertices by internal points\n/ \\param polyhedronFaceInternalPoints the polyhedron face internal points\n/ \\param polyhedronInternalPoint a polyhedron internal point\n/ \\return the polyhedron tetrahedrons indices, size 1x(4*numTetrahedrons)\n/ \note the polyhedron face internal points are polyhedronVertices.size() + f\n/ \note the polyhedron internal point index is polyhedronVertices.size() + polyhedronFaceInternalPoints.size()")
            .def("extract_tetrahedron_points",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::Vector3d &, const std::vector<unsigned int> &>(&Gedim::GeometryUtilities::ExtractTetrahedronPoints, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_internal_point"), py::arg("point_tetrahedrons"),
                "/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronInternalPoint a polyhedron internal point\n/ \\param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra\n/ \\return the tetrahedrons coordinates, size 1 x numTetra")
            .def("extract_tetrahedron_points",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::Vector3d &, const std::vector<Eigen::Vector3d> &, const std::vector<unsigned int> &>(&Gedim::GeometryUtilities::ExtractTetrahedronPoints, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_internal_point"), py::arg("polyhedron_face_internal_points"), py::arg("point_tetrahedrons"),
                "/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronInternalPoint a polyhedron internal point\n/ \\param polyhedronFaceInternalPoints the polyhedron face internal points\n/ \\param pointTetrahedrons the polyhedron sub-division tetrahedrons, size 1 x 4 * numTetra\n/ \\return the tetrahedrons coordinates, size 1 x numTetra")
            .def("polyhedron_coordinate_system",
                &Gedim::GeometryUtilities::PolyhedronCoordinateSystem,
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"),
                "/ \\brief Get Polyhedron Coordinate System\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\return the four vertices indices forming a coordinate system for the polyhedron, size 1x4")
            .def("export_polyhedron_to_vtu",
                py::overload_cast<const Eigen::MatrixXd &, const Eigen::MatrixXi &, const std::vector<Eigen::MatrixXi> &, const std::string &>(&Gedim::GeometryUtilities::ExportPolyhedronToVTU, py::const_),
                py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("export_folder"),
                "/ \\brief Export Polyhedron To VTU\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param exportFolder the folder in which to export")
            .def("export_polyhedron_to_vtu",
                py::overload_cast<const unsigned int &, const Eigen::MatrixXd &, const Eigen::MatrixXi &, const std::vector<Eigen::MatrixXi> &, const std::vector<Eigen::MatrixXd> &, const double &, const Eigen::Vector3d &, const std::vector<Eigen::MatrixXd> &, const std::vector<double> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Matrix3d> &, const std::vector<std::vector<Eigen::Matrix3d>> &, const std::vector<Eigen::Vector3d> &, const std::vector<Eigen::Vector3d> &, const std::vector<bool> &, const std::string &>(&Gedim::GeometryUtilities::ExportPolyhedronToVTU, py::const_),
                py::arg("index"), py::arg("polyhedron_vertices"), py::arg("polyhedron_edges"), py::arg("polyhedron_faces"), py::arg("polyhedron_tetra"), py::arg("polyhedron_volume"), py::arg("polyhedron_centroid"), py::arg("polyhedron_faces3_d_vertices"), py::arg("polyhedron_faces_area"), py::arg("polyhedron_faces2_d_centroid"), py::arg("polyhedron_faces_translation"), py::arg("polyhedron_faces_rotation_matrix"), py::arg("polyhedron_faces3_d_triangles"), py::arg("polyhedron_faces3_d_internal_point"), py::arg("polyhedron_faces3_d_normal"), py::arg("polyhedron_faces3_d_normal_direction"), py::arg("export_folder"),
                "/ \\brief Export Polyhedron To VTU\n/ \\param polyhedronVertices the polyhedron vertices\n/ \\param polyhedronEdges the polyhedron edges\n/ \\param polyhedronFaces the polyhedron faces\n/ \\param exportFolder the folder in which to export")
            .def("export_polygon_to_vtu",
                &Gedim::GeometryUtilities::ExportPolygonToVTU, py::arg("index"), py::arg("polygon"), py::arg("polygon_triangles"), py::arg("polygon_volume"), py::arg("polygon_centroid"), py::arg("polygon_edges_centroid"), py::arg("polygon_edges_normal"), py::arg("polygon_edges_normal_direction"), py::arg("export_folder"))
            ;
    } // </namespace Gedim>
    ////////////////////    </generated_from:GeometryUtilities.hpp>    ////////////////////

    // </litgen_pydef> // Autogenerated code end
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  AUTOGENERATED CODE END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}